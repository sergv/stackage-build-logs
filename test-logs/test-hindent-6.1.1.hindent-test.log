Resolving dependencies...
Build profile: -w ghc-9.6.6 -O1
In order, the following will be built (use -v for more details):
 - hindent-6.1.1 (test:hindent-test) (ephemeral targets)
Preprocessing test suite 'hindent-test' for hindent-6.1.1...
Building test suite 'hindent-test' for hindent-6.1.1...
Running 1 test suites...
Test suite hindent-test: RUNNING...

markdown tokenizer
  should tokenize plain text [✔]
  should tokenize headings [✔]
  should tokenize code fence beginnings with labels [✔]
  should tokenize full code fences [✔]
  should tokenize lines inside code fences as plain text [✔]
markdown parser
  should parse a heading followed by text as a section [✔]
HIndent test codes
  Shebangs
    No newlines after a shebang [✔]
    Double shebangs [✔]
  Modules
    Empty module [✔]
    Module headers
      Without an export list [✔]
      With an export list [✔]
      With an export list; indentation 4 [✔]
    Module-level pragmas
      A `WARNING` for a module without an export list. [✔]
      A `DEPRECATED` for a module with an export list. [✔]
      A pragma's name is converted to the SHOUT_CASE. [✔]
      Pragmas, GHC options, and haddock options. [✔]
      Accept pragmas via `OPTIONS -XFOO` [✔]
      Accept pragmas via `OPTIONS_GHC -XFOO` [✔]
      A pragma's length is adjusted automatically [✔]
      Collect multiple extensions correctly [✔]
      Collect multiple extensions separated by commas correctly [✔]
      Do not collect pragma-like comments [✔]
  Imports, foreign imports, and foreign exports
    Import lists [✔]
    Shorter identifiers come first [✔]
    Import with `ExplicitNamespaces`. [✔]
    Import a pattern [✔]
    Sorted [✔]
    Explicit imports - capitals first (typeclasses/types), then operators, then identifiers [✔]
    Pretty import specification [✔]
    An import declaration importing lots of data constructors [✔]
    Preserve newlines between import groups [✔]
    `PackageImports` [✔]
    Importing a `#` [✔]
    Foreign imports and exports
      A `ccall` foreign export [✔]
      A `ccall` unsafe foreign import [✔]
      A `capi` foreign import [✔]
      A `stdcall` foreign import [✔]
      A `prim` foreign import [✔]
      A `javascript` foreign import [✔]
  Declarations
    Data family [✔]
    `StandaloneKindSignatures` [✔]
    Default declaration [✔]
    `ANN` pragmas
      Value annotation. [✔]
      Type annotation. [✔]
      Module annotation. [✔]
    Class declarations
      Default signatures [✔]
      `TypeOperators` and `MultiParamTypeClasses` [✔]
      Class constraints
        Empty [✔]
        Long [✔]
      Class methods
        With class constraints [✔]
        Long signatures [✔]
      Associated type synonyms
        Associated type synonyms [✔]
        Associated type synonyms annotated with injectivity information [✔]
    Class instance declarations
      Without methods [✔]
      With methods [✔]
      With type operators [✔]
      With a type alias [✔]
      A `where` clause between instance functions [✔]
      With a `SPECIALISE` pragma [✔]
      With associated data types [✔]
      With overlapping pragmas
        `OVERLAPPING` [✔]
        `OVERLAPPABLE` [✔]
        `OVERLAPS` [✔]
        `INCOHERENT` [✔]
      With class constraints
        Short name [✔]
        Long name [✔]
      Explicit foralls
        Without class constraints [✔]
        With class constraints [✔]
      Symbol class constructor
        Infix [✔]
        Prefix [✔]
    Data declarations
      Data declaration with underscore [✔]
      A data declaration with typeclass constraints [✔]
      Multiple constructors at once [✔]
      No fields [✔]
      Single field [✔]
      Multiple unnamed fields [✔]
      A lot of unnamed fields in a constructor [✔]
      A banged field [✔]
      A record constructor with a field [✔]
      Multiple constructors with fields [✔]
      A mixture of constructors with unnamed fields and record constructors [✔]
      An infix data constructor [✔]
      An `UNPACK`ed field. [✔]
      An `NOUNPACK`ed field. [✔]
      A lazy field. [✔]
      Fields with `forall` constraints
        Single [✔]
        Multiple [✔]
      Derivings
        With a single constructor [✔]
        With multiple constructors [✔]
        With a record constructor [✔]
        Multiple derivings [✔]
        Various deriving strategies [✔]
        `StandaloneDeriving` [✔]
      GADT declarations
        With a kind signature [✔]
        Without a kind signature [✔]
        With a `forall` but no contexts [✔]
        With a context but no `forall`s [✔]
        With methods with record signatures [✔]
    Data instance declarations
      Without type applications [✔]
      With type applications [✔]
    Function declarations
      Case inside `do` and lambda [✔]
      A `case` inside a `let`. [✔]
      A `do` inside a lambda. [✔]
      Case with natural pattern (See NPat of https://hackage.haskell.org/package/ghc-lib-parser-9.2.3.20220527/docs/Language-Haskell-Syntax-Pat.html#t:Pat) [✔]
      Main[50:11] [✔]
      A `do` inside a guard arm [✔]
      `if` having a long condition [✔]
      A long signature inside a where clause [✔]
      A `forall` type inside a where clause [✔]
      Prefix notation for operators [✔]
      Guards and pattern guards [✔]
      Where clause [✔]
      An empty line is inserted after an empty `where` [✔]
      Multiple function declarations with an empty `where` [✔]
      Let inside a `where` [✔]
      The indent after a top-level `where` has always 2 spaces. [✔]
      The indent after a `where` inside a `case` depends on the indent space setting [✔]
      Pattern matchings
        View pattern [✔]
        Match against a list [✔]
        Multiple matchings [✔]
        n+k patterns [✔]
        Binary symbol data constructor in pattern [✔]
        Infix constructor pattern [✔]
        Unboxed sum pattern matching. [✔]
        Pattern matching against a infix constructor with a module name prefix [✔]
        Pattern matchings against record
          Short [✔]
          Long [✔]
          Another long one [✔]
          Symbol constructor, short [✔]
          Symbol constructor, long [✔]
          Symbol field [✔]
          Punned symbol field [✔]
          `RecordWileCards` [✔]
          As pattern [✔]
    Infix declarations
      infixl [✔]
      infixr [✔]
      infix [✔]
    Pattern synonym declarations
      Unidirectional with a pattern type signature [✔]
      Bidirectional record pattern [✔]
      Explicit bidirectional
        With a prefix constructor [✔]
        With an infix constructor [✔]
    Pragma declarations
      `INLINE` [✔]
      `NOINLINE` with an operator enclosed by parentheses [✔]
      `INLINABLE` [✔]
      `OPAQUE` [✔]
      `INLINE` with levels [✔]
      A `DEPRECATED`. [✔]
      A `WARNING`. [✔]
      A `COMPLETE` [✔]
      Top-level `SPECIALISE` [✔]
      Multiple signatures in a `SPECIALISE` [✔]
      A `SCC` [✔]
      Rule declarations
        Without `forall`s [✔]
        With `forall` but no type signatures [✔]
        With `forall` and type signatures [✔]
    Role annotation declarations
      `normal` [✔]
      `representational` [✔]
      `phantom` [✔]
    Type family declarations
      Without annotations [✔]
      With annotations [✔]
      With injectivity annotations [✔]
      Closed type families [✔]
    Type family instance declarations
      Without holes [✔]
      With a hole [✔]
    Type signature declarations
      Multiple function signatures at once [✔]
      Type using a numeric value [✔]
      Type using a character value [✔]
      Type using a unicode string value [✔]
      A dot not enclosed by spaces is printed correctly if `OverloadedRecordDot` is not enabled. [✔]
      Short [✔]
      Always break after `::` on overlong signatures [✔]
      A long type is broken into lines [✔]
      Long parameter list with a `forall` [✔]
      Implicit parameters [✔]
      Quasiquotes in types [✔]
      Tuples [✔]
      Infix operator [✔]
      With a record [✔]
      `forall` type [✔]
      An infix operator containing `#` [✔]
      Multiple line function signature inside a `where` [✔]
      Types with many type applications [✔]
      Promoted types
        Class constraints should leave `::` on same line [✔]
        An infix operator containing `#` [✔]
        Prefix promoted symbol type constructor [✔]
        Promoted lists
          Short [✔]
          Long [✔]
          Nested [✔]
      Symbol type constructors
        Infix [✔]
        Prefix [✔]
      Type signature with class constraints
        Single [✔]
        Multiple [✔]
        Multiple without parentheses [✔]
        Long constraints [✔]
        Class constraints should leave `::` on same line [✔]
        Symbol class constructor in class constraint [✔]
      Unboxed types
        Short unboxed sums [✔]
        Long unboxed sums [✔]
        Large unboxed tuples [✔]
    Type synonym declarations
      Short [✔]
      Long [✔]
      Very higher-kinded type [✔]
      Infix type constructor [✔]
      Type with a string [✔]
      `TypeOperators` [✔]
      Functional dependencies
        Short [✔]
        Long [✔]
      With class constraints
        Single [✔]
        Multiple [✔]
      MINIMAL pragmas
        Monad example [✔]
        Very long names #310 [✔]
  Expressions
    A minus sign [✔]
    Lists [✔]
    Multi-way if [✔]
    Type application [✔]
    An expression with a SCC pragma [✔]
    A hole [✔]
    Implicit value [✔]
    `UnboxedSums` [✔]
    `StaticPointers` [✔]
    `OverloadedLabels` [✔]
    Arrows
      `-<` [✔]
      `-<<` [✔]
      `(| ... |)` [✔]
      Lambda equation. [✔]
      Case expression. [✔]
      Lambda case [✔]
      `if ... then ... else` [✔]
      `let ... in` [✔]
    Case expressions
      Normal case [✔]
      Inside a `where` and `do` [✔]
      Empty case [✔]
      Empty lambda case [✔]
      A guard in a case [✔]
      cases [✔]
    `do` expressions
      Long function applications [✔]
      Do as a left-hand side of an infix operation [✔]
      Bindings
        Short [✔]
        Large [✔]
      `let` bindings
        With type signatures but no class constraints [✔]
        With both type signatures and class constraints [✔]
      `RecursiveDo`
        `rec` [✔]
        `mdo` [✔]
      `QualifiedDo`
        Qualified do [✔]
        Qualified do with `mdo` [✔]
    Function applications
      Long line, tuple [✔]
      Long line, tuple section [✔]
      Linebreaks after very short names if the total line length goes over the limit [✔]
    Lambda expressions
      Lazy patterns [✔]
      Bang patterns [✔]
      An infix operator with a lambda expression [✔]
      Nested lambdas [✔]
      In a `case` [✔]
    Let ... in expressions
      With bang parameters [✔]
      With implicit parameters [✔]
      inside a `do` [✔]
    List comprehensions
      Short [✔]
      Long [✔]
      Another long one [✔]
      With operators [✔]
      Transform list comprehensions [✔]
      Parallel list comprehensions
        Short [✔]
        Long [✔]
    Operators
      With `do` [✔]
      With lambda-case [✔]
      Qualified operator as an argument [✔]
      Apply an infix operator in prefix style [✔]
      Qualified operator [✔]
      In parentheses [✔]
      Qualified operator in parentheses [✔]
      A list constructor enclosed by parentheses [✔]
      A data constructor enclosed by parentheses [✔]
      Force indent and print RHS in a top-level expression [✔]
      Operator chains
        Applicative style [✔]
        `$` chain [✔]
        Arithmetic operations [✔]
        Lens operators [✔]
    Primitive type values
      `Char` [✔]
      `\n` as a `Char` [✔]
      `String` with a `\n` [✔]
      Multiple line string [✔]
      Hex integers [✔]
      Unboxed integers [✔]
      Unboxed floating point numbers [✔]
      Unboxed `Char` [✔]
      Unboxed `String` [✔]
      `NumericUnderscores` [✔]
    Quasi-quotes
      Body has multiple lines. [✔]
      Body has a top-level declaration. [✔]
      Typed quote. [✔]
      Preserve the trailing newline. [✔]
    Ranges
      from [✔]
      from to [✔]
      from then [✔]
      from then to [✔]
    Records
      No fields [✔]
      Short [✔]
      Medium [✔]
      Long [✔]
      Another long one [✔]
      Record body may be in one line even if a new line is inserted after the variable name. [✔]
      Symbol constructor [✔]
      Symbol field [✔]
      A field updater in a `do` inside a `let ... in`. [✔]
      `OverloadedRecordDot` [✔]
      `OverloadedRecordUpdate` [✔]
    Sections
      With a LHS [✔]
      With a RHS [✔]
      With a large RHS [✔]
  Template Haskell
    Expression brackets [✔]
    Pattern brackets [✔]
    Type brackets [✔]
    A quoted TH name from a type name [✔]
    Quoted list constructors [✔]
    Pattern splices [✔]
    Typed splice [✔]
  Comments
    Only comments [✔]
    Double comments in a line [✔]
    Comments within a declaration [✔]
    Comments in a do expression [✔]
    Comments in a class instance [✔]
    Comments in a case expression [✔]
    Haddock comments [✔]
    Haddock for a class method [✔]
    Module header with haddock comments [✔]
    Comments around regular declarations [✔]
    Multi-line comments [✔]
    Multi-line comments with multi-line contents [✔]
    Comments on functions in where clause [✔]
    Comments in a 'where' clause [✔]
    Haddocks around data constructors [✔]
  Identifiers
    Unicode [✔]
    `rec` and `mdo` are valid identifiers unless `RecursiveDo` is enabled [✔]
    The first character of an infix operator can be `@` unless `TypeApplications` is enabled. [✔]
  Complex input
    A complex, slow-to-print decl [✔]
    Random snippet from hindent itself [✔]
    Quasi quotes [✔]
  C preprocessor
    Conditionals (`#if`) [✔]
    Conditionals inside a `where` with empty lines and CPP [✔]
    Macro definitions (`#define`) [✔]
    Escaped newlines [✔]
    Language extensions are effective across CPP boundaries. [✔]
  Literate Haskell
    Code with `>`s [✔]

Finished in 0.8424 seconds
343 examples, 0 failures
Test suite hindent-test: PASS
Test suite logged to:
/tmp/workdir-hindent/hindent-6.1.1/dist-newstyle/build/x86_64-linux/ghc-9.6.6/hindent-6.1.1/t/hindent-test/test/hindent-6.1.1-hindent-test.log
1 of 1 test suites (1 of 1 test cases) passed.
