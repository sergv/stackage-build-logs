Build profile: -w ghc-9.6.6 -O1
In order, the following will be built (use -v for more details):
 - algebraic-graphs-0.7 (test:main) (ephemeral targets)
Preprocessing test suite 'main' for algebraic-graphs-0.7...
Building test suite 'main' for algebraic-graphs-0.7...
Running 1 test suites...
Test suite main: RUNNING...

============ Acyclic.AdjacencyMap.Show ============
OK: show empty                == "empty"
OK: show (shrink 1)           == "vertex 1"
OK: show (shrink $ 1 + 2)     == "vertices [1,2]"
OK: show (shrink $ 1 * 2)     == "(fromJust . toAcyclic) (edge 1 2)"
OK: show (shrink $ 1 * 2 * 3) == "(fromJust . toAcyclic) (edges [(1,2),(1,3),(2,3)])"
OK: show (shrink $ 1 * 2 + 3) == "(fromJust . toAcyclic) (overlay (vertex 3) (edge 1 2))"

============ Acyclic.AdjacencyMap.fromAcyclic ============
OK: fromAcyclic empty                == empty
OK: fromAcyclic . vertex             == vertex
OK: fromAcyclic (shrink $ 1 * 3 * 2) == star 1 [2,3]
OK: vertexCount . fromAcyclic        == vertexCount
OK: edgeCount   . fromAcyclic        == edgeCount
OK: isAcyclic   . fromAcyclic        == const True

============ Acyclic.AdjacencyMap.empty ============
OK: isEmpty     empty == True
OK: hasVertex x empty == False
OK: vertexCount empty == 0
OK: edgeCount   empty == 0

============ Acyclic.AdjacencyMap.vertex ============
OK: isEmpty     (vertex x) == False
OK: hasVertex x (vertex y) == (x == y)
OK: vertexCount (vertex x) == 1
OK: edgeCount   (vertex x) == 0

============ Acyclic.AdjacencyMap.vertices ============
OK: vertices []            == empty
OK: vertices [x]           == vertex x
OK: hasVertex x . vertices == elem x
OK: vertexCount . vertices == length . nub
OK: vertexSet   . vertices == Set.fromList

============ Acyclic.AdjacencyMap.union ============
OK: vertexSet (union x y) == <correct result>
OK: edgeSet   (union x y) == <correct result>

============ Acyclic.AdjacencyMap.join ============
OK: vertexSet (join x y) == <correct result>
OK: edgeSet   (join x y) == <correct result>

============ Acyclic.AdjacencyMap.isSubgraphOf ============
OK: isSubgraphOf empty        x          ==  True
OK: isSubgraphOf (vertex x)   empty      ==  False
OK: isSubgraphOf (induce p x) x          ==  True
OK: isSubgraphOf x (transitiveClosure x) ==  True
OK: isSubgraphOf x y                     ==> x <= y

============ Acyclic.AdjacencyMap.isEmpty ============
OK: isEmpty empty                             == True
OK: isEmpty (vertex x)                        == False
OK: isEmpty (removeVertex x $ vertex x)       == True
OK: isEmpty (removeEdge 1 2 $ shrink $ 1 * 2) == False

============ Acyclic.AdjacencyMap.hasVertex ============
OK: hasVertex x empty            == False
OK: hasVertex x (vertex y)       == (x == y)
OK: hasVertex x . removeVertex x == const False

============ Acyclic.AdjacencyMap.hasEdge ============
OK: hasEdge x y empty            == False
OK: hasEdge x y (vertex z)       == False
OK: hasEdge 1 2 (shrink $ 1 * 2) == True
OK: hasEdge x y . removeEdge x y == const False
OK: hasEdge x y                  == elem (x,y) . edgeList

============ Acyclic.AdjacencyMap.vertexCount ============
OK: vertexCount empty             ==  0
OK: vertexCount (vertex x)        ==  1
OK: vertexCount                   ==  length . vertexList
OK: vertexCount x < vertexCount y ==> x < y

============ Acyclic.AdjacencyMap.edgeCount ============
OK: edgeCount empty            == 0
OK: edgeCount (vertex x)       == 0
OK: edgeCount (shrink $ 1 * 2) == 1
OK: edgeCount                  == length . edgeList

============ Acyclic.AdjacencyMap.vertexList ============
OK: vertexList empty      == []
OK: vertexList (vertex x) == [x]
OK: vertexList . vertices == nub . sort

============ Acyclic.AdjacencyMap.edgeList ============
OK: edgeList empty            == []
OK: edgeList (vertex x)       == []
OK: edgeList (shrink $ 2 * 1) == [(2,1)]
OK: edgeList . transpose      == sort . map swap . edgeList

============ Acyclic.AdjacencyMap.adjacencyList ============
OK: adjacencyList empty            == []
OK: adjacencyList (vertex x)       == [(x, [])]
OK: adjacencyList (shrink $ 1 * 2) == [(1, [2]), (2, [])]

============ Acyclic.AdjacencyMap.vertexSet ============
OK: vertexSet empty      == Set.empty
OK: vertexSet . vertex   == Set.singleton
OK: vertexSet . vertices == Set.fromList

============ Acyclic.AdjacencyMap.edgeSet ============
OK: edgeSet empty            == Set.empty
OK: edgeSet (vertex x)       == Set.empty
OK: edgeSet (shrink $ 1 * 2) == Set.singleton (1,2)

============ Acyclic.AdjacencyMap.preSet ============
OK: preSet x empty            == Set.empty
OK: preSet x (vertex x)       == Set.empty
OK: preSet 1 (shrink $ 1 * 2) == Set.empty
OK: preSet 2 (shrink $ 1 * 2) == Set.fromList [1]
OK: Set.member x . preSet x   == const False

============ Acyclic.AdjacencyMap.postSet ============
OK: postSet x empty            == Set.empty
OK: postSet x (vertex x)       == Set.empty
OK: postSet 1 (shrink $ 1 * 2) == Set.fromList [2]
OK: postSet 2 (shrink $ 1 * 2) == Set.empty
OK: Set.member x . postSet x   == const False

============ Acyclic.AdjacencyMap.removeVertex ============
OK: removeVertex x (vertex x)       == empty
OK: removeVertex 1 (vertex 2)       == vertex 2
OK: removeVertex 1 (shrink $ 1 * 2) == vertex 2
OK: removeVertex x . removeVertex x == removeVertex x

============ Acyclic.AdjacencyMap.removeEdge ============
OK: removeEdge 1 2 (shrink $ 1 * 2)     == vertices [1,2]
OK: removeEdge x y . removeEdge x y     == removeEdge x y
OK: removeEdge x y . removeVertex x     == removeVertex x
OK: removeEdge 1 2 (shrink $ 1 * 2 * 3) == shrink ((1 + 2) * 3)

============ Acyclic.AdjacencyMap.transpose ============
OK: transpose empty       == empty
OK: transpose (vertex x)  == vertex x
OK: transpose . transpose == id
OK: edgeList . transpose  == sort . map swap . edgeList

============ Acyclic.AdjacencyMap.induce ============
OK: induce (const True ) x      == x
OK: induce (const False) x      == empty
OK: induce (/= x)               == removeVertex x
OK: induce p . induce q         == induce (\x -> p x && q x)
OK: isSubgraphOf (induce p x) x == True

============ Acyclic.AdjacencyMap.induceJust ============
OK: induceJust (vertex Nothing) == empty
OK: induceJust . vertex . Just  == vertex

============ Acyclic.AdjacencyMap.box ============
OK: edgeList (box (shrink $ 1 * 2) (shrink $ 10 * 20)) == <correct result>

OK: box x y               ~~ box y x
OK: box x (vertex ())     ~~ x
OK: box x empty           ~~ empty
OK: box x (box y z)       ~~ box (box x y) z
OK: transpose   (box x y) == box (transpose x) (transpose y)
OK: vertexCount (box x y) == vertexCount x * vertexCount y
OK: edgeCount   (box x y) <= vertexCount x * edgeCount y + edgeCount x * vertexCount y

============ Acyclic.AdjacencyMap.transitiveClosure ============
OK: transitiveClosure empty                    == empty
OK: transitiveClosure (vertex x)               == vertex x
OK: transitiveClosure (shrink $ 1 * 2 + 2 * 3) == shrink (1 * 2 + 1 * 3 + 2 * 3)
OK: transitiveClosure . transitiveClosure      == transitiveClosure

============ Acyclic.AdjacencyMap.topSort ============
OK: topSort empty                          == []
OK: topSort (vertex x)                     == [x]
OK: topSort (shrink $ 1 * (2 + 4) + 3 * 4) == [1, 2, 3, 4]
OK: topSort (join x y)                     == fmap Left (topSort x) ++ fmap Right (topSort y)
OK: Right . topSort                        == AM.topSort . fromAcyclic

============ Acyclic.AdjacencyMap.scc ============
OK:            scc empty               == empty
OK:            scc (vertex x)          == vertex (NonEmpty.vertex x)
OK:            scc (edge 1 1)          == vertex (NonEmpty.edge 1 1)
OK: edgeList $ scc (edge 1 2)          == [ (NonEmpty.vertex 1, NonEmpty.vertex 2) ]
OK: edgeList $ scc (3 * 1 * 4 * 1 * 5) == <correct result>

============ Acyclic.AdjacencyMap.toAcyclic ============
OK: toAcyclic (path    [1,2,3]) == Just (shrink $ 1 * 2 + 2 * 3)
OK: toAcyclic (clique  [3,2,1]) == Just (transpose (shrink $ 1 * 2 * 3))
OK: toAcyclic (circuit [1,2,3]) == Nothing
OK: toAcyclic . fromAcyclic     == Just

============ Acyclic.AdjacencyMap.toAcyclicOrd ============
OK: toAcyclicOrd empty       == empty
OK: toAcyclicOrd . vertex    == vertex
OK: toAcyclicOrd (1 + 2)     == shrink (1 + 2)
OK: toAcyclicOrd (1 * 2)     == shrink (1 * 2)
OK: toAcyclicOrd (2 * 1)     == shrink (1 + 2)
OK: toAcyclicOrd (1 * 2 * 1) == shrink (1 * 2)
OK: toAcyclicOrd (1 * 2 * 3) == shrink (1 * 2 * 3)

============ Acyclic.AdjacencyMap.shrink ============
OK: shrink . AM.vertex   == vertex
OK: shrink . AM.vertices == vertices
OK: shrink . fromAcyclic == id

============ Acyclic.AdjacencyMap.consistent ============
OK: Arbitrary
OK: empty
OK: vertex
OK: vertices
OK: union
OK: join
OK: transpose
OK: box
OK: transitiveClosure
OK: scc
OK: toAcyclic
OK: toAcyclicOrd

============ AdjacencyIntMap ============
OK: Axioms of graphs

============ AdjacencyIntMap.fromAdjacencyMap ============
OK: fromAdjacencyMap == stars . AdjacencyMap.adjacencyList

============ AdjacencyIntMap.consistent ============
OK: Consistency of the Arbitrary instance

OK: consistent empty         == True
OK: consistent (vertex x)    == True
OK: consistent (overlay x y) == True
OK: consistent (connect x y) == True
OK: consistent (edge x y)    == True
OK: consistent (edges xs)    == True
OK: consistent (stars xs)    == True

============ AdjacencyIntMap.Show ============
OK: show (empty    ) == "empty"
OK: show (1        ) == "vertex 1"
OK: show (1 + 2    ) == "vertices [1,2]"
OK: show (1 * 2    ) == "edge 1 2"
OK: show (1 * 2 * 3) == "edges [(1,2),(1,3),(2,3)]"
OK: show (1 * 2 + 3) == "overlay (vertex 3) (edge 1 2)"

OK: show (vertex (-1)                            ) == "vertex (-1)"
OK: show (vertex (-1) + vertex (-2)              ) == "vertices [-2,-1]"
OK: show (vertex (-2) * vertex (-1)              ) == "edge (-2) (-1)"
OK: show (vertex (-3) * vertex (-2) * vertex (-1)) == "edges [(-3,-2),(-3,-1),(-2,-1)]"
OK: show (vertex (-3) * vertex (-2) + vertex (-1)) == "overlay (vertex (-1)) (edge (-3) (-2))"

============ AdjacencyIntMap.Ord ============
OK: vertex 1 <  vertex 2
OK: vertex 3 <  edge 1 2
OK: vertex 1 <  edge 1 1
OK: edge 1 1 <  edge 1 2
OK: edge 1 2 <  edge 1 1 + edge 2 2
OK: edge 1 2 <  edge 1 3
OK: x        <= x + y
OK: x + y    <= x * y

============ AdjacencyIntMap.empty ============
OK: isEmpty     empty == True
OK: hasVertex x empty == False
OK: vertexCount empty == 0
OK: edgeCount   empty == 0

============ AdjacencyIntMap.vertex ============
OK: isEmpty     (vertex x) == False
OK: hasVertex x (vertex y) == (x == y)
OK: vertexCount (vertex x) == 1
OK: edgeCount   (vertex x) == 0

============ AdjacencyIntMap.edge ============
OK: edge x y               == connect (vertex x) (vertex y)
OK: hasEdge x y (edge x y) == True
OK: edgeCount   (edge x y) == 1
OK: vertexCount (edge 1 1) == 1
OK: vertexCount (edge 1 2) == 2

============ AdjacencyIntMap.overlay ============
OK: isEmpty     (overlay x y) == isEmpty   x   && isEmpty   y
OK: hasVertex z (overlay x y) == hasVertex z x || hasVertex z y
OK: vertexCount (overlay x y) >= vertexCount x
OK: vertexCount (overlay x y) <= vertexCount x + vertexCount y
OK: edgeCount   (overlay x y) >= edgeCount x
OK: edgeCount   (overlay x y) <= edgeCount x   + edgeCount y
OK: vertexCount (overlay 1 2) == 2
OK: edgeCount   (overlay 1 2) == 0

============ AdjacencyIntMap.connect ============
OK: isEmpty     (connect x y) == isEmpty   x   && isEmpty   y
OK: hasVertex z (connect x y) == hasVertex z x || hasVertex z y
OK: vertexCount (connect x y) >= vertexCount x
OK: vertexCount (connect x y) <= vertexCount x + vertexCount y
OK: edgeCount   (connect x y) >= edgeCount x
OK: edgeCount   (connect x y) >= edgeCount y
OK: edgeCount   (connect x y) >= vertexCount x * vertexCount y
OK: edgeCount   (connect x y) <= vertexCount x * vertexCount y + edgeCount x + edgeCount y
OK: vertexCount (connect 1 2) == 2
OK: edgeCount   (connect 1 2) == 1

============ AdjacencyIntMap.vertices ============
OK: vertices []            == empty
OK: vertices [x]           == vertex x
OK: vertices               == overlays . map vertex
OK: hasVertex x . vertices == elem x
OK: vertexCount . vertices == length . nub
OK: vertexSet   . vertices == Set.fromList

============ AdjacencyIntMap.edges ============
OK: edges []          == empty
OK: edges [(x,y)]     == edge x y
OK: edges             == overlays . map (uncurry edge)
OK: edgeCount . edges == length . nub

============ AdjacencyIntMap.overlays ============
OK: overlays []        == empty
OK: overlays [x]       == x
OK: overlays [x,y]     == overlay x y
OK: overlays           == foldr overlay empty
OK: isEmpty . overlays == all isEmpty

============ AdjacencyIntMap.connects ============
OK: connects []        == empty
OK: connects [x]       == x
OK: connects [x,y]     == connect x y
OK: connects           == foldr connect empty
OK: isEmpty . connects == all isEmpty

============ AdjacencyIntMap.fromAdjacencyIntSets ============
OK: fromAdjacencyIntSets []                                     == empty
OK: fromAdjacencyIntSets [(x, IntSet.empty)]                    == vertex x
OK: fromAdjacencyIntSets [(x, IntSet.singleton y)]              == edge x y
OK: fromAdjacencyIntSets . map (fmap IntSet.fromList)           == stars
OK: overlay (fromAdjacencyIntSets xs) (fromAdjacencyIntSets ys) == fromAdjacencyIntSets (xs ++ ys)

============ AdjacencyIntMap.isSubgraphOf ============
OK: isSubgraphOf empty         x             ==  True
OK: isSubgraphOf (vertex x)    empty         ==  False
OK: isSubgraphOf x             (overlay x y) ==  True
OK: isSubgraphOf (overlay x y) (connect x y) ==  True
OK: isSubgraphOf (path xs)     (circuit xs)  ==  True
OK: isSubgraphOf x y                         ==> x <= y

============ AdjacencyIntMap.toGraph et al. ============
OK: toGraph                    == foldg Empty Vertex Overlay Connect
OK: foldg                      == Algebra.Graph.foldg . toGraph
OK: isEmpty                    == foldg True (const False) (&&) (&&)
OK: size                       == foldg 1 (const 1) (+) (+)
OK: hasVertex x                == foldg False (==x) (||) (||)
OK: hasEdge x y                == Algebra.Graph.hasEdge x y . toGraph
OK: vertexCount                == Set.size . vertexSet
OK: edgeCount                  == Set.size . edgeSet
OK: vertexList                 == Set.toAscList . vertexSet
OK: edgeList                   == Set.toAscList . edgeSet
OK: vertexSet                  == foldg Set.empty Set.singleton Set.union Set.union
OK: vertexIntSet               == foldg IntSet.empty IntSet.singleton IntSet.union IntSet.union
OK: edgeSet                    == Algebra.Graph.AdjacencyMap.edgeSet . foldg empty vertex overlay connect
OK: preSet x                   == Algebra.Graph.AdjacencyMap.preSet x . toAdjacencyMap
OK: preIntSet x                == Algebra.Graph.AdjacencyIntMap.preIntSet x . toAdjacencyIntMap
OK: postSet x                  == Algebra.Graph.AdjacencyMap.postSet x . toAdjacencyMap
OK: postIntSet x               == Algebra.Graph.AdjacencyIntMap.postIntSet x . toAdjacencyIntMap
OK: adjacencyList              == Algebra.Graph.AdjacencyMap.adjacencyList . toAdjacencyMap
OK: adjacencyMap               == Algebra.Graph.AdjacencyMap.adjacencyMap . toAdjacencyMap
OK: adjacencyIntMap            == Algebra.Graph.AdjacencyIntMap.adjacencyIntMap . toAdjacencyIntMap
OK: adjacencyMapTranspose      == Algebra.Graph.AdjacencyMap.adjacencyMap . toAdjacencyMapTranspose
OK: adjacencyIntMapTranspose   == Algebra.Graph.AdjacencyIntMap.adjacencyIntMap . toAdjacencyIntMapTranspose
OK: dfsForest                  == Algebra.Graph.AdjacencyMap.dfsForest . toAdjacencyMap
OK: dfsForestFrom              == Algebra.Graph.AdjacencyMap.dfsForestFrom . toAdjacencyMap
OK: dfs                        == Algebra.Graph.AdjacencyMap.dfs . toAdjacencyMap
OK: reachable                  == Algebra.Graph.AdjacencyMap.reachable . toAdjacencyMap
OK: topSort                    == Algebra.Graph.AdjacencyMap.topSort . toAdjacencyMap
OK: isAcyclic                  == Algebra.Graph.AdjacencyMap.isAcyclic . toAdjacencyMap
OK: isTopSortOf vs             == Algebra.Graph.AdjacencyMap.isTopSortOf vs . toAdjacencyMap
OK: toAdjacencyMap             == foldg empty vertex overlay connect
OK: toAdjacencyMapTranspose    == foldg empty vertex overlay (flip connect)
OK: toAdjacencyIntMap          == foldg empty vertex overlay connect
OK: toAdjacencyIntMapTranspose == foldg empty vertex overlay (flip connect)
OK: isDfsForestOf f            == Algebra.Graph.AdjacencyMap.isDfsForestOf f . toAdjacencyMap
OK: isTopSortOf vs             == Algebra.Graph.AdjacencyMap.isTopSortOf vs . toAdjacencyMap

============ AdjacencyIntMap.foldg ============
OK: foldg empty vertex        overlay connect        == id
OK: foldg empty vertex        overlay (flip connect) == transpose
OK: foldg 1     (const 1)     (+)     (+)            == size
OK: foldg True  (const False) (&&)    (&&)           == isEmpty

============ AdjacencyIntMap.isEmpty ============
OK: isEmpty empty                       == True
OK: isEmpty (overlay empty empty)       == True
OK: isEmpty (vertex x)                  == False
OK: isEmpty (removeVertex x $ vertex x) == True
OK: isEmpty (removeEdge x y $ edge x y) == False

============ AdjacencyIntMap.hasVertex ============
OK: hasVertex x empty            == False
OK: hasVertex x (vertex y)       == (x == y)
OK: hasVertex x . removeVertex x == const False

============ AdjacencyIntMap.hasEdge ============
OK: hasEdge x y empty            == False
OK: hasEdge x y (vertex z)       == False
OK: hasEdge x y (edge x y)       == True
OK: hasEdge x y . removeEdge x y == const False
OK: hasEdge x y                  == elem (x,y) . edgeList

============ AdjacencyIntMap.vertexCount ============
OK: vertexCount empty             ==  0
OK: vertexCount (vertex x)        ==  1
OK: vertexCount                   ==  length . vertexList
OK: vertexCount x < vertexCount y ==> x < y

============ AdjacencyIntMap.edgeCount ============
OK: edgeCount empty      == 0
OK: edgeCount (vertex x) == 0
OK: edgeCount (edge x y) == 1
OK: edgeCount            == length . edgeList

============ AdjacencyIntMap.vertexList ============
OK: vertexList empty      == []
OK: vertexList (vertex x) == [x]
OK: vertexList . vertices == nub . sort

============ AdjacencyIntMap.vertexSet ============
OK: vertexSet empty      == Set.empty
OK: vertexSet . vertex   == Set.singleton
OK: vertexSet . vertices == Set.fromList

============ AdjacencyIntMap.vertexIntSet ============
OK: vertexIntSet empty      == IntSet.empty
OK: vertexIntSet . vertex   == IntSet.singleton
OK: vertexIntSet . vertices == IntSet.fromList
OK: vertexIntSet . clique   == IntSet.fromList

============ AdjacencyIntMap.edgeList ============
OK: edgeList empty          == []
OK: edgeList (vertex x)     == []
OK: edgeList (edge x y)     == [(x,y)]
OK: edgeList (star 2 [3,1]) == [(2,1), (2,3)]
OK: edgeList . edges        == nub . sort

============ AdjacencyIntMap.edgeSet ============
OK: edgeSet empty      == Set.empty
OK: edgeSet (vertex x) == Set.empty
OK: edgeSet (edge x y) == Set.singleton (x,y)
OK: edgeSet . edges    == Set.fromList

============ AdjacencyIntMap.adjacencyList ============
OK: adjacencyList empty          == []
OK: adjacencyList (vertex x)     == [(x, [])]
OK: adjacencyList (edge 1 2)     == [(1, [2]), (2, [])]
OK: adjacencyList (star 2 [3,1]) == [(1, []), (2, [1,3]), (3, [])]

============ AdjacencyIntMap.preSet ============
OK: preSet x empty      == Set.empty
OK: preSet x (vertex x) == Set.empty
OK: preSet 1 (edge 1 2) == Set.empty
OK: preSet y (edge x y) == Set.fromList [x]

============ AdjacencyIntMap.preIntSet ============
OK: preIntSet x empty      == IntSet.empty
OK: preIntSet x (vertex x) == IntSet.empty
OK: preIntSet 1 (edge 1 2) == IntSet.empty
OK: preIntSet y (edge x y) == IntSet.fromList [x]

============ AdjacencyIntMap.postSet ============
OK: postSet x empty      == Set.empty
OK: postSet x (vertex x) == Set.empty
OK: postSet x (edge x y) == Set.fromList [y]
OK: postSet 2 (edge 1 2) == Set.empty

============ AdjacencyIntMap.postIntSet ============
OK: postIntSet x empty      == IntSet.empty
OK: postIntSet x (vertex x) == IntSet.empty
OK: postIntSet 2 (edge 1 2) == IntSet.empty
OK: postIntSet x (edge x y) == IntSet.fromList [y]

============ AdjacencyIntMap.path ============
OK: path []    == empty
OK: path [x]   == vertex x
OK: path [x,y] == edge x y

============ AdjacencyIntMap.circuit ============
OK: circuit []    == empty
OK: circuit [x]   == edge x x
OK: circuit [x,y] == edges [(x,y), (y,x)]

============ AdjacencyIntMap.clique ============
OK: clique []         == empty
OK: clique [x]        == vertex x
OK: clique [x,y]      == edge x y
OK: clique [x,y,z]    == edges [(x,y), (x,z), (y,z)]
OK: clique (xs ++ ys) == connect (clique xs) (clique ys)

============ AdjacencyIntMap.biclique ============
OK: biclique []      []      == empty
OK: biclique [x]     []      == vertex x
OK: biclique []      [y]     == vertex y
OK: biclique [x1,x2] [y1,y2] == edges [(x1,y1), (x1,y2), (x2,y1), (x2,y2)]
OK: biclique xs      ys      == connect (vertices xs) (vertices ys)

============ AdjacencyIntMap.star ============
OK: star x []    == vertex x
OK: star x [y]   == edge x y
OK: star x [y,z] == edges [(x,y), (x,z)]
OK: star x ys    == connect (vertex x) (vertices ys)

============ AdjacencyIntMap.stars ============
OK: stars []                      == empty
OK: stars [(x, [])]               == vertex x
OK: stars [(x, [y])]              == edge x y
OK: stars [(x, ys)]               == star x ys
OK: stars                         == overlays . map (uncurry star)
OK: stars . adjacencyList         == id
OK: overlay (stars xs) (stars ys) == stars (xs ++ ys)

============ AdjacencyIntMap.tree ============
OK: tree (Node x [])                                         == vertex x
OK: tree (Node x [Node y [Node z []]])                       == path [x,y,z]
OK: tree (Node x [Node y [], Node z []])                     == star x [y,z]
OK: tree (Node 1 [Node 2 [], Node 3 [Node 4 [], Node 5 []]]) == edges [(1,2), (1,3), (3,4), (3,5)]

============ AdjacencyIntMap.forest ============
OK: forest []                                                  == empty
OK: forest [x]                                                 == tree x
OK: forest [Node 1 [Node 2 [], Node 3 []], Node 4 [Node 5 []]] == edges [(1,2), (1,3), (4,5)]
OK: forest                                                     == overlays . map tree

============ AdjacencyIntMap.removeVertex ============
OK: removeVertex x (vertex x)       == empty
OK: removeVertex 1 (vertex 2)       == vertex 2
OK: removeVertex x (edge x x)       == empty
OK: removeVertex 1 (edge 1 2)       == vertex 2
OK: removeVertex x . removeVertex x == removeVertex x

============ AdjacencyIntMap.removeEdge ============
OK: removeEdge x y (edge x y)       == vertices [x,y]
OK: removeEdge x y . removeEdge x y == removeEdge x y
OK: removeEdge x y . removeVertex x == removeVertex x
OK: removeEdge 1 1 (1 * 1 * 2 * 2)  == 1 * 2 * 2
OK: removeEdge 1 2 (1 * 1 * 2 * 2)  == 1 * 1 + 2 * 2

============ AdjacencyIntMap.replaceVertex ============
OK: replaceVertex x x            == id
OK: replaceVertex x y (vertex x) == vertex y
OK: replaceVertex x y            == mergeVertices (== x) y

============ AdjacencyIntMap.mergeVertices ============
OK: mergeVertices (const False) x    == id
OK: mergeVertices (== x) y           == replaceVertex x y
OK: mergeVertices even 1 (0 * 2)     == 1 * 1
OK: mergeVertices odd  1 (3 + 4 * 5) == 4 * 1

============ AdjacencyIntMap.transpose ============
OK: transpose empty       == empty
OK: transpose (vertex x)  == vertex x
OK: transpose (edge x y)  == edge y x
OK: transpose . transpose == id
OK: edgeList . transpose  == sort . map swap . edgeList

============ AdjacencyIntMap.gmap ============
OK: gmap f empty      == empty
OK: gmap f (vertex x) == vertex (f x)
OK: gmap f (edge x y) == edge (f x) (f y)
OK: gmap id           == id
OK: gmap f . gmap g   == gmap (f . g)

============ AdjacencyIntMap.induce ============
OK: induce (const True ) x      == x
OK: induce (const False) x      == empty
OK: induce (/= x)               == removeVertex x
OK: induce p . induce q         == induce (\x -> p x && q x)
OK: isSubgraphOf (induce p x) x == True

============ AdjacencyIntMap.compose ============
OK: compose empty            x                == empty
OK: compose x                empty            == empty
OK: compose (vertex x)       y                == empty
OK: compose x                (vertex y)       == empty
OK: compose x                (compose y z)    == compose (compose x y) z
OK: compose x                (overlay y z)    == overlay (compose x y) (compose x z)
OK: compose (overlay x y) z                   == overlay (compose x z) (compose y z)
OK: compose (edge x y)       (edge y z)       == edge x z
OK: compose (path    [1..5]) (path    [1..5]) == edges [(1,3),(2,4),(3,5)]
OK: compose (circuit [1..5]) (circuit [1..5]) == circuit [1,3,5,2,4]

============ AdjacencyIntMap.closure ============
OK: closure empty           == empty
OK: closure (vertex x)      == edge x x
OK: closure (edge x x)      == edge x x
OK: closure (edge x y)      == edges [(x,x), (x,y), (y,y)]
OK: closure (path $ nub xs) == reflexiveClosure (clique $ nub xs)
OK: closure                 == reflexiveClosure . transitiveClosure
OK: closure                 == transitiveClosure . reflexiveClosure
OK: closure . closure       == closure
OK: postSet x (closure y)   == Set.fromList (reachable y x)

============ AdjacencyIntMap.reflexiveClosure ============
OK: reflexiveClosure empty              == empty
OK: reflexiveClosure (vertex x)         == edge x x
OK: reflexiveClosure (edge x x)         == edge x x
OK: reflexiveClosure (edge x y)         == edges [(x,x), (x,y), (y,y)]
OK: reflexiveClosure . reflexiveClosure == reflexiveClosure

============ AdjacencyIntMap.symmetricClosure ============
OK: symmetricClosure empty              == empty
OK: symmetricClosure (vertex x)         == vertex x
OK: symmetricClosure (edge x y)         == edges [(x,y), (y,x)]
OK: symmetricClosure x                  == overlay x (transpose x)
OK: symmetricClosure . symmetricClosure == symmetricClosure

============ AdjacencyIntMap.transitiveClosure ============
OK: transitiveClosure empty               == empty
OK: transitiveClosure (vertex x)          == vertex x
OK: transitiveClosure (edge x y)          == edge x y
OK: transitiveClosure (path $ nub xs)     == clique (nub $ xs)
OK: transitiveClosure . transitiveClosure == transitiveClosure

============ AdjacencyIntMap.bfsForest ============
OK: forest $ bfsForest (edge 1 2) [0]        == empty
OK: forest $ bfsForest (edge 1 2) [1]        == edge 1 2
OK: forest $ bfsForest (edge 1 2) [2]        == vertex 2
OK: forest $ bfsForest (edge 1 2) [0,1,2]    == vertices [1,2]
OK: forest $ bfsForest (edge 1 2) [2,1,0]    == vertices [1,2]
OK: forest $ bfsForest (edge 1 1) [1]        == vertex 1
OK: isSubgraphOf (forest $ bfsForest x vs) x == True
OK: bfsForest x (vertexList x)               == map ( -> Node v []) (nub $ vertexList x)
OK: bfsForest x []                           == []
OK: bfsForest empty vs                       == []
OK: bfsForest (3 * (1 + 4) * (1 + 5)) [1,4]  == <correct result>
OK: forest $ bfsForest (circuit [1..5] + circuit [5,4..1]) [3] == path [3,2,1] + path [3,4,5]

============ AdjacencyIntMap.bfs ============
OK: bfs (edge 1 2) [0]                                   == []
OK: bfs (edge 1 2) [1]                                   == [[1], [2]]
OK: bfs (edge 1 2) [2]                                   == [[2]]
OK: bfs (edge 1 2) [1,2]                                 == [[1,2]]
OK: bfs (edge 1 2) [2,1]                                 == [[2,1]]
OK: bfs (edge 1 1) [1]                                   == [[1]]
OK: bfs empty vs                                         == []
OK: bfs x []                                             == []
OK: bfs (1 * 2 + 3 * 4 + 5 * 6) [1,2]                    == [[1,2]]
OK: bfs (1 * 2 + 3 * 4 + 5 * 6) [1,3]                    == [[1,3], [2,4]]
OK: bfs (3 * (1 + 4) * (1 + 5)) [3]                      == [[3], [1,4,5]]
OK: bfs (circuit [1..5] + circuit [5,4..1]) [2]          == [[2], [1,3], [5,4]]
OK: concat $ bfs (circuit [1..5] + circuit [5,4..1]) [3] == [3,2,4,1,5]
OK: map concat . transpose . map levels . bfsForest x    == bfs x

============ AdjacencyIntMap.dfsForest ============
OK: forest $ dfsForest empty              == empty
OK: forest $ dfsForest (edge 1 1)         == vertex 1
OK: forest $ dfsForest (edge 1 2)         == edge 1 2
OK: forest $ dfsForest (edge 2 1)         == vertices [1,2]
OK: isSubgraphOf (forest $ dfsForest x) x == True
OK: isDfsForestOf (dfsForest x) x         == True
OK: dfsForest . forest . dfsForest        == dfsForest
OK: dfsForest (vertices vs)               == map (\v -> Node v []) (nub $ sort vs)
OK: dfsForest $ 3 * (1 + 4) * (1 + 5)     == <correct result>
OK: forest (dfsForest $ circuit [1..5] + circuit [5,4..1]) == path [1,2,3,4,5]

============ AdjacencyIntMap.dfsForestFrom ============
OK: forest $ dfsForestFrom empty      vs             == empty
OK: forest $ dfsForestFrom (edge 1 1) [1]            == vertex 1
OK: forest $ dfsForestFrom (edge 1 2) [0]            == empty
OK: forest $ dfsForestFrom (edge 1 2) [1]            == edge 1 2
OK: forest $ dfsForestFrom (edge 1 2) [2]            == vertex 2
OK: forest $ dfsForestFrom (edge 1 2) [1,2]          == edge 1 2
OK: forest $ dfsForestFrom (edge 1 2) [2,1]          == vertices [1,2]
OK: isSubgraphOf (forest $ dfsForestFrom x vs) x     == True
OK: isDfsForestOf (dfsForestFrom x (vertexList x)) x == True
OK: dfsForestFrom x (vertexList x)                   == dfsForest x
OK: dfsForestFrom x []                               == []
OK: dfsForestFrom (3 * (1 + 4) * (1 + 5)) [1,4]      == <correct result>
OK: forest $ dfsForestFrom (circuit [1..5] + circuit [5,4..1]) [3] == path [3,2,1,5,4]

============ AdjacencyIntMap.dfs ============
OK: dfs empty      vs    == []
OK: dfs (edge 1 1) [1]   == [1]
OK: dfs (edge 1 2) [0]   == []
OK: dfs (edge 1 2) [1]   == [1,2]
OK: dfs (edge 1 2) [2]   == [2]
OK: dfs (edge 1 2) [1,2] == [1,2]
OK: dfs (edge 1 2) [2,1] == [2,1]
OK: dfs x          []    == []

OK: and [ hasVertex v x | v <- dfs x vs ]       == True
OK: dfs (3 * (1 + 4) * (1 + 5)) [1,4]           == [1,5,4]
OK: dfs (circuit [1..5] + circuit [5,4..1]) [3] == [3,2,1,5,4]

============ AdjacencyIntMap.dfs ============
OK: reachable empty              x == []
OK: reachable (vertex 1)         1 == [1]
OK: reachable (edge 1 1)         1 == [1]
OK: reachable (edge 1 2)         0 == []
OK: reachable (edge 1 2)         1 == [1,2]
OK: reachable (edge 1 2)         2 == [2]
OK: reachable (path    [1..8]  ) 4 == [4..8]
OK: reachable (circuit [1..8]  ) 4 == [4..8] ++ [1..3]
OK: reachable (clique  [8,7..1]) 8 == [8] ++ [1..7]

OK: and [ hasVertex v x | v <- reachable x y ] == True

============ AdjacencyIntMap.topSort ============
OK: topSort (1 * 2 + 3 * 1)                    == Right [3,1,2]
OK: topSort (path [1..5])                      == Right [1..5]
OK: topSort (3 * (1 * 4 + 2 * 5))              == Right [3,1,2,4,5]
OK: topSort (1 * 2 + 2 * 1)                    == Left (2 :| [1])
OK: topSort (path [5,4..1] + edge 2 4)         == Left (4 :| [3,2])
OK: topSort (circuit [1..5])                   == Left (3 :| [1,2])
OK: topSort (circuit [1..3] + circuit [3,2,1]) == Left (3 :| [2])
OK: topSort (1 * 2 + (5 + 2) * 1 + 3 * 4 * 3)  == Left (1 :| [2])
OK: fmap (flip isTopSortOf x) (topSort x) /= Right False
OK: topSort . vertices     == Right . nub . sort

============ AdjacencyIntMap.testIsAcyclic ============
OK: isAcyclic (1 * 2 + 3 * 1) == True
OK: isAcyclic (1 * 2 + 2 * 1) == False
OK: isAcyclic . circuit       == null
OK: isAcyclic                 == isRight . topSort

============ AdjacencyIntMap.isDfsForestOf ============
OK: isDfsForestOf []                              empty            == True
OK: isDfsForestOf []                              (vertex 1)       == False
OK: isDfsForestOf [Node 1 []]                     (vertex 1)       == True
OK: isDfsForestOf [Node 1 []]                     (vertex 2)       == False
OK: isDfsForestOf [Node 1 [], Node 1 []]          (vertex 1)       == False
OK: isDfsForestOf [Node 1 []]                     (edge 1 1)       == True
OK: isDfsForestOf [Node 1 []]                     (edge 1 2)       == False
OK: isDfsForestOf [Node 1 [], Node 2 []]          (edge 1 2)       == False
OK: isDfsForestOf [Node 2 [], Node 1 []]          (edge 1 2)       == True
OK: isDfsForestOf [Node 1 [Node 2 []]]            (edge 1 2)       == True
OK: isDfsForestOf [Node 1 [], Node 2 []]          (vertices [1,2]) == True
OK: isDfsForestOf [Node 2 [], Node 1 []]          (vertices [1,2]) == True
OK: isDfsForestOf [Node 1 [Node 2 []]]            (vertices [1,2]) == False
OK: isDfsForestOf [Node 1 [Node 2 [Node 3 []]]]   (path [1,2,3])   == True
OK: isDfsForestOf [Node 1 [Node 3 [Node 2 []]]]   (path [1,2,3])   == False
OK: isDfsForestOf [Node 3 [], Node 1 [Node 2 []]] (path [1,2,3])   == True
OK: isDfsForestOf [Node 2 [Node 3 []], Node 1 []] (path [1,2,3])   == True
OK: isDfsForestOf [Node 1 [], Node 2 [Node 3 []]] (path [1,2,3])   == False

============ AdjacencyIntMap.isTopSortOf ============
OK: isTopSortOf [3,1,2] (1 * 2 + 3 * 1) == True
OK: isTopSortOf [1,2,3] (1 * 2 + 3 * 1) == False
OK: isTopSortOf []      (1 * 2 + 3 * 1) == False
OK: isTopSortOf []      empty           == True
OK: isTopSortOf [x]     (vertex x)      == True
OK: isTopSortOf [x]     (edge x x)      == False

============ AdjacencyMap ============
OK: Axioms of graphs

============ AdjacencyMap.consistent ============
OK: Consistency of the Arbitrary instance

OK: consistent empty         == True
OK: consistent (vertex x)    == True
OK: consistent (overlay x y) == True
OK: consistent (connect x y) == True
OK: consistent (edge x y)    == True
OK: consistent (edges xs)    == True
OK: consistent (stars xs)    == True

============ AdjacencyMap.Show ============
OK: show (empty    ) == "empty"
OK: show (1        ) == "vertex 1"
OK: show (1 + 2    ) == "vertices [1,2]"
OK: show (1 * 2    ) == "edge 1 2"
OK: show (1 * 2 * 3) == "edges [(1,2),(1,3),(2,3)]"
OK: show (1 * 2 + 3) == "overlay (vertex 3) (edge 1 2)"

OK: show (vertex (-1)                            ) == "vertex (-1)"
OK: show (vertex (-1) + vertex (-2)              ) == "vertices [-2,-1]"
OK: show (vertex (-2) * vertex (-1)              ) == "edge (-2) (-1)"
OK: show (vertex (-3) * vertex (-2) * vertex (-1)) == "edges [(-3,-2),(-3,-1),(-2,-1)]"
OK: show (vertex (-3) * vertex (-2) + vertex (-1)) == "overlay (vertex (-1)) (edge (-3) (-2))"

============ AdjacencyMap.Ord ============
OK: vertex 1 <  vertex 2
OK: vertex 3 <  edge 1 2
OK: vertex 1 <  edge 1 1
OK: edge 1 1 <  edge 1 2
OK: edge 1 2 <  edge 1 1 + edge 2 2
OK: edge 1 2 <  edge 1 3
OK: x        <= x + y
OK: x + y    <= x * y

============ AdjacencyMap.empty ============
OK: isEmpty     empty == True
OK: hasVertex x empty == False
OK: vertexCount empty == 0
OK: edgeCount   empty == 0

============ AdjacencyMap.vertex ============
OK: isEmpty     (vertex x) == False
OK: hasVertex x (vertex y) == (x == y)
OK: vertexCount (vertex x) == 1
OK: edgeCount   (vertex x) == 0

============ AdjacencyMap.edge ============
OK: edge x y               == connect (vertex x) (vertex y)
OK: hasEdge x y (edge x y) == True
OK: edgeCount   (edge x y) == 1
OK: vertexCount (edge 1 1) == 1
OK: vertexCount (edge 1 2) == 2

============ AdjacencyMap.overlay ============
OK: isEmpty     (overlay x y) == isEmpty   x   && isEmpty   y
OK: hasVertex z (overlay x y) == hasVertex z x || hasVertex z y
OK: vertexCount (overlay x y) >= vertexCount x
OK: vertexCount (overlay x y) <= vertexCount x + vertexCount y
OK: edgeCount   (overlay x y) >= edgeCount x
OK: edgeCount   (overlay x y) <= edgeCount x   + edgeCount y
OK: vertexCount (overlay 1 2) == 2
OK: edgeCount   (overlay 1 2) == 0

============ AdjacencyMap.connect ============
OK: isEmpty     (connect x y) == isEmpty   x   && isEmpty   y
OK: hasVertex z (connect x y) == hasVertex z x || hasVertex z y
OK: vertexCount (connect x y) >= vertexCount x
OK: vertexCount (connect x y) <= vertexCount x + vertexCount y
OK: edgeCount   (connect x y) >= edgeCount x
OK: edgeCount   (connect x y) >= edgeCount y
OK: edgeCount   (connect x y) >= vertexCount x * vertexCount y
OK: edgeCount   (connect x y) <= vertexCount x * vertexCount y + edgeCount x + edgeCount y
OK: vertexCount (connect 1 2) == 2
OK: edgeCount   (connect 1 2) == 1

============ AdjacencyMap.vertices ============
OK: vertices []            == empty
OK: vertices [x]           == vertex x
OK: vertices               == overlays . map vertex
OK: hasVertex x . vertices == elem x
OK: vertexCount . vertices == length . nub
OK: vertexSet   . vertices == Set.fromList

============ AdjacencyMap.edges ============
OK: edges []          == empty
OK: edges [(x,y)]     == edge x y
OK: edges             == overlays . map (uncurry edge)
OK: edgeCount . edges == length . nub

============ AdjacencyMap.overlays ============
OK: overlays []        == empty
OK: overlays [x]       == x
OK: overlays [x,y]     == overlay x y
OK: overlays           == foldr overlay empty
OK: isEmpty . overlays == all isEmpty

============ AdjacencyMap.connects ============
OK: connects []        == empty
OK: connects [x]       == x
OK: connects [x,y]     == connect x y
OK: connects           == foldr connect empty
OK: isEmpty . connects == all isEmpty

============ AdjacencyMap.fromAdjacencySets ============
OK: fromAdjacencySets []                                  == empty
OK: fromAdjacencySets [(x, Set.empty)]                    == vertex x
OK: fromAdjacencySets [(x, Set.singleton y)]              == edge x y
OK: fromAdjacencySets . map (fmap Set.fromList)           == stars
OK: overlay (fromAdjacencySets xs) (fromAdjacencySets ys) == fromAdjacencySets (xs ++ ys)

============ AdjacencyMap.isSubgraphOf ============
OK: isSubgraphOf empty         x             ==  True
OK: isSubgraphOf (vertex x)    empty         ==  False
OK: isSubgraphOf x             (overlay x y) ==  True
OK: isSubgraphOf (overlay x y) (connect x y) ==  True
OK: isSubgraphOf (path xs)     (circuit xs)  ==  True
OK: isSubgraphOf x y                         ==> x <= y

============ AdjacencyMap.toGraph et al. ============
OK: toGraph                    == foldg Empty Vertex Overlay Connect
OK: foldg                      == Algebra.Graph.foldg . toGraph
OK: isEmpty                    == foldg True (const False) (&&) (&&)
OK: size                       == foldg 1 (const 1) (+) (+)
OK: hasVertex x                == foldg False (==x) (||) (||)
OK: hasEdge x y                == Algebra.Graph.hasEdge x y . toGraph
OK: vertexCount                == Set.size . vertexSet
OK: edgeCount                  == Set.size . edgeSet
OK: vertexList                 == Set.toAscList . vertexSet
OK: edgeList                   == Set.toAscList . edgeSet
OK: vertexSet                  == foldg Set.empty Set.singleton Set.union Set.union
OK: vertexIntSet               == foldg IntSet.empty IntSet.singleton IntSet.union IntSet.union
OK: edgeSet                    == Algebra.Graph.AdjacencyMap.edgeSet . foldg empty vertex overlay connect
OK: preSet x                   == Algebra.Graph.AdjacencyMap.preSet x . toAdjacencyMap
OK: preIntSet x                == Algebra.Graph.AdjacencyIntMap.preIntSet x . toAdjacencyIntMap
OK: postSet x                  == Algebra.Graph.AdjacencyMap.postSet x . toAdjacencyMap
OK: postIntSet x               == Algebra.Graph.AdjacencyIntMap.postIntSet x . toAdjacencyIntMap
OK: adjacencyList              == Algebra.Graph.AdjacencyMap.adjacencyList . toAdjacencyMap
OK: adjacencyMap               == Algebra.Graph.AdjacencyMap.adjacencyMap . toAdjacencyMap
OK: adjacencyIntMap            == Algebra.Graph.AdjacencyIntMap.adjacencyIntMap . toAdjacencyIntMap
OK: adjacencyMapTranspose      == Algebra.Graph.AdjacencyMap.adjacencyMap . toAdjacencyMapTranspose
OK: adjacencyIntMapTranspose   == Algebra.Graph.AdjacencyIntMap.adjacencyIntMap . toAdjacencyIntMapTranspose
OK: dfsForest                  == Algebra.Graph.AdjacencyMap.dfsForest . toAdjacencyMap
OK: dfsForestFrom              == Algebra.Graph.AdjacencyMap.dfsForestFrom . toAdjacencyMap
OK: dfs                        == Algebra.Graph.AdjacencyMap.dfs . toAdjacencyMap
OK: reachable                  == Algebra.Graph.AdjacencyMap.reachable . toAdjacencyMap
OK: topSort                    == Algebra.Graph.AdjacencyMap.topSort . toAdjacencyMap
OK: isAcyclic                  == Algebra.Graph.AdjacencyMap.isAcyclic . toAdjacencyMap
OK: isTopSortOf vs             == Algebra.Graph.AdjacencyMap.isTopSortOf vs . toAdjacencyMap
OK: toAdjacencyMap             == foldg empty vertex overlay connect
OK: toAdjacencyMapTranspose    == foldg empty vertex overlay (flip connect)
OK: toAdjacencyIntMap          == foldg empty vertex overlay connect
OK: toAdjacencyIntMapTranspose == foldg empty vertex overlay (flip connect)
OK: isDfsForestOf f            == Algebra.Graph.AdjacencyMap.isDfsForestOf f . toAdjacencyMap
OK: isTopSortOf vs             == Algebra.Graph.AdjacencyMap.isTopSortOf vs . toAdjacencyMap

============ AdjacencyMap.foldg ============
OK: foldg empty vertex        overlay connect        == id
OK: foldg empty vertex        overlay (flip connect) == transpose
OK: foldg 1     (const 1)     (+)     (+)            == size
OK: foldg True  (const False) (&&)    (&&)           == isEmpty

============ AdjacencyMap.isEmpty ============
OK: isEmpty empty                       == True
OK: isEmpty (overlay empty empty)       == True
OK: isEmpty (vertex x)                  == False
OK: isEmpty (removeVertex x $ vertex x) == True
OK: isEmpty (removeEdge x y $ edge x y) == False

============ AdjacencyMap.hasVertex ============
OK: hasVertex x empty            == False
OK: hasVertex x (vertex y)       == (x == y)
OK: hasVertex x . removeVertex x == const False

============ AdjacencyMap.hasEdge ============
OK: hasEdge x y empty            == False
OK: hasEdge x y (vertex z)       == False
OK: hasEdge x y (edge x y)       == True
OK: hasEdge x y . removeEdge x y == const False
OK: hasEdge x y                  == elem (x,y) . edgeList

============ AdjacencyMap.vertexCount ============
OK: vertexCount empty             ==  0
OK: vertexCount (vertex x)        ==  1
OK: vertexCount                   ==  length . vertexList
OK: vertexCount x < vertexCount y ==> x < y

============ AdjacencyMap.edgeCount ============
OK: edgeCount empty      == 0
OK: edgeCount (vertex x) == 0
OK: edgeCount (edge x y) == 1
OK: edgeCount            == length . edgeList

============ AdjacencyMap.vertexList ============
OK: vertexList empty      == []
OK: vertexList (vertex x) == [x]
OK: vertexList . vertices == nub . sort

============ AdjacencyMap.vertexSet ============
OK: vertexSet empty      == Set.empty
OK: vertexSet . vertex   == Set.singleton
OK: vertexSet . vertices == Set.fromList

============ AdjacencyMap.vertexIntSet ============
OK: vertexIntSet empty      == IntSet.empty
OK: vertexIntSet . vertex   == IntSet.singleton
OK: vertexIntSet . vertices == IntSet.fromList
OK: vertexIntSet . clique   == IntSet.fromList

============ AdjacencyMap.edgeList ============
OK: edgeList empty          == []
OK: edgeList (vertex x)     == []
OK: edgeList (edge x y)     == [(x,y)]
OK: edgeList (star 2 [3,1]) == [(2,1), (2,3)]
OK: edgeList . edges        == nub . sort

============ AdjacencyMap.edgeSet ============
OK: edgeSet empty      == Set.empty
OK: edgeSet (vertex x) == Set.empty
OK: edgeSet (edge x y) == Set.singleton (x,y)
OK: edgeSet . edges    == Set.fromList

============ AdjacencyMap.adjacencyList ============
OK: adjacencyList empty          == []
OK: adjacencyList (vertex x)     == [(x, [])]
OK: adjacencyList (edge 1 2)     == [(1, [2]), (2, [])]
OK: adjacencyList (star 2 [3,1]) == [(1, []), (2, [1,3]), (3, [])]

============ AdjacencyMap.preSet ============
OK: preSet x empty      == Set.empty
OK: preSet x (vertex x) == Set.empty
OK: preSet 1 (edge 1 2) == Set.empty
OK: preSet y (edge x y) == Set.fromList [x]

============ AdjacencyMap.preIntSet ============
OK: preIntSet x empty      == IntSet.empty
OK: preIntSet x (vertex x) == IntSet.empty
OK: preIntSet 1 (edge 1 2) == IntSet.empty
OK: preIntSet y (edge x y) == IntSet.fromList [x]

============ AdjacencyMap.postSet ============
OK: postSet x empty      == Set.empty
OK: postSet x (vertex x) == Set.empty
OK: postSet x (edge x y) == Set.fromList [y]
OK: postSet 2 (edge 1 2) == Set.empty

============ AdjacencyMap.postIntSet ============
OK: postIntSet x empty      == IntSet.empty
OK: postIntSet x (vertex x) == IntSet.empty
OK: postIntSet 2 (edge 1 2) == IntSet.empty
OK: postIntSet x (edge x y) == IntSet.fromList [y]

============ AdjacencyMap.path ============
OK: path []    == empty
OK: path [x]   == vertex x
OK: path [x,y] == edge x y

============ AdjacencyMap.circuit ============
OK: circuit []    == empty
OK: circuit [x]   == edge x x
OK: circuit [x,y] == edges [(x,y), (y,x)]

============ AdjacencyMap.clique ============
OK: clique []         == empty
OK: clique [x]        == vertex x
OK: clique [x,y]      == edge x y
OK: clique [x,y,z]    == edges [(x,y), (x,z), (y,z)]
OK: clique (xs ++ ys) == connect (clique xs) (clique ys)

============ AdjacencyMap.biclique ============
OK: biclique []      []      == empty
OK: biclique [x]     []      == vertex x
OK: biclique []      [y]     == vertex y
OK: biclique [x1,x2] [y1,y2] == edges [(x1,y1), (x1,y2), (x2,y1), (x2,y2)]
OK: biclique xs      ys      == connect (vertices xs) (vertices ys)

============ AdjacencyMap.star ============
OK: star x []    == vertex x
OK: star x [y]   == edge x y
OK: star x [y,z] == edges [(x,y), (x,z)]
OK: star x ys    == connect (vertex x) (vertices ys)

============ AdjacencyMap.stars ============
OK: stars []                      == empty
OK: stars [(x, [])]               == vertex x
OK: stars [(x, [y])]              == edge x y
OK: stars [(x, ys)]               == star x ys
OK: stars                         == overlays . map (uncurry star)
OK: stars . adjacencyList         == id
OK: overlay (stars xs) (stars ys) == stars (xs ++ ys)

============ AdjacencyMap.tree ============
OK: tree (Node x [])                                         == vertex x
OK: tree (Node x [Node y [Node z []]])                       == path [x,y,z]
OK: tree (Node x [Node y [], Node z []])                     == star x [y,z]
OK: tree (Node 1 [Node 2 [], Node 3 [Node 4 [], Node 5 []]]) == edges [(1,2), (1,3), (3,4), (3,5)]

============ AdjacencyMap.forest ============
OK: forest []                                                  == empty
OK: forest [x]                                                 == tree x
OK: forest [Node 1 [Node 2 [], Node 3 []], Node 4 [Node 5 []]] == edges [(1,2), (1,3), (4,5)]
OK: forest                                                     == overlays . map tree

============ AdjacencyMap.removeVertex ============
OK: removeVertex x (vertex x)       == empty
OK: removeVertex 1 (vertex 2)       == vertex 2
OK: removeVertex x (edge x x)       == empty
OK: removeVertex 1 (edge 1 2)       == vertex 2
OK: removeVertex x . removeVertex x == removeVertex x

============ AdjacencyMap.removeEdge ============
OK: removeEdge x y (edge x y)       == vertices [x,y]
OK: removeEdge x y . removeEdge x y == removeEdge x y
OK: removeEdge x y . removeVertex x == removeVertex x
OK: removeEdge 1 1 (1 * 1 * 2 * 2)  == 1 * 2 * 2
OK: removeEdge 1 2 (1 * 1 * 2 * 2)  == 1 * 1 + 2 * 2

============ AdjacencyMap.replaceVertex ============
OK: replaceVertex x x            == id
OK: replaceVertex x y (vertex x) == vertex y
OK: replaceVertex x y            == mergeVertices (== x) y

============ AdjacencyMap.mergeVertices ============
OK: mergeVertices (const False) x    == id
OK: mergeVertices (== x) y           == replaceVertex x y
OK: mergeVertices even 1 (0 * 2)     == 1 * 1
OK: mergeVertices odd  1 (3 + 4 * 5) == 4 * 1

============ AdjacencyMap.transpose ============
OK: transpose empty       == empty
OK: transpose (vertex x)  == vertex x
OK: transpose (edge x y)  == edge y x
OK: transpose . transpose == id
OK: edgeList . transpose  == sort . map swap . edgeList

============ AdjacencyMap.gmap ============
OK: gmap f empty      == empty
OK: gmap f (vertex x) == vertex (f x)
OK: gmap f (edge x y) == edge (f x) (f y)
OK: gmap id           == id
OK: gmap f . gmap g   == gmap (f . g)

============ AdjacencyMap.induce ============
OK: induce (const True ) x      == x
OK: induce (const False) x      == empty
OK: induce (/= x)               == removeVertex x
OK: induce p . induce q         == induce (\x -> p x && q x)
OK: isSubgraphOf (induce p x) x == True

============ AdjacencyMap.compose ============
OK: compose empty            x                == empty
OK: compose x                empty            == empty
OK: compose (vertex x)       y                == empty
OK: compose x                (vertex y)       == empty
OK: compose x                (compose y z)    == compose (compose x y) z
OK: compose x                (overlay y z)    == overlay (compose x y) (compose x z)
OK: compose (overlay x y) z                   == overlay (compose x z) (compose y z)
OK: compose (edge x y)       (edge y z)       == edge x z
OK: compose (path    [1..5]) (path    [1..5]) == edges [(1,3),(2,4),(3,5)]
OK: compose (circuit [1..5]) (circuit [1..5]) == circuit [1,3,5,2,4]

============ AdjacencyMap.closure ============
OK: closure empty           == empty
OK: closure (vertex x)      == edge x x
OK: closure (edge x x)      == edge x x
OK: closure (edge x y)      == edges [(x,x), (x,y), (y,y)]
OK: closure (path $ nub xs) == reflexiveClosure (clique $ nub xs)
OK: closure                 == reflexiveClosure . transitiveClosure
OK: closure                 == transitiveClosure . reflexiveClosure
OK: closure . closure       == closure
OK: postSet x (closure y)   == Set.fromList (reachable y x)

============ AdjacencyMap.reflexiveClosure ============
OK: reflexiveClosure empty              == empty
OK: reflexiveClosure (vertex x)         == edge x x
OK: reflexiveClosure (edge x x)         == edge x x
OK: reflexiveClosure (edge x y)         == edges [(x,x), (x,y), (y,y)]
OK: reflexiveClosure . reflexiveClosure == reflexiveClosure

============ AdjacencyMap.symmetricClosure ============
OK: symmetricClosure empty              == empty
OK: symmetricClosure (vertex x)         == vertex x
OK: symmetricClosure (edge x y)         == edges [(x,y), (y,x)]
OK: symmetricClosure x                  == overlay x (transpose x)
OK: symmetricClosure . symmetricClosure == symmetricClosure

============ AdjacencyMap.transitiveClosure ============
OK: transitiveClosure empty               == empty
OK: transitiveClosure (vertex x)          == vertex x
OK: transitiveClosure (edge x y)          == edge x y
OK: transitiveClosure (path $ nub xs)     == clique (nub $ xs)
OK: transitiveClosure . transitiveClosure == transitiveClosure

============ AdjacencyMap.box ============
OK: box x y               ~~ box y x
OK: box x (overlay y z)   == overlay (box x y) (box x z)
OK: box x (vertex ())     ~~ x
OK: box x empty           ~~ empty
OK: box x (box y z)       ~~ box (box x y) z
OK: transpose   (box x y) == box (transpose x) (transpose y)
OK: vertexCount (box x y) == vertexCount x * vertexCount y
OK: edgeCount   (box x y) <= vertexCount x * edgeCount y + edgeCount x * vertexCount y

============ AdjacencyMap.bfsForest ============
OK: forest $ bfsForest (edge 1 2) [0]        == empty
OK: forest $ bfsForest (edge 1 2) [1]        == edge 1 2
OK: forest $ bfsForest (edge 1 2) [2]        == vertex 2
OK: forest $ bfsForest (edge 1 2) [0,1,2]    == vertices [1,2]
OK: forest $ bfsForest (edge 1 2) [2,1,0]    == vertices [1,2]
OK: forest $ bfsForest (edge 1 1) [1]        == vertex 1
OK: isSubgraphOf (forest $ bfsForest x vs) x == True
OK: bfsForest x (vertexList x)               == map ( -> Node v []) (nub $ vertexList x)
OK: bfsForest x []                           == []
OK: bfsForest empty vs                       == []
OK: bfsForest (3 * (1 + 4) * (1 + 5)) [1,4]  == <correct result>
OK: forest $ bfsForest (circuit [1..5] + circuit [5,4..1]) [3] == path [3,2,1] + path [3,4,5]

============ AdjacencyMap.bfs ============
OK: bfs (edge 1 2) [0]                                   == []
OK: bfs (edge 1 2) [1]                                   == [[1], [2]]
OK: bfs (edge 1 2) [2]                                   == [[2]]
OK: bfs (edge 1 2) [1,2]                                 == [[1,2]]
OK: bfs (edge 1 2) [2,1]                                 == [[2,1]]
OK: bfs (edge 1 1) [1]                                   == [[1]]
OK: bfs empty vs                                         == []
OK: bfs x []                                             == []
OK: bfs (1 * 2 + 3 * 4 + 5 * 6) [1,2]                    == [[1,2]]
OK: bfs (1 * 2 + 3 * 4 + 5 * 6) [1,3]                    == [[1,3], [2,4]]
OK: bfs (3 * (1 + 4) * (1 + 5)) [3]                      == [[3], [1,4,5]]
OK: bfs (circuit [1..5] + circuit [5,4..1]) [2]          == [[2], [1,3], [5,4]]
OK: concat $ bfs (circuit [1..5] + circuit [5,4..1]) [3] == [3,2,4,1,5]
OK: map concat . transpose . map levels . bfsForest x    == bfs x

============ AdjacencyMap.dfsForest ============
OK: forest $ dfsForest empty              == empty
OK: forest $ dfsForest (edge 1 1)         == vertex 1
OK: forest $ dfsForest (edge 1 2)         == edge 1 2
OK: forest $ dfsForest (edge 2 1)         == vertices [1,2]
OK: isSubgraphOf (forest $ dfsForest x) x == True
OK: isDfsForestOf (dfsForest x) x         == True
OK: dfsForest . forest . dfsForest        == dfsForest
OK: dfsForest (vertices vs)               == map (\v -> Node v []) (nub $ sort vs)
OK: dfsForest $ 3 * (1 + 4) * (1 + 5)     == <correct result>
OK: forest (dfsForest $ circuit [1..5] + circuit [5,4..1]) == path [1,2,3,4,5]

============ AdjacencyMap.dfsForestFrom ============
OK: forest $ dfsForestFrom empty      vs             == empty
OK: forest $ dfsForestFrom (edge 1 1) [1]            == vertex 1
OK: forest $ dfsForestFrom (edge 1 2) [0]            == empty
OK: forest $ dfsForestFrom (edge 1 2) [1]            == edge 1 2
OK: forest $ dfsForestFrom (edge 1 2) [2]            == vertex 2
OK: forest $ dfsForestFrom (edge 1 2) [1,2]          == edge 1 2
OK: forest $ dfsForestFrom (edge 1 2) [2,1]          == vertices [1,2]
OK: isSubgraphOf (forest $ dfsForestFrom x vs) x     == True
OK: isDfsForestOf (dfsForestFrom x (vertexList x)) x == True
OK: dfsForestFrom x (vertexList x)                   == dfsForest x
OK: dfsForestFrom x []                               == []
OK: dfsForestFrom (3 * (1 + 4) * (1 + 5)) [1,4]      == <correct result>
OK: forest $ dfsForestFrom (circuit [1..5] + circuit [5,4..1]) [3] == path [3,2,1,5,4]

============ AdjacencyMap.dfs ============
OK: dfs empty      vs    == []
OK: dfs (edge 1 1) [1]   == [1]
OK: dfs (edge 1 2) [0]   == []
OK: dfs (edge 1 2) [1]   == [1,2]
OK: dfs (edge 1 2) [2]   == [2]
OK: dfs (edge 1 2) [1,2] == [1,2]
OK: dfs (edge 1 2) [2,1] == [2,1]
OK: dfs x          []    == []

OK: and [ hasVertex v x | v <- dfs x vs ]       == True
OK: dfs (3 * (1 + 4) * (1 + 5)) [1,4]           == [1,5,4]
OK: dfs (circuit [1..5] + circuit [5,4..1]) [3] == [3,2,1,5,4]

============ AdjacencyMap.dfs ============
OK: reachable empty              x == []
OK: reachable (vertex 1)         1 == [1]
OK: reachable (edge 1 1)         1 == [1]
OK: reachable (edge 1 2)         0 == []
OK: reachable (edge 1 2)         1 == [1,2]
OK: reachable (edge 1 2)         2 == [2]
OK: reachable (path    [1..8]  ) 4 == [4..8]
OK: reachable (circuit [1..8]  ) 4 == [4..8] ++ [1..3]
OK: reachable (clique  [8,7..1]) 8 == [8] ++ [1..7]

OK: and [ hasVertex v x | v <- reachable x y ] == True

============ AdjacencyMap.topSort ============
OK: topSort (1 * 2 + 3 * 1)                    == Right [3,1,2]
OK: topSort (path [1..5])                      == Right [1..5]
OK: topSort (3 * (1 * 4 + 2 * 5))              == Right [3,1,2,4,5]
OK: topSort (1 * 2 + 2 * 1)                    == Left (2 :| [1])
OK: topSort (path [5,4..1] + edge 2 4)         == Left (4 :| [3,2])
OK: topSort (circuit [1..5])                   == Left (3 :| [1,2])
OK: topSort (circuit [1..3] + circuit [3,2,1]) == Left (3 :| [2])
OK: topSort (1 * 2 + (5 + 2) * 1 + 3 * 4 * 3)  == Left (1 :| [2])
OK: fmap (flip isTopSortOf x) (topSort x) /= Right False
OK: topSort . vertices     == Right . nub . sort

============ AdjacencyMap.testIsAcyclic ============
OK: isAcyclic (1 * 2 + 3 * 1) == True
OK: isAcyclic (1 * 2 + 2 * 1) == False
OK: isAcyclic . circuit       == null
OK: isAcyclic                 == isRight . topSort

============ AdjacencyMap.isDfsForestOf ============
OK: isDfsForestOf []                              empty            == True
OK: isDfsForestOf []                              (vertex 1)       == False
OK: isDfsForestOf [Node 1 []]                     (vertex 1)       == True
OK: isDfsForestOf [Node 1 []]                     (vertex 2)       == False
OK: isDfsForestOf [Node 1 [], Node 1 []]          (vertex 1)       == False
OK: isDfsForestOf [Node 1 []]                     (edge 1 1)       == True
OK: isDfsForestOf [Node 1 []]                     (edge 1 2)       == False
OK: isDfsForestOf [Node 1 [], Node 2 []]          (edge 1 2)       == False
OK: isDfsForestOf [Node 2 [], Node 1 []]          (edge 1 2)       == True
OK: isDfsForestOf [Node 1 [Node 2 []]]            (edge 1 2)       == True
OK: isDfsForestOf [Node 1 [], Node 2 []]          (vertices [1,2]) == True
OK: isDfsForestOf [Node 2 [], Node 1 []]          (vertices [1,2]) == True
OK: isDfsForestOf [Node 1 [Node 2 []]]            (vertices [1,2]) == False
OK: isDfsForestOf [Node 1 [Node 2 [Node 3 []]]]   (path [1,2,3])   == True
OK: isDfsForestOf [Node 1 [Node 3 [Node 2 []]]]   (path [1,2,3])   == False
OK: isDfsForestOf [Node 3 [], Node 1 [Node 2 []]] (path [1,2,3])   == True
OK: isDfsForestOf [Node 2 [Node 3 []], Node 1 []] (path [1,2,3])   == True
OK: isDfsForestOf [Node 1 [], Node 2 [Node 3 []]] (path [1,2,3])   == False

============ AdjacencyMap.isTopSortOf ============
OK: isTopSortOf [3,1,2] (1 * 2 + 3 * 1) == True
OK: isTopSortOf [1,2,3] (1 * 2 + 3 * 1) == False
OK: isTopSortOf []      (1 * 2 + 3 * 1) == False
OK: isTopSortOf []      empty           == True
OK: isTopSortOf [x]     (vertex x)      == True
OK: isTopSortOf [x]     (edge x x)      == False

============ AdjacencyMap.induceJust ============
OK: induceJust (vertex Nothing)                               == empty
OK: induceJust (edge (Just x) Nothing)                        == vertex x
OK: induceJust . gmap Just                                    == id
OK: induceJust . gmap (\x -> if p x then Just x else Nothing) == induce p

============ AdjacencyMap.scc ============
OK: scc empty               == empty
OK: scc (vertex x)          == vertex (NonEmpty.vertex x)
OK: scc (vertices xs)       == vertices (map NonEmpty.vertex xs)
OK: scc (edge 1 1)          == vertex (NonEmpty.edge 1 1)
OK: scc (edge 1 2)          == edge   (NonEmpty.vertex 1) (NonEmpty.vertex 2)
OK: scc (circuit (1:xs))    == vertex (NonEmpty.circuit1 (1 :| xs))
OK: scc (3 * 1 * 4 * 1 * 5) == <correct result>
OK: isAcyclic . scc == const True
OK: isAcyclic x     == (scc x == gmap NonEmpty.vertex x)
OK: scc g == KL.scc g

============ Bipartite.AdjacencyMap.Num ============
OK: 0                     == rightVertex 0
OK: swap 1                == leftVertex 1
OK: swap 1 + 2            == vertices [1] [2]
OK: swap 1 * 2            == edge 1 2
OK: swap 1 + 2 * swap 3   == overlay (leftVertex 1) (edge 3 2)
OK: swap 1 * (2 + swap 3) == connect (leftVertex 1) (vertices [3] [2])

============ Bipartite.AdjacencyMap.Show ============
OK: show empty                 == "empty"
OK: show 1                     == "rightVertex 1"
OK: show (swap 2)              == "leftVertex 2"
OK: show 1 + 2                 == "vertices [] [1,2]"
OK: show (swap (1 + 2))        == "vertices [1,2] []"
OK: show (swap 1 * 2)          == "edge 1 2"
OK: show (swap 1 * 2 * swap 3) == "edges [(1,2),(3,2)]"
OK: show (swap 1 * 2 + swap 3) == "overlay (leftVertex 3) (edge 1 2)"

============ Bipartite.AdjacencyMap.Eq ============
OK: (x == y) == (leftAdjacencyMap x == leftAdjacencyMap y && rightAdjacencyMap x == rightAdjacencyMap y)

OK:         x + y == y + x
OK:   x + (y + z) == (x + y) + z
OK:     x * empty == x
OK:     empty * x == x
OK:         x * y == y * x
OK:   x * (y * z) == (x * y) * z
OK:   x * (y + z) == x * y + x * z
OK:   (x + y) * z == x * z + y * z
OK:     x * y * z == x * y + x * z + y * z
OK:     x + empty == x
OK:     empty + x == x
OK:         x + x == x
OK: x * y + x + y == x * y
OK:     x * x * x == x * x

OK:  leftVertex x * leftVertex y  ==  leftVertex x + leftVertex y 
OK: rightVertex x * rightVertex y == rightVertex x + rightVertex y

============ Bipartite.AdjacencyMap.leftAdjacencyMap ============
OK: leftAdjacencyMap empty           == Map.empty
OK: leftAdjacencyMap (leftVertex x)  == Map.singleton x Set.empty
OK: leftAdjacencyMap (rightVertex x) == Map.empty
OK: leftAdjacencyMap (edge x y)      == Map.singleton x (Set.singleton y)

============ Bipartite.AdjacencyMap.rightAdjacencyMap ============
OK: rightAdjacencyMap empty           == Map.empty
OK: rightAdjacencyMap (leftVertex x)  == Map.empty
OK: rightAdjacencyMap (rightVertex x) == Map.singleton x Set.empty
OK: rightAdjacencyMap (edge x y)      == Map.singleton y (Set.singleton x)

============ Bipartite.AdjacencyMap.empty ============
OK: isEmpty empty           == True
OK: leftAdjacencyMap empty  == Map.empty
OK: rightAdjacencyMap empty == Map.empty
OK: hasVertex x empty       == False

============ Bipartite.AdjacencyMap.leftVertex ============
OK: leftAdjacencyMap (leftVertex x)  == Map.singleton x Set.empty
OK: rightAdjacencyMap (leftVertex x) == Map.empty
OK: hasLeftVertex x (leftVertex y)   == (x == y)
OK: hasRightVertex x (leftVertex y)  == False
OK: hasEdge x y (leftVertex z)       == False

============ Bipartite.AdjacencyMap.rightVertex ============
OK: leftAdjacencyMap (rightVertex x)  == Map.empty
OK: rightAdjacencyMap (rightVertex x) == Map.singleton x Set.empty
OK: hasLeftVertex x (rightVertex y)   == False
OK: hasRightVertex x (rightVertex y)  == (x == y)
OK: hasEdge x y (rightVertex z)       == False

============ Bipartite.AdjacencyMap.vertex ============
OK: vertex . Left  == leftVertex
OK: vertex . Right == rightVertex

============ Bipartite.AdjacencyMap.edge ============
OK: edge x y                     == connect (leftVertex x) (rightVertex y)
OK: leftAdjacencyMap (edge x y)  == Map.singleton x (Set.singleton y)
OK: rightAdjacencyMap (edge x y) == Map.singleton y (Set.singleton x)
OK: hasEdge x y (edge x y)       == True
OK: hasEdge 1 2 (edge 2 1)       == False

============ Bipartite.AdjacencyMap.overlay ============
OK: isEmpty     (overlay x y) == isEmpty   x   && isEmpty   y
OK: hasVertex z (overlay x y) == hasVertex z x || hasVertex z y
OK: vertexCount (overlay x y) >= vertexCount x
OK: vertexCount (overlay x y) <= vertexCount x + vertexCount y
OK: edgeCount   (overlay x y) >= edgeCount x
OK: edgeCount   (overlay x y) <= edgeCount x   + edgeCount y

============ Bipartite.AdjacencyMap.connect ============
OK: connect (leftVertex x)     (leftVertex y)     == vertices [x,y] []
OK: connect (leftVertex x)     (rightVertex y)    == edge x y
OK: connect (rightVertex x)    (leftVertex y)     == edge y x
OK: connect (rightVertex x)    (rightVertex y)    == vertices [] [x,y]
OK: connect (vertices xs1 ys1) (vertices xs2 ys2) == overlay (biclique xs1 ys2) (biclique xs2 ys1)
OK: isEmpty     (connect x y)                     == isEmpty   x   && isEmpty   y
OK: hasVertex z (connect x y)                     == hasVertex z x || hasVertex z y
OK: vertexCount (connect x y)                     >= vertexCount x
OK: vertexCount (connect x y)                     <= vertexCount x + vertexCount y
OK: edgeCount   (connect x y)                     >= edgeCount x
OK: edgeCount   (connect x y)                     >= leftVertexCount x * rightVertexCount y
OK: edgeCount   (connect x y)                     <= leftVertexCount x * rightVertexCount y + rightVertexCount x * leftVertexCount y + edgeCount x + edgeCount y

============ Bipartite.AdjacencyMap.vertices ============
OK: vertices [] []                    == empty
OK: vertices [x] []                   == leftVertex x
OK: vertices [] [x]                   == rightVertex x
OK: vertices xs ys                    == overlays (map leftVertex xs ++ map rightVertex ys)
OK: hasLeftVertex  x (vertices xs ys) == elem x xs
OK: hasRightVertex y (vertices xs ys) == elem y ys

============ Bipartite.AdjacencyMap.edges ============
OK: edges []            == empty
OK: edges [(x,y)]       == edge x y
OK: edges               == overlays . map (uncurry edge)
OK: hasEdge x y . edges == elem (x,y)
OK: edgeCount   . edges == length . nub

============ Bipartite.AdjacencyMap.overlays ============
OK: overlays []        == empty
OK: overlays [x]       == x
OK: overlays [x,y]     == overlay x y
OK: overlays           == foldr overlay empty
OK: isEmpty . overlays == all isEmpty

============ Bipartite.AdjacencyMap.connects ============
OK: connects []        == empty
OK: connects [x]       == x
OK: connects [x,y]     == connect x y
OK: connects           == foldr connect empty
OK: isEmpty . connects == all isEmpty

============ Bipartite.AdjacencyMap.swap ============
OK: swap empty            == empty
OK: swap . leftVertex     == rightVertex
OK: swap (vertices xs ys) == vertices ys xs
OK: swap (edge x y)       == edge y x
OK: swap . edges          == edges . map Data.Tuple.swap
OK: swap . swap           == id

============ Bipartite.AdjacencyMap.toBipartite ============
OK: toBipartite empty                      == empty
OK: toBipartite (vertex (Left x))          == leftVertex x
OK: toBipartite (vertex (Right x))         == rightVertex x
OK: toBipartite (edge (Left x) (Left y))   == vertices [x,y] []
OK: toBipartite (edge (Left x) (Right y))  == edge x y
OK: toBipartite (edge (Right x) (Left y))  == edge y x
OK: toBipartite (edge (Right x) (Right y)) == vertices [] [x,y]
OK: toBipartite . clique                   == uncurry biclique . partitionEithers
OK: toBipartite . fromBipartite            == id

============ Bipartite.AdjacencyMap.toBipartiteWith ============
OK: toBipartiteWith f empty == empty
OK: toBipartiteWith Left x  == vertices (vertexList x) []
OK: toBipartiteWith Right x == vertices [] (vertexList x)
OK: toBipartiteWith f       == toBipartite . gmap f
OK: toBipartiteWith id      == toBipartite

============ Bipartite.AdjacencyMap.fromBipartite ============
OK: fromBipartite empty          == empty
OK: fromBipartite (leftVertex x) == vertex (Left x)
OK: fromBipartite (edge x y)     == edges [(Left x, Right y), (Right y, Left x)]

============ Bipartite.AdjacencyMap.fromBipartiteWith ============
OK: fromBipartiteWith Left Right             == fromBipartite
OK: fromBipartiteWith id id (vertices xs ys) == vertices (xs ++ ys)
OK: fromBipartiteWith id id . edges          == symmetricClosure . edges

============ Bipartite.AdjacencyMap.isEmpty ============
OK: isEmpty empty                 == True
OK: isEmpty (overlay empty empty) == True
OK: isEmpty (vertex x)            == False
OK: isEmpty                       == (==) empty

============ Bipartite.AdjacencyMap.hasLeftVertex ============
OK: hasLeftVertex x empty           == False
OK: hasLeftVertex x (leftVertex y)  == (x == y)
OK: hasLeftVertex x (rightVertex y) == False

============ Bipartite.AdjacencyMap.hasRightVertex ============
OK: hasRightVertex x empty           == False
OK: hasRightVertex x (leftVertex y)  == False
OK: hasRightVertex x (rightVertex y) == (x == y)

============ Bipartite.AdjacencyMap.hasVertex ============
OK: hasVertex . Left  == hasLeftVertex
OK: hasVertex . Right == hasRightVertex

============ Bipartite.AdjacencyMap.hasEdge ============
OK: hasEdge x y empty      == False
OK: hasEdge x y (vertex z) == False
OK: hasEdge x y (edge x y) == True
OK: hasEdge x y            == elem (x,y) . edgeList

============ Bipartite.AdjacencyMap.leftVertexCount ============
OK: leftVertexCount empty           == 0
OK: leftVertexCount (leftVertex x)  == 1
OK: leftVertexCount (rightVertex x) == 0
OK: leftVertexCount (edge x y)      == 1
OK: leftVertexCount . edges         == length . nub . map fst

============ Bipartite.AdjacencyMap.rightVertexCount ============
OK: rightVertexCount empty           == 0
OK: rightVertexCount (leftVertex x)  == 0
OK: rightVertexCount (rightVertex x) == 1
OK: rightVertexCount (edge x y)      == 1
OK: rightVertexCount . edges         == length . nub . map snd

============ Bipartite.AdjacencyMap.vertexCount ============
OK: vertexCount empty      == 0
OK: vertexCount (vertex x) == 1
OK: vertexCount (edge x y) == 2
OK: vertexCount x          == leftVertexCount x + rightVertexCount x

============ Bipartite.AdjacencyMap.edgeCount ============
OK: edgeCount empty      == 0
OK: edgeCount (vertex x) == 0
OK: edgeCount (edge x y) == 1
OK: edgeCount . edges    == length . nub

============ Bipartite.AdjacencyMap.leftVertexList ============
OK: leftVertexList empty              == []
OK: leftVertexList (leftVertex x)     == [x]
OK: leftVertexList (rightVertex x)    == []
OK: leftVertexList . flip vertices [] == nub . sort

============ Bipartite.AdjacencyMap.rightVertexList ============
OK: rightVertexList empty           == []
OK: rightVertexList (leftVertex x)  == []
OK: rightVertexList (rightVertex x) == [x]
OK: rightVertexList . vertices []   == nub . sort

============ Bipartite.AdjacencyMap.vertexList ============
OK: vertexList empty                             == []
OK: vertexList (vertex x)                        == [x]
OK: vertexList (edge x y)                        == [Left x, Right y]
OK: vertexList (vertices (lefts xs) (rights xs)) == nub (sort xs)

============ Bipartite.AdjacencyMap.edgeList ============
OK: edgeList empty      == []
OK: edgeList (vertex x) == []
OK: edgeList (edge x y) == [(x,y)]
OK: edgeList . edges    == nub . sort

============ Bipartite.AdjacencyMap.leftVertexSet ============
OK: leftVertexSet empty              == Set.empty
OK: leftVertexSet . leftVertex       == Set.singleton
OK: leftVertexSet . rightVertex      == const Set.empty
OK: leftVertexSet . flip vertices [] == Set.fromList

============ Bipartite.AdjacencyMap.rightVertexSet ============
OK: rightVertexSet empty         == Set.empty
OK: rightVertexSet . leftVertex  == const Set.empty
OK: rightVertexSet . rightVertex == Set.singleton
OK: rightVertexSet . vertices [] == Set.fromList

============ Bipartite.AdjacencyMap.vertexSet ============
OK: vertexSet empty                             == Set.empty
OK: vertexSet . vertex                          == Set.singleton
OK: vertexSet (edge x y)                        == Set.fromList [Left x, Right y]
OK: vertexSet (vertices (lefts xs) (rights xs)) == Set.fromList xs

============ Bipartite.AdjacencyMap.edgeSet ============
OK: edgeSet empty      == Set.empty
OK: edgeSet (vertex x) == Set.empty
OK: edgeSet (edge x y) == Set.singleton (x,y)
OK: edgeSet . edges    == Set.fromList

============ Bipartite.AdjacencyMap.leftAdjacencyList ============
OK: leftAdjacencyList empty            == []
OK: leftAdjacencyList (vertices [] xs) == []
OK: leftAdjacencyList (vertices xs []) == []
OK: leftAdjacencyList (edge x y)       == [(x, [y])]
OK: leftAdjacencyList (star x ys)      == [(x, nub (sort ys))]

============ Bipartite.AdjacencyMap.rightAdjacencyList ============
OK: rightAdjacencyList empty            == []
OK: rightAdjacencyList (vertices [] xs) == [(x, []) | x <- nub (sort xs)]
OK: rightAdjacencyList (vertices xs []) == []
OK: rightAdjacencyList (edge x y)       == [(y, [x])]
OK: rightAdjacencyList (star x ys)      == [(y, [x])  | y <- nub (sort ys)]

============ Bipartite.AdjacencyMap.evenList ============
OK: evenList []                 == Nil
OK: evenList [(1,2), (3,4)]     == [1, 2, 3, 4] :: List Int Int
OK: evenList [(1,'a'), (2,'b')] == Cons 1 (Cons 'a' (Cons 2 (Cons 'b' Nil)))

============ Bipartite.AdjacencyMap.oddList ============
OK: oddList 1 []                 == Cons 1 Nil
OK: oddList 1 [(2,3), (4,5)]     == [1, 2, 3, 4, 5] :: List Int Int
OK: oddList 1 [('a',2), ('b',3)] == Cons 1 (Cons 'a' (Cons 2 (Cons 'b' (Cons 3 Nil))))

============ Bipartite.AdjacencyMap.path ============
OK: path Nil                   == empty
OK: path (Cons x Nil)          == leftVertex x
OK: path (Cons x (Cons y Nil)) == edge x y
OK: path [1, 2, 3, 4, 5]       == edges [(1,2), (3,2), (3,4), (5,4)]

============ Bipartite.AdjacencyMap.circuit ============
OK: circuit []                    == empty
OK: circuit [(x,y)]               == edge x y
OK: circuit [(1,2), (3,4), (5,6)] == edges [(1,2), (3,2), (3,4), (5,4), (5,6), (1,6)]
OK: circuit . reverse             == swap . circuit . map Data.Tuple.swap

============ Bipartite.AdjacencyMap.biclique ============
OK: biclique [] [] == empty
OK: biclique xs [] == vertices xs []
OK: biclique [] ys == vertices [] ys
OK: biclique xs ys == connect (vertices xs []) (vertices [] ys)

============ Bipartite.AdjacencyMap.star ============
OK: star x []    == leftVertex x
OK: star x [y]   == edge x y
OK: star x [y,z] == edges [(x,y), (x,z)]
OK: star x ys    == connect (leftVertex x) (vertices [] ys)

============ Bipartite.AdjacencyMap.stars ============
OK: stars []                      == empty
OK: stars [(x, [])]               == leftVertex x
OK: stars [(x, [y])]              == edge x y
OK: stars [(x, ys)]               == star x ys
OK: star x [y,z]                  == edges [(x,y), (x,z)]
OK: stars                         == overlays . map (uncurry star)
OK: overlay (stars xs) (stars ys) == stars (xs ++ ys)

============ Bipartite.AdjacencyMap.mesh ============
OK: mesh xs []           == empty
OK: mesh [] ys           == empty
OK: mesh [x] [y]         == leftVertex (x,y)
OK: mesh [1,1] ['a','b'] == biclique [(1,'a'), (1,'b')] [(1,'a'), (1,'b')]
OK: mesh [1,2] ['a','b'] == biclique [(1,'a'), (2,'b')] [(1,'b'), (2,'a')]

============ Bipartite.AdjacencyMap.removeLeftVertex ============
OK: removeLeftVertex x (leftVertex x)       == empty
OK: removeLeftVertex 1 (leftVertex 2)       == leftVertex 2
OK: removeLeftVertex x (rightVertex y)      == rightVertex y
OK: removeLeftVertex x (edge x y)           == rightVertex y
OK: removeLeftVertex x . removeLeftVertex x == removeLeftVertex x

============ Bipartite.AdjacencyMap.removeRightVertex ============
OK: removeRightVertex x (rightVertex x)       == empty
OK: removeRightVertex 1 (rightVertex 2)       == rightVertex 2
OK: removeRightVertex x (leftVertex y)        == leftVertex y
OK: removeRightVertex y (edge x y)            == leftVertex x
OK: removeRightVertex x . removeRightVertex x == removeRightVertex x

============ Bipartite.AdjacencyMap.removeEdge ============
OK: removeEdge x y (edge x y)            == vertices [x] [y]
OK: removeEdge x y . removeEdge x y      == removeEdge x y
OK: removeEdge x y . removeLeftVertex x  == removeLeftVertex x
OK: removeEdge x y . removeRightVertex y == removeRightVertex y

============ Bipartite.AdjacencyMap.bimap ============
OK: bimap f g empty           == empty
OK: bimap f g . vertex        == vertex . Data.Bifunctor.bimap f g
OK: bimap f g (edge x y)      == edge (f x) (g y)
OK: bimap id id               == id
OK: bimap f1 g1 . bimap f2 g2 == bimap (f1 . f2) (g1 . g2)

============ Bipartite.AdjacencyMap.box ============
OK: box (path [0,1]) (path ['a','b']) == <correct result>

OK: box x y                ~~ box y x
OK: box x (box y z)        ~~ box (box x y) z
OK: box x (box y z)        ~~ box (box x y) z
OK: box x (leftVertex ())  ~~ x
OK: box x (rightVertex ()) ~~ swap x
OK: box x empty            ~~ empty
OK: vertexCount (box x y)  <= vertexCount x * vertexCount y
OK: edgeCount (box x y)    <= vertexCount x * edgeCount y + edgeCount x * vertexCount y

OK: box == boxWith (,) (,) (,) (,)

============ Bipartite.AdjacencyMap.consistent ============
OK: consistent empty            == True
OK: consistent (vertex x)       == True
OK: consistent (edge x y)       == True
OK: consistent (edges x)        == True
OK: consistent (toBipartite x)  == True
OK: consistent (swap x)         == True
OK: consistent (circuit xs)     == True
OK: consistent (biclique xs ys) == True

============ Bipartite.AdjacencyMap.Algorithm.detectParts ============
OK: detectParts empty                                       == Right empty
OK: detectParts (vertex 1)                                  == Right (leftVertex 1)
OK: detectParts (edge 1 1)                                  == Left [1]
OK: detectParts (edge 1 2)                                  == Right (edge 1 2)
OK: detectParts (edge 0 (-1))                               == Right (edge (-1) 0)
OK: detectParts (1 * (2 + 3))                               == Right (edges [(1, 2), (1, 3)])
OK: detectParts ((1 + 3) * (2 + 4) + 6 * 5)                 == Right (swap (1 + 3) * (2 + 4) + swap 5 * 6
OK: detectParts ((1 + 2) * (3 + 4) * (5 + 6))               == Left [1, 3, 2, 4, 5]
OK: detectParts ((1 + 2) * (3 + 4) + (3 + 4) * 5)           == Right (swap (1 + 2) * (3 + 4) + swap 5 * (3 + 4))
OK: detectParts (1 * 2 * 3)                                 == Left [2, 3, 1]
OK: detectParts ((1 * 3 * 4) + 2 * (1 + 2))                 == Left [2]
OK: detectParts (clique [1..10])                            == Left [1, 2, 3]
OK: detectParts (circuit [1..11])                           == Left [1..11]
OK: detectParts (circuit [1..10])                           == Right (circuit [(2 * x - 1, 2 * x) | x <- [1..5]])
OK: detectParts (biclique [] xs)                            == Right (vertices xs [])
OK: detectParts (biclique (map Left (x:xs)) (map Right ys)) == Right (biclique (map Left (x:xs)) (map Right ys))
OK: isRight (detectParts (star x ys))                       == not (elem x ys)
OK: isRight (detectParts (fromBipartite (toBipartite x)))   == True

OK: ((all ((flip Set.member) $ edgeSet $ symmetricClosure x) . edgeSet) <$> detectParts x) /= Right False
OK: (Set.map $ fromEither) <$> (vertexSet <$> (detectParts (fromBipartite (toBipartite x)))) == Right (vertexSet x)
OK: fromEither (Bifunctor.bimap ((flip Set.isSubsetOf) (vertexSet x) . Set.fromList) (const True) (detectParts x)) == True
OK: fromEither (Bifunctor.bimap ((flip Set.isSubsetOf) (edgeSet (symmetricClosure x)) . AM.edgeSet . circuit) (const True) (detectParts x)) == True
OK: fromEither (Bifunctor.bimap (((==) 1) . ((flip mod) 2) . length) (const True) (detectParts x)) == True

============ Show (Bipartite.AdjacencyMap.Algorithm.Matching a b) ============
OK: show (matching [])                == "matching []"
OK: show (matching [(2,'a'),(1,'b')]) == "matching [(1,'b'),(2,'a')]"

============ Eq (Bipartite.AdjacencyMap.Algorithm.Matching a b) ============
OK: (x == y) == ((pairOfLeft x == pairOfLeft y) && (pairOfRight x == pairOfRight y))

============ Bipartite.AdjacencyMap.Algorithm.pairOfLeft ============
OK: pairOfLeft (matching [])                 == Map.empty
OK: pairOfLeft (matching [(2,'a'), (1,'b')]) == Map.fromList [(2,'a'), (1,'b')]
OK: Map.size . pairOfLeft                    == Map.size . pairOfRight

============ Bipartite.AdjacencyMap.Algorithm.pairOfRight ============
OK: pairOfRight (matching [])                 == Map.empty
OK: pairOfRight (matching [(2,'a'), (1,'b')]) == Map.fromList [('a',2), ('b',1)]
OK: Map.size . pairOfRight                    == Map.size . pairOfLeft

============ Bipartite.AdjacencyMap.Algorithm.matching ============
OK: matching [(1,'a'), (1,'b')]                   == matching [(1,'b')]
OK: matching [(1,'a'), (1,'b'), (2,'b'), (2,'a')] == matching [(2,'a')]

============ Bipartite.AdjacencyMap.Algorithm.isMatchingOf ============
OK: isMatchingOf (matching []) x               == True
OK: isMatchingOf (matching xs) empty           == null xs
OK: isMatchingOf (matching [(x,y)]) (edge x y) == True
OK: isMatchingOf (matching [(1,2)]) (edge 2 1) == False

============ Bipartite.AdjacencyMap.Algorithm.matchingSize ============
OK: matchingSize (matching [])                 == 0
OK: matchingSize (matching [(2,'a'), (1,'b')]) == 2
OK: matchingSize (matching [(1,'a'), (1,'b')]) == 1
OK: matchingSize (matching xs)                 <= length xs
OK: matchingSize x                             == Map.size . pairOfLeft

============ Bipartite.AdjacencyMap.Algorithm.maxMatching ============
OK: maxMatching empty                                          == matching []
OK: maxMatching (vertices xs ys)                               == matching []
OK: maxMatching (path [1,2,3,4])                               == matching [(1,2), (3,4)]
OK: matchingSize (maxMatching (circuit [(1,2), (3,4), (5,6)])) == 3
OK: matchingSize (maxMatching (star x (y:ys)))                 == 1
OK: matchingSize (maxMatching (biclique xs ys))                == min (length (nub xs)) (length (nub ys))
OK: isMatchingOf (maxMatching x) x                             == True

============ Bipartite.AdjacencyMap.Algorithm.isVertexCoverOf ============
OK: isVertexCoverOf (xs             , ys             ) empty          == Set.null xs && Set.null ys
OK: isVertexCoverOf (xs             , ys             ) (leftVertex x) == Set.isSubsetOf xs (Set.singleton x) && Set.null ys
OK: isVertexCoverOf (Set.empty      , Set.empty      ) (edge x y)     == False
OK: isVertexCoverOf (Set.singleton x, ys             ) (edge x y)     == Set.isSubsetOf ys (Set.singleton y)
OK: isVertexCoverOf (xs             , Set.singleton y) (edge x y)     == Set.isSubsetOf xs (Set.singleton x)

============ Bipartite.AdjacencyMap.Algorithm.minVertexCover ============
OK: minVertexCover empty                              == (Set.empty, Set.empty)
OK: minVertexCover (vertices xs ys)                   == (Set.empty, Set.empty)
OK: minVertexCover (path [1,2,3])                     == (Set.empty, Set.singleton 2)
OK: minVertexCover (star x (1:2:ys))                  == (Set.singleton x, Set.empty)
OK: vertexCoverSize (minVertexCover (biclique xs ys)) == min (length (nub xs)) (length (nub ys))
OK: vertexCoverSize . minVertexCover                  == matchingSize . maxMatching
OK: isVertexCoverOf (minVertexCover x) x              == True

============ Bipartite.AdjacencyMap.Algorithm.isIndependentSetOf ============
OK: isIndependentSetOf (xs             , ys             ) empty          == Set.null xs && Set.null ys
OK: isIndependentSetOf (xs             , ys             ) (leftVertex x) == Set.isSubsetOf xs (Set.singleton x) && Set.null ys
OK: isIndependentSetOf (Set.empty      , Set.empty      ) (edge x y)     == True
OK: isIndependentSetOf (Set.singleton x, ys             ) (edge x y)     == Set.null ys
OK: isIndependentSetOf (xs             , Set.singleton y) (edge x y)     == Set.null xs

============ Bipartite.AdjacencyMap.Algorithm.maxIndependentSet ============
OK: maxIndependentSet empty                                 == (Set.empty, Set.empty)
OK: maxIndependentSet (vertices xs ys)                      == (Set.fromList xs, Set.fromList ys)
OK: maxIndependentSet (path [1,2,3])                        == (Set.fromList [1,3], Set.empty)
OK: maxIndependentSet (star x (1:2:ys))                     == (Set.empty, Set.fromList (1:2:ys))
OK: independentSetSize (maxIndependentSet (biclique xs ys)) == max (length (nub xs)) (length (nub ys))
OK: independentSetSize (maxIndependentSet x)                == vertexCount x - vertexCoverSize (minVertexCover x)
OK: isIndependentSetOf (maxIndependentSet x) x              == True

============ Bipartite.AdjacencyMap.Algorithm.augmentingPath ============
OK: augmentingPath (matching [])      empty            == Left (Set.empty, Set.empty)
OK: augmentingPath (matching [])      (edge 1 2)       == Right [1,2]
OK: augmentingPath (matching [(1,2)]) (path [1,2,3])   == Left (Set.empty, Set.singleton 2)
OK: augmentingPath (matching [(3,2)]) (path [1,2,3,4]) == Right [1,2,3,4]
OK: isLeft (augmentingPath (maxMatching x) x)          == True

============ Bipartite.AdjacencyMap.Algorithm.consistentMatching ============
OK: consistentMatching (matching xs)   == True
OK: consistentMatching (maxMatching x) == True

============ Export.Eq ============
OK: mempty /= literal ""

============ Export.Ord ============
OK: mempty <  literal ""

============ Export.isEmpty ============
OK: isEmpty mempty       == True
OK: isEmpty (literal "") == False
OK: isEmpty x            == (x == mempty)

============ Export.literal ============
OK: literal "Hello, " <> literal "World!" == literal "Hello, World!"
OK: literal "I am just a string literal"  == "I am just a string literal"
OK: render . literal                      == id

============ Export.render ============
OK: render (literal "al" <> literal "ga") == "alga"
OK: render mempty                         == mempty

============ Export.<+> ============
OK: x <+> mempty         == x
OK: mempty <+> x         == x
OK: x <+> (y <+> z)      == (x <+> y) <+> z
OK: "name" <+> "surname" == "name surname"

============ Export.brackets ============
OK: brackets "i"    == "[i]"
OK: brackets mempty == "[]"

============ Export.doubleQuotes ============
OK: doubleQuotes "/path/with spaces"   == "\"/path/with spaces\""
OK: doubleQuotes (doubleQuotes mempty) == "\"\"\"\""

============ Export.indent ============
OK: indent 0        == id
OK: indent 1 mempty == " "

============ Export.unlines ============
OK: unlines []                    == mempty
OK: unlines [mempty]              == "\n"
OK: unlines ["title", "subtitle"] == "title\nsubtitle\n"

============ Export.export ============
OK: render $ export vDoc eDoc (1 + 2 * (3 + 4) :: Graph Int)

============ Export.Dot.export ============
OK: export style (1 * 2 + 3 * 4 * 5 :: Graph Int)

=========== Export.Dot.attributeQuoting ============
OK: export style' (1 * 2 + 3 * 4 * 5 :: Graph Int)

============ Export.Dot.exportAsIs ============
OK: exportAsIs (circuit ["a", "b", "c"] :: Graph String)

============ Export.Dot.exportViaShow ============
OK: exportViaShow (1 + 2 * (3 + 4) :: Graph Int)

============ Graph ============
OK: Axioms of graphs
OK: Theorems of graphs

============ Graph.Ord ============
OK: vertex 1 <  vertex 2
OK: vertex 3 <  edge 1 2
OK: vertex 1 <  edge 1 1
OK: edge 1 1 <  edge 1 2
OK: edge 1 2 <  edge 1 1 + edge 2 2
OK: edge 1 2 <  edge 1 3
OK: x        <= x + y
OK: x + y    <= x * y

============ Graph.empty ============
OK: isEmpty     empty == True
OK: hasVertex x empty == False
OK: vertexCount empty == 0
OK: edgeCount   empty == 0

============ Graph.vertex ============
OK: isEmpty     (vertex x) == False
OK: hasVertex x (vertex y) == (x == y)
OK: vertexCount (vertex x) == 1
OK: edgeCount   (vertex x) == 0

============ Graph.edge ============
OK: edge x y               == connect (vertex x) (vertex y)
OK: hasEdge x y (edge x y) == True
OK: edgeCount   (edge x y) == 1
OK: vertexCount (edge 1 1) == 1
OK: vertexCount (edge 1 2) == 2

============ Graph.overlay ============
OK: isEmpty     (overlay x y) == isEmpty   x   && isEmpty   y
OK: hasVertex z (overlay x y) == hasVertex z x || hasVertex z y
OK: vertexCount (overlay x y) >= vertexCount x
OK: vertexCount (overlay x y) <= vertexCount x + vertexCount y
OK: edgeCount   (overlay x y) >= edgeCount x
OK: edgeCount   (overlay x y) <= edgeCount x   + edgeCount y
OK: vertexCount (overlay 1 2) == 2
OK: edgeCount   (overlay 1 2) == 0

============ Graph.connect ============
OK: isEmpty     (connect x y) == isEmpty   x   && isEmpty   y
OK: hasVertex z (connect x y) == hasVertex z x || hasVertex z y
OK: vertexCount (connect x y) >= vertexCount x
OK: vertexCount (connect x y) <= vertexCount x + vertexCount y
OK: edgeCount   (connect x y) >= edgeCount x
OK: edgeCount   (connect x y) >= edgeCount y
OK: edgeCount   (connect x y) >= vertexCount x * vertexCount y
OK: edgeCount   (connect x y) <= vertexCount x * vertexCount y + edgeCount x + edgeCount y
OK: vertexCount (connect 1 2) == 2
OK: edgeCount   (connect 1 2) == 1

============ Graph.vertices ============
OK: vertices []            == empty
OK: vertices [x]           == vertex x
OK: vertices               == overlays . map vertex
OK: hasVertex x . vertices == elem x
OK: vertexCount . vertices == length . nub
OK: vertexSet   . vertices == Set.fromList

============ Graph.edges ============
OK: edges []          == empty
OK: edges [(x,y)]     == edge x y
OK: edges             == overlays . map (uncurry edge)
OK: edgeCount . edges == length . nub

============ Graph.overlays ============
OK: overlays []        == empty
OK: overlays [x]       == x
OK: overlays [x,y]     == overlay x y
OK: overlays           == foldr overlay empty
OK: isEmpty . overlays == all isEmpty

============ Graph.connects ============
OK: connects []        == empty
OK: connects [x]       == x
OK: connects [x,y]     == connect x y
OK: connects           == foldr connect empty
OK: isEmpty . connects == all isEmpty

============ Graph.isSubgraphOf ============
OK: isSubgraphOf empty         x             ==  True
OK: isSubgraphOf (vertex x)    empty         ==  False
OK: isSubgraphOf x             (overlay x y) ==  True
OK: isSubgraphOf (overlay x y) (connect x y) ==  True
OK: isSubgraphOf (path xs)     (circuit xs)  ==  True
OK: isSubgraphOf x y                         ==> x <= y

============ Graph.toGraph et al. ============
OK: toGraph                    == foldg Empty Vertex Overlay Connect
OK: foldg                      == Algebra.Graph.foldg . toGraph
OK: isEmpty                    == foldg True (const False) (&&) (&&)
OK: size                       == foldg 1 (const 1) (+) (+)
OK: hasVertex x                == foldg False (==x) (||) (||)
OK: hasEdge x y                == Algebra.Graph.hasEdge x y . toGraph
OK: vertexCount                == Set.size . vertexSet
OK: edgeCount                  == Set.size . edgeSet
OK: vertexList                 == Set.toAscList . vertexSet
OK: edgeList                   == Set.toAscList . edgeSet
OK: vertexSet                  == foldg Set.empty Set.singleton Set.union Set.union
OK: vertexIntSet               == foldg IntSet.empty IntSet.singleton IntSet.union IntSet.union
OK: edgeSet                    == Algebra.Graph.AdjacencyMap.edgeSet . foldg empty vertex overlay connect
OK: preSet x                   == Algebra.Graph.AdjacencyMap.preSet x . toAdjacencyMap
OK: preIntSet x                == Algebra.Graph.AdjacencyIntMap.preIntSet x . toAdjacencyIntMap
OK: postSet x                  == Algebra.Graph.AdjacencyMap.postSet x . toAdjacencyMap
OK: postIntSet x               == Algebra.Graph.AdjacencyIntMap.postIntSet x . toAdjacencyIntMap
OK: adjacencyList              == Algebra.Graph.AdjacencyMap.adjacencyList . toAdjacencyMap
OK: adjacencyMap               == Algebra.Graph.AdjacencyMap.adjacencyMap . toAdjacencyMap
OK: adjacencyIntMap            == Algebra.Graph.AdjacencyIntMap.adjacencyIntMap . toAdjacencyIntMap
OK: adjacencyMapTranspose      == Algebra.Graph.AdjacencyMap.adjacencyMap . toAdjacencyMapTranspose
OK: adjacencyIntMapTranspose   == Algebra.Graph.AdjacencyIntMap.adjacencyIntMap . toAdjacencyIntMapTranspose
OK: dfsForest                  == Algebra.Graph.AdjacencyMap.dfsForest . toAdjacencyMap
OK: dfsForestFrom              == Algebra.Graph.AdjacencyMap.dfsForestFrom . toAdjacencyMap
OK: dfs                        == Algebra.Graph.AdjacencyMap.dfs . toAdjacencyMap
OK: reachable                  == Algebra.Graph.AdjacencyMap.reachable . toAdjacencyMap
OK: topSort                    == Algebra.Graph.AdjacencyMap.topSort . toAdjacencyMap
OK: isAcyclic                  == Algebra.Graph.AdjacencyMap.isAcyclic . toAdjacencyMap
OK: isTopSortOf vs             == Algebra.Graph.AdjacencyMap.isTopSortOf vs . toAdjacencyMap
OK: toAdjacencyMap             == foldg empty vertex overlay connect
OK: toAdjacencyMapTranspose    == foldg empty vertex overlay (flip connect)
OK: toAdjacencyIntMap          == foldg empty vertex overlay connect
OK: toAdjacencyIntMapTranspose == foldg empty vertex overlay (flip connect)
OK: isDfsForestOf f            == Algebra.Graph.AdjacencyMap.isDfsForestOf f . toAdjacencyMap
OK: isTopSortOf vs             == Algebra.Graph.AdjacencyMap.isTopSortOf vs . toAdjacencyMap

============ Graph.foldg ============
OK: foldg empty vertex        overlay connect        == id
OK: foldg empty vertex        overlay (flip connect) == transpose
OK: foldg 1     (const 1)     (+)     (+)            == size
OK: foldg True  (const False) (&&)    (&&)           == isEmpty

============ Graph.isEmpty ============
OK: isEmpty empty                       == True
OK: isEmpty (overlay empty empty)       == True
OK: isEmpty (vertex x)                  == False
OK: isEmpty (removeVertex x $ vertex x) == True
OK: isEmpty (removeEdge x y $ edge x y) == False

============ Graph.hasVertex ============
OK: hasVertex x empty            == False
OK: hasVertex x (vertex y)       == (x == y)
OK: hasVertex x . removeVertex x == const False

============ Graph.hasEdge ============
OK: hasEdge x y empty            == False
OK: hasEdge x y (vertex z)       == False
OK: hasEdge x y (edge x y)       == True
OK: hasEdge x y . removeEdge x y == const False
OK: hasEdge x y                  == elem (x,y) . edgeList

============ Graph.vertexCount ============
OK: vertexCount empty             ==  0
OK: vertexCount (vertex x)        ==  1
OK: vertexCount                   ==  length . vertexList
OK: vertexCount x < vertexCount y ==> x < y

============ Graph.edgeCount ============
OK: edgeCount empty      == 0
OK: edgeCount (vertex x) == 0
OK: edgeCount (edge x y) == 1
OK: edgeCount            == length . edgeList

============ Graph.vertexList ============
OK: vertexList empty      == []
OK: vertexList (vertex x) == [x]
OK: vertexList . vertices == nub . sort

============ Graph.vertexSet ============
OK: vertexSet empty      == Set.empty
OK: vertexSet . vertex   == Set.singleton
OK: vertexSet . vertices == Set.fromList

============ Graph.vertexIntSet ============
OK: vertexIntSet empty      == IntSet.empty
OK: vertexIntSet . vertex   == IntSet.singleton
OK: vertexIntSet . vertices == IntSet.fromList
OK: vertexIntSet . clique   == IntSet.fromList

============ Graph.edgeList ============
OK: edgeList empty          == []
OK: edgeList (vertex x)     == []
OK: edgeList (edge x y)     == [(x,y)]
OK: edgeList (star 2 [3,1]) == [(2,1), (2,3)]
OK: edgeList . edges        == nub . sort

============ Graph.edgeSet ============
OK: edgeSet empty      == Set.empty
OK: edgeSet (vertex x) == Set.empty
OK: edgeSet (edge x y) == Set.singleton (x,y)
OK: edgeSet . edges    == Set.fromList

============ Graph.adjacencyList ============
OK: adjacencyList empty          == []
OK: adjacencyList (vertex x)     == [(x, [])]
OK: adjacencyList (edge 1 2)     == [(1, [2]), (2, [])]
OK: adjacencyList (star 2 [3,1]) == [(1, []), (2, [1,3]), (3, [])]

============ Graph.preSet ============
OK: preSet x empty      == Set.empty
OK: preSet x (vertex x) == Set.empty
OK: preSet 1 (edge 1 2) == Set.empty
OK: preSet y (edge x y) == Set.fromList [x]

============ Graph.preIntSet ============
OK: preIntSet x empty      == IntSet.empty
OK: preIntSet x (vertex x) == IntSet.empty
OK: preIntSet 1 (edge 1 2) == IntSet.empty
OK: preIntSet y (edge x y) == IntSet.fromList [x]

============ Graph.postSet ============
OK: postSet x empty      == Set.empty
OK: postSet x (vertex x) == Set.empty
OK: postSet x (edge x y) == Set.fromList [y]
OK: postSet 2 (edge 1 2) == Set.empty

============ Graph.postIntSet ============
OK: postIntSet x empty      == IntSet.empty
OK: postIntSet x (vertex x) == IntSet.empty
OK: postIntSet 2 (edge 1 2) == IntSet.empty
OK: postIntSet x (edge x y) == IntSet.fromList [y]

============ Graph.size ============
OK: size empty         == 1
OK: size (vertex x)    == 1
OK: size (overlay x y) == size x + size y
OK: size (connect x y) == size x + size y
OK: size x             >= 1
OK: size x             >= vertexCount x

============ Graph.path ============
OK: path []    == empty
OK: path [x]   == vertex x
OK: path [x,y] == edge x y

============ Graph.circuit ============
OK: circuit []    == empty
OK: circuit [x]   == edge x x
OK: circuit [x,y] == edges [(x,y), (y,x)]

============ Graph.clique ============
OK: clique []         == empty
OK: clique [x]        == vertex x
OK: clique [x,y]      == edge x y
OK: clique [x,y,z]    == edges [(x,y), (x,z), (y,z)]
OK: clique (xs ++ ys) == connect (clique xs) (clique ys)

============ Graph.biclique ============
OK: biclique []      []      == empty
OK: biclique [x]     []      == vertex x
OK: biclique []      [y]     == vertex y
OK: biclique [x1,x2] [y1,y2] == edges [(x1,y1), (x1,y2), (x2,y1), (x2,y2)]
OK: biclique xs      ys      == connect (vertices xs) (vertices ys)

============ Graph.star ============
OK: star x []    == vertex x
OK: star x [y]   == edge x y
OK: star x [y,z] == edges [(x,y), (x,z)]
OK: star x ys    == connect (vertex x) (vertices ys)

============ Graph.stars ============
OK: stars []                      == empty
OK: stars [(x, [])]               == vertex x
OK: stars [(x, [y])]              == edge x y
OK: stars [(x, ys)]               == star x ys
OK: stars                         == overlays . map (uncurry star)
OK: stars . adjacencyList         == id
OK: overlay (stars xs) (stars ys) == stars (xs ++ ys)

============ Graph.tree ============
OK: tree (Node x [])                                         == vertex x
OK: tree (Node x [Node y [Node z []]])                       == path [x,y,z]
OK: tree (Node x [Node y [], Node z []])                     == star x [y,z]
OK: tree (Node 1 [Node 2 [], Node 3 [Node 4 [], Node 5 []]]) == edges [(1,2), (1,3), (3,4), (3,5)]

============ Graph.forest ============
OK: forest []                                                  == empty
OK: forest [x]                                                 == tree x
OK: forest [Node 1 [Node 2 [], Node 3 []], Node 4 [Node 5 []]] == edges [(1,2), (1,3), (4,5)]
OK: forest                                                     == overlays . map tree

============ Graph.removeVertex ============
OK: removeVertex x (vertex x)       == empty
OK: removeVertex 1 (vertex 2)       == vertex 2
OK: removeVertex x (edge x x)       == empty
OK: removeVertex 1 (edge 1 2)       == vertex 2
OK: removeVertex x . removeVertex x == removeVertex x

============ Graph.removeEdge ============
OK: removeEdge x y (edge x y)       == vertices [x,y]
OK: removeEdge x y . removeEdge x y == removeEdge x y
OK: removeEdge x y . removeVertex x == removeVertex x
OK: removeEdge 1 1 (1 * 1 * 2 * 2)  == 1 * 2 * 2
OK: removeEdge 1 2 (1 * 1 * 2 * 2)  == 1 * 1 + 2 * 2
OK: size (removeEdge x y z)         <= 3 * size z

============ Graph.replaceVertex ============
OK: replaceVertex x x            == id
OK: replaceVertex x y (vertex x) == vertex y
OK: replaceVertex x y            == mergeVertices (== x) y

============ Graph.mergeVertices ============
OK: mergeVertices (const False) x    == id
OK: mergeVertices (== x) y           == replaceVertex x y
OK: mergeVertices even 1 (0 * 2)     == 1 * 1
OK: mergeVertices odd  1 (3 + 4 * 5) == 4 * 1

============ Graph.transpose ============
OK: transpose empty       == empty
OK: transpose (vertex x)  == vertex x
OK: transpose (edge x y)  == edge y x
OK: transpose . transpose == id
OK: edgeList . transpose  == sort . map swap . edgeList

============ Graph.gmap ============
OK: gmap f empty      == empty
OK: gmap f (vertex x) == vertex (f x)
OK: gmap f (edge x y) == edge (f x) (f y)
OK: gmap id           == id
OK: gmap f . gmap g   == gmap (f . g)

============ Graph.induce ============
OK: induce (const True ) x      == x
OK: induce (const False) x      == empty
OK: induce (/= x)               == removeVertex x
OK: induce p . induce q         == induce (\x -> p x && q x)
OK: isSubgraphOf (induce p x) x == True

============ Graph.induceJust ============
OK: induceJust (vertex Nothing)                               == empty
OK: induceJust (edge (Just x) Nothing)                        == vertex x
OK: induceJust . gmap Just                                    == id
OK: induceJust . gmap (\x -> if p x then Just x else Nothing) == induce p

============ Graph.compose ============
OK: compose empty            x                == empty
OK: compose x                empty            == empty
OK: compose (vertex x)       y                == empty
OK: compose x                (vertex y)       == empty
OK: compose x                (compose y z)    == compose (compose x y) z
OK: compose x                (overlay y z)    == overlay (compose x y) (compose x z)
OK: compose (overlay x y) z                   == overlay (compose x z) (compose y z)
OK: compose (edge x y)       (edge y z)       == edge x z
OK: compose (path    [1..5]) (path    [1..5]) == edges [(1,3),(2,4),(3,5)]
OK: compose (circuit [1..5]) (circuit [1..5]) == circuit [1,3,5,2,4]
OK: size (compose x y)                        <= edgeCount x + edgeCount y + 1

============ Graph.(===) ============
OK:     x === x         == True
OK:     x === x + empty == False
OK: x + y === x + y     == True
OK: 1 + 2 === 2 + 1     == False
OK: x + y === x * y     == False

============ Graph.mesh ============
OK: mesh xs     []    == empty
OK: mesh []     ys    == empty
OK: mesh [x]    [y]   == vertex (x, y)
OK: mesh xs     ys    == box (path xs) (path ys)
OK: mesh [1..3] "ab"  == <correct result>
OK: size (mesh xs ys) == max 1 (3 * length xs * length ys - length xs - length ys -1)

============ Graph.torus ============
OK: torus xs     []    == empty
OK: torus []     ys    == empty
OK: torus [x]    [y]   == edge (x,y) (x,y)
OK: torus xs     ys    == box (circuit xs) (circuit ys)
OK: torus [1,2]  "ab"  == <correct result>
OK: size (torus xs ys) == max 1 (3 * length xs * length ys)

============ Graph.deBruijn ============
OK:           deBruijn 0 xs               == edge [] []
OK: n > 0 ==> deBruijn n []               == empty
OK:           deBruijn 1 [0,1]            == edges [ ([0],[0]), ([0],[1]), ([1],[0]), ([1],[1]) ]
OK:           deBruijn 2 "0"              == edge "00" "00"
OK:           deBruijn 2 "01"             == <correct result>
OK:           transpose   (deBruijn n xs) == gmap reverse $ deBruijn n xs
OK:           vertexCount (deBruijn n xs) == (length $ nub xs)^n
OK: n > 0 ==> edgeCount   (deBruijn n xs) == (length $ nub xs)^(n + 1)

============ Graph.splitVertex ============
OK: splitVertex x []                   == removeVertex x
OK: splitVertex x [x]                  == id
OK: splitVertex x [y]                  == replaceVertex x y
OK: splitVertex 1 [0, 1] $ 1 * (2 + 3) == (0 + 1) * (2 + 3)

============ Graph.bind ============
OK: bind empty f         == empty
OK: bind (vertex x) f    == f x
OK: bind (edge x y) f    == connect (f x) (f y)
OK: bind (vertices xs) f == overlays (map f xs)
OK: bind x (const empty) == empty
OK: bind x vertex        == x
OK: bind (bind x f) g    == bind x (\y -> bind (f y) g)

============ Graph.simplify ============
OK: simplify              == id
OK: size (simplify x)     <= size x

============ Graph.box ============
OK: box x y               ~~ box y x
OK: box x (overlay y z)   == overlay (box x y) (box x z)
OK: box x (vertex ())     ~~ x
OK: box x empty           ~~ empty
OK: box x (box y z)       ~~ box (box x y) z
OK: transpose   (box x y) == box (transpose x) (transpose y)
OK: vertexCount (box x y) == vertexCount x * vertexCount y
OK: edgeCount   (box x y) <= vertexCount x * edgeCount y + edgeCount x * vertexCount y

============ Graph.sparsify ============
OK: sort . reachable x       == sort . rights . reachable (sparsify x) . Right
OK: vertexCount (sparsify x) <= vertexCount x + size x + 1
OK: edgeCount   (sparsify x) <= 3 * size x
OK: size        (sparsify x) <= 3 * size x

============ Graph.sparsifyKL ============
OK: sort . reachable x                 == sort . filter (<= n) . reachable (sparsifyKL n x)
OK: length (vertices $ sparsifyKL n x) <= vertexCount x + size x + 1
OK: length (edges    $ sparsifyKL n x) <= 3 * size x

============ Graph.context ============
OK: context (const False) x                   == Nothing
OK: context (== 1)        (edge 1 2)          == Just (Context [   ] [2  ])
OK: context (== 2)        (edge 1 2)          == Just (Context [1  ] [   ])
OK: context (const True ) (edge 1 2)          == Just (Context [1  ] [2  ])
OK: context (== 4)        (3 * 1 * 4 * 1 * 5) == Just (Context [3,1] [1,5])

============ Graph.buildg ============
OK: buildg (\e _ _ _ -> e)                                     == empty
OK: buildg (\_ v _ _ -> v x)                                   == vertex x
OK: buildg (\e v o c -> o (foldg e v o c x) (foldg e v o c y)) == overlay x y
OK: buildg (\e v o c -> c (foldg e v o c x) (foldg e v o c y)) == connect x y
OK: buildg (\e v o _ -> foldr o e (map v xs))                  == vertices xs
OK: buildg (\e v o c -> foldg e v o (flip c) g)                == transpose g

============ Internal.List ============
OK: pure 1 <> pure 4 == [1, 4]

============ Graph.Label ============

============ Any: instances ============
OK: Semiring
OK: StarSemiring
OK: Dioid

============ Distance Int: instances ============
OK: Semiring
OK: StarSemiring
OK: Dioid

============ Capacity Int: instances ============
OK: Semiring
OK: StarSemiring
OK: Dioid

============ Minimum (Path Int): instances ============
OK: LeftNearRing

============ PowerSet (Path Int): instances ============
OK: Semiring
OK: Dioid

============ Count Int: instances ============
OK: Semiring
OK: StarSemiring

============ Labelled.AdjacencyMap.consistent ============
OK: arbitraryLabelledAdjacencyMap
OK: empty
OK: vertex
OK: edge
OK: overlay
OK: connect
OK: vertices
OK: edges
OK: overlays
OK: fromAdjacencyMaps
OK: removeVertex
OK: removeEdge
OK: replaceVertex
OK: replaceEdge
OK: transpose
OK: gmap
OK: emap
OK: induce
OK: closure
OK: reflexiveClosure
OK: symmetricClosure
OK: transitiveClosure

============ Labelled.AdjacencyMap.empty ============
OK: isEmpty     empty == True
OK: hasVertex x empty == False
OK: vertexCount empty == 0
OK: edgeCount   empty == 0

============ Labelled.AdjacencyMap.vertex ============
OK: isEmpty     (vertex x) == False
OK: hasVertex x (vertex y) == (x == y)
OK: vertexCount (vertex x) == 1
OK: edgeCount   (vertex x) == 0

============ Labelled.AdjacencyMap.edge ============
OK: edge e    x y              == connect e (vertex x) (vertex y)
OK: edge zero x y              == vertices [x,y]
OK: hasEdge   x y (edge e x y) == (e /= mempty)
OK: edgeLabel x y (edge e x y) == e
OK: edgeCount     (edge e x y) == if e == mempty then 0 else 1
OK: vertexCount   (edge e 1 1) == 1
OK: vertexCount   (edge e 1 2) == 2
OK: x -<e>- y                  == edge e x y

============ Labelled.AdjacencyMap.overlay ============
OK: isEmpty     (overlay x y) == isEmpty   x   && isEmpty   y
OK: hasVertex z (overlay x y) == hasVertex z x || hasVertex z y
OK: vertexCount (overlay x y) >= vertexCount x
OK: vertexCount (overlay x y) <= vertexCount x + vertexCount y
OK: edgeCount   (overlay x y) >= edgeCount x
OK: edgeCount   (overlay x y) <= edgeCount x   + edgeCount y
OK: vertexCount (overlay 1 2) == 2
OK: edgeCount   (overlay 1 2) == 0

OK: edgeLabel x y $ overlay (edge e x y) (edge zero x y) == e
OK: edgeLabel x y $ overlay (edge e x y) (edge f    x y) == e <+> f

OK: edgeLabel 1 3 $ transitiveClosure (overlay (edge e 1 2) (edge one 2 3)) == e
OK: edgeLabel 1 3 $ transitiveClosure (overlay (edge e 1 2) (edge f   2 3)) == e <.> f

============ Labelled.AdjacencyMap.connect ============
OK: isEmpty     (connect e x y) == isEmpty   x   && isEmpty   y
OK: hasVertex z (connect e x y) == hasVertex z x || hasVertex z y
OK: vertexCount (connect e x y) >= vertexCount x
OK: vertexCount (connect e x y) <= vertexCount x + vertexCount y
OK: edgeCount   (connect e x y) <= vertexCount x * vertexCount y + edgeCount x + edgeCount y
OK: vertexCount (connect e 1 2) == 2
OK: edgeCount   (connect e 1 2) == if e == zero then 0 else 1

============ Labelled.AdjacencyMap.vertices ============
OK: vertices []            == empty
OK: vertices [x]           == vertex x
OK: vertices               == overlays . map vertex
OK: hasVertex x . vertices == elem x
OK: vertexCount . vertices == length . nub
OK: vertexSet   . vertices == Set.fromList

============ Labelled.AdjacencyMap.edges ============
OK: edges []        == empty
OK: edges [(e,x,y)] == edge e x y
OK: edges           == overlays . map (\(e, x, y) -> edge e x y)

============ Labelled.AdjacencyMap.overlays ============
OK: overlays []        == empty
OK: overlays [x]       == x
OK: overlays [x,y]     == overlay x y
OK: overlays           == foldr overlay empty
OK: isEmpty . overlays == all isEmpty

============ Labelled.AdjacencyMap.fromAdjacencyMaps ============
OK: fromAdjacencyMaps []                                  == empty
OK: fromAdjacencyMaps [(x, Map.empty)]                    == vertex x
OK: fromAdjacencyMaps [(x, Map.singleton y e)]            == if e == zero then vertices [x,y] else edge e x y
OK: overlay (fromAdjacencyMaps xs) (fromAdjacencyMaps ys) == fromAdjacencyMaps (xs ++ ys)

============ Labelled.AdjacencyMap.isSubgraphOf ============
OK: isSubgraphOf empty      x     ==  True
OK: isSubgraphOf (vertex x) empty ==  False
OK: isSubgraphOf x y              ==> x <= y

============ Labelled.AdjacencyMap.isEmpty ============
OK: isEmpty empty                         == True
OK: isEmpty (overlay empty empty)         == True
OK: isEmpty (vertex x)                    == False
OK: isEmpty (removeVertex x $ vertex x)   == True
OK: isEmpty (removeEdge x y $ edge e x y) == False

============ Labelled.AdjacencyMap.hasVertex ============
OK: hasVertex x empty            == False
OK: hasVertex x (vertex y)       == (x == y)
OK: hasVertex x . removeVertex x == const False

============ Labelled.AdjacencyMap.hasEdge ============
OK: hasEdge x y empty            == False
OK: hasEdge x y (vertex z)       == False
OK: hasEdge x y (edge e x y)     == (e /= zero)
OK: hasEdge x y . removeEdge x y == const False
OK: hasEdge x y                  == not . null . filter (\(_,ex,ey) -> ex == x && ey == y) . edgeList

============ Labelled.AdjacencyMap.edgeLabel ============
OK: edgeLabel x y empty         == zero
OK: edgeLabel x y (vertex z)    == zero
OK: edgeLabel x y (edge e x y)  == e
OK: edgeLabel s t (overlay x y) == edgeLabel s t x + edgeLabel s t y

============ Labelled.AdjacencyMap.vertexCount ============
OK: vertexCount empty             ==  0
OK: vertexCount (vertex x)        ==  1
OK: vertexCount                   ==  length . vertexList
OK: vertexCount x < vertexCount y ==> x < y

============ Labelled.AdjacencyMap.edgeCount ============
OK: edgeCount empty        == 0
OK: edgeCount (vertex x)   == 0
OK: edgeCount (edge e x y) == if e == zero then 0 else 1
OK: edgeCount              == length . edgeList

============ Labelled.AdjacencyMap.vertexList ============
OK: vertexList empty      == []
OK: vertexList (vertex x) == [x]
OK: vertexList . vertices == nub . sort

============ Labelled.AdjacencyMap.edgeList ============
OK: edgeList empty        == []
OK: edgeList (vertex x)   == []
OK: edgeList (edge e x y) == if e == zero then [] else [(e,x,y)]

============ Labelled.AdjacencyMap.vertexSet ============
OK: vertexSet empty      == Set.empty
OK: vertexSet . vertex   == Set.singleton
OK: vertexSet . vertices == Set.fromList

============ Labelled.AdjacencyMap.edgeSet ============
OK: edgeSet empty        == Set.empty
OK: edgeSet (vertex x)   == Set.empty
OK: edgeSet (edge e x y) == if e == zero then Set.empty else Set.singleton (e,x,y)

============ Labelled.AdjacencyMap.preSet ============
OK: preSet x empty        == Set.empty
OK: preSet x (vertex x)   == Set.empty
OK: preSet 1 (edge e 1 2) == Set.empty
OK: preSet y (edge e x y) == if e == zero then Set.empty else Set.fromList [x]

============ Labelled.AdjacencyMap.postSet ============
OK: postSet x empty        == Set.empty
OK: postSet x (vertex x)   == Set.empty
OK: postSet x (edge e x y) == if e == zero then Set.empty else Set.fromList [y]
OK: postSet 2 (edge e 1 2) == Set.empty

============ Labelled.AdjacencyMap.skeleton ============
OK: hasEdge x y == hasEdge x y . skeleton

============ Labelled.AdjacencyMap.removeVertex ============
OK: removeVertex x (vertex x)       == empty
OK: removeVertex 1 (vertex 2)       == vertex 2
OK: removeVertex x (edge e x x)     == empty
OK: removeVertex 1 (edge e 1 2)     == vertex 2
OK: removeVertex x . removeVertex x == removeVertex x

============ Labelled.AdjacencyMap.removeEdge ============
OK: removeEdge x y (edge e x y)     == vertices [x,y]
OK: removeEdge x y . removeEdge x y == removeEdge x y
OK: removeEdge x y . removeVertex x == removeVertex x
OK: removeEdge 1 1 (1 * 1 * 2 * 2)  == 1 * 2 * 2
OK: removeEdge 1 2 (1 * 1 * 2 * 2)  == 1 * 1 + 2 * 2

============ Labelled.AdjacencyMap.replaceVertex ============
OK: replaceVertex x x            == id
OK: replaceVertex x y (vertex x) == vertex y
OK: replaceVertex x y            == gmap (\v -> if v == x then y else v)

============ Labelled.AdjacencyMap.replaceEdge ============
OK: replaceEdge e x y z                 == overlay (removeEdge x y z) (edge e x y)
OK: replaceEdge e x y (edge f x y)      == edge e x y
OK: edgeLabel x y (replaceEdge e x y z) == e

============ Labelled.AdjacencyMap.transpose ============
OK: transpose empty        == empty
OK: transpose (vertex x)   == vertex x
OK: transpose (edge e x y) == edge e y x
OK: transpose . transpose  == id

============ Labelled.AdjacencyMap.gmap ============
OK: gmap f empty        == empty
OK: gmap f (vertex x)   == vertex (f x)
OK: gmap f (edge e x y) == edge e (f x) (f y)
OK: gmap id             == id
OK: gmap f . gmap g     == gmap (f . g)

============ Labelled.AdjacencyMap.emap ============
OK: emap h empty           == empty
OK: emap h (vertex x)      == vertex x
OK: emap h (edge e x y)    == edge (h e) x y
OK: emap h (overlay x y)   == overlay (emap h x) (emap h y)
OK: emap h (connect e x y) == connect (h e) (emap h x) (emap h y)
OK: emap id                == id
OK: emap g . emap h        == emap (g . h)

============ Labelled.AdjacencyMap.induce ============
OK: induce (const True ) x      == x
OK: induce (const False) x      == empty
OK: induce (/= x)               == removeVertex x
OK: induce p . induce q         == induce (\x -> p x && q x)
OK: isSubgraphOf (induce p x) x == True

============ Labelled.AdjacencyMap.induceJust ============
OK: induceJust (vertex Nothing)                               == empty
OK: induceJust (edge (Just x) Nothing)                        == vertex x
OK: induceJust . gmap Just                                    == id
OK: induceJust . gmap (\x -> if p x then Just x else Nothing) == induce p

============ Labelled.AdjacencyMap.closure ============
OK: closure empty         == empty
OK: closure (vertex x)    == edge one x x
OK: closure (edge e x x)  == edge one x x
OK: closure (edge e x y)  == edges [(one,x,x), (e,x,y), (one,y,y)]
OK: closure               == reflexiveClosure . transitiveClosure
OK: closure               == transitiveClosure . reflexiveClosure
OK: closure . closure     == closure
OK: postSet x (closure y) == Set.fromList (reachable y x)

============ Labelled.AdjacencyMap.reflexiveClosure ============
OK: reflexiveClosure empty              == empty
OK: reflexiveClosure (vertex x)         == edge one x x
OK: reflexiveClosure (edge e x x)       == edge one x x
OK: reflexiveClosure (edge e x y)       == edges [(one,x,x), (e,x,y), (one,y,y)]
OK: reflexiveClosure . reflexiveClosure == reflexiveClosure

============ Labelled.AdjacencyMap.symmetricClosure ============
OK: symmetricClosure empty              == empty
OK: symmetricClosure (vertex x)         == vertex x
OK: symmetricClosure (edge e x y)       == edges [(e,x,y), (e,y,x)]
OK: symmetricClosure x                  == overlay x (transpose x)
OK: symmetricClosure . symmetricClosure == symmetricClosure

============ Labelled.AdjacencyMap.transitiveClosure ============
OK: transitiveClosure empty               == empty
OK: transitiveClosure (vertex x)          == vertex x
OK: transitiveClosure (edge e x y)        == edge e x y
OK: transitiveClosure . transitiveClosure == transitiveClosure

============ Labelled.Graph.empty ============
OK: isEmpty     empty == True
OK: hasVertex x empty == False
OK: vertexCount empty == 0
OK: edgeCount   empty == 0

============ Labelled.Graph.vertex ============
OK: isEmpty     (vertex x) == False
OK: hasVertex x (vertex y) == (x == y)
OK: vertexCount (vertex x) == 1
OK: edgeCount   (vertex x) == 0

============ Labelled.Graph.edge ============
OK: edge e    x y              == connect e (vertex x) (vertex y)
OK: edge zero x y              == vertices [x,y]
OK: hasEdge   x y (edge e x y) == (e /= mempty)
OK: edgeLabel x y (edge e x y) == e
OK: edgeCount     (edge e x y) == if e == mempty then 0 else 1
OK: vertexCount   (edge e 1 1) == 1
OK: vertexCount   (edge e 1 2) == 2
OK: x -<e>- y                  == edge e x y

============ Labelled.Graph.overlay ============
OK: isEmpty     (overlay x y) == isEmpty   x   && isEmpty   y
OK: hasVertex z (overlay x y) == hasVertex z x || hasVertex z y
OK: vertexCount (overlay x y) >= vertexCount x
OK: vertexCount (overlay x y) <= vertexCount x + vertexCount y
OK: edgeCount   (overlay x y) >= edgeCount x
OK: edgeCount   (overlay x y) <= edgeCount x   + edgeCount y
OK: vertexCount (overlay 1 2) == 2
OK: edgeCount   (overlay 1 2) == 0

OK: edgeLabel x y $ overlay (edge e x y) (edge zero x y) == e
OK: edgeLabel x y $ overlay (edge e x y) (edge f    x y) == e <+> f

OK: edgeLabel 1 3 $ transitiveClosure (overlay (edge e 1 2) (edge one 2 3)) == e
OK: edgeLabel 1 3 $ transitiveClosure (overlay (edge e 1 2) (edge f   2 3)) == e <.> f

============ Labelled.Graph.connect ============
OK: isEmpty     (connect e x y) == isEmpty   x   && isEmpty   y
OK: hasVertex z (connect e x y) == hasVertex z x || hasVertex z y
OK: vertexCount (connect e x y) >= vertexCount x
OK: vertexCount (connect e x y) <= vertexCount x + vertexCount y
OK: edgeCount   (connect e x y) <= vertexCount x * vertexCount y + edgeCount x + edgeCount y
OK: vertexCount (connect e 1 2) == 2
OK: edgeCount   (connect e 1 2) == if e == zero then 0 else 1

============ Labelled.Graph.vertices ============
OK: vertices []            == empty
OK: vertices [x]           == vertex x
OK: vertices               == overlays . map vertex
OK: hasVertex x . vertices == elem x
OK: vertexCount . vertices == length . nub
OK: vertexSet   . vertices == Set.fromList

============ Labelled.Graph.edges ============
OK: edges []        == empty
OK: edges [(e,x,y)] == edge e x y
OK: edges           == overlays . map (\(e, x, y) -> edge e x y)

============ Labelled.Graph.overlays ============
OK: overlays []        == empty
OK: overlays [x]       == x
OK: overlays [x,y]     == overlay x y
OK: overlays           == foldr overlay empty
OK: isEmpty . overlays == all isEmpty

============ Labelled.Graph.foldg ============
OK: foldg empty     vertex        connect             == id
OK: foldg empty     vertex        (fmap flip connect) == transpose
OK: foldg 1         (const 1)     (const (+))         == size
OK: foldg True      (const False) (const (&&))        == isEmpty
OK: foldg False     (== x)        (const (||))        == hasVertex x
OK: foldg Set.empty Set.singleton (const Set.union)   == vertexSet

============ Labelled.Graph.buildg ============
OK: buildg (\e _ _ -> e)                                   == empty
OK: buildg (\_ v _ -> v x)                                 == vertex x
OK: buildg (\e v c -> c l (foldg e v c x) (foldg e v c y)) == connect l x y
OK: buildg (\e v c -> foldr (c zero) e (map v xs))         == vertices xs
OK: buildg (\e v c -> foldg e v (flip c) g)                == transpose g

============ Labelled.Graph.isSubgraphOf ============
OK: isSubgraphOf empty      x     ==  True
OK: isSubgraphOf (vertex x) empty ==  False
OK: isSubgraphOf x y              ==> x <= y

============ Labelled.Graph.isEmpty ============
OK: isEmpty empty                         == True
OK: isEmpty (overlay empty empty)         == True
OK: isEmpty (vertex x)                    == False
OK: isEmpty (removeVertex x $ vertex x)   == True
OK: isEmpty (removeEdge x y $ edge e x y) == False

============ Labelled.Graph.size ============
OK: size empty         == 1
OK: size (vertex x)    == 1
OK: size (overlay x y) == size x + size y
OK: size (connect x y) == size x + size y
OK: size x             >= 1
OK: size x             >= vertexCount x

============ Labelled.Graph.hasVertex ============
OK: hasVertex x empty            == False
OK: hasVertex x (vertex y)       == (x == y)
OK: hasVertex x . removeVertex x == const False

============ Labelled.Graph.hasEdge ============
OK: hasEdge x y empty            == False
OK: hasEdge x y (vertex z)       == False
OK: hasEdge x y (edge e x y)     == (e /= zero)
OK: hasEdge x y . removeEdge x y == const False
OK: hasEdge x y                  == not . null . filter (\(_,ex,ey) -> ex == x && ey == y) . edgeList

============ Labelled.Graph.edgeLabel ============
OK: edgeLabel x y empty         == zero
OK: edgeLabel x y (vertex z)    == zero
OK: edgeLabel x y (edge e x y)  == e
OK: edgeLabel s t (overlay x y) == edgeLabel s t x + edgeLabel s t y

============ Labelled.Graph.vertexCount ============
OK: vertexCount empty             ==  0
OK: vertexCount (vertex x)        ==  1
OK: vertexCount                   ==  length . vertexList
OK: vertexCount x < vertexCount y ==> x < y

============ Labelled.Graph.edgeCount ============
OK: edgeCount empty        == 0
OK: edgeCount (vertex x)   == 0
OK: edgeCount (edge e x y) == if e == zero then 0 else 1
OK: edgeCount              == length . edgeList

============ Labelled.Graph.vertexList ============
OK: vertexList empty      == []
OK: vertexList (vertex x) == [x]
OK: vertexList . vertices == nub . sort

============ Labelled.Graph.edgeList ============
OK: edgeList empty        == []
OK: edgeList (vertex x)   == []
OK: edgeList (edge e x y) == if e == zero then [] else [(e,x,y)]

============ Labelled.Graph.vertexSet ============
OK: vertexSet empty      == Set.empty
OK: vertexSet . vertex   == Set.singleton
OK: vertexSet . vertices == Set.fromList

============ Labelled.Graph.edgeSet ============
OK: edgeSet empty        == Set.empty
OK: edgeSet (vertex x)   == Set.empty
OK: edgeSet (edge e x y) == if e == zero then Set.empty else Set.singleton (e,x,y)

============ Labelled.Graph.preSet ============
OK: preSet x empty        == Set.empty
OK: preSet x (vertex x)   == Set.empty
OK: preSet 1 (edge e 1 2) == Set.empty
OK: preSet y (edge e x y) == if e == zero then Set.empty else Set.fromList [x]

============ Labelled.Graph.postSet ============
OK: postSet x empty        == Set.empty
OK: postSet x (vertex x)   == Set.empty
OK: postSet x (edge e x y) == if e == zero then Set.empty else Set.fromList [y]
OK: postSet 2 (edge e 1 2) == Set.empty

============ Labelled.Graph.removeVertex ============
OK: removeVertex x (vertex x)       == empty
OK: removeVertex 1 (vertex 2)       == vertex 2
OK: removeVertex x (edge e x x)     == empty
OK: removeVertex 1 (edge e 1 2)     == vertex 2
OK: removeVertex x . removeVertex x == removeVertex x

============ Labelled.Graph.removeEdge ============
OK: removeEdge x y (edge e x y)     == vertices [x,y]
OK: removeEdge x y . removeEdge x y == removeEdge x y
OK: removeEdge x y . removeVertex x == removeVertex x
OK: removeEdge 1 1 (1 * 1 * 2 * 2)  == 1 * 2 * 2
OK: removeEdge 1 2 (1 * 1 * 2 * 2)  == 1 * 1 + 2 * 2

============ Labelled.Graph.replaceVertex ============
OK: replaceVertex x x            == id
OK: replaceVertex x y (vertex x) == vertex y
OK: replaceVertex x y            == fmap (\v -> if v == x then y else v)

============ Labelled.Graph.replaceEdge ============
OK: replaceEdge e x y z                 == overlay (removeEdge x y z) (edge e x y)
OK: replaceEdge e x y (edge f x y)      == edge e x y
OK: edgeLabel x y (replaceEdge e x y z) == e

============ Labelled.Graph.transpose ============
OK: transpose empty        == empty
OK: transpose (vertex x)   == vertex x
OK: transpose (edge e x y) == edge e y x
OK: transpose . transpose == id

============ Labelled.Graph.fmap ============
OK: fmap f empty        == empty
OK: fmap f (vertex x)   == vertex (f x)
OK: fmap f (edge e x y) == edge e (f x) (f y)
OK: fmap id             == id
OK: fmap f . fmap g     == fmap (f . g)

============ Labelled.Graph.emap ============
OK: emap h empty           == empty
OK: emap h (vertex x)      == vertex x
OK: emap h (edge e x y)    == edge (h e) x y
OK: emap h (overlay x y)   == overlay (emap h x) (emap h y)
OK: emap h (connect e x y) == connect (h e) (emap h x) (emap h y)
OK: emap id                == id
OK: emap g . emap h        == emap (g . h)

============ Labelled.Graph.induce ============
OK: induce (const True ) x      == x
OK: induce (const False) x      == empty
OK: induce (/= x)               == removeVertex x
OK: induce p . induce q         == induce (\x -> p x && q x)
OK: isSubgraphOf (induce p x) x == True

============ Labelled.Graph.induceJust ============
OK: induceJust (vertex Nothing)                               == empty
OK: induceJust (edge (Just x) Nothing)                        == vertex x
OK: induceJust . gmap Just                                    == id
OK: induceJust . gmap (\x -> if p x then Just x else Nothing) == induce p

============ Labelled.Graph.closure ============
OK: closure empty         == empty
OK: closure (vertex x)    == edge one x x
OK: closure (edge e x x)  == edge one x x
OK: closure (edge e x y)  == edges [(one,x,x), (e,x,y), (one,y,y)]
OK: closure               == reflexiveClosure . transitiveClosure
OK: closure               == transitiveClosure . reflexiveClosure
OK: closure . closure     == closure
OK: postSet x (closure y) == Set.fromList (reachable y x)

============ Labelled.Graph.reflexiveClosure ============
OK: reflexiveClosure empty              == empty
OK: reflexiveClosure (vertex x)         == edge one x x
OK: reflexiveClosure (edge e x x)       == edge one x x
OK: reflexiveClosure (edge e x y)       == edges [(one,x,x), (e,x,y), (one,y,y)]
OK: reflexiveClosure . reflexiveClosure == reflexiveClosure

============ Labelled.Graph.symmetricClosure ============
OK: symmetricClosure empty              == empty
OK: symmetricClosure (vertex x)         == vertex x
OK: symmetricClosure (edge e x y)       == edges [(e,x,y), (e,y,x)]
OK: symmetricClosure x                  == overlay x (transpose x)
OK: symmetricClosure . symmetricClosure == symmetricClosure

============ Labelled.Graph.transitiveClosure ============
OK: transitiveClosure empty               == empty
OK: transitiveClosure (vertex x)          == vertex x
OK: transitiveClosure (edge e x y)        == edge e x y
OK: transitiveClosure . transitiveClosure == transitiveClosure

============ Labelled.Graph.context ============
OK: context (const False) x                   == Nothing
OK: context (== 1)        (edge e 1 2)        == if e == zero then Just (Context [] []) else Just (Context []      [(e,2)])
OK: context (== 2)        (edge e 1 2)        == if e == zero then Just (Context [] []) else Just (Context [(e,1)] []     )
OK: context (const True ) (edge e 1 2)        == if e == zero then Just (Context [] []) else Just (Context [(e,1)] [(e,2)])
OK: context (== 4)        (3 * 1 * 4 * 1 * 5) == Just (Context [(one,3), (one,1)] [(one,1), (one,5)])

============ NonEmpty.AdjacencyMap ============
OK: Axioms of non-empty graphs
OK: Theorems of non-empty graphs

============ Ord (NonEmpty.AdjacencyMap a) ============
OK: vertex 1 <  vertex 2
OK: vertex 3 <  edge 1 2
OK: vertex 1 <  edge 1 1
OK: edge 1 1 <  edge 1 2
OK: edge 1 2 <  edge 1 1 + edge 2 2
OK: edge 1 2 <  edge 1 3
OK: x        <= x + y
OK: x + y    <= x * y

============ Show (NonEmpty.AdjacencyMap a) ============
OK: show (1         :: AdjacencyMap Int) == "vertex 1"
OK: show (1 + 2     :: AdjacencyMap Int) == "vertices1 [1,2]"
OK: show (1 * 2     :: AdjacencyMap Int) == "edge 1 2"
OK: show (1 * 2 * 3 :: AdjacencyMap Int) == "edges1 [(1,2),(1,3),(2,3)]"
OK: show (1 * 2 + 3 :: AdjacencyMap Int) == "overlay (vertex 3) (edge 1 2)"
OK: show (vertex (-1)                             :: AdjacencyMap Int) == "vertex (-1)"
OK: show (vertex (-1) + vertex (-2)               :: AdjacencyMap Int) == "vertices1 [-2,-1]"
OK: show (vertex (-1) * vertex (-2)               :: AdjacencyMap Int) == "edge (-1) (-2)"
OK: show (vertex (-1) * vertex (-2) * vertex (-3) :: AdjacencyMap Int) == "edges1 [(-2,-3),(-1,-3),(-1,-2)]"
OK: show (vertex (-1) * vertex (-2) + vertex (-3) :: AdjacencyMap Int) == "overlay (vertex (-3)) (edge (-1) (-2))"

============ NonEmpty.AdjacencyMap.toNonEmpty ============
OK: toNonEmpty empty          == Nothing
OK: toNonEmpty . fromNonEmpty == Just

============ NonEmpty.AdjacencyMap.fromNonEmpty ============
OK: isEmpty . fromNonEmpty    == const False

============ NonEmpty.AdjacencyMap.vertex ============
OK: hasVertex x (vertex y) == (x == y)
OK: vertexCount (vertex x) == 1
OK: edgeCount   (vertex x) == 0

============ NonEmpty.AdjacencyMap.edge ============
OK: edge x y               == connect (vertex x) (vertex y)
OK: hasEdge x y (edge x y) == True
OK: edgeCount   (edge x y) == 1
OK: vertexCount (edge 1 1) == 1
OK: vertexCount (edge 1 2) == 2

============ NonEmpty.AdjacencyMap.overlay ============
OK: hasVertex z (overlay x y) == hasVertex z x || hasVertex z y
OK: vertexCount (overlay x y) >= vertexCount x
OK: vertexCount (overlay x y) <= vertexCount x + vertexCount y
OK: edgeCount   (overlay x y) >= edgeCount x
OK: edgeCount   (overlay x y) <= edgeCount x   + edgeCount y
OK: vertexCount (overlay 1 2) == 2
OK: edgeCount   (overlay 1 2) == 0

============ NonEmpty.AdjacencyMap.connect ============
OK: hasVertex z (connect x y) == hasVertex z x || hasVertex z y
OK: vertexCount (connect x y) >= vertexCount x
OK: vertexCount (connect x y) <= vertexCount x + vertexCount y
OK: edgeCount   (connect x y) >= edgeCount x
OK: edgeCount   (connect x y) >= edgeCount y
OK: edgeCount   (connect x y) >= vertexCount x * vertexCount y
OK: edgeCount   (connect x y) <= vertexCount x * vertexCount y + edgeCount x + edgeCount y
OK: vertexCount (connect 1 2) == 2
OK: edgeCount   (connect 1 2) == 1

============ NonEmpty.AdjacencyMap.vertices1 ============
OK: vertices1 [x]           == vertex x
OK: hasVertex x . vertices1 == elem x
OK: vertexCount . vertices1 == length . nub
OK: vertexSet   . vertices1 == Set.fromList . toList

============ NonEmpty.AdjacencyMap.edges1 ============
OK: edges1 [(x,y)]     == edge x y
OK: edges1             == overlays1 . fmap (uncurry edge)
OK: edgeCount . edges1 == length . nub

============ NonEmpty.AdjacencyMap.overlays1 ============
OK: overlays1 [x]   == x
OK: overlays1 [x,y] == overlay x y

============ NonEmpty.AdjacencyMap.connects1 ============
OK: connects1 [x]   == x
OK: connects1 [x,y] == connect x y

============ NonEmpty.AdjacencyMap.isSubgraphOf ============
OK: isSubgraphOf x             (overlay x y) ==  True
OK: isSubgraphOf (overlay x y) (connect x y) ==  True
OK: isSubgraphOf (path1 xs)    (circuit1 xs) ==  True
OK: isSubgraphOf x y                         ==> x <= y

============ NonEmpty.AdjacencyMap.hasVertex ============
OK: hasVertex x (vertex y) == (x == y)

============ NonEmpty.AdjacencyMap.hasEdge ============
OK: hasEdge x y (vertex z)       == False
OK: hasEdge x y (edge x y)       == True
OK: hasEdge x y . removeEdge x y == const False
OK: hasEdge x y                  == elem (x,y) . edgeList

============ NonEmpty.AdjacencyMap.vertexCount ============
OK: vertexCount (vertex x) == 1
OK: vertexCount x          >= 1
OK: vertexCount            == length . vertexList1

============ NonEmpty.AdjacencyMap.edgeCount ============
OK: edgeCount (vertex x) == 0
OK: edgeCount (edge x y) == 1
OK: edgeCount            == length . edgeList

============ NonEmpty.AdjacencyMap.vertexList1 ============
OK: vertexList1 (vertex x)  == [x]
OK: vertexList1 . vertices1 == nub . sort

============ NonEmpty.AdjacencyMap.edgeList ============
OK: edgeList (vertex x)     == []
OK: edgeList (edge x y)     == [(x,y)]
OK: edgeList (star 2 [3,1]) == [(2,1), (2,3)]
OK: edgeList . edges1       == nub . sort . toList
OK: edgeList . transpose    == sort . map swap . edgeList

============ NonEmpty.AdjacencyMap.vertexSet ============
OK: vertexSet . vertex    == Set.singleton
OK: vertexSet . vertices1 == Set.fromList . toList
OK: vertexSet . clique1   == Set.fromList . toList

============ NonEmpty.AdjacencyMap.edgeSet ============
OK: edgeSet (vertex x) == Set.empty
OK: edgeSet (edge x y) == Set.singleton (x,y)
OK: edgeSet . edges1   == Set.fromList . toList

============ NonEmpty.AdjacencyMap.preSet ============
OK: preSet x (vertex x) == Set.empty
OK: preSet 1 (edge 1 2) == Set.empty
OK: preSet y (edge x y) == Set.fromList [x]

============ NonEmpty.AdjacencyMap.postSet ============
OK: postSet x (vertex x) == Set.empty
OK: postSet x (edge x y) == Set.fromList [y]
OK: postSet 2 (edge 1 2) == Set.empty

============ NonEmpty.AdjacencyMap.path1 ============
OK: path1 [x]       == vertex x
OK: path1 [x,y]     == edge x y
OK: path1 . reverse == transpose . path1

============ NonEmpty.AdjacencyMap.circuit1 ============
OK: circuit1 [x]       == edge x x
OK: circuit1 [x,y]     == edges1 [(x,y), (y,x)]
OK: circuit1 . reverse == transpose . circuit1

============ NonEmpty.AdjacencyMap.clique1 ============
OK: clique1 [x]        == vertex x
OK: clique1 [x,y]      == edge x y
OK: clique1 [x,y,z]    == edges1 [(x,y), (x,z), (y,z)]
OK: clique1 (xs <> ys) == connect (clique1 xs) (clique1 ys)
OK: clique1 . reverse  == transpose . clique1

============ NonEmpty.AdjacencyMap.biclique1 ============
OK: biclique1 [x1,x2] [y1,y2] == edges1 [(x1,y1), (x1,y2), (x2,y1), (x2,y2)]
OK: biclique1 xs      ys      == connect (vertices1 xs) (vertices1 ys)

============ NonEmpty.AdjacencyMap.star ============
OK: star x []    == vertex x
OK: star x [y]   == edge x y
OK: star x [y,z] == edges1 [(x,y), (x,z)]

============ NonEmpty.AdjacencyMap.stars1 ============
OK: stars1 [(x, [] )]               == vertex x
OK: stars1 [(x, [y])]               == edge x y
OK: stars1 [(x, ys )]               == star x ys
OK: stars1                          == overlays1 . fmap (uncurry star)
OK: overlay (stars1 xs) (stars1 ys) == stars1 (xs <> ys)

============ NonEmpty.AdjacencyMap.tree ============
OK: tree (Node x [])                                         == vertex x
OK: tree (Node x [Node y [Node z []]])                       == path1 [x,y,z]
OK: tree (Node x [Node y [], Node z []])                     == star x [y,z]
OK: tree (Node 1 [Node 2 [], Node 3 [Node 4 [], Node 5 []]]) == edges1 [(1,2), (1,3), (3,4), (3,5)]

============ NonEmpty.AdjacencyMap.removeVertex1 ============
OK: removeVertex1 x (vertex x)          == Nothing
OK: removeVertex1 1 (vertex 2)          == Just (vertex 2)
OK: removeVertex1 x (edge x x)          == Nothing
OK: removeVertex1 1 (edge 1 2)          == Just (vertex 2)
OK: removeVertex1 x >=> removeVertex1 x == removeVertex1 x

============ NonEmpty.AdjacencyMap.removeEdge ============
OK: removeEdge x y (edge x y)       == vertices1 [x,y]
OK: removeEdge x y . removeEdge x y == removeEdge x y
OK: removeEdge 1 1 (1 * 1 * 2 * 2)  == 1 * 2 * 2
OK: removeEdge 1 2 (1 * 1 * 2 * 2)  == 1 * 1 + 2 * 2

============ NonEmpty.AdjacencyMap.replaceVertex ============
OK: replaceVertex x x            == id
OK: replaceVertex x y (vertex x) == vertex y
OK: replaceVertex x y            == mergeVertices (== x) y

============ NonEmpty.AdjacencyMap.mergeVertices ============
OK: mergeVertices (const False) x    == id
OK: mergeVertices (== x) y           == replaceVertex x y
OK: mergeVertices even 1 (0 * 2)     == 1 * 1
OK: mergeVertices odd  1 (3 + 4 * 5) == 4 * 1

============ NonEmpty.AdjacencyMap.transpose ============
OK: transpose (vertex x)  == vertex x
OK: transpose (edge x y)  == edge y x
OK: transpose . transpose == id
OK: edgeList . transpose  == sort . map swap . edgeList

============ NonEmpty.AdjacencyMap.gmap ============
OK: gmap f (vertex x) == vertex (f x)
OK: gmap f (edge x y) == edge (f x) (f y)
OK: gmap id           == id
OK: gmap f . gmap g   == gmap (f . g)

============ NonEmpty.AdjacencyMap.induce1 ============
OK: induce1 (const True ) x == Just x
OK: induce1 (const False) x == Nothing
OK: induce1 (/= x)          == removeVertex1 x
OK: induce1 p >=> induce1 q == induce1 (\x -> p x && q x)

============ NonEmpty.AdjacencyMap.induceJust1 ============
OK: induceJust1 (vertex Nothing)                               == Nothing
OK: induceJust1 (edge (Just x) Nothing)                        == Just (vertex x)
OK: induceJust1 . gmap Just                                    == Just
OK: induceJust1 . gmap (\x -> if p x then Just x else Nothing) == induce1 p

============ NonEmpty.AdjacencyMap.closure ============
OK: closure (vertex x)      == edge x x
OK: closure (edge x x)      == edge x x
OK: closure (edge x y)      == edges1 [(x,x), (x,y), (y,y)]
OK: closure (path1 $ nub xs) == reflexiveClosure (clique1 $ nub xs)
OK: closure                 == reflexiveClosure . transitiveClosure
OK: closure                 == transitiveClosure . reflexiveClosure
OK: closure . closure       == closure
OK: postSet x (closure y)   == Set.fromList (reachable y x)

============ NonEmpty.AdjacencyMap.reflexiveClosure ============
OK: reflexiveClosure (vertex x)         == edge x x
OK: reflexiveClosure (edge x x)         == edge x x
OK: reflexiveClosure (edge x y)         == edges1 [(x,x), (x,y), (y,y)]
OK: reflexiveClosure . reflexiveClosure == reflexiveClosure

============ NonEmpty.AdjacencyMap.symmetricClosure ============
OK: symmetricClosure (vertex x)         == vertex x
OK: symmetricClosure (edge x y)         == edges1 [(x,y), (y,x)]
OK: symmetricClosure x                  == overlay x (transpose x)
OK: symmetricClosure . symmetricClosure == symmetricClosure

============ NonEmpty.AdjacencyMap.transitiveClosure ============
OK: transitiveClosure (vertex x)          == vertex x
OK: transitiveClosure (edge x y)          == edge x y
OK: transitiveClosure (path1 $ nub xs)    == clique1 (nub $ xs)
OK: transitiveClosure . transitiveClosure == transitiveClosure

============ NonEmpty.Graph.============
OK: Axioms of non-empty graphs
OK: Theorems of non-empty graphs

============ Ord (NonEmpty.Graph a) ============
OK: vertex 1 <  vertex 2
OK: vertex 3 <  edge 1 2
OK: vertex 1 <  edge 1 1
OK: edge 1 1 <  edge 1 2
OK: edge 1 2 <  edge 1 1 + edge 2 2
OK: edge 1 2 <  edge 1 3
OK: x        <= x + y
OK: x + y    <= x * y

============ Functor (NonEmpty.Graph a) ============
OK: fmap f (vertex x) == vertex (f x)
OK: fmap f (edge x y) == edge (f x) (f y)
OK: fmap id           == id
OK: fmap f . fmap g   == fmap (f . g)

============ Monad (NonEmpty.Graph a) ============
OK: (vertex x >>= f)     == f x
OK: (edge x y >>= f)     == connect (f x) (f y)
OK: (vertices1 xs >>= f) == overlays1 (fmap f xs)
OK: (x >>= vertex)       == x
OK: ((x >>= f) >>= g)    == (x >>= (\y -> (f y) >>= g))

============ NonEmpty.Graph.toNonEmpty ============
OK: toNonEmpty empty       == Nothing
OK: toNonEmpty (toGraph x) == Just (x :: NonEmpty.Graph a)

============ NonEmpty.Graph.vertex ============
OK: hasVertex x (vertex y) == (x == y)
OK: vertexCount (vertex x) == 1
OK: edgeCount   (vertex x) == 0
OK: size        (vertex x) == 1

============ NonEmpty.Graph.edge ============
OK: edge x y               == connect (vertex x) (vertex y)
OK: hasEdge x y (edge x y) == True
OK: edgeCount   (edge x y) == 1
OK: vertexCount (edge 1 1) == 1
OK: vertexCount (edge 1 2) == 2

============ NonEmpty.Graph.overlay ============
OK: hasVertex z (overlay x y) == hasVertex z x || hasVertex z y
OK: vertexCount (overlay x y) >= vertexCount x
OK: vertexCount (overlay x y) <= vertexCount x + vertexCount y
OK: edgeCount   (overlay x y) >= edgeCount x
OK: edgeCount   (overlay x y) <= edgeCount x   + edgeCount y
OK: size        (overlay x y) == size x        + size y
OK: vertexCount (overlay 1 2) == 2
OK: edgeCount   (overlay 1 2) == 0

============ NonEmpty.Graph.overlay1 ============
OK:                overlay1 empty x == x
OK: x /= empty ==> overlay1 x     y == overlay (fromJust $ toNonEmpty x) y

============ NonEmpty.Graph.connect ============
OK: hasVertex z (connect x y) == hasVertex z x || hasVertex z y
OK: vertexCount (connect x y) >= vertexCount x
OK: vertexCount (connect x y) <= vertexCount x + vertexCount y
OK: edgeCount   (connect x y) >= edgeCount x
OK: edgeCount   (connect x y) >= edgeCount y
OK: edgeCount   (connect x y) >= vertexCount x * vertexCount y
OK: edgeCount   (connect x y) <= vertexCount x * vertexCount y + edgeCount x + edgeCount y
OK: size        (connect x y) == size x        + size y
OK: vertexCount (connect 1 2) == 2
OK: edgeCount   (connect 1 2) == 1

============ NonEmpty.Graph.vertices1 ============
OK: vertices1 [x]           == vertex x
OK: hasVertex x . vertices1 == elem x
OK: vertexCount . vertices1 == length . nub
OK: vertexSet   . vertices1 == Set.fromList . toList

============ NonEmpty.Graph.edges1 ============
OK: edges1 [(x,y)]     == edge x y
OK: edges1             == overlays1 . fmap (uncurry edge)
OK: edgeCount . edges1 == length . nub

============ NonEmpty.Graph.overlays1 ============
OK: overlays1 [x]   == x
OK: overlays1 [x,y] == overlay x y

============ NonEmpty.Graph.connects1 ============
OK: connects1 [x]   == x
OK: connects1 [x,y] == connect x y

============ NonEmpty.Graph.foldg1 ============
OK: foldg1 vertex    overlay connect        == id
OK: foldg1 vertex    overlay (flip connect) == transpose
OK: foldg1 (const 1) (+)     (+)            == size
OK: foldg1 (== x)    (||)    (||)           == hasVertex x

============ NonEmpty.Graph.isSubgraphOf ============
OK: isSubgraphOf x             (overlay x y) ==  True
OK: isSubgraphOf (overlay x y) (connect x y) ==  True
OK: isSubgraphOf (path1 xs)    (circuit1 xs) ==  True
OK: isSubgraphOf x y                         ==> x <= y

============ NonEmpty.Graph.(===) ============
OK:     x === x     == True
OK: x + y === x + y == True
OK: 1 + 2 === 2 + 1 == False
OK: x + y === x * y == False

============ NonEmpty.Graph.size ============
OK: size (vertex x)    == 1
OK: size (overlay x y) == size x + size y
OK: size (connect x y) == size x + size y
OK: size x             >= 1
OK: size x             >= vertexCount x

============ NonEmpty.Graph.hasVertex ============
OK: hasVertex x (vertex y) == (x == y)

============ NonEmpty.Graph.hasEdge ============
OK: hasEdge x y (vertex z)       == False
OK: hasEdge x y (edge x y)       == True
OK: hasEdge x y . removeEdge x y == const False
OK: hasEdge x y                  == elem (x,y) . edgeList

============ NonEmpty.Graph.vertexCount ============
OK: vertexCount (vertex x) == 1
OK: vertexCount x          >= 1
OK: vertexCount            == length . vertexList1

============ NonEmpty.Graph.edgeCount ============
OK: edgeCount (vertex x) == 0
OK: edgeCount (edge x y) == 1
OK: edgeCount            == length . edgeList

============ NonEmpty.Graph.vertexList1 ============
OK: vertexList1 (vertex x)  == [x]
OK: vertexList1 . vertices1 == nub . sort

============ NonEmpty.Graph.edgeList ============
OK: edgeList (vertex x)     == []
OK: edgeList (edge x y)     == [(x,y)]
OK: edgeList (star 2 [3,1]) == [(2,1), (2,3)]
OK: edgeList . edges1       == nub . sort . toList
OK: edgeList . transpose    == sort . map swap . edgeList

============ NonEmpty.Graph.vertexSet ============
OK: vertexSet . vertex    == Set.singleton
OK: vertexSet . vertices1 == Set.fromList . toList
OK: vertexSet . clique1   == Set.fromList . toList

============ NonEmpty.Graph.edgeSet ============
OK: edgeSet (vertex x) == Set.empty
OK: edgeSet (edge x y) == Set.singleton (x,y)
OK: edgeSet . edges1   == Set.fromList . toList

============ NonEmpty.Graph.path1 ============
OK: path1 [x]       == vertex x
OK: path1 [x,y]     == edge x y
OK: path1 . reverse == transpose . path1

============ NonEmpty.Graph.circuit1 ============
OK: circuit1 [x]       == edge x x
OK: circuit1 [x,y]     == edges1 [(x,y), (y,x)]
OK: circuit1 . reverse == transpose . circuit1

============ NonEmpty.Graph.clique1 ============
OK: clique1 [x]        == vertex x
OK: clique1 [x,y]      == edge x y
OK: clique1 [x,y,z]    == edges1 [(x,y), (x,z), (y,z)]
OK: clique1 (xs <> ys) == connect (clique1 xs) (clique1 ys)
OK: clique1 . reverse  == transpose . clique1

============ NonEmpty.Graph.biclique1 ============
OK: biclique1 [x1,x2] [y1,y2] == edges1 [(x1,y1), (x1,y2), (x2,y1), (x2,y2)]
OK: biclique1 xs      ys      == connect (vertices1 xs) (vertices1 ys)

============ NonEmpty.Graph.star ============
OK: star x []    == vertex x
OK: star x [y]   == edge x y
OK: star x [y,z] == edges1 [(x,y), (x,z)]

============ NonEmpty.Graph.stars1 ============
OK: stars1 [(x, [] )]               == vertex x
OK: stars1 [(x, [y])]               == edge x y
OK: stars1 [(x, ys )]               == star x ys
OK: stars1                          == overlays1 . fmap (uncurry star)
OK: overlay (stars1 xs) (stars1 ys) == stars1 (xs <> ys)

============ NonEmpty.Graph.tree ============
OK: tree (Node x [])                                         == vertex x
OK: tree (Node x [Node y [Node z []]])                       == path1 [x,y,z]
OK: tree (Node x [Node y [], Node z []])                     == star x [y,z]
OK: tree (Node 1 [Node 2 [], Node 3 [Node 4 [], Node 5 []]]) == edges1 [(1,2), (1,3), (3,4), (3,5)]

============ NonEmpty.Graph.mesh1 ============
OK: mesh1 [x]     [y]        == vertex (x, y)
OK: mesh1 xs      ys         == box (path1 xs) (path1 ys)
OK: mesh1 [1,2,3] ['a', 'b'] == <correct result>
OK: size (mesh xs ys)        == max 1 (3 * length xs * length ys - length xs - length ys -1)

============ NonEmpty.Graph.torus1 ============
OK: torus1 [x]   [y]        == edge (x,y) (x,y)
OK: torus1 xs    ys         == box (circuit1 xs) (circuit1 ys)
OK: torus1 [1,2] ['a', 'b'] == <correct result>
OK: size (torus1 xs ys)     == max 1 (3 * length xs * length ys)

============ NonEmpty.Graph.removeVertex1 ============
OK: removeVertex1 x (vertex x)          == Nothing
OK: removeVertex1 1 (vertex 2)          == Just (vertex 2)
OK: removeVertex1 x (edge x x)          == Nothing
OK: removeVertex1 1 (edge 1 2)          == Just (vertex 2)
OK: removeVertex1 x >=> removeVertex1 x == removeVertex1 x

============ NonEmpty.Graph.removeEdge ============
OK: removeEdge x y (edge x y)       == vertices1 [x,y]
OK: removeEdge x y . removeEdge x y == removeEdge x y
OK: removeEdge 1 1 (1 * 1 * 2 * 2)  == 1 * 2 * 2
OK: removeEdge 1 2 (1 * 1 * 2 * 2)  == 1 * 1 + 2 * 2
OK: size (removeEdge x y z)         <= 3 * size z

============ NonEmpty.Graph.replaceVertex ============
OK: replaceVertex x x            == id
OK: replaceVertex x y (vertex x) == vertex y
OK: replaceVertex x y            == mergeVertices (== x) y

============ NonEmpty.Graph.mergeVertices ============
OK: mergeVertices (const False) x    == id
OK: mergeVertices (== x) y           == replaceVertex x y
OK: mergeVertices even 1 (0 * 2)     == 1 * 1
OK: mergeVertices odd  1 (3 + 4 * 5) == 4 * 1

============ NonEmpty.Graph.splitVertex1 ============
OK: splitVertex1 x [x]                 == id
OK: splitVertex1 x [y]                 == replaceVertex x y
OK: splitVertex1 1 [0,1] $ 1 * (2 + 3) == (0 + 1) * (2 + 3)

============ NonEmpty.Graph.transpose ============
OK: transpose (vertex x)  == vertex x
OK: transpose (edge x y)  == edge y x
OK: transpose . transpose == id
OK: transpose (box x y)   == box (transpose x) (transpose y)
OK: edgeList . transpose  == sort . map swap . edgeList

============ NonEmpty.Graph.induce1 ============
OK: induce1 (const True ) x == Just x
OK: induce1 (const False) x == Nothing
OK: induce1 (/= x)          == removeVertex1 x
OK: induce1 p >=> induce1 q == induce1 (\x -> p x && q x)

============ NonEmpty.Graph.induceJust1 ============
OK: induceJust1 (vertex Nothing)                               == Nothing
OK: induceJust1 (edge (Just x) Nothing)                        == Just (vertex x)
OK: induceJust1 . fmap Just                                    == Just
OK: induceJust1 . fmap (\x -> if p x then Just x else Nothing) == induce1 p

============ NonEmpty.Graph.simplify ============
OK: simplify             ==  id
OK: size (simplify x)    <=  size x
OK: simplify 1           === 1
OK: simplify (1 + 1)     === 1
OK: simplify (1 + 2 + 1) === 1 + 2
OK: simplify (1 * 1 * 1) === 1 * 1

============ NonEmpty.Graph.sparsify ============
OK: sort . reachable x       == sort . rights . reachable (sparsify x) . Right
OK: vertexCount (sparsify x) <= vertexCount x + size x + 1
OK: edgeCount   (sparsify x) <= 3 * size x
OK: size        (sparsify x) <= 3 * size x

============ NonEmpty.Graph.sparsifyKL ============
OK: sort . reachable x                 == sort . filter (<= n) . reachable (sparsifyKL n x)
OK: length (vertices $ sparsifyKL n x) <= vertexCount x + size x + 1
OK: length (edges    $ sparsifyKL n x) <= 3 * size x

============ NonEmpty.Graph.box ============
OK: box (path1 [0,1]) (path1 ['a','b']) == <correct result>
OK: box x y                             ~~ box y x
OK: box x (overlay y z)                 == overlay (box x y) (box x z)
OK: box x (vertex ())                   ~~ x
OK: box x (box y z)                     ~~ box (box x y) z
OK: transpose   (box x y)               == box (transpose x) (transpose y)
OK: vertexCount (box x y)               == vertexCount x * vertexCount y
OK: edgeCount   (box x y)               <= vertexCount x * edgeCount y + edgeCount x * vertexCount y

============ Relation ============
OK: Axioms of graphs

============ Relation.consistent ============
OK: Consistency of the Arbitrary instance

OK: consistent empty         == True
OK: consistent (vertex x)    == True
OK: consistent (overlay x y) == True
OK: consistent (connect x y) == True
OK: consistent (edge x y)    == True
OK: consistent (edges xs)    == True
OK: consistent (stars xs)    == True

============ Relation.Show ============
OK: show (empty    ) == "empty"
OK: show (1        ) == "vertex 1"
OK: show (1 + 2    ) == "vertices [1,2]"
OK: show (1 * 2    ) == "edge 1 2"
OK: show (1 * 2 * 3) == "edges [(1,2),(1,3),(2,3)]"
OK: show (1 * 2 + 3) == "overlay (vertex 3) (edge 1 2)"

OK: show (vertex (-1)                            ) == "vertex (-1)"
OK: show (vertex (-1) + vertex (-2)              ) == "vertices [-2,-1]"
OK: show (vertex (-2) * vertex (-1)              ) == "edge (-2) (-1)"
OK: show (vertex (-3) * vertex (-2) * vertex (-1)) == "edges [(-3,-2),(-3,-1),(-2,-1)]"
OK: show (vertex (-3) * vertex (-2) + vertex (-1)) == "overlay (vertex (-1)) (edge (-3) (-2))"

============ Relation.Ord ============
OK: vertex 1 <  vertex 2
OK: vertex 3 <  edge 1 2
OK: vertex 1 <  edge 1 1
OK: edge 1 1 <  edge 1 2
OK: edge 1 2 <  edge 1 1 + edge 2 2
OK: edge 1 2 <  edge 1 3
OK: x        <= x + y
OK: x + y    <= x * y

============ Relation.empty ============
OK: isEmpty     empty == True
OK: hasVertex x empty == False
OK: vertexCount empty == 0
OK: edgeCount   empty == 0

============ Relation.vertex ============
OK: isEmpty     (vertex x) == False
OK: hasVertex x (vertex y) == (x == y)
OK: vertexCount (vertex x) == 1
OK: edgeCount   (vertex x) == 0

============ Relation.edge ============
OK: edge x y               == connect (vertex x) (vertex y)
OK: hasEdge x y (edge x y) == True
OK: edgeCount   (edge x y) == 1
OK: vertexCount (edge 1 1) == 1
OK: vertexCount (edge 1 2) == 2

============ Relation.overlay ============
OK: isEmpty     (overlay x y) == isEmpty   x   && isEmpty   y
OK: hasVertex z (overlay x y) == hasVertex z x || hasVertex z y
OK: vertexCount (overlay x y) >= vertexCount x
OK: vertexCount (overlay x y) <= vertexCount x + vertexCount y
OK: edgeCount   (overlay x y) >= edgeCount x
OK: edgeCount   (overlay x y) <= edgeCount x   + edgeCount y
OK: vertexCount (overlay 1 2) == 2
OK: edgeCount   (overlay 1 2) == 0

============ Relation.connect ============
OK: isEmpty     (connect x y) == isEmpty   x   && isEmpty   y
OK: hasVertex z (connect x y) == hasVertex z x || hasVertex z y
OK: vertexCount (connect x y) >= vertexCount x
OK: vertexCount (connect x y) <= vertexCount x + vertexCount y
OK: edgeCount   (connect x y) >= edgeCount x
OK: edgeCount   (connect x y) >= edgeCount y
OK: edgeCount   (connect x y) >= vertexCount x * vertexCount y
OK: edgeCount   (connect x y) <= vertexCount x * vertexCount y + edgeCount x + edgeCount y
OK: vertexCount (connect 1 2) == 2
OK: edgeCount   (connect 1 2) == 1

============ Relation.vertices ============
OK: vertices []            == empty
OK: vertices [x]           == vertex x
OK: vertices               == overlays . map vertex
OK: hasVertex x . vertices == elem x
OK: vertexCount . vertices == length . nub
OK: vertexSet   . vertices == Set.fromList

============ Relation.edges ============
OK: edges []          == empty
OK: edges [(x,y)]     == edge x y
OK: edges             == overlays . map (uncurry edge)
OK: edgeCount . edges == length . nub

============ Relation.overlays ============
OK: overlays []        == empty
OK: overlays [x]       == x
OK: overlays [x,y]     == overlay x y
OK: overlays           == foldr overlay empty
OK: isEmpty . overlays == all isEmpty

============ Relation.connects ============
OK: connects []        == empty
OK: connects [x]       == x
OK: connects [x,y]     == connect x y
OK: connects           == foldr connect empty
OK: isEmpty . connects == all isEmpty

============ Relation.isSubgraphOf ============
OK: isSubgraphOf empty         x             ==  True
OK: isSubgraphOf (vertex x)    empty         ==  False
OK: isSubgraphOf x             (overlay x y) ==  True
OK: isSubgraphOf (overlay x y) (connect x y) ==  True
OK: isSubgraphOf (path xs)     (circuit xs)  ==  True
OK: isSubgraphOf x y                         ==> x <= y

============ Relation.toGraph et al. ============
OK: toGraph                    == foldg Empty Vertex Overlay Connect
OK: foldg                      == Algebra.Graph.foldg . toGraph
OK: isEmpty                    == foldg True (const False) (&&) (&&)
OK: size                       == foldg 1 (const 1) (+) (+)
OK: hasVertex x                == foldg False (==x) (||) (||)
OK: hasEdge x y                == Algebra.Graph.hasEdge x y . toGraph
OK: vertexCount                == Set.size . vertexSet
OK: edgeCount                  == Set.size . edgeSet
OK: vertexList                 == Set.toAscList . vertexSet
OK: edgeList                   == Set.toAscList . edgeSet
OK: vertexSet                  == foldg Set.empty Set.singleton Set.union Set.union
OK: vertexIntSet               == foldg IntSet.empty IntSet.singleton IntSet.union IntSet.union
OK: edgeSet                    == Algebra.Graph.AdjacencyMap.edgeSet . foldg empty vertex overlay connect
OK: preSet x                   == Algebra.Graph.AdjacencyMap.preSet x . toAdjacencyMap
OK: preIntSet x                == Algebra.Graph.AdjacencyIntMap.preIntSet x . toAdjacencyIntMap
OK: postSet x                  == Algebra.Graph.AdjacencyMap.postSet x . toAdjacencyMap
OK: postIntSet x               == Algebra.Graph.AdjacencyIntMap.postIntSet x . toAdjacencyIntMap
OK: adjacencyList              == Algebra.Graph.AdjacencyMap.adjacencyList . toAdjacencyMap
OK: adjacencyMap               == Algebra.Graph.AdjacencyMap.adjacencyMap . toAdjacencyMap
OK: adjacencyIntMap            == Algebra.Graph.AdjacencyIntMap.adjacencyIntMap . toAdjacencyIntMap
OK: adjacencyMapTranspose      == Algebra.Graph.AdjacencyMap.adjacencyMap . toAdjacencyMapTranspose
OK: adjacencyIntMapTranspose   == Algebra.Graph.AdjacencyIntMap.adjacencyIntMap . toAdjacencyIntMapTranspose
OK: dfsForest                  == Algebra.Graph.AdjacencyMap.dfsForest . toAdjacencyMap
OK: dfsForestFrom              == Algebra.Graph.AdjacencyMap.dfsForestFrom . toAdjacencyMap
OK: dfs                        == Algebra.Graph.AdjacencyMap.dfs . toAdjacencyMap
OK: reachable                  == Algebra.Graph.AdjacencyMap.reachable . toAdjacencyMap
OK: topSort                    == Algebra.Graph.AdjacencyMap.topSort . toAdjacencyMap
OK: isAcyclic                  == Algebra.Graph.AdjacencyMap.isAcyclic . toAdjacencyMap
OK: isTopSortOf vs             == Algebra.Graph.AdjacencyMap.isTopSortOf vs . toAdjacencyMap
OK: toAdjacencyMap             == foldg empty vertex overlay connect
OK: toAdjacencyMapTranspose    == foldg empty vertex overlay (flip connect)
OK: toAdjacencyIntMap          == foldg empty vertex overlay connect
OK: toAdjacencyIntMapTranspose == foldg empty vertex overlay (flip connect)
OK: isDfsForestOf f            == Algebra.Graph.AdjacencyMap.isDfsForestOf f . toAdjacencyMap
OK: isTopSortOf vs             == Algebra.Graph.AdjacencyMap.isTopSortOf vs . toAdjacencyMap

============ Relation.foldg ============
OK: foldg empty vertex        overlay connect        == id
OK: foldg empty vertex        overlay (flip connect) == transpose
OK: foldg 1     (const 1)     (+)     (+)            == size
OK: foldg True  (const False) (&&)    (&&)           == isEmpty

============ Relation.isEmpty ============
OK: isEmpty empty                       == True
OK: isEmpty (overlay empty empty)       == True
OK: isEmpty (vertex x)                  == False
OK: isEmpty (removeVertex x $ vertex x) == True
OK: isEmpty (removeEdge x y $ edge x y) == False

============ Relation.hasVertex ============
OK: hasVertex x empty            == False
OK: hasVertex x (vertex y)       == (x == y)
OK: hasVertex x . removeVertex x == const False

============ Relation.hasEdge ============
OK: hasEdge x y empty            == False
OK: hasEdge x y (vertex z)       == False
OK: hasEdge x y (edge x y)       == True
OK: hasEdge x y . removeEdge x y == const False
OK: hasEdge x y                  == elem (x,y) . edgeList

============ Relation.vertexCount ============
OK: vertexCount empty             ==  0
OK: vertexCount (vertex x)        ==  1
OK: vertexCount                   ==  length . vertexList
OK: vertexCount x < vertexCount y ==> x < y

============ Relation.edgeCount ============
OK: edgeCount empty      == 0
OK: edgeCount (vertex x) == 0
OK: edgeCount (edge x y) == 1
OK: edgeCount            == length . edgeList

============ Relation.vertexList ============
OK: vertexList empty      == []
OK: vertexList (vertex x) == [x]
OK: vertexList . vertices == nub . sort

============ Relation.vertexSet ============
OK: vertexSet empty      == Set.empty
OK: vertexSet . vertex   == Set.singleton
OK: vertexSet . vertices == Set.fromList

============ Relation.vertexIntSet ============
OK: vertexIntSet empty      == IntSet.empty
OK: vertexIntSet . vertex   == IntSet.singleton
OK: vertexIntSet . vertices == IntSet.fromList
OK: vertexIntSet . clique   == IntSet.fromList

============ Relation.edgeList ============
OK: edgeList empty          == []
OK: edgeList (vertex x)     == []
OK: edgeList (edge x y)     == [(x,y)]
OK: edgeList (star 2 [3,1]) == [(2,1), (2,3)]
OK: edgeList . edges        == nub . sort

============ Relation.edgeSet ============
OK: edgeSet empty      == Set.empty
OK: edgeSet (vertex x) == Set.empty
OK: edgeSet (edge x y) == Set.singleton (x,y)
OK: edgeSet . edges    == Set.fromList

============ Relation.adjacencyList ============
OK: adjacencyList empty          == []
OK: adjacencyList (vertex x)     == [(x, [])]
OK: adjacencyList (edge 1 2)     == [(1, [2]), (2, [])]
OK: adjacencyList (star 2 [3,1]) == [(1, []), (2, [1,3]), (3, [])]

============ Relation.preSet ============
OK: preSet x empty      == Set.empty
OK: preSet x (vertex x) == Set.empty
OK: preSet 1 (edge 1 2) == Set.empty
OK: preSet y (edge x y) == Set.fromList [x]

============ Relation.preIntSet ============
OK: preIntSet x empty      == IntSet.empty
OK: preIntSet x (vertex x) == IntSet.empty
OK: preIntSet 1 (edge 1 2) == IntSet.empty
OK: preIntSet y (edge x y) == IntSet.fromList [x]

============ Relation.postSet ============
OK: postSet x empty      == Set.empty
OK: postSet x (vertex x) == Set.empty
OK: postSet x (edge x y) == Set.fromList [y]
OK: postSet 2 (edge 1 2) == Set.empty

============ Relation.postIntSet ============
OK: postIntSet x empty      == IntSet.empty
OK: postIntSet x (vertex x) == IntSet.empty
OK: postIntSet 2 (edge 1 2) == IntSet.empty
OK: postIntSet x (edge x y) == IntSet.fromList [y]

============ Relation.path ============
OK: path []    == empty
OK: path [x]   == vertex x
OK: path [x,y] == edge x y

============ Relation.circuit ============
OK: circuit []    == empty
OK: circuit [x]   == edge x x
OK: circuit [x,y] == edges [(x,y), (y,x)]

============ Relation.clique ============
OK: clique []         == empty
OK: clique [x]        == vertex x
OK: clique [x,y]      == edge x y
OK: clique [x,y,z]    == edges [(x,y), (x,z), (y,z)]
OK: clique (xs ++ ys) == connect (clique xs) (clique ys)

============ Relation.biclique ============
OK: biclique []      []      == empty
OK: biclique [x]     []      == vertex x
OK: biclique []      [y]     == vertex y
OK: biclique [x1,x2] [y1,y2] == edges [(x1,y1), (x1,y2), (x2,y1), (x2,y2)]
OK: biclique xs      ys      == connect (vertices xs) (vertices ys)

============ Relation.star ============
OK: star x []    == vertex x
OK: star x [y]   == edge x y
OK: star x [y,z] == edges [(x,y), (x,z)]
OK: star x ys    == connect (vertex x) (vertices ys)

============ Relation.stars ============
OK: stars []                      == empty
OK: stars [(x, [])]               == vertex x
OK: stars [(x, [y])]              == edge x y
OK: stars [(x, ys)]               == star x ys
OK: stars                         == overlays . map (uncurry star)
OK: stars . adjacencyList         == id
OK: overlay (stars xs) (stars ys) == stars (xs ++ ys)

============ Relation.tree ============
OK: tree (Node x [])                                         == vertex x
OK: tree (Node x [Node y [Node z []]])                       == path [x,y,z]
OK: tree (Node x [Node y [], Node z []])                     == star x [y,z]
OK: tree (Node 1 [Node 2 [], Node 3 [Node 4 [], Node 5 []]]) == edges [(1,2), (1,3), (3,4), (3,5)]

============ Relation.forest ============
OK: forest []                                                  == empty
OK: forest [x]                                                 == tree x
OK: forest [Node 1 [Node 2 [], Node 3 []], Node 4 [Node 5 []]] == edges [(1,2), (1,3), (4,5)]
OK: forest                                                     == overlays . map tree

============ Relation.removeVertex ============
OK: removeVertex x (vertex x)       == empty
OK: removeVertex 1 (vertex 2)       == vertex 2
OK: removeVertex x (edge x x)       == empty
OK: removeVertex 1 (edge 1 2)       == vertex 2
OK: removeVertex x . removeVertex x == removeVertex x

============ Relation.removeEdge ============
OK: removeEdge x y (edge x y)       == vertices [x,y]
OK: removeEdge x y . removeEdge x y == removeEdge x y
OK: removeEdge x y . removeVertex x == removeVertex x
OK: removeEdge 1 1 (1 * 1 * 2 * 2)  == 1 * 2 * 2
OK: removeEdge 1 2 (1 * 1 * 2 * 2)  == 1 * 1 + 2 * 2

============ Relation.replaceVertex ============
OK: replaceVertex x x            == id
OK: replaceVertex x y (vertex x) == vertex y
OK: replaceVertex x y            == mergeVertices (== x) y

============ Relation.mergeVertices ============
OK: mergeVertices (const False) x    == id
OK: mergeVertices (== x) y           == replaceVertex x y
OK: mergeVertices even 1 (0 * 2)     == 1 * 1
OK: mergeVertices odd  1 (3 + 4 * 5) == 4 * 1

============ Relation.transpose ============
OK: transpose empty       == empty
OK: transpose (vertex x)  == vertex x
OK: transpose (edge x y)  == edge y x
OK: transpose . transpose == id
OK: edgeList . transpose  == sort . map swap . edgeList

============ Relation.gmap ============
OK: gmap f empty      == empty
OK: gmap f (vertex x) == vertex (f x)
OK: gmap f (edge x y) == edge (f x) (f y)
OK: gmap id           == id
OK: gmap f . gmap g   == gmap (f . g)

============ Relation.induce ============
OK: induce (const True ) x      == x
OK: induce (const False) x      == empty
OK: induce (/= x)               == removeVertex x
OK: induce p . induce q         == induce (\x -> p x && q x)
OK: isSubgraphOf (induce p x) x == True

============ Relation.compose ============
OK: compose empty            x                == empty
OK: compose x                empty            == empty
OK: compose (vertex x)       y                == empty
OK: compose x                (vertex y)       == empty
OK: compose x                (compose y z)    == compose (compose x y) z
OK: compose x                (overlay y z)    == overlay (compose x y) (compose x z)
OK: compose (overlay x y) z                   == overlay (compose x z) (compose y z)
OK: compose (edge x y)       (edge y z)       == edge x z
OK: compose (path    [1..5]) (path    [1..5]) == edges [(1,3),(2,4),(3,5)]
OK: compose (circuit [1..5]) (circuit [1..5]) == circuit [1,3,5,2,4]

============ Relation.closure ============
OK: closure empty           == empty
OK: closure (vertex x)      == edge x x
OK: closure (edge x x)      == edge x x
OK: closure (edge x y)      == edges [(x,x), (x,y), (y,y)]
OK: closure (path $ nub xs) == reflexiveClosure (clique $ nub xs)
OK: closure                 == reflexiveClosure . transitiveClosure
OK: closure                 == transitiveClosure . reflexiveClosure
OK: closure . closure       == closure
OK: postSet x (closure y)   == Set.fromList (reachable y x)

============ Relation.reflexiveClosure ============
OK: reflexiveClosure empty              == empty
OK: reflexiveClosure (vertex x)         == edge x x
OK: reflexiveClosure (edge x x)         == edge x x
OK: reflexiveClosure (edge x y)         == edges [(x,x), (x,y), (y,y)]
OK: reflexiveClosure . reflexiveClosure == reflexiveClosure

============ Relation.symmetricClosure ============
OK: symmetricClosure empty              == empty
OK: symmetricClosure (vertex x)         == vertex x
OK: symmetricClosure (edge x y)         == edges [(x,y), (y,x)]
OK: symmetricClosure x                  == overlay x (transpose x)
OK: symmetricClosure . symmetricClosure == symmetricClosure

============ Relation.transitiveClosure ============
OK: transitiveClosure empty               == empty
OK: transitiveClosure (vertex x)          == vertex x
OK: transitiveClosure (edge x y)          == edge x y
OK: transitiveClosure (path $ nub xs)     == clique (nub $ xs)
OK: transitiveClosure . transitiveClosure == transitiveClosure

============ Relation.induceJust ============
OK: induceJust (vertex Nothing)                               == empty
OK: induceJust (edge (Just x) Nothing)                        == vertex x
OK: induceJust . gmap Just                                    == id
OK: induceJust . gmap (\x -> if p x then Just x else Nothing) == induce p

============ ReflexiveRelation ============
OK: Axioms of reflexive graphs

============ TransitiveRelation ============
OK: Axioms of transitive graphs
OK: path xs == (clique xs :: TransitiveRelation Int)

============ PreorderRelation ============
OK: Axioms of preorder graphs
OK: path xs == (clique xs :: PreorderRelation Int)

============ Symmetric.Relation ============
OK: Axioms of undirected graphs

============ Symmetric.Relation.consistent ============
OK: Consistency of the Arbitrary instance

OK: consistent empty         == True
OK: consistent (vertex x)    == True
OK: consistent (overlay x y) == True
OK: consistent (connect x y) == True
OK: consistent (edge x y)    == True
OK: consistent (edges xs)    == True
OK: consistent (stars xs)    == True

============ Symmetric.Relation.Show ============
OK: show (empty    ) == "empty"
OK: show (1        ) == "vertex 1"
OK: show (1 + 2    ) == "vertices [1,2]"
OK: show (1 * 2    ) == "edge 1 2"
OK: show (1 * 2 * 3) == "edges [(1,2),(1,3),(2,3)]"
OK: show (1 * 2 + 3) == "overlay (vertex 3) (edge 1 2)"

OK: show (vertex (-1)                            ) == "vertex (-1)"
OK: show (vertex (-1) + vertex (-2)              ) == "vertices [-2,-1]"
OK: show (vertex (-2) * vertex (-1)              ) == "edge (-2) (-1)"
OK: show (vertex (-3) * vertex (-2) * vertex (-1)) == "edges [(-3,-2),(-3,-1),(-2,-1)]"
OK: show (vertex (-3) * vertex (-2) + vertex (-1)) == "overlay (vertex (-1)) (edge (-3) (-2))"

OK: show (2 * 1    ) == "edge 1 2"
OK: show (1 * 2 * 1) == "edges [(1,1),(1,2)]"
OK: show (3 * 2 * 1) == "edges [(1,2),(1,3),(2,3)]"

============ Symmetric.Relation.toSymmetric ============
OK: toSymmetric (edge 1 2)         == edge 1 2
OK: toSymmetric . fromSymmetric    == id
OK: fromSymmetric    . toSymmetric == symmetricClosure
OK: vertexCount      . toSymmetric == vertexCount
OK: (*2) . edgeCount . toSymmetric >= edgeCount

============ Symmetric.Relation.fromSymmetric ============
OK: fromSymmetric (edge 1 2)    == edges [(1,2), (2,1)]
OK: vertexCount . fromSymmetric == vertexCount
OK: edgeCount   . fromSymmetric <= (*2) . edgeCount

============ Symmetric.Relation.Ord ============
OK: vertex 1 <  vertex 2
OK: vertex 3 <  edge 1 2
OK: vertex 1 <  edge 1 1
OK: edge 1 1 <  edge 1 2
OK: edge 1 2 <  edge 1 1 + edge 2 2
OK: edge 2 1 <  edge 1 3
OK: edge 1 2 == edge 2 1
OK: x        <= x + y
OK: x + y    <= x * y

============ Symmetric.Relation.empty ============
OK: isEmpty     empty == True
OK: hasVertex x empty == False
OK: vertexCount empty == 0
OK: edgeCount   empty == 0

============ Symmetric.Relation.vertex ============
OK: isEmpty     (vertex x) == False
OK: hasVertex x (vertex y) == (x == y)
OK: vertexCount (vertex x) == 1
OK: edgeCount   (vertex x) == 0

============ Symmetric.Relation.edge ============
OK: edge x y               == connect (vertex x) (vertex y)
OK: edge x y               == edge y x
OK: edge x y               == edges [(x,y), (y,x)]
OK: hasEdge x y (edge x y) == True
OK: edgeCount   (edge x y) == 1
OK: vertexCount (edge 1 1) == 1
OK: vertexCount (edge 1 2) == 2

============ Symmetric.Relation.overlay ============
OK: isEmpty     (overlay x y) == isEmpty   x   && isEmpty   y
OK: hasVertex z (overlay x y) == hasVertex z x || hasVertex z y
OK: vertexCount (overlay x y) >= vertexCount x
OK: vertexCount (overlay x y) <= vertexCount x + vertexCount y
OK: edgeCount   (overlay x y) >= edgeCount x
OK: edgeCount   (overlay x y) <= edgeCount x   + edgeCount y
OK: vertexCount (overlay 1 2) == 2
OK: edgeCount   (overlay 1 2) == 0

============ Symmetric.Relation.connect ============
OK: connect x y               == connect y x
OK: isEmpty     (connect x y) == isEmpty   x   && isEmpty   y
OK: hasVertex z (connect x y) == hasVertex z x || hasVertex z y
OK: vertexCount (connect x y) >= vertexCount x
OK: vertexCount (connect x y) <= vertexCount x + vertexCount y
OK: edgeCount   (connect x y) >= edgeCount x
OK: edgeCount   (connect x y) >= edgeCount y
OK: edgeCount   (connect x y) >= vertexCount x * vertexCount y `div` 2
OK: edgeCount   (connect x y) <= vertexCount x * vertexCount y + edgeCount x + edgeCount y
OK: vertexCount (connect 1 2) == 2
OK: edgeCount   (connect 1 2) == 1

============ Symmetric.Relation.vertices ============
OK: vertices []            == empty
OK: vertices [x]           == vertex x
OK: vertices               == overlays . map vertex
OK: hasVertex x . vertices == elem x
OK: vertexCount . vertices == length . nub
OK: vertexSet   . vertices == Set.fromList

============ Symmetric.Relation.edges ============
OK: edges []             == empty
OK: edges [(x,y)]        == edge x y
OK: edges [(x,y), (y,x)] == edge x y

============ Symmetric.Relation.overlays ============
OK: overlays []        == empty
OK: overlays [x]       == x
OK: overlays [x,y]     == overlay x y
OK: overlays           == foldr overlay empty
OK: isEmpty . overlays == all isEmpty

============ Symmetric.Relation.connects ============
OK: connects []        == empty
OK: connects [x]       == x
OK: connects [x,y]     == connect x y
OK: connects           == foldr connect empty
OK: isEmpty . connects == all isEmpty
OK: connects           == connects . reverse

============ Symmetric.Relation.isSubgraphOf ============
OK: isSubgraphOf empty         x             ==  True
OK: isSubgraphOf (vertex x)    empty         ==  False
OK: isSubgraphOf x             (overlay x y) ==  True
OK: isSubgraphOf (overlay x y) (connect x y) ==  True
OK: isSubgraphOf (path xs)     (circuit xs)  ==  True
OK: isSubgraphOf x y                         ==> x <= y
OK: isSubgraphOf (edge x y) (edge y x)       ==  True

============ Symmetric.Relation.toGraph et al. ============
OK: toGraph                    == foldg Empty Vertex Overlay Connect
OK: foldg                      == Algebra.Graph.foldg . toGraph
OK: isEmpty                    == foldg True (const False) (&&) (&&)
OK: size                       == foldg 1 (const 1) (+) (+)
OK: hasVertex x                == foldg False (==x) (||) (||)
OK: hasEdge x y                == Algebra.Graph.hasEdge x y . toGraph
OK: vertexCount                == Set.size . vertexSet
OK: edgeCount                  == Set.size . edgeSet
OK: vertexList                 == Set.toAscList . vertexSet
OK: edgeList                   == Set.toAscList . edgeSet
OK: vertexSet                  == foldg Set.empty Set.singleton Set.union Set.union
OK: vertexIntSet               == foldg IntSet.empty IntSet.singleton IntSet.union IntSet.union
OK: adjacencyList              == Algebra.Graph.AdjacencyMap.adjacencyList . toAdjacencyMap
OK: adjacencyMap               == Algebra.Graph.AdjacencyMap.adjacencyMap . toAdjacencyMap
OK: adjacencyIntMap            == Algebra.Graph.AdjacencyIntMap.adjacencyIntMap . toAdjacencyIntMap
OK: adjacencyMapTranspose      == Algebra.Graph.AdjacencyMap.adjacencyMap . toAdjacencyMapTranspose
OK: adjacencyIntMapTranspose   == Algebra.Graph.AdjacencyIntMap.adjacencyIntMap . toAdjacencyIntMapTranspose
OK: dfsForest                  == Algebra.Graph.AdjacencyMap.dfsForest . toAdjacencyMap
OK: dfsForestFrom              == Algebra.Graph.AdjacencyMap.dfsForestFrom . toAdjacencyMap
OK: dfs                        == Algebra.Graph.AdjacencyMap.dfs . toAdjacencyMap
OK: reachable                  == Algebra.Graph.AdjacencyMap.reachable . toAdjacencyMap
OK: topSort                    == Algebra.Graph.AdjacencyMap.topSort . toAdjacencyMap
OK: isAcyclic                  == Algebra.Graph.AdjacencyMap.isAcyclic . toAdjacencyMap
OK: isTopSortOf vs             == Algebra.Graph.AdjacencyMap.isTopSortOf vs . toAdjacencyMap
OK: toAdjacencyMap             == foldg empty vertex overlay connect
OK: toAdjacencyMapTranspose    == foldg empty vertex overlay (flip connect)
OK: toAdjacencyIntMap          == foldg empty vertex overlay connect
OK: toAdjacencyIntMapTranspose == foldg empty vertex overlay (flip connect)
OK: isDfsForestOf f            == Algebra.Graph.AdjacencyMap.isDfsForestOf f . toAdjacencyMap
OK: isTopSortOf vs             == Algebra.Graph.AdjacencyMap.isTopSortOf vs . toAdjacencyMap

============ Symmetric.Relation.isEmpty ============
OK: isEmpty empty                       == True
OK: isEmpty (overlay empty empty)       == True
OK: isEmpty (vertex x)                  == False
OK: isEmpty (removeVertex x $ vertex x) == True
OK: isEmpty (removeEdge x y $ edge x y) == False

============ Symmetric.Relation.hasVertex ============
OK: hasVertex x empty            == False
OK: hasVertex x (vertex y)       == (x == y)
OK: hasVertex x . removeVertex x == const False

============ Symmetric.Relation.hasEdge ============
OK: hasEdge x y empty            == False
OK: hasEdge x y (vertex z)       == False
OK: hasEdge x y (edge x y)       == True
OK: hasEdge x y (edge y x)       == True
OK: hasEdge x y . removeEdge x y == const False
OK: hasEdge x y                  == elem (min x y, max x y) . edgeList

============ Symmetric.Relation.vertexCount ============
OK: vertexCount empty             ==  0
OK: vertexCount (vertex x)        ==  1
OK: vertexCount                   ==  length . vertexList
OK: vertexCount x < vertexCount y ==> x < y

============ Symmetric.Relation.edgeCount ============
OK: edgeCount empty      == 0
OK: edgeCount (vertex x) == 0
OK: edgeCount (edge x y) == 1
OK: edgeCount            == length . edgeList

============ Symmetric.Relation.vertexList ============
OK: vertexList empty      == []
OK: vertexList (vertex x) == [x]
OK: vertexList . vertices == nub . sort

============ Symmetric.Relation.vertexSet ============
OK: vertexSet empty      == Set.empty
OK: vertexSet . vertex   == Set.singleton
OK: vertexSet . vertices == Set.fromList

============ Symmetric.Relation.vertexIntSet ============
OK: vertexIntSet empty      == IntSet.empty
OK: vertexIntSet . vertex   == IntSet.singleton
OK: vertexIntSet . vertices == IntSet.fromList
OK: vertexIntSet . clique   == IntSet.fromList

============ Symmetric.Relation.edgeList ============
OK: edgeList empty          == []
OK: edgeList (vertex x)     == []
OK: edgeList (edge x y)     == [(min x y, max y x)]
OK: edgeList (star 2 [3,1]) == [(1,2), (2,3)]

============ Symmetric.Relation.edgeSet ============
OK: edgeSet empty      == Set.empty
OK: edgeSet (vertex x) == Set.empty
OK: edgeSet (edge x y) == Set.singleton (min x y, max x y)

============ Symmetric.Relation.adjacencyList ============
OK: adjacencyList empty          == []
OK: adjacencyList (vertex x)     == [(x, [])]
OK: adjacencyList (edge 1 2)     == [(1, [2]), (2, [1])]
OK: adjacencyList (star 2 [3,1]) == [(1, [2]), (2, [1,3]), (3, [2])]

============ Symmetric.Relation.neighbours ============
OK: neighbours x empty      == Set.empty
OK: neighbours x (vertex x) == Set.empty
OK: neighbours x (edge x y) == Set.fromList [y]
OK: neighbours y (edge x y) == Set.fromList [x]

============ Symmetric.Relation.path ============
OK: path []    == empty
OK: path [x]   == vertex x
OK: path [x,y] == edge x y
OK: path       == path . reverse

============ Symmetric.Relation.circuit ============
OK: circuit []    == empty
OK: circuit [x]   == edge x x
OK: circuit [x,y] == edges [(x,y), (y,x)]
OK: circuit       == circuit . reverse

============ Symmetric.Relation.clique ============
OK: clique []         == empty
OK: clique [x]        == vertex x
OK: clique [x,y]      == edge x y
OK: clique [x,y,z]    == edges [(x,y), (x,z), (y,z)]
OK: clique (xs ++ ys) == connect (clique xs) (clique ys)
OK: clique            == clique . reverse

============ Symmetric.Relation.biclique ============
OK: biclique []      []      == empty
OK: biclique [x]     []      == vertex x
OK: biclique []      [y]     == vertex y
OK: biclique [x1,x2] [y1,y2] == edges [(x1,y1), (x1,y2), (x2,y1), (x2,y2)]
OK: biclique xs      ys      == connect (vertices xs) (vertices ys)

============ Symmetric.Relation.star ============
OK: star x []    == vertex x
OK: star x [y]   == edge x y
OK: star x [y,z] == edges [(x,y), (x,z)]
OK: star x ys    == connect (vertex x) (vertices ys)

============ Symmetric.Relation.stars ============
OK: stars []                      == empty
OK: stars [(x, [])]               == vertex x
OK: stars [(x, [y])]              == edge x y
OK: stars [(x, ys)]               == star x ys
OK: stars                         == overlays . map (uncurry star)
OK: stars . adjacencyList         == id
OK: overlay (stars xs) (stars ys) == stars (xs ++ ys)

============ Symmetric.Relation.tree ============
OK: tree (Node x [])                                         == vertex x
OK: tree (Node x [Node y [Node z []]])                       == path [x,y,z]
OK: tree (Node x [Node y [], Node z []])                     == star x [y,z]
OK: tree (Node 1 [Node 2 [], Node 3 [Node 4 [], Node 5 []]]) == edges [(1,2), (1,3), (3,4), (3,5)]

============ Symmetric.Relation.forest ============
OK: forest []                                                  == empty
OK: forest [x]                                                 == tree x
OK: forest [Node 1 [Node 2 [], Node 3 []], Node 4 [Node 5 []]] == edges [(1,2), (1,3), (4,5)]
OK: forest                                                     == overlays . map tree

============ Symmetric.Relation.removeVertex ============
OK: removeVertex x (vertex x)       == empty
OK: removeVertex 1 (vertex 2)       == vertex 2
OK: removeVertex x (edge x x)       == empty
OK: removeVertex 1 (edge 1 2)       == vertex 2
OK: removeVertex x . removeVertex x == removeVertex x

============ Symmetric.Relation.removeEdge ============
OK: removeEdge x y (edge x y)       == vertices [x,y]
OK: removeEdge x y . removeEdge x y == removeEdge x y
OK: removeEdge x y . removeVertex x == removeVertex x
OK: removeEdge 1 1 (1 * 1 * 2 * 2)  == 1 * 2 * 2
OK: removeEdge 1 2 (1 * 1 * 2 * 2)  == 1 * 1 + 2 * 2
OK: removeEdge x y                  == removeEdge y x

============ Symmetric.Relation.replaceVertex ============
OK: replaceVertex x x            == id
OK: replaceVertex x y (vertex x) == vertex y
OK: replaceVertex x y            == mergeVertices (== x) y

============ Symmetric.Relation.mergeVertices ============
OK: mergeVertices (const False) x    == id
OK: mergeVertices (== x) y           == replaceVertex x y
OK: mergeVertices even 1 (0 * 2)     == 1 * 1
OK: mergeVertices odd  1 (3 + 4 * 5) == 4 * 1

============ Symmetric.Relation.gmap ============
OK: gmap f empty      == empty
OK: gmap f (vertex x) == vertex (f x)
OK: gmap f (edge x y) == edge (f x) (f y)
OK: gmap id           == id
OK: gmap f . gmap g   == gmap (f . g)

============ Symmetric.Relation.induce ============
OK: induce (const True ) x      == x
OK: induce (const False) x      == empty
OK: induce (/= x)               == removeVertex x
OK: induce p . induce q         == induce (\x -> p x && q x)
OK: isSubgraphOf (induce p x) x == True

============ Symmetric.Relation.induceJust ============
OK: induceJust (vertex Nothing)                               == empty
OK: induceJust (edge (Just x) Nothing)                        == vertex x
OK: induceJust . gmap Just                                    == id
OK: induceJust . gmap (\x -> if p x then Just x else Nothing) == induce p

============ Example.Todo (Holiday) ============
OK: A todo list is semantically Maybe [a]
OK: The overlay operator (+) adds non-dependent items to the todo list
OK: The connect operator (*) adds dependency between items
OK: Contradictory constraints make the todo list impossible to schedule
OK: Introduce item priority to schedule the todo list
OK: Custom connect operators pull/repel arguments during scheduling

============ Example.Todo (Commandline) ============
OK: The pull connect operator maintains command line semantics
OK: Swapping flags are allowed by the commutative overlay opeartor
OK: The usual connect operator breaks semantics
OK: Transform command lines by adding optimisation flag

============ Typed ============

============ Typed.fromAdjacencyMap ============
OK: toGraphKL (fromAdjacencyMap (1 * 2 + 3 * 1))                                == array (0,2) [(0,[1]), (1,[]), (2,[0])]
OK: toGraphKL (fromAdjacencyMap (1 * 2 + 2 * 1))                                == array (0,1) [(0,[1]), (1,[0])]
OK: map (fromVertexKL h) (vertices $ toGraphKL h)                               == vertexList g
OK: map (\(x, y) -> (fromVertexKL h x, fromVertexKL h y)) (edges $ toGraphKL h) == edgeList g

============ Typed.fromAdjacencyIntMap ============
OK: toGraphKL (fromAdjacencyIntMap (1 * 2 + 3 * 1))                             == array (0,2) [(0,[1]), (1,[]), (2,[0])]
OK: toGraphKL (fromAdjacencyIntMap (1 * 2 + 2 * 1))                             == array (0,1) [(0,[1]), (1,[0])]
OK: map (fromVertexKL h) (vertices $ toGraphKL h)                               == IntSet.toAscList (vertexIntSet g)
OK: map (\(x, y) -> (fromVertexKL h x, fromVertexKL h y)) (edges $ toGraphKL h) == edgeList g

============ Typed.dfsForest ============
OK: forest (dfsForest % edge 1 1)           == vertex 1
OK: forest (dfsForest % edge 1 2)           == edge 1 2
OK: forest (dfsForest % edge 2 1)           == vertices [1, 2]
OK: isSubgraphOf (forest $ dfsForest % x) x == True
OK: dfsForest % forest (dfsForest % x)      == dfsForest % x
OK: dfsForest % vertices vs                 == map (\v -> Node v []) (nub $ sort vs)
OK: dfsForest % (3 * (1 + 4) * (1 + 5))     == <correct result>

============ Typed.dfsForestFrom ============
OK: forest $ (dfsForestFrom % edge 1 1) [1]         == vertex 1
OK: forest $ (dfsForestFrom % edge 1 2) [0]         == empty
OK: forest $ (dfsForestFrom % edge 1 2) [1]         == edge 1 2
OK: forest $ (dfsForestFrom % edge 1 2) [2]         == vertex 2
OK: forest $ (dfsForestFrom % edge 1 2) [2,1]       == vertices [1,2]
OK: isSubgraphOf (forest $ dfsForestFrom % x $ vs) x == True
OK: dfsForestFrom % x $ vertexList x                == dfsForest % x
OK: dfsForestFrom % vertices vs $ vs                == map (\v -> Node v []) (nub vs)
OK: dfsForestFrom % x $ []                          == []
OK: dfsForestFrom % (3 * (1 + 4) * (1 + 5)) $ [1,4] == <correct result>

============ Typed.dfs ============
OK: dfs % edge 1 1 $ [1]   == [1]
OK: dfs % edge 1 2 $ [0]   == []
OK: dfs % edge 1 2 $ [1]   == [1,2]
OK: dfs % edge 1 2 $ [2]   == [2]
OK: dfs % edge 1 2 $ [1,2] == [1,2]
OK: dfs % edge 1 2 $ [2,1] == [2,1]
OK: dfs % x        $ []    == []

OK: dfs % (3 * (1 + 4) * (1 + 5)) $ [1,4]     == [1,5,4]
OK: and [ hasVertex v x | v <- dfs % x $ vs ] == True

============ Typed.topSort ============
OK: topSort % (1 * 2 + 3 * 1) == [3,1,2]
OK: topSort % (1 * 2 + 2 * 1) == [1,2]

============ Graph.Undirected ============
OK: Axioms of undirected graphs

============ Graph.Undirected.Show ============
OK: show (empty    ) == "empty"
OK: show (1        ) == "vertex 1"
OK: show (1 + 2    ) == "vertices [1,2]"
OK: show (1 * 2    ) == "edge 1 2"
OK: show (1 * 2 * 3) == "edges [(1,2),(1,3),(2,3)]"
OK: show (1 * 2 + 3) == "overlay (vertex 3) (edge 1 2)"

OK: show (vertex (-1)                            ) == "vertex (-1)"
OK: show (vertex (-1) + vertex (-2)              ) == "vertices [-2,-1]"
OK: show (vertex (-2) * vertex (-1)              ) == "edge (-2) (-1)"
OK: show (vertex (-3) * vertex (-2) * vertex (-1)) == "edges [(-3,-2),(-3,-1),(-2,-1)]"
OK: show (vertex (-3) * vertex (-2) + vertex (-1)) == "overlay (vertex (-1)) (edge (-3) (-2))"

OK: show (2 * 1    ) == "edge 1 2"
OK: show (1 * 2 * 1) == "edges [(1,1),(1,2)]"
OK: show (3 * 2 * 1) == "edges [(1,2),(1,3),(2,3)]"

============ Graph.Undirected.toUndirected ============
OK: toUndirected (edge 1 2)         == edge 1 2
OK: toUndirected . fromUndirected   == id
OK: vertexCount      . toUndirected == vertexCount
OK: (*2) . edgeCount . toUndirected >= edgeCount

============ Graph.Undirected.fromUndirected ============
OK: fromUndirected (edge 1 2)    == edges [(1,2),(2,1)]
OK: toUndirected . fromUndirected == id
OK: vertexCount . fromUndirected == vertexCount
OK: edgeCount   . fromUndirected <= (*2) . edgeCount

============ Graph.Undirected.complement ================
OK: complement empty              == empty
OK: complement (vertex x)         == vertex x
OK: complement (edge 1 1)         == edge 1 1
OK: complement (edge 1 2)         == vertices [1, 2]
OK: complement (star 1 [2, 3])    == overlay (vertex 1) (edge 2 3)
OK: complement . complement       == id

============ Graph.Undirected.Ord ============
OK: vertex 1 <  vertex 2
OK: vertex 3 <  edge 1 2
OK: vertex 1 <  edge 1 1
OK: edge 1 1 <  edge 1 2
OK: edge 1 2 <  edge 1 1 + edge 2 2
OK: edge 2 1 <  edge 1 3
OK: edge 1 2 == edge 2 1
OK: x        <= x + y
OK: x + y    <= x * y

============ Graph.Undirected.empty ============
OK: isEmpty     empty == True
OK: hasVertex x empty == False
OK: vertexCount empty == 0
OK: edgeCount   empty == 0

============ Graph.Undirected.vertex ============
OK: isEmpty     (vertex x) == False
OK: hasVertex x (vertex y) == (x == y)
OK: vertexCount (vertex x) == 1
OK: edgeCount   (vertex x) == 0

============ Graph.Undirected.edge ============
OK: edge x y               == connect (vertex x) (vertex y)
OK: edge x y               == edge y x
OK: edge x y               == edges [(x,y), (y,x)]
OK: hasEdge x y (edge x y) == True
OK: edgeCount   (edge x y) == 1
OK: vertexCount (edge 1 1) == 1
OK: vertexCount (edge 1 2) == 2

============ Graph.Undirected.overlay ============
OK: isEmpty     (overlay x y) == isEmpty   x   && isEmpty   y
OK: hasVertex z (overlay x y) == hasVertex z x || hasVertex z y
OK: vertexCount (overlay x y) >= vertexCount x
OK: vertexCount (overlay x y) <= vertexCount x + vertexCount y
OK: edgeCount   (overlay x y) >= edgeCount x
OK: edgeCount   (overlay x y) <= edgeCount x   + edgeCount y
OK: vertexCount (overlay 1 2) == 2
OK: edgeCount   (overlay 1 2) == 0

============ Graph.Undirected.connect ============
OK: connect x y               == connect y x
OK: isEmpty     (connect x y) == isEmpty   x   && isEmpty   y
OK: hasVertex z (connect x y) == hasVertex z x || hasVertex z y
OK: vertexCount (connect x y) >= vertexCount x
OK: vertexCount (connect x y) <= vertexCount x + vertexCount y
OK: edgeCount   (connect x y) >= edgeCount x
OK: edgeCount   (connect x y) >= edgeCount y
OK: edgeCount   (connect x y) >= vertexCount x * vertexCount y `div` 2
OK: edgeCount   (connect x y) <= vertexCount x * vertexCount y + edgeCount x + edgeCount y
OK: vertexCount (connect 1 2) == 2
OK: edgeCount   (connect 1 2) == 1

============ Graph.Undirected.vertices ============
OK: vertices []            == empty
OK: vertices [x]           == vertex x
OK: vertices               == overlays . map vertex
OK: hasVertex x . vertices == elem x
OK: vertexCount . vertices == length . nub
OK: vertexSet   . vertices == Set.fromList

============ Graph.Undirected.edges ============
OK: edges []             == empty
OK: edges [(x,y)]        == edge x y
OK: edges [(x,y), (y,x)] == edge x y

============ Graph.Undirected.overlays ============
OK: overlays []        == empty
OK: overlays [x]       == x
OK: overlays [x,y]     == overlay x y
OK: overlays           == foldr overlay empty
OK: isEmpty . overlays == all isEmpty

============ Graph.Undirected.connects ============
OK: connects []        == empty
OK: connects [x]       == x
OK: connects [x,y]     == connect x y
OK: connects           == foldr connect empty
OK: isEmpty . connects == all isEmpty
OK: connects           == connects . reverse

============ Graph.Undirected.isSubgraphOf ============
OK: isSubgraphOf empty         x             ==  True
OK: isSubgraphOf (vertex x)    empty         ==  False
OK: isSubgraphOf x             (overlay x y) ==  True
OK: isSubgraphOf (overlay x y) (connect x y) ==  True
OK: isSubgraphOf (path xs)     (circuit xs)  ==  True
OK: isSubgraphOf x y                         ==> x <= y
OK: isSubgraphOf (edge x y) (edge y x)       ==  True

============ Graph.Undirected.path ============
OK: path []    == empty
OK: path [x]   == vertex x
OK: path [x,y] == edge x y
OK: path       == path . reverse

============ Graph.Undirected.circuit ============
OK: circuit []    == empty
OK: circuit [x]   == edge x x
OK: circuit [x,y] == edges [(x,y), (y,x)]
OK: circuit       == circuit . reverse

============ Graph.Undirected.clique ============
OK: clique []         == empty
OK: clique [x]        == vertex x
OK: clique [x,y]      == edge x y
OK: clique [x,y,z]    == edges [(x,y), (x,z), (y,z)]
OK: clique (xs ++ ys) == connect (clique xs) (clique ys)
OK: clique            == clique . reverse

============ Graph.Undirected.biclique ============
OK: biclique []      []      == empty
OK: biclique [x]     []      == vertex x
OK: biclique []      [y]     == vertex y
OK: biclique [x1,x2] [y1,y2] == edges [(x1,y1), (x1,y2), (x2,y1), (x2,y2)]
OK: biclique xs      ys      == connect (vertices xs) (vertices ys)

============ Graph.Undirected.star ============
OK: star x []    == vertex x
OK: star x [y]   == edge x y
OK: star x [y,z] == edges [(x,y), (x,z)]
OK: star x ys    == connect (vertex x) (vertices ys)

============ Graph.Undirected.stars ============
OK: stars []                      == empty
OK: stars [(x, [])]               == vertex x
OK: stars [(x, [y])]              == edge x y
OK: stars [(x, ys)]               == star x ys
OK: stars                         == overlays . map (uncurry star)
OK: stars . adjacencyList         == id
OK: overlay (stars xs) (stars ys) == stars (xs ++ ys)

============ Graph.Undirected.tree ============
OK: tree (Node x [])                                         == vertex x
OK: tree (Node x [Node y [Node z []]])                       == path [x,y,z]
OK: tree (Node x [Node y [], Node z []])                     == star x [y,z]
OK: tree (Node 1 [Node 2 [], Node 3 [Node 4 [], Node 5 []]]) == edges [(1,2), (1,3), (3,4), (3,5)]

============ Graph.Undirected.forest ============
OK: forest []                                                  == empty
OK: forest [x]                                                 == tree x
OK: forest [Node 1 [Node 2 [], Node 3 []], Node 4 [Node 5 []]] == edges [(1,2), (1,3), (4,5)]
OK: forest                                                     == overlays . map tree

============ Graph.Undirected.removeVertex ============
OK: removeVertex x (vertex x)       == empty
OK: removeVertex 1 (vertex 2)       == vertex 2
OK: removeVertex x (edge x x)       == empty
OK: removeVertex 1 (edge 1 2)       == vertex 2
OK: removeVertex x . removeVertex x == removeVertex x

============ Graph.Undirected.removeEdge ============
OK: removeEdge x y (edge x y)       == vertices [x,y]
OK: removeEdge x y . removeEdge x y == removeEdge x y
OK: removeEdge x y . removeVertex x == removeVertex x
OK: removeEdge 1 1 (1 * 1 * 2 * 2)  == 1 * 2 * 2
OK: removeEdge 1 2 (1 * 1 * 2 * 2)  == 1 * 1 + 2 * 2
OK: removeEdge x y                  == removeEdge y x

============ Graph.Undirected.replaceVertex ============
OK: replaceVertex x x            == id
OK: replaceVertex x y (vertex x) == vertex y
OK: replaceVertex x y            == mergeVertices (== x) y

============ Graph.Undirected.mergeVertices ============
OK: mergeVertices (const False) x    == id
OK: mergeVertices (== x) y           == replaceVertex x y
OK: mergeVertices even 1 (0 * 2)     == 1 * 1
OK: mergeVertices odd  1 (3 + 4 * 5) == 4 * 1

============ Graph.Undirected.gmap ============
OK: gmap f empty      == empty
OK: gmap f (vertex x) == vertex (f x)
OK: gmap f (edge x y) == edge (f x) (f y)
OK: gmap id           == id
OK: gmap f . gmap g   == gmap (f . g)

============ Graph.Undirected.induce ============
OK: induce (const True ) x      == x
OK: induce (const False) x      == empty
OK: induce (/= x)               == removeVertex x
OK: induce p . induce q         == induce (\x -> p x && q x)
OK: isSubgraphOf (induce p x) x == True

============ Graph.Undirected.induceJust ============
OK: induceJust (vertex Nothing)                               == empty
OK: induceJust (edge (Just x) Nothing)                        == vertex x
OK: induceJust . gmap Just                                    == id
OK: induceJust . gmap (\x -> if p x then Just x else Nothing) == induce p
Test suite main: PASS
Test suite logged to:
/tmp/workdir-algebraic-graphs/algebraic-graphs-0.7/dist-newstyle/build/x86_64-linux/ghc-9.6.6/algebraic-graphs-0.7/t/main/test/algebraic-graphs-0.7-main.log
1 of 1 test suites (1 of 1 test cases) passed.
