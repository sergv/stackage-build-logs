Build profile: -w ghc-9.6.6 -O1
In order, the following will be built (use -v for more details):
 - quickcheck-monoid-subclasses-0.3.0.4 (test:test) (ephemeral targets)
Preprocessing test suite 'test' for quickcheck-monoid-subclasses-0.3.0.4...
Building test suite 'test' for quickcheck-monoid-subclasses-0.3.0.4...
Running 1 test suites...
Test suite test: RUNNING...

Class
  Testing Cancellative laws for type ()
    cancellativeLaw_cancellation_prefix [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    cancellativeLaw_cancellation_suffix [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
  Testing Commutative laws for type ()
    commutativeLaw_basic [✔]
      +++ OK, passed 100 tests.
      
      Only 0% (a /= b) && (a <> b /= a) && (b <> a /= b), but expected 0%
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
  Testing DistributiveGCDMonoid laws for type ()
    distributiveGCDMonoidLaw_distributivity_left [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b, c], but expected 0%
      Only 0% allUnique [a, b, c], but expected 0%
      Only 0% allUniqueNonNull [a, b, c], but expected 0%
    distributiveGCDMonoidLaw_distributivity_right [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b, c], but expected 0%
      Only 0% allUnique [a, b, c], but expected 0%
      Only 0% allUniqueNonNull [a, b, c], but expected 0%
  Testing DistributiveLCMMonoid laws for type ()
    distributiveLCMMonoidLaw_distributivity_left [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b, c], but expected 0%
      Only 0% allUnique [a, b, c], but expected 0%
      Only 0% allUniqueNonNull [a, b, c], but expected 0%
    distributiveLCMMonoidLaw_distributivity_right [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b, c], but expected 0%
      Only 0% allUnique [a, b, c], but expected 0%
      Only 0% allUniqueNonNull [a, b, c], but expected 0%
    distributiveLCMMonoidLaw_distributivity_gcd_lcm [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b, c], but expected 0%
      Only 0% allUnique [a, b, c], but expected 0%
      Only 0% allUniqueNonNull [a, b, c], but expected 0%
    distributiveLCMMonoidLaw_distributivity_lcm_gcd [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b, c], but expected 0%
      Only 0% allUnique [a, b, c], but expected 0%
      Only 0% allUniqueNonNull [a, b, c], but expected 0%
  Testing Factorial laws for type ()
    factorialLaw_coverage [✔]
      +++ OK, passed 100 tests (100% length a == 0).
      
      Only 0% length a == 1, but expected 0%
      Only 0% length a >= 2, but expected 0%
    factorialLaw_length_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors_reverse [✔]
      +++ OK, passed 100 tests.
    factorialLaw_all_factors_prime [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primePrefix_foldr [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primeSuffix_foldl [✔]
      +++ OK, passed 100 tests.
    factorialLaw_factors_foldl [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    factorialLaw_factors_foldl' [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    factorialLaw_factors_foldr [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
  Testing FactorialMonoid laws for type ()
    factorialMonoidLaw_coverage [✔]
      +++ OK, passed 100 tests (100% length a == 0).
      
      Only 0% length a == 1, but expected 0%
      Only 0% length a >= 2, but expected 0%
    factorialMonoidLaw_null [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_reverse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_inits [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_tails [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_span [✔]
      +++ OK, passed 100 tests.
      
      Only 0% any (not . p) (factors a), but expected 0%
      Only 0% any p (factors a), but expected 0%
    factorialMonoidLaw_split [✔]
      +++ OK, passed 100 tests.
      
      Only 0% any (not . p) (factors a), but expected 0%
      Only 0% any p (factors a), but expected 0%
    factorialMonoidLaw_split_intersperse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitAt [✔]
      +++ OK, passed 100 tests.
  Testing GCDMonoid laws for type ()
    gcdMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests (100% (a </> gcd a b) /= mempty).
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% gcd a b /= mempty, but expected 0%
    gcdMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests (100% (b </> gcd a b) /= mempty).
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% gcd a b /= mempty, but expected 0%
    gcdMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      100% all isJust [a </> c, b </> c, c </> gcd a b]
      100% c == gcd a b
      
      Only 0% allNonNull [a, b, c], but expected 0%
      Only 0% allUnique [a, b, c], but expected 0%
      Only 0% allUniqueNonNull [a, b, c], but expected 0%
      Only 0% c /= gcd a b, but expected 0%
      Only 0% not (all isJust [a </> c, b </> c, c </> gcd a b]), but expected 0%
    gcdMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    gcdMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests.
      
      Only 0% a /= mempty, but expected 0%
    gcdMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests.
      
      Only 0% a /= mempty, but expected 0%
    gcdMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests (100% gcd a b == mempty).
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% gcd a b /= mempty, but expected 0%
    gcdMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b, c], but expected 0%
      Only 0% allUnique [a, b, c], but expected 0%
      Only 0% allUniqueNonNull [a, b, c], but expected 0%
      Only 0% gcd a b /= mempty, but expected 0%
      Only 0% gcd b c /= mempty, but expected 0%
    gcdMonoidLaw_equivalence_commonPrefix [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% commonPrefix a b /= mempty, but expected 0%
      Only 0% gcd a b /= mempty, but expected 0%
    gcdMonoidLaw_equivalence_commonSuffix [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% commonSuffix a b /= mempty, but expected 0%
      Only 0% gcd a b /= mempty, but expected 0%
  Testing LCMMonoid laws for type ()
    lcmMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests.
      
      Only 0% (lcm a b </> a) /= Just mempty, but expected 0%
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% lcm a b /= mempty, but expected 0%
    lcmMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests.
      
      Only 0% (lcm a b </> b) /= Just mempty, but expected 0%
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% lcm a b /= mempty, but expected 0%
    lcmMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      100% all isJust [c </> a, c </> b, lcm a b </> c]
      100% c == lcm a b
      
      Only 0% allNonNull [a, b, c], but expected 0%
      Only 0% allUnique [a, b, c], but expected 0%
      Only 0% allUniqueNonNull [a, b, c], but expected 0%
      Only 0% c /= lcm a b, but expected 0%
      Only 0% not (all isJust [c </> a, c </> b, lcm a b </> c]), but expected 0%
    lcmMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    lcmMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests.
      
      Only 0% a /= mempty, but expected 0%
    lcmMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests.
      
      Only 0% a /= mempty, but expected 0%
    lcmMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% lcm a b /= mempty, but expected 0%
    lcmMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b, c], but expected 0%
      Only 0% allUnique [a, b, c], but expected 0%
      Only 0% allUniqueNonNull [a, b, c], but expected 0%
      Only 0% lcm a b /= mempty, but expected 0%
      Only 0% lcm b c /= mempty, but expected 0%
    lcmMonoidLaw_absorption_gcd_lcm [✔]
      +++ OK, passed 100 tests (100% gcd a b == mempty).
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% gcd a b /= mempty, but expected 0%
    lcmMonoidLaw_absorption_lcm_gcd [✔]
      +++ OK, passed 100 tests (100% gcd a b == mempty).
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% gcd a b /= mempty, but expected 0%
  Testing LeftCancellative laws for type ()
    leftCancellativeLaw_cancellation [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
  Testing LeftDistributiveGCDMonoid laws for type ()
    leftDistributiveGCDMonoidLaw_distributivity [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b, c], but expected 0%
      Only 0% allUnique [a, b, c], but expected 0%
      Only 0% allUniqueNonNull [a, b, c], but expected 0%
      Only 0% commonPrefix b c /= mempty && a /= mempty, but expected 0%
  Testing LeftGCDMonoid laws for type ()
    leftGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests (100% stripPrefix (commonPrefix a b) a /= mempty).
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% commonPrefix a b /= mempty, but expected 0%
    leftGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests (100% stripPrefix (commonPrefix a b) b /= mempty).
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% commonPrefix a b /= mempty, but expected 0%
    leftGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      100% antecedent == True
      100% consequent == True
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% antecedent == False, but expected 0%
      Only 0% consequent == False, but expected 0%
    leftGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    leftGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests.
      
      Only 0% a /= mempty, but expected 0%
    leftGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests.
      
      Only 0% a /= mempty, but expected 0%
    leftGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests (100% commonPrefix a b == mempty).
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% commonPrefix a b /= mempty, but expected 0%
    leftGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b, c], but expected 0%
      Only 0% allUnique [a, b, c], but expected 0%
      Only 0% allUniqueNonNull [a, b, c], but expected 0%
      Only 0% commonPrefix (commonPrefix a b) c /= mempty, but expected 0%
      Only 0% commonPrefix a (commonPrefix b c) /= mempty, but expected 0%
    leftGCDMonoidLaw_stripCommonPrefix_commonPrefix [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% commonPrefix a b /= mempty, but expected 0%
    leftGCDMonoidLaw_stripCommonPrefix_mappend_1 [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty, but expected 0%
    leftGCDMonoidLaw_stripCommonPrefix_mappend_2 [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty, but expected 0%
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_1 [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty, but expected 0%
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_2 [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty, but expected 0%
  Testing LeftReductive laws for type ()
    leftReductiveLaw_isPrefixOf_mappend [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    leftReductiveLaw_isPrefixOf_stripPrefix [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    leftReductiveLaw_stripPrefix [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
  Testing MonoidNull laws for type ()
    monoidNullLaw_basic [✔]
      +++ OK, passed 100 tests (100% a == mempty).
      
      Only 0% a /= mempty, but expected 0%
  Testing Monus laws for type ()
    monusLaw_axiom_1 [✔]
      +++ OK, passed 100 tests (100% a == mempty).
      
      Only 0% a /= mempty, but expected 0%
    monusLaw_axiom_2 [✔]
      +++ OK, passed 100 tests (100% a == mempty).
      
      Only 0% a /= mempty, but expected 0%
    monusLaw_axiom_3 [✔]
      +++ OK, passed 100 tests.
      
      Only 0% (a <\> b) /= mempty, but expected 0%
      Only 0% (b <\> a) /= mempty, but expected 0%
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    monusLaw_axiom_4 [✔]
      +++ OK, passed 100 tests.
      
      Only 0% (a <\> b) <\> c /= mempty, but expected 0%
      Only 0% allNonNull [a, b, c], but expected 0%
      Only 0% allUnique [a, b, c], but expected 0%
      Only 0% allUniqueNonNull [a, b, c], but expected 0%
    monusLaw_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests.
      
      Only 0% a <\> b /= mempty, but expected 0%
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    monusLaw_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests.
      
      Only 0% a <\> b /= mempty, but expected 0%
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
  Testing OverlappingGCDMonoid laws for type ()
    overlappingGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests (100% stripSuffix (overlap a b) a /= mempty).
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% overlap a b /= mempty, but expected 0%
    overlappingGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests (100% stripPrefix (overlap a b) b /= mempty).
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% overlap a b /= mempty, but expected 0%
    overlappingGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    overlappingGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests.
      
      Only 0% a /= mempty, but expected 0%
    overlappingGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests.
      
      Only 0% a /= mempty, but expected 0%
    overlappingGCDMonoidLaw_overlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% overlap a b /= mempty && stripPrefixOverlap a b /= mempty, but expected 0%
    overlappingGCDMonoidLaw_overlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% stripSuffixOverlap b a /= mempty && overlap a b /= mempty, but expected 0%
    overlappingGCDMonoidLaw_stripOverlap_overlap [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% overlap a b /= mempty, but expected 0%
    overlappingGCDMonoidLaw_stripOverlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% stripPrefixOverlap a b /= mempty, but expected 0%
    overlappingGCDMonoidLaw_stripOverlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% stripSuffixOverlap b a /= mempty, but expected 0%
  Testing PositiveMonoid laws for type ()
    positiveMonoidLaw_fundamental [✔]
      +++ OK, passed 100 tests (100% null (a <> b)).
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% not (null (a <> b)), but expected 0%
  Testing Reductive laws for type ()
    reductiveLaw_equivalence_prefix [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    reductiveLaw_equivalence_suffix [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    reductiveLaw_inversion_prefix [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    reductiveLaw_inversion_suffix [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
  Testing RightCancellative laws for type ()
    rightCancellativeLaw_cancellation [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
  Testing RightDistributiveGCDMonoid laws for type ()
    rightDistributiveGCDMonoidLaw_distributivity [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b, c], but expected 0%
      Only 0% allUnique [a, b, c], but expected 0%
      Only 0% allUniqueNonNull [a, b, c], but expected 0%
      Only 0% commonSuffix a b /= mempty && c /= mempty, but expected 0%
  Testing RightGCDMonoid laws for type ()
    rightGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests (100% stripSuffix (commonSuffix a b) a /= mempty).
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% commonSuffix a b /= mempty, but expected 0%
    rightGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests (100% stripSuffix (commonSuffix a b) b /= mempty).
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% commonSuffix a b /= mempty, but expected 0%
    rightGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      100% antecedent == True
      100% consequent == True
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% antecedent == False, but expected 0%
      Only 0% consequent == False, but expected 0%
    rightGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    rightGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests.
      
      Only 0% a /= mempty, but expected 0%
    rightGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests.
      
      Only 0% a /= mempty, but expected 0%
    rightGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests (100% commonSuffix a b == mempty).
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% commonSuffix a b /= mempty, but expected 0%
    rightGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b, c], but expected 0%
      Only 0% allUnique [a, b, c], but expected 0%
      Only 0% allUniqueNonNull [a, b, c], but expected 0%
      Only 0% commonSuffix (commonSuffix a b) c /= mempty, but expected 0%
      Only 0% commonSuffix a (commonSuffix b c) /= mempty, but expected 0%
    rightGCDMonoidLaw_stripCommonSuffix_commonSuffix [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% commonSuffix a b /= mempty, but expected 0%
    rightGCDMonoidLaw_stripCommonSuffix_mappend_1 [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% stripCommonSuffix a b & \(x, _, s) -> x /= mempty && s /= mempty, but expected 0%
    rightGCDMonoidLaw_stripCommonSuffix_mappend_2 [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% stripCommonSuffix a b & \(_, x, s) -> x /= mempty && s /= mempty, but expected 0%
    rightGCDMonoidLaw_stripCommonSuffix_stripSuffix_1 [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% stripCommonSuffix a b & \(x, _, s) -> x /= mempty && s /= mempty, but expected 0%
    rightGCDMonoidLaw_stripCommonSuffix_stripSuffix_2 [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% stripCommonSuffix a b & \(_, x, s) -> x /= mempty && s /= mempty, but expected 0%
  Testing RightReductive laws for type ()
    rightReductiveLaw_isSuffixOf_mappend [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    rightReductiveLaw_isSuffixOf_stripSuffix [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    rightReductiveLaw_stripSuffix [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
  Testing StableFactorial laws for type ()
    stableFactorialLaw_factors_mappend [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    stableFactorialLaw_factors_reverse [✔]
      +++ OK, passed 100 tests.
    stableFactorialLaw_primePrefix_primeSuffix_reverse [✔]
      +++ OK, passed 100 tests.
    stableFactorialLaw_primeSuffix_primePrefix_reverse [✔]
      +++ OK, passed 100 tests.
  Testing Factorial laws for type ByteString
    factorialLaw_coverage [✔]
      +++ OK, passed 800 tests:
      95.4% length a >= 2
       3.2% length a == 0
       1.4% length a == 1
    factorialLaw_length_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors_reverse [✔]
      +++ OK, passed 100 tests.
    factorialLaw_all_factors_prime [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primePrefix_foldr [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primeSuffix_foldl [✔]
      +++ OK, passed 100 tests.
    factorialLaw_factors_foldl [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b]
      92% allUnique [a, b]
      89% allUniqueNonNull [a, b]
    factorialLaw_factors_foldl' [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b]
      92% allUnique [a, b]
      89% allUniqueNonNull [a, b]
    factorialLaw_factors_foldr [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b]
      92% allUnique [a, b]
      89% allUniqueNonNull [a, b]
  Testing FactorialMonoid laws for type ByteString
    factorialMonoidLaw_coverage [✔]
      +++ OK, passed 800 tests:
      95.4% length a >= 2
       3.2% length a == 0
       1.4% length a == 1
    factorialMonoidLaw_null [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_reverse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_inits [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_tails [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_span [✔]
      +++ OK, passed 100 tests:
      96% any (not . p) (factors a)
      94% any p (factors a)
    factorialMonoidLaw_split [✔]
      +++ OK, passed 100 tests:
      96% any (not . p) (factors a)
      94% any p (factors a)
    factorialMonoidLaw_split_intersperse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitAt [✔]
      +++ OK, passed 100 tests.
  Testing LeftCancellative laws for type ByteString
    leftCancellativeLaw_cancellation [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b]
      92% allUnique [a, b]
      89% allUniqueNonNull [a, b]
  Testing LeftDistributiveGCDMonoid laws for type ByteString
    leftDistributiveGCDMonoidLaw_distributivity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      81% allUnique [a, b, c]
      78% allUniqueNonNull [a, b, c]
      40% commonPrefix b c /= mempty && a /= mempty
  Testing LeftGCDMonoid laws for type ByteString
    leftGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) a /= mempty
      95% allNonNull [a, b]
      92% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      31% commonPrefix a b /= mempty
    leftGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) b /= mempty
      95% allNonNull [a, b]
      92% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      31% commonPrefix a b /= mempty
    leftGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b]
      92% allUnique [a, b]
      91% antecedent == False
      91% consequent == False
      89% allUniqueNonNull [a, b]
       9% antecedent == True
       9% consequent == True
    leftGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    leftGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (96% a /= mempty).
    leftGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (96% a /= mempty).
    leftGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b]
      92% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      69% commonPrefix a b == mempty
      31% commonPrefix a b /= mempty
    leftGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      81% allUnique [a, b, c]
      78% allUniqueNonNull [a, b, c]
      30% commonPrefix (commonPrefix a b) c /= mempty
      30% commonPrefix a (commonPrefix b c) /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_commonPrefix [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b]
      92% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      31% commonPrefix a b /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b]
      92% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      19% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b]
      92% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      15% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_1 [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b]
      92% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      19% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_2 [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b]
      92% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      15% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
  Testing LeftReductive laws for type ByteString
    leftReductiveLaw_isPrefixOf_mappend [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b]
      92% allUnique [a, b]
      89% allUniqueNonNull [a, b]
    leftReductiveLaw_isPrefixOf_stripPrefix [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b]
      92% allUnique [a, b]
      89% allUniqueNonNull [a, b]
    leftReductiveLaw_stripPrefix [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b]
      92% allUnique [a, b]
      89% allUniqueNonNull [a, b]
  Testing MonoidNull laws for type ByteString
    monoidNullLaw_basic [✔]
      +++ OK, passed 100 tests:
      96% a /= mempty
       4% a == mempty
  Testing OverlappingGCDMonoid laws for type ByteString
    overlappingGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (overlap a b) a /= mempty
      95% allNonNull [a, b]
      92% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      37% overlap a b /= mempty
    overlappingGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (overlap a b) b /= mempty
      95% allNonNull [a, b]
      92% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      37% overlap a b /= mempty
    overlappingGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    overlappingGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (96% a /= mempty).
    overlappingGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (96% a /= mempty).
    overlappingGCDMonoidLaw_overlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b]
      92% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      21% overlap a b /= mempty && stripPrefixOverlap a b /= mempty
    overlappingGCDMonoidLaw_overlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b]
      92% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      25% stripSuffixOverlap b a /= mempty && overlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_overlap [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b]
      92% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      37% overlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b]
      92% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      81% stripPrefixOverlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b]
      92% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      84% stripSuffixOverlap b a /= mempty
  Testing PositiveMonoid laws for type ByteString
    positiveMonoidLaw_fundamental [✔]
      +++ OK, passed 100 tests:
      98% not (null (a <> b))
      95% allNonNull [a, b]
      92% allUnique [a, b]
      89% allUniqueNonNull [a, b]
       2% null (a <> b)
  Testing RightCancellative laws for type ByteString
    rightCancellativeLaw_cancellation [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b]
      92% allUnique [a, b]
      89% allUniqueNonNull [a, b]
  Testing RightDistributiveGCDMonoid laws for type ByteString
    rightDistributiveGCDMonoidLaw_distributivity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      81% allUnique [a, b, c]
      78% allUniqueNonNull [a, b, c]
      36% commonSuffix a b /= mempty && c /= mempty
  Testing RightGCDMonoid laws for type ByteString
    rightGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (commonSuffix a b) a /= mempty
      95% allNonNull [a, b]
      92% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      34% commonSuffix a b /= mempty
    rightGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (commonSuffix a b) b /= mempty
      95% allNonNull [a, b]
      92% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      34% commonSuffix a b /= mempty
    rightGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b]
      92% allUnique [a, b]
      91% antecedent == False
      91% consequent == False
      89% allUniqueNonNull [a, b]
       9% antecedent == True
       9% consequent == True
    rightGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    rightGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (96% a /= mempty).
    rightGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (96% a /= mempty).
    rightGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b]
      92% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      66% commonSuffix a b == mempty
      34% commonSuffix a b /= mempty
    rightGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      81% allUnique [a, b, c]
      78% allUniqueNonNull [a, b, c]
      26% commonSuffix (commonSuffix a b) c /= mempty
      26% commonSuffix a (commonSuffix b c) /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_commonSuffix [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b]
      92% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      34% commonSuffix a b /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b]
      92% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      16% stripCommonSuffix a b & \(x, _, s) -> x /= mempty && s /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b]
      92% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      18% stripCommonSuffix a b & \(_, x, s) -> x /= mempty && s /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_stripSuffix_1 [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b]
      92% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      16% stripCommonSuffix a b & \(x, _, s) -> x /= mempty && s /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_stripSuffix_2 [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b]
      92% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      18% stripCommonSuffix a b & \(_, x, s) -> x /= mempty && s /= mempty
  Testing RightReductive laws for type ByteString
    rightReductiveLaw_isSuffixOf_mappend [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b]
      92% allUnique [a, b]
      89% allUniqueNonNull [a, b]
    rightReductiveLaw_isSuffixOf_stripSuffix [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b]
      92% allUnique [a, b]
      89% allUniqueNonNull [a, b]
    rightReductiveLaw_stripSuffix [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b]
      92% allUnique [a, b]
      89% allUniqueNonNull [a, b]
  Testing StableFactorial laws for type ByteString
    stableFactorialLaw_factors_mappend [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b]
      92% allUnique [a, b]
      89% allUniqueNonNull [a, b]
    stableFactorialLaw_factors_reverse [✔]
      +++ OK, passed 100 tests.
    stableFactorialLaw_primePrefix_primeSuffix_reverse [✔]
      +++ OK, passed 100 tests.
    stableFactorialLaw_primeSuffix_primePrefix_reverse [✔]
      +++ OK, passed 100 tests.
  Testing Factorial laws for type Dual ByteString
    factorialLaw_coverage [✔]
      +++ OK, passed 800 tests:
      95.4% length a >= 2
       3.2% length a == 0
       1.4% length a == 1
    factorialLaw_length_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors_reverse [✔]
      +++ OK, passed 100 tests.
    factorialLaw_all_factors_prime [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primePrefix_foldr [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primeSuffix_foldl [✔]
      +++ OK, passed 100 tests.
    factorialLaw_factors_foldl [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b]
      92% allUnique [a, b]
      89% allUniqueNonNull [a, b]
    factorialLaw_factors_foldl' [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b]
      92% allUnique [a, b]
      89% allUniqueNonNull [a, b]
    factorialLaw_factors_foldr [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b]
      92% allUnique [a, b]
      89% allUniqueNonNull [a, b]
  Testing FactorialMonoid laws for type Dual ByteString
    factorialMonoidLaw_coverage [✔]
      +++ OK, passed 800 tests:
      95.4% length a >= 2
       3.2% length a == 0
       1.4% length a == 1
    factorialMonoidLaw_null [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_reverse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_inits [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_tails [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_span [✔]
      +++ OK, passed 100 tests:
      95% any p (factors a)
      94% any (not . p) (factors a)
    factorialMonoidLaw_split [✔]
      +++ OK, passed 100 tests:
      95% any p (factors a)
      94% any (not . p) (factors a)
    factorialMonoidLaw_split_intersperse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitAt [✔]
      +++ OK, passed 100 tests.
  Testing LeftCancellative laws for type Dual ByteString
    leftCancellativeLaw_cancellation [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b]
      92% allUnique [a, b]
      89% allUniqueNonNull [a, b]
  Testing LeftDistributiveGCDMonoid laws for type Dual ByteString
    leftDistributiveGCDMonoidLaw_distributivity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      81% allUnique [a, b, c]
      78% allUniqueNonNull [a, b, c]
      38% commonPrefix b c /= mempty && a /= mempty
  Testing LeftGCDMonoid laws for type Dual ByteString
    leftGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) a /= mempty
      95% allNonNull [a, b]
      92% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      31% commonPrefix a b /= mempty
    leftGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) b /= mempty
      95% allNonNull [a, b]
      92% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      31% commonPrefix a b /= mempty
    leftGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b]
      92% allUnique [a, b]
      92% antecedent == False
      92% consequent == False
      89% allUniqueNonNull [a, b]
       8% antecedent == True
       8% consequent == True
    leftGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    leftGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (96% a /= mempty).
    leftGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (96% a /= mempty).
    leftGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b]
      92% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      69% commonPrefix a b == mempty
      31% commonPrefix a b /= mempty
    leftGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      81% allUnique [a, b, c]
      78% allUniqueNonNull [a, b, c]
      29% commonPrefix (commonPrefix a b) c /= mempty
      29% commonPrefix a (commonPrefix b c) /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_commonPrefix [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b]
      92% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      31% commonPrefix a b /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b]
      92% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      19% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b]
      92% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      15% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_1 [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b]
      92% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      19% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_2 [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b]
      92% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      15% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
  Testing LeftReductive laws for type Dual ByteString
    leftReductiveLaw_isPrefixOf_mappend [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b]
      92% allUnique [a, b]
      89% allUniqueNonNull [a, b]
    leftReductiveLaw_isPrefixOf_stripPrefix [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b]
      92% allUnique [a, b]
      89% allUniqueNonNull [a, b]
    leftReductiveLaw_stripPrefix [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b]
      92% allUnique [a, b]
      89% allUniqueNonNull [a, b]
  Testing MonoidNull laws for type Dual ByteString
    monoidNullLaw_basic [✔]
      +++ OK, passed 100 tests:
      96% a /= mempty
       4% a == mempty
  Testing OverlappingGCDMonoid laws for type Dual ByteString
    overlappingGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (overlap a b) a /= mempty
      95% allNonNull [a, b]
      92% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      37% overlap a b /= mempty
    overlappingGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (overlap a b) b /= mempty
      95% allNonNull [a, b]
      92% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      37% overlap a b /= mempty
    overlappingGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    overlappingGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (96% a /= mempty).
    overlappingGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (96% a /= mempty).
    overlappingGCDMonoidLaw_overlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b]
      92% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      21% overlap a b /= mempty && stripPrefixOverlap a b /= mempty
    overlappingGCDMonoidLaw_overlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b]
      92% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      25% stripSuffixOverlap b a /= mempty && overlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_overlap [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b]
      92% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      37% overlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b]
      92% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      81% stripPrefixOverlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b]
      92% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      84% stripSuffixOverlap b a /= mempty
  Testing PositiveMonoid laws for type Dual ByteString
    positiveMonoidLaw_fundamental [✔]
      +++ OK, passed 100 tests:
      98% not (null (a <> b))
      95% allNonNull [a, b]
      92% allUnique [a, b]
      89% allUniqueNonNull [a, b]
       2% null (a <> b)
  Testing RightCancellative laws for type Dual ByteString
    rightCancellativeLaw_cancellation [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b]
      92% allUnique [a, b]
      89% allUniqueNonNull [a, b]
  Testing RightDistributiveGCDMonoid laws for type Dual ByteString
    rightDistributiveGCDMonoidLaw_distributivity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      81% allUnique [a, b, c]
      78% allUniqueNonNull [a, b, c]
      36% commonSuffix a b /= mempty && c /= mempty
  Testing RightGCDMonoid laws for type Dual ByteString
    rightGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (commonSuffix a b) a /= mempty
      95% allNonNull [a, b]
      92% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      35% commonSuffix a b /= mempty
    rightGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (commonSuffix a b) b /= mempty
      95% allNonNull [a, b]
      92% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      35% commonSuffix a b /= mempty
    rightGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b]
      92% allUnique [a, b]
      91% antecedent == False
      91% consequent == False
      89% allUniqueNonNull [a, b]
       9% antecedent == True
       9% consequent == True
    rightGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    rightGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (96% a /= mempty).
    rightGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (96% a /= mempty).
    rightGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b]
      92% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      65% commonSuffix a b == mempty
      35% commonSuffix a b /= mempty
    rightGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      81% allUnique [a, b, c]
      78% allUniqueNonNull [a, b, c]
      26% commonSuffix (commonSuffix a b) c /= mempty
      26% commonSuffix a (commonSuffix b c) /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_commonSuffix [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b]
      92% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      35% commonSuffix a b /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b]
      92% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      17% stripCommonSuffix a b & \(x, _, s) -> x /= mempty && s /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b]
      92% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      19% stripCommonSuffix a b & \(_, x, s) -> x /= mempty && s /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_stripSuffix_1 [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b]
      92% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      17% stripCommonSuffix a b & \(x, _, s) -> x /= mempty && s /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_stripSuffix_2 [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b]
      92% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      19% stripCommonSuffix a b & \(_, x, s) -> x /= mempty && s /= mempty
  Testing RightReductive laws for type Dual ByteString
    rightReductiveLaw_isSuffixOf_mappend [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b]
      92% allUnique [a, b]
      89% allUniqueNonNull [a, b]
    rightReductiveLaw_isSuffixOf_stripSuffix [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b]
      92% allUnique [a, b]
      89% allUniqueNonNull [a, b]
    rightReductiveLaw_stripSuffix [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b]
      92% allUnique [a, b]
      89% allUniqueNonNull [a, b]
  Testing StableFactorial laws for type Dual ByteString
    stableFactorialLaw_factors_mappend [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b]
      92% allUnique [a, b]
      89% allUniqueNonNull [a, b]
    stableFactorialLaw_factors_reverse [✔]
      +++ OK, passed 100 tests.
    stableFactorialLaw_primePrefix_primeSuffix_reverse [✔]
      +++ OK, passed 100 tests.
    stableFactorialLaw_primeSuffix_primePrefix_reverse [✔]
      +++ OK, passed 100 tests.
  Testing Factorial laws for type Text
    factorialLaw_coverage [✔]
      +++ OK, passed 800 tests:
      96.9% length a >= 2
       1.9% length a == 0
       1.2% length a == 1
    factorialLaw_length_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors_reverse [✔]
      +++ OK, passed 100 tests.
    factorialLaw_all_factors_prime [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primePrefix_foldr [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primeSuffix_foldl [✔]
      +++ OK, passed 100 tests.
    factorialLaw_factors_foldl [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
    factorialLaw_factors_foldl' [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
    factorialLaw_factors_foldr [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
  Testing FactorialMonoid laws for type Text
    factorialMonoidLaw_coverage [✔]
      +++ OK, passed 800 tests:
      96.9% length a >= 2
       1.9% length a == 0
       1.2% length a == 1
    factorialMonoidLaw_null [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_reverse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_inits [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_tails [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_span [✔]
      +++ OK, passed 100 tests:
      96% any p (factors a)
      94% any (not . p) (factors a)
    factorialMonoidLaw_split [✔]
      +++ OK, passed 100 tests:
      96% any p (factors a)
      94% any (not . p) (factors a)
    factorialMonoidLaw_split_intersperse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitAt [✔]
      +++ OK, passed 100 tests.
  Testing LeftCancellative laws for type Text
    leftCancellativeLaw_cancellation [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
  Testing LeftDistributiveGCDMonoid laws for type Text
    leftDistributiveGCDMonoidLaw_distributivity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      82% allUnique [a, b, c]
      78% allUniqueNonNull [a, b, c]
      35% commonPrefix b c /= mempty && a /= mempty
  Testing LeftGCDMonoid laws for type Text
    leftGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) a /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      32% commonPrefix a b /= mempty
    leftGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) b /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      32% commonPrefix a b /= mempty
    leftGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      95% antecedent == False
      95% consequent == False
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
       5% antecedent == True
       5% consequent == True
    leftGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    leftGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    leftGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    leftGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      68% commonPrefix a b == mempty
      32% commonPrefix a b /= mempty
    leftGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      82% allUnique [a, b, c]
      78% allUniqueNonNull [a, b, c]
      27% commonPrefix (commonPrefix a b) c /= mempty
      27% commonPrefix a (commonPrefix b c) /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_commonPrefix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      32% commonPrefix a b /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      18% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      15% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_1 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      18% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_2 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      15% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
  Testing LeftReductive laws for type Text
    leftReductiveLaw_isPrefixOf_mappend [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
    leftReductiveLaw_isPrefixOf_stripPrefix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
    leftReductiveLaw_stripPrefix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
  Testing MonoidNull laws for type Text
    monoidNullLaw_basic [✔]
      +++ OK, passed 100 tests:
      97% a /= mempty
       3% a == mempty
  Testing OverlappingGCDMonoid laws for type Text
    overlappingGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (overlap a b) a /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      37% overlap a b /= mempty
    overlappingGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (overlap a b) b /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      37% overlap a b /= mempty
    overlappingGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    overlappingGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    overlappingGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    overlappingGCDMonoidLaw_overlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      21% overlap a b /= mempty && stripPrefixOverlap a b /= mempty
    overlappingGCDMonoidLaw_overlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      23% stripSuffixOverlap b a /= mempty && overlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_overlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      37% overlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      82% stripPrefixOverlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      84% stripSuffixOverlap b a /= mempty
  Testing PositiveMonoid laws for type Text
    positiveMonoidLaw_fundamental [✔]
      +++ OK, passed 400 tests:
      98.5% not (null (a <> b))
      96.0% allNonNull [a, b]
      91.0% allUnique [a, b]
      88.5% allUniqueNonNull [a, b]
       1.5% null (a <> b)
  Testing RightCancellative laws for type Text
    rightCancellativeLaw_cancellation [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
  Testing RightDistributiveGCDMonoid laws for type Text
    rightDistributiveGCDMonoidLaw_distributivity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      82% allUnique [a, b, c]
      78% allUniqueNonNull [a, b, c]
      38% commonSuffix a b /= mempty && c /= mempty
  Testing RightGCDMonoid laws for type Text
    rightGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (commonSuffix a b) a /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      34% commonSuffix a b /= mempty
    rightGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (commonSuffix a b) b /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      34% commonSuffix a b /= mempty
    rightGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      95% antecedent == False
      95% consequent == False
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
       5% antecedent == True
       5% consequent == True
    rightGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    rightGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    rightGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    rightGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      66% commonSuffix a b == mempty
      34% commonSuffix a b /= mempty
    rightGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      82% allUnique [a, b, c]
      78% allUniqueNonNull [a, b, c]
      28% commonSuffix (commonSuffix a b) c /= mempty
      28% commonSuffix a (commonSuffix b c) /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_commonSuffix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      34% commonSuffix a b /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      15% stripCommonSuffix a b & \(x, _, s) -> x /= mempty && s /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      18% stripCommonSuffix a b & \(_, x, s) -> x /= mempty && s /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_stripSuffix_1 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      15% stripCommonSuffix a b & \(x, _, s) -> x /= mempty && s /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_stripSuffix_2 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      18% stripCommonSuffix a b & \(_, x, s) -> x /= mempty && s /= mempty
  Testing RightReductive laws for type Text
    rightReductiveLaw_isSuffixOf_mappend [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
    rightReductiveLaw_isSuffixOf_stripSuffix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
    rightReductiveLaw_stripSuffix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
  Testing StableFactorial laws for type Text
    stableFactorialLaw_factors_mappend [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
    stableFactorialLaw_factors_reverse [✔]
      +++ OK, passed 100 tests.
    stableFactorialLaw_primePrefix_primeSuffix_reverse [✔]
      +++ OK, passed 100 tests.
    stableFactorialLaw_primeSuffix_primePrefix_reverse [✔]
      +++ OK, passed 100 tests.
  Testing Factorial laws for type Dual Text
    factorialLaw_coverage [✔]
      +++ OK, passed 800 tests:
      96.9% length a >= 2
       1.9% length a == 0
       1.2% length a == 1
    factorialLaw_length_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors_reverse [✔]
      +++ OK, passed 100 tests.
    factorialLaw_all_factors_prime [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primePrefix_foldr [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primeSuffix_foldl [✔]
      +++ OK, passed 100 tests.
    factorialLaw_factors_foldl [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
    factorialLaw_factors_foldl' [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
    factorialLaw_factors_foldr [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
  Testing FactorialMonoid laws for type Dual Text
    factorialMonoidLaw_coverage [✔]
      +++ OK, passed 800 tests:
      96.9% length a >= 2
       1.9% length a == 0
       1.2% length a == 1
    factorialMonoidLaw_null [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_reverse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_inits [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_tails [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_span [✔]
      +++ OK, passed 100 tests:
      96% any p (factors a)
      95% any (not . p) (factors a)
    factorialMonoidLaw_split [✔]
      +++ OK, passed 100 tests:
      96% any p (factors a)
      95% any (not . p) (factors a)
    factorialMonoidLaw_split_intersperse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitAt [✔]
      +++ OK, passed 100 tests.
  Testing LeftCancellative laws for type Dual Text
    leftCancellativeLaw_cancellation [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
  Testing LeftDistributiveGCDMonoid laws for type Dual Text
    leftDistributiveGCDMonoidLaw_distributivity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      82% allUnique [a, b, c]
      78% allUniqueNonNull [a, b, c]
      35% commonPrefix b c /= mempty && a /= mempty
  Testing LeftGCDMonoid laws for type Dual Text
    leftGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) a /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      32% commonPrefix a b /= mempty
    leftGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) b /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      32% commonPrefix a b /= mempty
    leftGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      95% antecedent == False
      95% consequent == False
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
       5% antecedent == True
       5% consequent == True
    leftGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    leftGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    leftGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    leftGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      68% commonPrefix a b == mempty
      32% commonPrefix a b /= mempty
    leftGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      82% allUnique [a, b, c]
      78% allUniqueNonNull [a, b, c]
      27% commonPrefix (commonPrefix a b) c /= mempty
      27% commonPrefix a (commonPrefix b c) /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_commonPrefix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      32% commonPrefix a b /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      18% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      15% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_1 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      18% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_2 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      15% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
  Testing LeftReductive laws for type Dual Text
    leftReductiveLaw_isPrefixOf_mappend [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
    leftReductiveLaw_isPrefixOf_stripPrefix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
    leftReductiveLaw_stripPrefix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
  Testing MonoidNull laws for type Dual Text
    monoidNullLaw_basic [✔]
      +++ OK, passed 100 tests:
      97% a /= mempty
       3% a == mempty
  Testing OverlappingGCDMonoid laws for type Dual Text
    overlappingGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (overlap a b) a /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      36% overlap a b /= mempty
    overlappingGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (overlap a b) b /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      36% overlap a b /= mempty
    overlappingGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    overlappingGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    overlappingGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    overlappingGCDMonoidLaw_overlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      20% overlap a b /= mempty && stripPrefixOverlap a b /= mempty
    overlappingGCDMonoidLaw_overlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      22% stripSuffixOverlap b a /= mempty && overlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_overlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      36% overlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      82% stripPrefixOverlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      84% stripSuffixOverlap b a /= mempty
  Testing PositiveMonoid laws for type Dual Text
    positiveMonoidLaw_fundamental [✔]
      +++ OK, passed 400 tests:
      98.5% not (null (a <> b))
      96.0% allNonNull [a, b]
      91.0% allUnique [a, b]
      88.5% allUniqueNonNull [a, b]
       1.5% null (a <> b)
  Testing RightCancellative laws for type Dual Text
    rightCancellativeLaw_cancellation [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
  Testing RightDistributiveGCDMonoid laws for type Dual Text
    rightDistributiveGCDMonoidLaw_distributivity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      82% allUnique [a, b, c]
      78% allUniqueNonNull [a, b, c]
      38% commonSuffix a b /= mempty && c /= mempty
  Testing RightGCDMonoid laws for type Dual Text
    rightGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (commonSuffix a b) a /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      34% commonSuffix a b /= mempty
    rightGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (commonSuffix a b) b /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      34% commonSuffix a b /= mempty
    rightGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      95% antecedent == False
      95% consequent == False
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
       5% antecedent == True
       5% consequent == True
    rightGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    rightGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    rightGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    rightGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      66% commonSuffix a b == mempty
      34% commonSuffix a b /= mempty
    rightGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      82% allUnique [a, b, c]
      78% allUniqueNonNull [a, b, c]
      28% commonSuffix (commonSuffix a b) c /= mempty
      28% commonSuffix a (commonSuffix b c) /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_commonSuffix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      34% commonSuffix a b /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      15% stripCommonSuffix a b & \(x, _, s) -> x /= mempty && s /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      18% stripCommonSuffix a b & \(_, x, s) -> x /= mempty && s /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_stripSuffix_1 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      15% stripCommonSuffix a b & \(x, _, s) -> x /= mempty && s /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_stripSuffix_2 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      18% stripCommonSuffix a b & \(_, x, s) -> x /= mempty && s /= mempty
  Testing RightReductive laws for type Dual Text
    rightReductiveLaw_isSuffixOf_mappend [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
    rightReductiveLaw_isSuffixOf_stripSuffix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
    rightReductiveLaw_stripSuffix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
  Testing StableFactorial laws for type Dual Text
    stableFactorialLaw_factors_mappend [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
    stableFactorialLaw_factors_reverse [✔]
      +++ OK, passed 100 tests.
    stableFactorialLaw_primePrefix_primeSuffix_reverse [✔]
      +++ OK, passed 100 tests.
    stableFactorialLaw_primeSuffix_primePrefix_reverse [✔]
      +++ OK, passed 100 tests.
  Testing Factorial laws for type [Small Int]
    factorialLaw_coverage [✔]
      +++ OK, passed 800 tests:
      96.9% length a >= 2
       1.9% length a == 0
       1.2% length a == 1
    factorialLaw_length_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors_reverse [✔]
      +++ OK, passed 100 tests.
    factorialLaw_all_factors_prime [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primePrefix_foldr [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primeSuffix_foldl [✔]
      +++ OK, passed 100 tests.
    factorialLaw_factors_foldl [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
    factorialLaw_factors_foldl' [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
    factorialLaw_factors_foldr [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
  Testing FactorialMonoid laws for type [Small Int]
    factorialMonoidLaw_coverage [✔]
      +++ OK, passed 800 tests:
      96.9% length a >= 2
       1.9% length a == 0
       1.2% length a == 1
    factorialMonoidLaw_null [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_reverse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_inits [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_tails [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_span [✔]
      +++ OK, passed 100 tests:
      97% any p (factors a)
      94% any (not . p) (factors a)
    factorialMonoidLaw_split [✔]
      +++ OK, passed 100 tests:
      97% any p (factors a)
      94% any (not . p) (factors a)
    factorialMonoidLaw_split_intersperse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitAt [✔]
      +++ OK, passed 100 tests.
  Testing LeftCancellative laws for type [Small Int]
    leftCancellativeLaw_cancellation [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
  Testing LeftDistributiveGCDMonoid laws for type [Small Int]
    leftDistributiveGCDMonoidLaw_distributivity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      81% allUnique [a, b, c]
      77% allUniqueNonNull [a, b, c]
      37% commonPrefix b c /= mempty && a /= mempty
  Testing LeftGCDMonoid laws for type [Small Int]
    leftGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) a /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      34% commonPrefix a b /= mempty
    leftGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) b /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      34% commonPrefix a b /= mempty
    leftGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      95% antecedent == False
      95% consequent == False
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
       5% antecedent == True
       5% consequent == True
    leftGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    leftGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    leftGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    leftGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      66% commonPrefix a b == mempty
      34% commonPrefix a b /= mempty
    leftGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      81% allUnique [a, b, c]
      77% allUniqueNonNull [a, b, c]
      29% commonPrefix (commonPrefix a b) c /= mempty
      29% commonPrefix a (commonPrefix b c) /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_commonPrefix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      34% commonPrefix a b /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      20% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      17% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_1 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      20% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_2 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      17% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
  Testing LeftReductive laws for type [Small Int]
    leftReductiveLaw_isPrefixOf_mappend [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
    leftReductiveLaw_isPrefixOf_stripPrefix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
    leftReductiveLaw_stripPrefix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
  Testing MonoidNull laws for type [Small Int]
    monoidNullLaw_basic [✔]
      +++ OK, passed 100 tests:
      97% a /= mempty
       3% a == mempty
  Testing OverlappingGCDMonoid laws for type [Small Int]
    overlappingGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (overlap a b) a /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      37% overlap a b /= mempty
    overlappingGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (overlap a b) b /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      37% overlap a b /= mempty
    overlappingGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    overlappingGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    overlappingGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    overlappingGCDMonoidLaw_overlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      20% overlap a b /= mempty && stripPrefixOverlap a b /= mempty
    overlappingGCDMonoidLaw_overlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      23% stripSuffixOverlap b a /= mempty && overlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_overlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      37% overlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      81% stripPrefixOverlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      84% stripSuffixOverlap b a /= mempty
  Testing PositiveMonoid laws for type [Small Int]
    positiveMonoidLaw_fundamental [✔]
      +++ OK, passed 400 tests:
      98.5% not (null (a <> b))
      96.0% allNonNull [a, b]
      90.8% allUnique [a, b]
      88.2% allUniqueNonNull [a, b]
       1.5% null (a <> b)
  Testing RightCancellative laws for type [Small Int]
    rightCancellativeLaw_cancellation [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
  Testing RightDistributiveGCDMonoid laws for type [Small Int]
    rightDistributiveGCDMonoidLaw_distributivity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      81% allUnique [a, b, c]
      77% allUniqueNonNull [a, b, c]
      39% commonSuffix a b /= mempty && c /= mempty
  Testing RightGCDMonoid laws for type [Small Int]
    rightGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (commonSuffix a b) a /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      37% commonSuffix a b /= mempty
    rightGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (commonSuffix a b) b /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      37% commonSuffix a b /= mempty
    rightGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      97% antecedent == False
      97% consequent == False
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
       3% antecedent == True
       3% consequent == True
    rightGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    rightGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    rightGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    rightGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      63% commonSuffix a b == mempty
      37% commonSuffix a b /= mempty
    rightGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      81% allUnique [a, b, c]
      77% allUniqueNonNull [a, b, c]
      29% commonSuffix (commonSuffix a b) c /= mempty
      29% commonSuffix a (commonSuffix b c) /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_commonSuffix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      37% commonSuffix a b /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      17% stripCommonSuffix a b & \(x, _, s) -> x /= mempty && s /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      20% stripCommonSuffix a b & \(_, x, s) -> x /= mempty && s /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_stripSuffix_1 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      17% stripCommonSuffix a b & \(x, _, s) -> x /= mempty && s /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_stripSuffix_2 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      20% stripCommonSuffix a b & \(_, x, s) -> x /= mempty && s /= mempty
  Testing RightReductive laws for type [Small Int]
    rightReductiveLaw_isSuffixOf_mappend [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
    rightReductiveLaw_isSuffixOf_stripSuffix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
    rightReductiveLaw_stripSuffix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
  Testing StableFactorial laws for type [Small Int]
    stableFactorialLaw_factors_mappend [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
    stableFactorialLaw_factors_reverse [✔]
      +++ OK, passed 100 tests.
    stableFactorialLaw_primePrefix_primeSuffix_reverse [✔]
      +++ OK, passed 100 tests.
    stableFactorialLaw_primeSuffix_primePrefix_reverse [✔]
      +++ OK, passed 100 tests.
  Testing Factorial laws for type Dual [Small Int]
    factorialLaw_coverage [✔]
      +++ OK, passed 800 tests:
      96.9% length a >= 2
       1.9% length a == 0
       1.2% length a == 1
    factorialLaw_length_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors_reverse [✔]
      +++ OK, passed 100 tests.
    factorialLaw_all_factors_prime [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primePrefix_foldr [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primeSuffix_foldl [✔]
      +++ OK, passed 100 tests.
    factorialLaw_factors_foldl [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
    factorialLaw_factors_foldl' [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
    factorialLaw_factors_foldr [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
  Testing FactorialMonoid laws for type Dual [Small Int]
    factorialMonoidLaw_coverage [✔]
      +++ OK, passed 800 tests:
      96.9% length a >= 2
       1.9% length a == 0
       1.2% length a == 1
    factorialMonoidLaw_null [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_reverse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_inits [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_tails [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_span [✔]
      +++ OK, passed 100 tests:
      96% any p (factors a)
      95% any (not . p) (factors a)
    factorialMonoidLaw_split [✔]
      +++ OK, passed 100 tests:
      96% any p (factors a)
      95% any (not . p) (factors a)
    factorialMonoidLaw_split_intersperse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitAt [✔]
      +++ OK, passed 100 tests.
  Testing LeftCancellative laws for type Dual [Small Int]
    leftCancellativeLaw_cancellation [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
  Testing LeftDistributiveGCDMonoid laws for type Dual [Small Int]
    leftDistributiveGCDMonoidLaw_distributivity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      81% allUnique [a, b, c]
      77% allUniqueNonNull [a, b, c]
      37% commonPrefix b c /= mempty && a /= mempty
  Testing LeftGCDMonoid laws for type Dual [Small Int]
    leftGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) a /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      35% commonPrefix a b /= mempty
    leftGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) b /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      35% commonPrefix a b /= mempty
    leftGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      96% antecedent == False
      96% consequent == False
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
       4% antecedent == True
       4% consequent == True
    leftGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    leftGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    leftGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    leftGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      65% commonPrefix a b == mempty
      35% commonPrefix a b /= mempty
    leftGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      81% allUnique [a, b, c]
      77% allUniqueNonNull [a, b, c]
      29% commonPrefix (commonPrefix a b) c /= mempty
      29% commonPrefix a (commonPrefix b c) /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_commonPrefix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      35% commonPrefix a b /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      21% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      17% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_1 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      21% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_2 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      17% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
  Testing LeftReductive laws for type Dual [Small Int]
    leftReductiveLaw_isPrefixOf_mappend [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
    leftReductiveLaw_isPrefixOf_stripPrefix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
    leftReductiveLaw_stripPrefix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
  Testing MonoidNull laws for type Dual [Small Int]
    monoidNullLaw_basic [✔]
      +++ OK, passed 100 tests:
      97% a /= mempty
       3% a == mempty
  Testing OverlappingGCDMonoid laws for type Dual [Small Int]
    overlappingGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (overlap a b) a /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      38% overlap a b /= mempty
    overlappingGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (overlap a b) b /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      38% overlap a b /= mempty
    overlappingGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    overlappingGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    overlappingGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    overlappingGCDMonoidLaw_overlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      22% overlap a b /= mempty && stripPrefixOverlap a b /= mempty
    overlappingGCDMonoidLaw_overlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      24% stripSuffixOverlap b a /= mempty && overlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_overlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      38% overlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      82% stripPrefixOverlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      84% stripSuffixOverlap b a /= mempty
  Testing PositiveMonoid laws for type Dual [Small Int]
    positiveMonoidLaw_fundamental [✔]
      +++ OK, passed 400 tests:
      98.5% not (null (a <> b))
      96.0% allNonNull [a, b]
      90.8% allUnique [a, b]
      88.2% allUniqueNonNull [a, b]
       1.5% null (a <> b)
  Testing RightCancellative laws for type Dual [Small Int]
    rightCancellativeLaw_cancellation [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
  Testing RightDistributiveGCDMonoid laws for type Dual [Small Int]
    rightDistributiveGCDMonoidLaw_distributivity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      81% allUnique [a, b, c]
      77% allUniqueNonNull [a, b, c]
      39% commonSuffix a b /= mempty && c /= mempty
  Testing RightGCDMonoid laws for type Dual [Small Int]
    rightGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (commonSuffix a b) a /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      36% commonSuffix a b /= mempty
    rightGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (commonSuffix a b) b /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      36% commonSuffix a b /= mempty
    rightGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      96% antecedent == False
      96% consequent == False
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
       4% antecedent == True
       4% consequent == True
    rightGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    rightGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    rightGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    rightGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      64% commonSuffix a b == mempty
      36% commonSuffix a b /= mempty
    rightGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      81% allUnique [a, b, c]
      77% allUniqueNonNull [a, b, c]
      29% commonSuffix (commonSuffix a b) c /= mempty
      29% commonSuffix a (commonSuffix b c) /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_commonSuffix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      36% commonSuffix a b /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      16% stripCommonSuffix a b & \(x, _, s) -> x /= mempty && s /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      20% stripCommonSuffix a b & \(_, x, s) -> x /= mempty && s /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_stripSuffix_1 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      16% stripCommonSuffix a b & \(x, _, s) -> x /= mempty && s /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_stripSuffix_2 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      20% stripCommonSuffix a b & \(_, x, s) -> x /= mempty && s /= mempty
  Testing RightReductive laws for type Dual [Small Int]
    rightReductiveLaw_isSuffixOf_mappend [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
    rightReductiveLaw_isSuffixOf_stripSuffix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
    rightReductiveLaw_stripSuffix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
  Testing StableFactorial laws for type Dual [Small Int]
    stableFactorialLaw_factors_mappend [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
    stableFactorialLaw_factors_reverse [✔]
      +++ OK, passed 100 tests.
    stableFactorialLaw_primePrefix_primeSuffix_reverse [✔]
      +++ OK, passed 100 tests.
    stableFactorialLaw_primeSuffix_primePrefix_reverse [✔]
      +++ OK, passed 100 tests.
  Testing Factorial laws for type Seq (Small Int)
    factorialLaw_coverage [✔]
      +++ OK, passed 800 tests:
      96.9% length a >= 2
       1.9% length a == 0
       1.2% length a == 1
    factorialLaw_length_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors_reverse [✔]
      +++ OK, passed 100 tests.
    factorialLaw_all_factors_prime [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primePrefix_foldr [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primeSuffix_foldl [✔]
      +++ OK, passed 100 tests.
    factorialLaw_factors_foldl [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
    factorialLaw_factors_foldl' [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
    factorialLaw_factors_foldr [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
  Testing FactorialMonoid laws for type Seq (Small Int)
    factorialMonoidLaw_coverage [✔]
      +++ OK, passed 800 tests:
      96.9% length a >= 2
       1.9% length a == 0
       1.2% length a == 1
    factorialMonoidLaw_null [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_reverse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_inits [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_tails [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_span [✔]
      +++ OK, passed 100 tests:
      96% any p (factors a)
      94% any (not . p) (factors a)
    factorialMonoidLaw_split [✔]
      +++ OK, passed 100 tests:
      96% any p (factors a)
      94% any (not . p) (factors a)
    factorialMonoidLaw_split_intersperse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitAt [✔]
      +++ OK, passed 100 tests.
  Testing LeftCancellative laws for type Seq (Small Int)
    leftCancellativeLaw_cancellation [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
  Testing LeftDistributiveGCDMonoid laws for type Seq (Small Int)
    leftDistributiveGCDMonoidLaw_distributivity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      81% allUnique [a, b, c]
      77% allUniqueNonNull [a, b, c]
      37% commonPrefix b c /= mempty && a /= mempty
  Testing LeftGCDMonoid laws for type Seq (Small Int)
    leftGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) a /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      34% commonPrefix a b /= mempty
    leftGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) b /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      34% commonPrefix a b /= mempty
    leftGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      95% antecedent == False
      95% consequent == False
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
       5% antecedent == True
       5% consequent == True
    leftGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    leftGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    leftGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    leftGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      66% commonPrefix a b == mempty
      34% commonPrefix a b /= mempty
    leftGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      81% allUnique [a, b, c]
      77% allUniqueNonNull [a, b, c]
      29% commonPrefix (commonPrefix a b) c /= mempty
      29% commonPrefix a (commonPrefix b c) /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_commonPrefix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      34% commonPrefix a b /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      20% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      17% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_1 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      20% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_2 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      17% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
  Testing LeftReductive laws for type Seq (Small Int)
    leftReductiveLaw_isPrefixOf_mappend [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
    leftReductiveLaw_isPrefixOf_stripPrefix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
    leftReductiveLaw_stripPrefix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
  Testing MonoidNull laws for type Seq (Small Int)
    monoidNullLaw_basic [✔]
      +++ OK, passed 100 tests:
      97% a /= mempty
       3% a == mempty
  Testing OverlappingGCDMonoid laws for type Seq (Small Int)
    overlappingGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (overlap a b) a /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      37% overlap a b /= mempty
    overlappingGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (overlap a b) b /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      37% overlap a b /= mempty
    overlappingGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    overlappingGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    overlappingGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    overlappingGCDMonoidLaw_overlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      20% overlap a b /= mempty && stripPrefixOverlap a b /= mempty
    overlappingGCDMonoidLaw_overlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      23% stripSuffixOverlap b a /= mempty && overlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_overlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      37% overlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      81% stripPrefixOverlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      84% stripSuffixOverlap b a /= mempty
  Testing PositiveMonoid laws for type Seq (Small Int)
    positiveMonoidLaw_fundamental [✔]
      +++ OK, passed 400 tests:
      98.5% not (null (a <> b))
      96.0% allNonNull [a, b]
      90.8% allUnique [a, b]
      88.2% allUniqueNonNull [a, b]
       1.5% null (a <> b)
  Testing RightCancellative laws for type Seq (Small Int)
    rightCancellativeLaw_cancellation [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
  Testing RightDistributiveGCDMonoid laws for type Seq (Small Int)
    rightDistributiveGCDMonoidLaw_distributivity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      81% allUnique [a, b, c]
      77% allUniqueNonNull [a, b, c]
      39% commonSuffix a b /= mempty && c /= mempty
  Testing RightGCDMonoid laws for type Seq (Small Int)
    rightGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (commonSuffix a b) a /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      37% commonSuffix a b /= mempty
    rightGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (commonSuffix a b) b /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      37% commonSuffix a b /= mempty
    rightGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      97% antecedent == False
      97% consequent == False
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
       3% antecedent == True
       3% consequent == True
    rightGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    rightGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    rightGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    rightGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      63% commonSuffix a b == mempty
      37% commonSuffix a b /= mempty
    rightGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      81% allUnique [a, b, c]
      77% allUniqueNonNull [a, b, c]
      29% commonSuffix (commonSuffix a b) c /= mempty
      29% commonSuffix a (commonSuffix b c) /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_commonSuffix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      37% commonSuffix a b /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      17% stripCommonSuffix a b & \(x, _, s) -> x /= mempty && s /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      20% stripCommonSuffix a b & \(_, x, s) -> x /= mempty && s /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_stripSuffix_1 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      17% stripCommonSuffix a b & \(x, _, s) -> x /= mempty && s /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_stripSuffix_2 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      20% stripCommonSuffix a b & \(_, x, s) -> x /= mempty && s /= mempty
  Testing RightReductive laws for type Seq (Small Int)
    rightReductiveLaw_isSuffixOf_mappend [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
    rightReductiveLaw_isSuffixOf_stripSuffix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
    rightReductiveLaw_stripSuffix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
  Testing StableFactorial laws for type Seq (Small Int)
    stableFactorialLaw_factors_mappend [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
    stableFactorialLaw_factors_reverse [✔]
      +++ OK, passed 100 tests.
    stableFactorialLaw_primePrefix_primeSuffix_reverse [✔]
      +++ OK, passed 100 tests.
    stableFactorialLaw_primeSuffix_primePrefix_reverse [✔]
      +++ OK, passed 100 tests.
  Testing Factorial laws for type Dual (Seq (Small Int))
    factorialLaw_coverage [✔]
      +++ OK, passed 800 tests:
      96.9% length a >= 2
       1.9% length a == 0
       1.2% length a == 1
    factorialLaw_length_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors_reverse [✔]
      +++ OK, passed 100 tests.
    factorialLaw_all_factors_prime [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primePrefix_foldr [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primeSuffix_foldl [✔]
      +++ OK, passed 100 tests.
    factorialLaw_factors_foldl [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
    factorialLaw_factors_foldl' [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
    factorialLaw_factors_foldr [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
  Testing FactorialMonoid laws for type Dual (Seq (Small Int))
    factorialMonoidLaw_coverage [✔]
      +++ OK, passed 800 tests:
      96.9% length a >= 2
       1.9% length a == 0
       1.2% length a == 1
    factorialMonoidLaw_null [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_reverse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_inits [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_tails [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_span [✔]
      +++ OK, passed 100 tests:
      96% any p (factors a)
      94% any (not . p) (factors a)
    factorialMonoidLaw_split [✔]
      +++ OK, passed 100 tests:
      96% any p (factors a)
      94% any (not . p) (factors a)
    factorialMonoidLaw_split_intersperse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitAt [✔]
      +++ OK, passed 100 tests.
  Testing LeftCancellative laws for type Dual (Seq (Small Int))
    leftCancellativeLaw_cancellation [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
  Testing LeftDistributiveGCDMonoid laws for type Dual (Seq (Small Int))
    leftDistributiveGCDMonoidLaw_distributivity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      81% allUnique [a, b, c]
      77% allUniqueNonNull [a, b, c]
      37% commonPrefix b c /= mempty && a /= mempty
  Testing LeftGCDMonoid laws for type Dual (Seq (Small Int))
    leftGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) a /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      35% commonPrefix a b /= mempty
    leftGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) b /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      35% commonPrefix a b /= mempty
    leftGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      96% antecedent == False
      96% consequent == False
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
       4% antecedent == True
       4% consequent == True
    leftGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    leftGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    leftGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    leftGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      65% commonPrefix a b == mempty
      35% commonPrefix a b /= mempty
    leftGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      81% allUnique [a, b, c]
      77% allUniqueNonNull [a, b, c]
      29% commonPrefix (commonPrefix a b) c /= mempty
      29% commonPrefix a (commonPrefix b c) /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_commonPrefix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      35% commonPrefix a b /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      21% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      17% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_1 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      21% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_2 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      17% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
  Testing LeftReductive laws for type Dual (Seq (Small Int))
    leftReductiveLaw_isPrefixOf_mappend [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
    leftReductiveLaw_isPrefixOf_stripPrefix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
    leftReductiveLaw_stripPrefix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
  Testing MonoidNull laws for type Dual (Seq (Small Int))
    monoidNullLaw_basic [✔]
      +++ OK, passed 100 tests:
      97% a /= mempty
       3% a == mempty
  Testing OverlappingGCDMonoid laws for type Dual (Seq (Small Int))
    overlappingGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (overlap a b) a /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      38% overlap a b /= mempty
    overlappingGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (overlap a b) b /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      38% overlap a b /= mempty
    overlappingGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    overlappingGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    overlappingGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    overlappingGCDMonoidLaw_overlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      22% overlap a b /= mempty && stripPrefixOverlap a b /= mempty
    overlappingGCDMonoidLaw_overlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      24% stripSuffixOverlap b a /= mempty && overlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_overlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      38% overlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      82% stripPrefixOverlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      84% stripSuffixOverlap b a /= mempty
  Testing PositiveMonoid laws for type Dual (Seq (Small Int))
    positiveMonoidLaw_fundamental [✔]
      +++ OK, passed 400 tests:
      98.5% not (null (a <> b))
      96.0% allNonNull [a, b]
      90.8% allUnique [a, b]
      88.2% allUniqueNonNull [a, b]
       1.5% null (a <> b)
  Testing RightCancellative laws for type Dual (Seq (Small Int))
    rightCancellativeLaw_cancellation [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
  Testing RightDistributiveGCDMonoid laws for type Dual (Seq (Small Int))
    rightDistributiveGCDMonoidLaw_distributivity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      81% allUnique [a, b, c]
      77% allUniqueNonNull [a, b, c]
      39% commonSuffix a b /= mempty && c /= mempty
  Testing RightGCDMonoid laws for type Dual (Seq (Small Int))
    rightGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (commonSuffix a b) a /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      36% commonSuffix a b /= mempty
    rightGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (commonSuffix a b) b /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      36% commonSuffix a b /= mempty
    rightGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      96% antecedent == False
      96% consequent == False
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
       4% antecedent == True
       4% consequent == True
    rightGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    rightGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    rightGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    rightGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      64% commonSuffix a b == mempty
      36% commonSuffix a b /= mempty
    rightGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      81% allUnique [a, b, c]
      77% allUniqueNonNull [a, b, c]
      29% commonSuffix (commonSuffix a b) c /= mempty
      29% commonSuffix a (commonSuffix b c) /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_commonSuffix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      36% commonSuffix a b /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      16% stripCommonSuffix a b & \(x, _, s) -> x /= mempty && s /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      20% stripCommonSuffix a b & \(_, x, s) -> x /= mempty && s /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_stripSuffix_1 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      16% stripCommonSuffix a b & \(x, _, s) -> x /= mempty && s /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_stripSuffix_2 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      20% stripCommonSuffix a b & \(_, x, s) -> x /= mempty && s /= mempty
  Testing RightReductive laws for type Dual (Seq (Small Int))
    rightReductiveLaw_isSuffixOf_mappend [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
    rightReductiveLaw_isSuffixOf_stripSuffix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
    rightReductiveLaw_stripSuffix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
  Testing StableFactorial laws for type Dual (Seq (Small Int))
    stableFactorialLaw_factors_mappend [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
    stableFactorialLaw_factors_reverse [✔]
      +++ OK, passed 100 tests.
    stableFactorialLaw_primePrefix_primeSuffix_reverse [✔]
      +++ OK, passed 100 tests.
    stableFactorialLaw_primeSuffix_primePrefix_reverse [✔]
      +++ OK, passed 100 tests.
  Testing Factorial laws for type Vector (Small Int)
    factorialLaw_coverage [✔]
      +++ OK, passed 800 tests:
      96.9% length a >= 2
       1.9% length a == 0
       1.2% length a == 1
    factorialLaw_length_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors_reverse [✔]
      +++ OK, passed 100 tests.
    factorialLaw_all_factors_prime [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primePrefix_foldr [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primeSuffix_foldl [✔]
      +++ OK, passed 100 tests.
    factorialLaw_factors_foldl [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
    factorialLaw_factors_foldl' [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
    factorialLaw_factors_foldr [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
  Testing FactorialMonoid laws for type Vector (Small Int)
    factorialMonoidLaw_coverage [✔]
      +++ OK, passed 800 tests:
      96.9% length a >= 2
       1.9% length a == 0
       1.2% length a == 1
    factorialMonoidLaw_null [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_reverse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_inits [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_tails [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_span [✔]
      +++ OK, passed 100 tests:
      97% any p (factors a)
      94% any (not . p) (factors a)
    factorialMonoidLaw_split [✔]
      +++ OK, passed 100 tests:
      97% any p (factors a)
      94% any (not . p) (factors a)
    factorialMonoidLaw_split_intersperse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitAt [✔]
      +++ OK, passed 100 tests.
  Testing LeftCancellative laws for type Vector (Small Int)
    leftCancellativeLaw_cancellation [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
  Testing LeftDistributiveGCDMonoid laws for type Vector (Small Int)
    leftDistributiveGCDMonoidLaw_distributivity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      81% allUnique [a, b, c]
      77% allUniqueNonNull [a, b, c]
      37% commonPrefix b c /= mempty && a /= mempty
  Testing LeftGCDMonoid laws for type Vector (Small Int)
    leftGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) a /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      34% commonPrefix a b /= mempty
    leftGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) b /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      34% commonPrefix a b /= mempty
    leftGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      95% antecedent == False
      95% consequent == False
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
       5% antecedent == True
       5% consequent == True
    leftGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    leftGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    leftGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    leftGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      66% commonPrefix a b == mempty
      34% commonPrefix a b /= mempty
    leftGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      81% allUnique [a, b, c]
      77% allUniqueNonNull [a, b, c]
      29% commonPrefix (commonPrefix a b) c /= mempty
      29% commonPrefix a (commonPrefix b c) /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_commonPrefix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      34% commonPrefix a b /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      20% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      17% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_1 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      20% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_2 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      17% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
  Testing LeftReductive laws for type Vector (Small Int)
    leftReductiveLaw_isPrefixOf_mappend [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
    leftReductiveLaw_isPrefixOf_stripPrefix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
    leftReductiveLaw_stripPrefix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
  Testing MonoidNull laws for type Vector (Small Int)
    monoidNullLaw_basic [✔]
      +++ OK, passed 100 tests:
      97% a /= mempty
       3% a == mempty
  Testing OverlappingGCDMonoid laws for type Vector (Small Int)
    overlappingGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (overlap a b) a /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      37% overlap a b /= mempty
    overlappingGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (overlap a b) b /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      37% overlap a b /= mempty
    overlappingGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    overlappingGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    overlappingGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    overlappingGCDMonoidLaw_overlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      20% overlap a b /= mempty && stripPrefixOverlap a b /= mempty
    overlappingGCDMonoidLaw_overlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      23% stripSuffixOverlap b a /= mempty && overlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_overlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      37% overlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      81% stripPrefixOverlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      84% stripSuffixOverlap b a /= mempty
  Testing PositiveMonoid laws for type Vector (Small Int)
    positiveMonoidLaw_fundamental [✔]
      +++ OK, passed 400 tests:
      98.5% not (null (a <> b))
      96.0% allNonNull [a, b]
      90.8% allUnique [a, b]
      88.2% allUniqueNonNull [a, b]
       1.5% null (a <> b)
  Testing RightCancellative laws for type Vector (Small Int)
    rightCancellativeLaw_cancellation [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
  Testing RightDistributiveGCDMonoid laws for type Vector (Small Int)
    rightDistributiveGCDMonoidLaw_distributivity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      81% allUnique [a, b, c]
      77% allUniqueNonNull [a, b, c]
      39% commonSuffix a b /= mempty && c /= mempty
  Testing RightGCDMonoid laws for type Vector (Small Int)
    rightGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (commonSuffix a b) a /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      37% commonSuffix a b /= mempty
    rightGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (commonSuffix a b) b /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      37% commonSuffix a b /= mempty
    rightGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      97% antecedent == False
      97% consequent == False
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
       3% antecedent == True
       3% consequent == True
    rightGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    rightGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    rightGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    rightGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      63% commonSuffix a b == mempty
      37% commonSuffix a b /= mempty
    rightGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      81% allUnique [a, b, c]
      77% allUniqueNonNull [a, b, c]
      29% commonSuffix (commonSuffix a b) c /= mempty
      29% commonSuffix a (commonSuffix b c) /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_commonSuffix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      37% commonSuffix a b /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      17% stripCommonSuffix a b & \(x, _, s) -> x /= mempty && s /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      20% stripCommonSuffix a b & \(_, x, s) -> x /= mempty && s /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_stripSuffix_1 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      17% stripCommonSuffix a b & \(x, _, s) -> x /= mempty && s /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_stripSuffix_2 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      20% stripCommonSuffix a b & \(_, x, s) -> x /= mempty && s /= mempty
  Testing RightReductive laws for type Vector (Small Int)
    rightReductiveLaw_isSuffixOf_mappend [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
    rightReductiveLaw_isSuffixOf_stripSuffix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
    rightReductiveLaw_stripSuffix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
  Testing StableFactorial laws for type Vector (Small Int)
    stableFactorialLaw_factors_mappend [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
    stableFactorialLaw_factors_reverse [✔]
      +++ OK, passed 100 tests.
    stableFactorialLaw_primePrefix_primeSuffix_reverse [✔]
      +++ OK, passed 100 tests.
    stableFactorialLaw_primeSuffix_primePrefix_reverse [✔]
      +++ OK, passed 100 tests.
  Testing Factorial laws for type Dual (Vector (Small Int))
    factorialLaw_coverage [✔]
      +++ OK, passed 800 tests:
      96.9% length a >= 2
       1.9% length a == 0
       1.2% length a == 1
    factorialLaw_length_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors_reverse [✔]
      +++ OK, passed 100 tests.
    factorialLaw_all_factors_prime [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primePrefix_foldr [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primeSuffix_foldl [✔]
      +++ OK, passed 100 tests.
    factorialLaw_factors_foldl [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
    factorialLaw_factors_foldl' [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
    factorialLaw_factors_foldr [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
  Testing FactorialMonoid laws for type Dual (Vector (Small Int))
    factorialMonoidLaw_coverage [✔]
      +++ OK, passed 800 tests:
      96.9% length a >= 2
       1.9% length a == 0
       1.2% length a == 1
    factorialMonoidLaw_null [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_reverse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_inits [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_tails [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_span [✔]
      +++ OK, passed 100 tests:
      96% any p (factors a)
      95% any (not . p) (factors a)
    factorialMonoidLaw_split [✔]
      +++ OK, passed 100 tests:
      96% any p (factors a)
      95% any (not . p) (factors a)
    factorialMonoidLaw_split_intersperse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitAt [✔]
      +++ OK, passed 100 tests.
  Testing LeftCancellative laws for type Dual (Vector (Small Int))
    leftCancellativeLaw_cancellation [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
  Testing LeftDistributiveGCDMonoid laws for type Dual (Vector (Small Int))
    leftDistributiveGCDMonoidLaw_distributivity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      81% allUnique [a, b, c]
      77% allUniqueNonNull [a, b, c]
      37% commonPrefix b c /= mempty && a /= mempty
  Testing LeftGCDMonoid laws for type Dual (Vector (Small Int))
    leftGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) a /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      35% commonPrefix a b /= mempty
    leftGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) b /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      35% commonPrefix a b /= mempty
    leftGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      96% antecedent == False
      96% consequent == False
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
       4% antecedent == True
       4% consequent == True
    leftGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    leftGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    leftGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    leftGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      65% commonPrefix a b == mempty
      35% commonPrefix a b /= mempty
    leftGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      81% allUnique [a, b, c]
      77% allUniqueNonNull [a, b, c]
      29% commonPrefix (commonPrefix a b) c /= mempty
      29% commonPrefix a (commonPrefix b c) /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_commonPrefix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      35% commonPrefix a b /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      21% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      17% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_1 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      21% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_2 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      17% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
  Testing LeftReductive laws for type Dual (Vector (Small Int))
    leftReductiveLaw_isPrefixOf_mappend [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
    leftReductiveLaw_isPrefixOf_stripPrefix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
    leftReductiveLaw_stripPrefix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
  Testing MonoidNull laws for type Dual (Vector (Small Int))
    monoidNullLaw_basic [✔]
      +++ OK, passed 100 tests:
      97% a /= mempty
       3% a == mempty
  Testing OverlappingGCDMonoid laws for type Dual (Vector (Small Int))
    overlappingGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (overlap a b) a /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      38% overlap a b /= mempty
    overlappingGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (overlap a b) b /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      38% overlap a b /= mempty
    overlappingGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    overlappingGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    overlappingGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    overlappingGCDMonoidLaw_overlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      22% overlap a b /= mempty && stripPrefixOverlap a b /= mempty
    overlappingGCDMonoidLaw_overlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      24% stripSuffixOverlap b a /= mempty && overlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_overlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      38% overlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      82% stripPrefixOverlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      84% stripSuffixOverlap b a /= mempty
  Testing PositiveMonoid laws for type Dual (Vector (Small Int))
    positiveMonoidLaw_fundamental [✔]
      +++ OK, passed 400 tests:
      98.5% not (null (a <> b))
      96.0% allNonNull [a, b]
      90.8% allUnique [a, b]
      88.2% allUniqueNonNull [a, b]
       1.5% null (a <> b)
  Testing RightCancellative laws for type Dual (Vector (Small Int))
    rightCancellativeLaw_cancellation [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
  Testing RightDistributiveGCDMonoid laws for type Dual (Vector (Small Int))
    rightDistributiveGCDMonoidLaw_distributivity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      81% allUnique [a, b, c]
      77% allUniqueNonNull [a, b, c]
      39% commonSuffix a b /= mempty && c /= mempty
  Testing RightGCDMonoid laws for type Dual (Vector (Small Int))
    rightGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (commonSuffix a b) a /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      36% commonSuffix a b /= mempty
    rightGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (commonSuffix a b) b /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      36% commonSuffix a b /= mempty
    rightGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      96% antecedent == False
      96% consequent == False
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
       4% antecedent == True
       4% consequent == True
    rightGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    rightGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    rightGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    rightGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      64% commonSuffix a b == mempty
      36% commonSuffix a b /= mempty
    rightGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      81% allUnique [a, b, c]
      77% allUniqueNonNull [a, b, c]
      29% commonSuffix (commonSuffix a b) c /= mempty
      29% commonSuffix a (commonSuffix b c) /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_commonSuffix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      36% commonSuffix a b /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      16% stripCommonSuffix a b & \(x, _, s) -> x /= mempty && s /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      20% stripCommonSuffix a b & \(_, x, s) -> x /= mempty && s /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_stripSuffix_1 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      16% stripCommonSuffix a b & \(x, _, s) -> x /= mempty && s /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_stripSuffix_2 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
      20% stripCommonSuffix a b & \(_, x, s) -> x /= mempty && s /= mempty
  Testing RightReductive laws for type Dual (Vector (Small Int))
    rightReductiveLaw_isSuffixOf_mappend [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
    rightReductiveLaw_isSuffixOf_stripSuffix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
    rightReductiveLaw_stripSuffix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
  Testing StableFactorial laws for type Dual (Vector (Small Int))
    stableFactorialLaw_factors_mappend [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      89% allUniqueNonNull [a, b]
    stableFactorialLaw_factors_reverse [✔]
      +++ OK, passed 100 tests.
    stableFactorialLaw_primePrefix_primeSuffix_reverse [✔]
      +++ OK, passed 100 tests.
    stableFactorialLaw_primeSuffix_primePrefix_reverse [✔]
      +++ OK, passed 100 tests.
  Testing Commutative laws for type Set (Small Int)
    commutativeLaw_basic [✔]
      +++ OK, passed 100 tests:
      84% allUnique [a, b]
      34% (a /= b) && (a <> b /= a) && (b <> a /= b)
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
  Testing DistributiveGCDMonoid laws for type Set (Small Int)
    distributiveGCDMonoidLaw_distributivity_left [✔]
      +++ OK, passed 100 tests:
      68% allUnique [a, b, c]
      34% allNonNull [a, b, c]
      30% allUniqueNonNull [a, b, c]
    distributiveGCDMonoidLaw_distributivity_right [✔]
      +++ OK, passed 100 tests:
      68% allUnique [a, b, c]
      34% allNonNull [a, b, c]
      30% allUniqueNonNull [a, b, c]
  Testing DistributiveLCMMonoid laws for type Set (Small Int)
    distributiveLCMMonoidLaw_distributivity_left [✔]
      +++ OK, passed 100 tests:
      68% allUnique [a, b, c]
      34% allNonNull [a, b, c]
      30% allUniqueNonNull [a, b, c]
    distributiveLCMMonoidLaw_distributivity_right [✔]
      +++ OK, passed 100 tests:
      68% allUnique [a, b, c]
      34% allNonNull [a, b, c]
      30% allUniqueNonNull [a, b, c]
    distributiveLCMMonoidLaw_distributivity_gcd_lcm [✔]
      +++ OK, passed 100 tests:
      68% allUnique [a, b, c]
      34% allNonNull [a, b, c]
      30% allUniqueNonNull [a, b, c]
    distributiveLCMMonoidLaw_distributivity_lcm_gcd [✔]
      +++ OK, passed 100 tests:
      68% allUnique [a, b, c]
      34% allNonNull [a, b, c]
      30% allUniqueNonNull [a, b, c]
  Testing Factorial laws for type Set (Small Int)
    factorialLaw_coverage [✔]
      +++ OK, passed 400 tests:
      96.2% length a >= 2
       2.0% length a == 1
       1.8% length a == 0
    factorialLaw_length_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors_reverse [✔]
      +++ OK, passed 100 tests.
    factorialLaw_all_factors_prime [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primePrefix_foldr [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primeSuffix_foldl [✔]
      +++ OK, passed 100 tests.
    factorialLaw_factors_foldl [✔]
      +++ OK, passed 100 tests:
      84% allUnique [a, b]
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
    factorialLaw_factors_foldl' [✔]
      +++ OK, passed 100 tests:
      84% allUnique [a, b]
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
    factorialLaw_factors_foldr [✔]
      +++ OK, passed 100 tests:
      84% allUnique [a, b]
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
  Testing FactorialMonoid laws for type Set (Small Int)
    factorialMonoidLaw_coverage [✔]
      +++ OK, passed 400 tests:
      96.2% length a >= 2
       2.0% length a == 1
       1.8% length a == 0
    factorialMonoidLaw_null [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_reverse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_inits [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_tails [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_span [✔]
      +++ OK, passed 100 tests:
      96% any p (factors a)
      94% any (not . p) (factors a)
    factorialMonoidLaw_split [✔]
      +++ OK, passed 100 tests:
      96% any p (factors a)
      94% any (not . p) (factors a)
    factorialMonoidLaw_split_intersperse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitAt [✔]
      +++ OK, passed 100 tests.
  Testing GCDMonoid laws for type Set (Small Int)
    gcdMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% (a </> gcd a b) /= mempty
      97% gcd a b /= mempty
      84% allUnique [a, b]
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
    gcdMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% (b </> gcd a b) /= mempty
      97% gcd a b /= mempty
      84% allUnique [a, b]
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
    gcdMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      82% c /= gcd a b
      82% not (all isJust [a </> c, b </> c, c </> gcd a b])
      68% allUnique [a, b, c]
      34% allNonNull [a, b, c]
      30% allUniqueNonNull [a, b, c]
      18% all isJust [a </> c, b </> c, c </> gcd a b]
      18% c == gcd a b
    gcdMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    gcdMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    gcdMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    gcdMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      97% gcd a b /= mempty
      84% allUnique [a, b]
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
       3% gcd a b == mempty
    gcdMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      97% gcd a b /= mempty
      95% gcd b c /= mempty
      68% allUnique [a, b, c]
      34% allNonNull [a, b, c]
      30% allUniqueNonNull [a, b, c]
    gcdMonoidLaw_equivalence_commonPrefix [✔]
      +++ OK, passed 100 tests:
      97% commonPrefix a b /= mempty
      97% gcd a b /= mempty
      84% allUnique [a, b]
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
    gcdMonoidLaw_equivalence_commonSuffix [✔]
      +++ OK, passed 100 tests:
      97% commonSuffix a b /= mempty
      97% gcd a b /= mempty
      84% allUnique [a, b]
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
  Testing LCMMonoid laws for type Set (Small Int)
    lcmMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      99% lcm a b /= mempty
      84% allUnique [a, b]
      58% (lcm a b </> a) /= Just mempty
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
    lcmMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      99% lcm a b /= mempty
      84% allUnique [a, b]
      60% (lcm a b </> b) /= Just mempty
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
    lcmMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      82% c /= lcm a b
      82% not (all isJust [c </> a, c </> b, lcm a b </> c])
      68% allUnique [a, b, c]
      34% allNonNull [a, b, c]
      30% allUniqueNonNull [a, b, c]
      18% all isJust [c </> a, c </> b, lcm a b </> c]
      18% c == lcm a b
    lcmMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    lcmMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    lcmMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    lcmMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      99% lcm a b /= mempty
      84% allUnique [a, b]
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
    lcmMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      99% lcm a b /= mempty
      99% lcm b c /= mempty
      68% allUnique [a, b, c]
      34% allNonNull [a, b, c]
      30% allUniqueNonNull [a, b, c]
    lcmMonoidLaw_absorption_gcd_lcm [✔]
      +++ OK, passed 100 tests:
      97% gcd a b /= mempty
      84% allUnique [a, b]
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
       3% gcd a b == mempty
    lcmMonoidLaw_absorption_lcm_gcd [✔]
      +++ OK, passed 100 tests:
      97% gcd a b /= mempty
      84% allUnique [a, b]
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
       3% gcd a b == mempty
  Testing LeftDistributiveGCDMonoid laws for type Set (Small Int)
    leftDistributiveGCDMonoidLaw_distributivity [✔]
      +++ OK, passed 100 tests:
      94% commonPrefix b c /= mempty && a /= mempty
      68% allUnique [a, b, c]
      34% allNonNull [a, b, c]
      30% allUniqueNonNull [a, b, c]
  Testing LeftGCDMonoid laws for type Set (Small Int)
    leftGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) a /= mempty
      97% commonPrefix a b /= mempty
      84% allUnique [a, b]
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) b /= mempty
      97% commonPrefix a b /= mempty
      84% allUnique [a, b]
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 200 tests:
      98.0% antecedent == False
      98.0% consequent == False
      82.0% allUnique [a, b]
      28.5% allNonNull [a, b]
      28.5% allUniqueNonNull [a, b]
       2.0% antecedent == True
       2.0% consequent == True
    leftGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    leftGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    leftGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    leftGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      97% commonPrefix a b /= mempty
      84% allUnique [a, b]
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
       3% commonPrefix a b == mempty
    leftGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      94% commonPrefix (commonPrefix a b) c /= mempty
      94% commonPrefix a (commonPrefix b c) /= mempty
      68% allUnique [a, b, c]
      34% allNonNull [a, b, c]
      30% allUniqueNonNull [a, b, c]
    leftGCDMonoidLaw_stripCommonPrefix_commonPrefix [✔]
      +++ OK, passed 100 tests:
      97% commonPrefix a b /= mempty
      84% allUnique [a, b]
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_stripCommonPrefix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      84% allUnique [a, b]
      59% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_stripCommonPrefix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      84% allUnique [a, b]
      57% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_1 [✔]
      +++ OK, passed 100 tests:
      84% allUnique [a, b]
      59% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_2 [✔]
      +++ OK, passed 100 tests:
      84% allUnique [a, b]
      57% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
  Testing LeftReductive laws for type Set (Small Int)
    leftReductiveLaw_isPrefixOf_mappend [✔]
      +++ OK, passed 100 tests:
      84% allUnique [a, b]
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
    leftReductiveLaw_isPrefixOf_stripPrefix [✔]
      +++ OK, passed 100 tests:
      84% allUnique [a, b]
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
    leftReductiveLaw_stripPrefix [✔]
      +++ OK, passed 100 tests:
      84% allUnique [a, b]
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
  Testing MonoidNull laws for type Set (Small Int)
    monoidNullLaw_basic [✔]
      +++ OK, passed 100 tests:
      97% a /= mempty
       3% a == mempty
  Testing Monus laws for type Set (Small Int)
    monusLaw_axiom_1 [✔]
      +++ OK, passed 100 tests:
      97% a /= mempty
       3% a == mempty
    monusLaw_axiom_2 [✔]
      +++ OK, passed 100 tests:
      97% a /= mempty
       3% a == mempty
    monusLaw_axiom_3 [✔]
      +++ OK, passed 100 tests:
      84% allUnique [a, b]
      60% (a <\> b) /= mempty
      58% (b <\> a) /= mempty
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
    monusLaw_axiom_4 [✔]
      +++ OK, passed 100 tests:
      68% allUnique [a, b, c]
      43% (a <\> b) <\> c /= mempty
      34% allNonNull [a, b, c]
      30% allUniqueNonNull [a, b, c]
    monusLaw_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      84% allUnique [a, b]
      60% a <\> b /= mempty
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
    monusLaw_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      84% allUnique [a, b]
      60% a <\> b /= mempty
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
  Testing OverlappingGCDMonoid laws for type Set (Small Int)
    overlappingGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (overlap a b) a /= mempty
      97% overlap a b /= mempty
      84% allUnique [a, b]
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (overlap a b) b /= mempty
      97% overlap a b /= mempty
      84% allUnique [a, b]
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    overlappingGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    overlappingGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    overlappingGCDMonoidLaw_overlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      84% allUnique [a, b]
      57% overlap a b /= mempty && stripPrefixOverlap a b /= mempty
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_overlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      84% allUnique [a, b]
      59% stripSuffixOverlap b a /= mempty && overlap a b /= mempty
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_stripOverlap_overlap [✔]
      +++ OK, passed 100 tests:
      97% overlap a b /= mempty
      84% allUnique [a, b]
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_stripOverlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      84% allUnique [a, b]
      58% stripPrefixOverlap a b /= mempty
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_stripOverlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      84% allUnique [a, b]
      60% stripSuffixOverlap b a /= mempty
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
  Testing PositiveMonoid laws for type Set (Small Int)
    positiveMonoidLaw_fundamental [✔]
      +++ OK, passed 400 tests:
      98.5% not (null (a <> b))
      82.8% allUnique [a, b]
      28.2% allNonNull [a, b]
      28.2% allUniqueNonNull [a, b]
       1.5% null (a <> b)
  Testing Reductive laws for type Set (Small Int)
    reductiveLaw_equivalence_prefix [✔]
      +++ OK, passed 100 tests:
      84% allUnique [a, b]
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
    reductiveLaw_equivalence_suffix [✔]
      +++ OK, passed 100 tests:
      84% allUnique [a, b]
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
    reductiveLaw_inversion_prefix [✔]
      +++ OK, passed 100 tests:
      84% allUnique [a, b]
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
    reductiveLaw_inversion_suffix [✔]
      +++ OK, passed 100 tests:
      84% allUnique [a, b]
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
  Testing RightDistributiveGCDMonoid laws for type Set (Small Int)
    rightDistributiveGCDMonoidLaw_distributivity [✔]
      +++ OK, passed 100 tests:
      95% commonSuffix a b /= mempty && c /= mempty
      68% allUnique [a, b, c]
      34% allNonNull [a, b, c]
      30% allUniqueNonNull [a, b, c]
  Testing RightGCDMonoid laws for type Set (Small Int)
    rightGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (commonSuffix a b) a /= mempty
      97% commonSuffix a b /= mempty
      84% allUnique [a, b]
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
    rightGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (commonSuffix a b) b /= mempty
      97% commonSuffix a b /= mempty
      84% allUnique [a, b]
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
    rightGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 200 tests:
      98.0% antecedent == False
      98.0% consequent == False
      82.0% allUnique [a, b]
      28.5% allNonNull [a, b]
      28.5% allUniqueNonNull [a, b]
       2.0% antecedent == True
       2.0% consequent == True
    rightGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    rightGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    rightGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    rightGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      97% commonSuffix a b /= mempty
      84% allUnique [a, b]
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
       3% commonSuffix a b == mempty
    rightGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      94% commonSuffix (commonSuffix a b) c /= mempty
      94% commonSuffix a (commonSuffix b c) /= mempty
      68% allUnique [a, b, c]
      34% allNonNull [a, b, c]
      30% allUniqueNonNull [a, b, c]
    rightGCDMonoidLaw_stripCommonSuffix_commonSuffix [✔]
      +++ OK, passed 100 tests:
      97% commonSuffix a b /= mempty
      84% allUnique [a, b]
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
    rightGCDMonoidLaw_stripCommonSuffix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      84% allUnique [a, b]
      59% stripCommonSuffix a b & \(x, _, s) -> x /= mempty && s /= mempty
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
    rightGCDMonoidLaw_stripCommonSuffix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      84% allUnique [a, b]
      57% stripCommonSuffix a b & \(_, x, s) -> x /= mempty && s /= mempty
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
    rightGCDMonoidLaw_stripCommonSuffix_stripSuffix_1 [✔]
      +++ OK, passed 100 tests:
      84% allUnique [a, b]
      59% stripCommonSuffix a b & \(x, _, s) -> x /= mempty && s /= mempty
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
    rightGCDMonoidLaw_stripCommonSuffix_stripSuffix_2 [✔]
      +++ OK, passed 100 tests:
      84% allUnique [a, b]
      57% stripCommonSuffix a b & \(_, x, s) -> x /= mempty && s /= mempty
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
  Testing RightReductive laws for type Set (Small Int)
    rightReductiveLaw_isSuffixOf_mappend [✔]
      +++ OK, passed 100 tests:
      84% allUnique [a, b]
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
    rightReductiveLaw_isSuffixOf_stripSuffix [✔]
      +++ OK, passed 100 tests:
      84% allUnique [a, b]
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
    rightReductiveLaw_stripSuffix [✔]
      +++ OK, passed 100 tests:
      84% allUnique [a, b]
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
  Testing Commutative laws for type Set Natural
    commutativeLaw_basic [✔]
      +++ OK, passed 100 tests:
      85% allUnique [a, b]
      34% (a /= b) && (a <> b /= a) && (b <> a /= b)
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
  Testing DistributiveGCDMonoid laws for type Set Natural
    distributiveGCDMonoidLaw_distributivity_left [✔]
      +++ OK, passed 100 tests:
      68% allUnique [a, b, c]
      34% allNonNull [a, b, c]
      30% allUniqueNonNull [a, b, c]
    distributiveGCDMonoidLaw_distributivity_right [✔]
      +++ OK, passed 100 tests:
      68% allUnique [a, b, c]
      34% allNonNull [a, b, c]
      30% allUniqueNonNull [a, b, c]
  Testing DistributiveLCMMonoid laws for type Set Natural
    distributiveLCMMonoidLaw_distributivity_left [✔]
      +++ OK, passed 100 tests:
      68% allUnique [a, b, c]
      34% allNonNull [a, b, c]
      30% allUniqueNonNull [a, b, c]
    distributiveLCMMonoidLaw_distributivity_right [✔]
      +++ OK, passed 100 tests:
      68% allUnique [a, b, c]
      34% allNonNull [a, b, c]
      30% allUniqueNonNull [a, b, c]
    distributiveLCMMonoidLaw_distributivity_gcd_lcm [✔]
      +++ OK, passed 100 tests:
      68% allUnique [a, b, c]
      34% allNonNull [a, b, c]
      30% allUniqueNonNull [a, b, c]
    distributiveLCMMonoidLaw_distributivity_lcm_gcd [✔]
      +++ OK, passed 100 tests:
      68% allUnique [a, b, c]
      34% allNonNull [a, b, c]
      30% allUniqueNonNull [a, b, c]
  Testing Factorial laws for type Set Natural
    factorialLaw_coverage [✔]
      +++ OK, passed 400 tests:
      96.8% length a >= 2
       1.8% length a == 0
       1.5% length a == 1
    factorialLaw_length_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors_reverse [✔]
      +++ OK, passed 100 tests.
    factorialLaw_all_factors_prime [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primePrefix_foldr [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primeSuffix_foldl [✔]
      +++ OK, passed 100 tests.
    factorialLaw_factors_foldl [✔]
      +++ OK, passed 100 tests:
      85% allUnique [a, b]
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
    factorialLaw_factors_foldl' [✔]
      +++ OK, passed 100 tests:
      85% allUnique [a, b]
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
    factorialLaw_factors_foldr [✔]
      +++ OK, passed 100 tests:
      85% allUnique [a, b]
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
  Testing FactorialMonoid laws for type Set Natural
    factorialMonoidLaw_coverage [✔]
      +++ OK, passed 400 tests:
      96.8% length a >= 2
       1.8% length a == 0
       1.5% length a == 1
    factorialMonoidLaw_null [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_reverse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_inits [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_tails [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_span [✔]
      +++ OK, passed 100 tests:
      95% any (not . p) (factors a)
      94% any p (factors a)
    factorialMonoidLaw_split [✔]
      +++ OK, passed 100 tests:
      95% any (not . p) (factors a)
      94% any p (factors a)
    factorialMonoidLaw_split_intersperse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitAt [✔]
      +++ OK, passed 100 tests.
  Testing GCDMonoid laws for type Set Natural
    gcdMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% (a </> gcd a b) /= mempty
      97% gcd a b /= mempty
      85% allUnique [a, b]
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
    gcdMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% (b </> gcd a b) /= mempty
      97% gcd a b /= mempty
      85% allUnique [a, b]
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
    gcdMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      83% c /= gcd a b
      83% not (all isJust [a </> c, b </> c, c </> gcd a b])
      68% allUnique [a, b, c]
      34% allNonNull [a, b, c]
      30% allUniqueNonNull [a, b, c]
      17% all isJust [a </> c, b </> c, c </> gcd a b]
      17% c == gcd a b
    gcdMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    gcdMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    gcdMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    gcdMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      97% gcd a b /= mempty
      85% allUnique [a, b]
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
       3% gcd a b == mempty
    gcdMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      97% gcd a b /= mempty
      95% gcd b c /= mempty
      68% allUnique [a, b, c]
      34% allNonNull [a, b, c]
      30% allUniqueNonNull [a, b, c]
    gcdMonoidLaw_equivalence_commonPrefix [✔]
      +++ OK, passed 100 tests:
      97% commonPrefix a b /= mempty
      97% gcd a b /= mempty
      85% allUnique [a, b]
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
    gcdMonoidLaw_equivalence_commonSuffix [✔]
      +++ OK, passed 100 tests:
      97% commonSuffix a b /= mempty
      97% gcd a b /= mempty
      85% allUnique [a, b]
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
  Testing LCMMonoid laws for type Set Natural
    lcmMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      99% lcm a b /= mempty
      85% allUnique [a, b]
      59% (lcm a b </> a) /= Just mempty
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
    lcmMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      99% lcm a b /= mempty
      85% allUnique [a, b]
      60% (lcm a b </> b) /= Just mempty
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
    lcmMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      82% c /= lcm a b
      82% not (all isJust [c </> a, c </> b, lcm a b </> c])
      68% allUnique [a, b, c]
      34% allNonNull [a, b, c]
      30% allUniqueNonNull [a, b, c]
      18% all isJust [c </> a, c </> b, lcm a b </> c]
      18% c == lcm a b
    lcmMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    lcmMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    lcmMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    lcmMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      99% lcm a b /= mempty
      85% allUnique [a, b]
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
    lcmMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      99% lcm a b /= mempty
      99% lcm b c /= mempty
      68% allUnique [a, b, c]
      34% allNonNull [a, b, c]
      30% allUniqueNonNull [a, b, c]
    lcmMonoidLaw_absorption_gcd_lcm [✔]
      +++ OK, passed 100 tests:
      97% gcd a b /= mempty
      85% allUnique [a, b]
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
       3% gcd a b == mempty
    lcmMonoidLaw_absorption_lcm_gcd [✔]
      +++ OK, passed 100 tests:
      97% gcd a b /= mempty
      85% allUnique [a, b]
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
       3% gcd a b == mempty
  Testing LeftDistributiveGCDMonoid laws for type Set Natural
    leftDistributiveGCDMonoidLaw_distributivity [✔]
      +++ OK, passed 100 tests:
      94% commonPrefix b c /= mempty && a /= mempty
      68% allUnique [a, b, c]
      34% allNonNull [a, b, c]
      30% allUniqueNonNull [a, b, c]
  Testing LeftGCDMonoid laws for type Set Natural
    leftGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) a /= mempty
      97% commonPrefix a b /= mempty
      85% allUnique [a, b]
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) b /= mempty
      97% commonPrefix a b /= mempty
      85% allUnique [a, b]
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 200 tests:
      98.5% antecedent == False
      98.5% consequent == False
      82.5% allUnique [a, b]
      28.5% allNonNull [a, b]
      28.5% allUniqueNonNull [a, b]
       1.5% antecedent == True
       1.5% consequent == True
    leftGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    leftGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    leftGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    leftGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      97% commonPrefix a b /= mempty
      85% allUnique [a, b]
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
       3% commonPrefix a b == mempty
    leftGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      94% commonPrefix (commonPrefix a b) c /= mempty
      94% commonPrefix a (commonPrefix b c) /= mempty
      68% allUnique [a, b, c]
      34% allNonNull [a, b, c]
      30% allUniqueNonNull [a, b, c]
    leftGCDMonoidLaw_stripCommonPrefix_commonPrefix [✔]
      +++ OK, passed 100 tests:
      97% commonPrefix a b /= mempty
      85% allUnique [a, b]
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_stripCommonPrefix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      85% allUnique [a, b]
      59% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_stripCommonPrefix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      85% allUnique [a, b]
      58% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_1 [✔]
      +++ OK, passed 100 tests:
      85% allUnique [a, b]
      59% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_2 [✔]
      +++ OK, passed 100 tests:
      85% allUnique [a, b]
      58% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
  Testing LeftReductive laws for type Set Natural
    leftReductiveLaw_isPrefixOf_mappend [✔]
      +++ OK, passed 100 tests:
      85% allUnique [a, b]
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
    leftReductiveLaw_isPrefixOf_stripPrefix [✔]
      +++ OK, passed 100 tests:
      85% allUnique [a, b]
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
    leftReductiveLaw_stripPrefix [✔]
      +++ OK, passed 100 tests:
      85% allUnique [a, b]
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
  Testing MonoidNull laws for type Set Natural
    monoidNullLaw_basic [✔]
      +++ OK, passed 100 tests:
      97% a /= mempty
       3% a == mempty
  Testing Monus laws for type Set Natural
    monusLaw_axiom_1 [✔]
      +++ OK, passed 100 tests:
      97% a /= mempty
       3% a == mempty
    monusLaw_axiom_2 [✔]
      +++ OK, passed 100 tests:
      97% a /= mempty
       3% a == mempty
    monusLaw_axiom_3 [✔]
      +++ OK, passed 100 tests:
      85% allUnique [a, b]
      60% (a <\> b) /= mempty
      59% (b <\> a) /= mempty
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
    monusLaw_axiom_4 [✔]
      +++ OK, passed 100 tests:
      68% allUnique [a, b, c]
      43% (a <\> b) <\> c /= mempty
      34% allNonNull [a, b, c]
      30% allUniqueNonNull [a, b, c]
    monusLaw_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      85% allUnique [a, b]
      60% a <\> b /= mempty
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
    monusLaw_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      85% allUnique [a, b]
      60% a <\> b /= mempty
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
  Testing OverlappingGCDMonoid laws for type Set Natural
    overlappingGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (overlap a b) a /= mempty
      97% overlap a b /= mempty
      85% allUnique [a, b]
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (overlap a b) b /= mempty
      97% overlap a b /= mempty
      85% allUnique [a, b]
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    overlappingGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    overlappingGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    overlappingGCDMonoidLaw_overlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      85% allUnique [a, b]
      58% overlap a b /= mempty && stripPrefixOverlap a b /= mempty
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_overlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      85% allUnique [a, b]
      59% stripSuffixOverlap b a /= mempty && overlap a b /= mempty
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_stripOverlap_overlap [✔]
      +++ OK, passed 100 tests:
      97% overlap a b /= mempty
      85% allUnique [a, b]
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_stripOverlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      85% allUnique [a, b]
      59% stripPrefixOverlap a b /= mempty
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_stripOverlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      85% allUnique [a, b]
      60% stripSuffixOverlap b a /= mempty
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
  Testing PositiveMonoid laws for type Set Natural
    positiveMonoidLaw_fundamental [✔]
      +++ OK, passed 400 tests:
      98.5% not (null (a <> b))
      84.0% allUnique [a, b]
      28.7% allNonNull [a, b]
      28.7% allUniqueNonNull [a, b]
       1.5% null (a <> b)
  Testing Reductive laws for type Set Natural
    reductiveLaw_equivalence_prefix [✔]
      +++ OK, passed 100 tests:
      85% allUnique [a, b]
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
    reductiveLaw_equivalence_suffix [✔]
      +++ OK, passed 100 tests:
      85% allUnique [a, b]
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
    reductiveLaw_inversion_prefix [✔]
      +++ OK, passed 100 tests:
      85% allUnique [a, b]
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
    reductiveLaw_inversion_suffix [✔]
      +++ OK, passed 100 tests:
      85% allUnique [a, b]
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
  Testing RightDistributiveGCDMonoid laws for type Set Natural
    rightDistributiveGCDMonoidLaw_distributivity [✔]
      +++ OK, passed 100 tests:
      95% commonSuffix a b /= mempty && c /= mempty
      68% allUnique [a, b, c]
      34% allNonNull [a, b, c]
      30% allUniqueNonNull [a, b, c]
  Testing RightGCDMonoid laws for type Set Natural
    rightGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (commonSuffix a b) a /= mempty
      97% commonSuffix a b /= mempty
      85% allUnique [a, b]
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
    rightGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (commonSuffix a b) b /= mempty
      97% commonSuffix a b /= mempty
      85% allUnique [a, b]
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
    rightGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 200 tests:
      98.5% antecedent == False
      98.5% consequent == False
      82.5% allUnique [a, b]
      28.5% allNonNull [a, b]
      28.5% allUniqueNonNull [a, b]
       1.5% antecedent == True
       1.5% consequent == True
    rightGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    rightGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    rightGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    rightGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      97% commonSuffix a b /= mempty
      85% allUnique [a, b]
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
       3% commonSuffix a b == mempty
    rightGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      94% commonSuffix (commonSuffix a b) c /= mempty
      94% commonSuffix a (commonSuffix b c) /= mempty
      68% allUnique [a, b, c]
      34% allNonNull [a, b, c]
      30% allUniqueNonNull [a, b, c]
    rightGCDMonoidLaw_stripCommonSuffix_commonSuffix [✔]
      +++ OK, passed 100 tests:
      97% commonSuffix a b /= mempty
      85% allUnique [a, b]
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
    rightGCDMonoidLaw_stripCommonSuffix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      85% allUnique [a, b]
      59% stripCommonSuffix a b & \(x, _, s) -> x /= mempty && s /= mempty
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
    rightGCDMonoidLaw_stripCommonSuffix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      85% allUnique [a, b]
      58% stripCommonSuffix a b & \(_, x, s) -> x /= mempty && s /= mempty
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
    rightGCDMonoidLaw_stripCommonSuffix_stripSuffix_1 [✔]
      +++ OK, passed 100 tests:
      85% allUnique [a, b]
      59% stripCommonSuffix a b & \(x, _, s) -> x /= mempty && s /= mempty
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
    rightGCDMonoidLaw_stripCommonSuffix_stripSuffix_2 [✔]
      +++ OK, passed 100 tests:
      85% allUnique [a, b]
      58% stripCommonSuffix a b & \(_, x, s) -> x /= mempty && s /= mempty
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
  Testing RightReductive laws for type Set Natural
    rightReductiveLaw_isSuffixOf_mappend [✔]
      +++ OK, passed 100 tests:
      85% allUnique [a, b]
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
    rightReductiveLaw_isSuffixOf_stripSuffix [✔]
      +++ OK, passed 100 tests:
      85% allUnique [a, b]
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
    rightReductiveLaw_stripSuffix [✔]
      +++ OK, passed 100 tests:
      85% allUnique [a, b]
      34% allNonNull [a, b]
      34% allUniqueNonNull [a, b]
  Testing Commutative laws for type Product (Small Int)
    commutativeLaw_basic [✔]
      +++ OK, passed 100 tests:
      90% allNonNull [a, b]
      78% allUnique [a, b]
      77% allUniqueNonNull [a, b]
      74% (a /= b) && (a <> b /= a) && (b <> a /= b)
  Testing Factorial laws for type Product (Small Int)
    factorialLaw_coverage [✔]
      +++ OK, passed 800 tests:
      57.8% length a == 1
      41.2% length a >= 2
       1.0% length a == 0
    factorialLaw_length_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors_reverse [✔]
      +++ OK, passed 100 tests.
    factorialLaw_all_factors_prime [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primePrefix_foldr [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primeSuffix_foldl [✔]
      +++ OK, passed 100 tests.
    factorialLaw_factors_foldl [✔]
      +++ OK, passed 100 tests:
      90% allNonNull [a, b]
      78% allUnique [a, b]
      77% allUniqueNonNull [a, b]
    factorialLaw_factors_foldl' [✔]
      +++ OK, passed 100 tests:
      90% allNonNull [a, b]
      78% allUnique [a, b]
      77% allUniqueNonNull [a, b]
    factorialLaw_factors_foldr [✔]
      +++ OK, passed 100 tests:
      90% allNonNull [a, b]
      78% allUnique [a, b]
      77% allUniqueNonNull [a, b]
  Testing FactorialMonoid laws for type Product (Small Int)
    factorialMonoidLaw_coverage [✔]
      +++ OK, passed 800 tests:
      57.8% length a == 1
      41.2% length a >= 2
       1.0% length a == 0
    factorialMonoidLaw_null [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_reverse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_inits [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_tails [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_span [✔]
      +++ OK, passed 100 tests:
      60% any p (factors a)
      59% any (not . p) (factors a)
    factorialMonoidLaw_split [✔]
      +++ OK, passed 100 tests:
      60% any p (factors a)
      59% any (not . p) (factors a)
    factorialMonoidLaw_split_intersperse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitAt [✔]
      +++ OK, passed 100 tests.
  Testing LeftReductive laws for type Product (Small Int)
    leftReductiveLaw_isPrefixOf_mappend [✔]
      +++ OK, passed 100 tests:
      90% allNonNull [a, b]
      78% allUnique [a, b]
      77% allUniqueNonNull [a, b]
    leftReductiveLaw_isPrefixOf_stripPrefix [✔]
      +++ OK, passed 100 tests:
      90% allNonNull [a, b]
      78% allUnique [a, b]
      77% allUniqueNonNull [a, b]
    leftReductiveLaw_stripPrefix [✔]
      +++ OK, passed 100 tests:
      90% allNonNull [a, b]
      78% allUnique [a, b]
      77% allUniqueNonNull [a, b]
  Testing MonoidNull laws for type Product (Small Int)
    monoidNullLaw_basic [✔]
      +++ OK, passed 800 tests:
      99.0% a /= mempty
       1.0% a == mempty
  Testing Reductive laws for type Product (Small Int)
    reductiveLaw_equivalence_prefix [✔]
      +++ OK, passed 100 tests:
      90% allNonNull [a, b]
      78% allUnique [a, b]
      77% allUniqueNonNull [a, b]
    reductiveLaw_equivalence_suffix [✔]
      +++ OK, passed 100 tests:
      90% allNonNull [a, b]
      78% allUnique [a, b]
      77% allUniqueNonNull [a, b]
    reductiveLaw_inversion_prefix [✔]
      +++ OK, passed 100 tests:
      90% allNonNull [a, b]
      78% allUnique [a, b]
      77% allUniqueNonNull [a, b]
    reductiveLaw_inversion_suffix [✔]
      +++ OK, passed 100 tests:
      90% allNonNull [a, b]
      78% allUnique [a, b]
      77% allUniqueNonNull [a, b]
  Testing RightReductive laws for type Product (Small Int)
    rightReductiveLaw_isSuffixOf_mappend [✔]
      +++ OK, passed 100 tests:
      90% allNonNull [a, b]
      78% allUnique [a, b]
      77% allUniqueNonNull [a, b]
    rightReductiveLaw_isSuffixOf_stripSuffix [✔]
      +++ OK, passed 100 tests:
      90% allNonNull [a, b]
      78% allUnique [a, b]
      77% allUniqueNonNull [a, b]
    rightReductiveLaw_stripSuffix [✔]
      +++ OK, passed 100 tests:
      90% allNonNull [a, b]
      78% allUnique [a, b]
      77% allUniqueNonNull [a, b]
  Testing Commutative laws for type Product Natural
    commutativeLaw_basic [✔]
      +++ OK, passed 100 tests:
      92% allNonNull [a, b]
      83% allUnique [a, b]
      82% allUniqueNonNull [a, b]
      75% (a /= b) && (a <> b /= a) && (b <> a /= b)
  Testing DistributiveGCDMonoid laws for type Product Natural
    distributiveGCDMonoidLaw_distributivity_left [✔]
      +++ OK, passed 100 tests:
      91% allNonNull [a, b, c]
      59% allUnique [a, b, c]
      58% allUniqueNonNull [a, b, c]
    distributiveGCDMonoidLaw_distributivity_right [✔]
      +++ OK, passed 100 tests:
      91% allNonNull [a, b, c]
      59% allUnique [a, b, c]
      58% allUniqueNonNull [a, b, c]
  Testing DistributiveLCMMonoid laws for type Product Natural
    distributiveLCMMonoidLaw_distributivity_left [✔]
      +++ OK, passed 100 tests:
      91% allNonNull [a, b, c]
      59% allUnique [a, b, c]
      58% allUniqueNonNull [a, b, c]
    distributiveLCMMonoidLaw_distributivity_right [✔]
      +++ OK, passed 100 tests:
      91% allNonNull [a, b, c]
      59% allUnique [a, b, c]
      58% allUniqueNonNull [a, b, c]
    distributiveLCMMonoidLaw_distributivity_gcd_lcm [✔]
      +++ OK, passed 100 tests:
      91% allNonNull [a, b, c]
      59% allUnique [a, b, c]
      58% allUniqueNonNull [a, b, c]
    distributiveLCMMonoidLaw_distributivity_lcm_gcd [✔]
      +++ OK, passed 100 tests:
      91% allNonNull [a, b, c]
      59% allUnique [a, b, c]
      58% allUniqueNonNull [a, b, c]
  Testing Factorial laws for type Product Natural
    factorialLaw_coverage [✔]
      +++ OK, passed 400 tests:
      79.2% length a >= 2
      19.0% length a == 1
       1.8% length a == 0
    factorialLaw_length_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors_reverse [✔]
      +++ OK, passed 100 tests.
    factorialLaw_all_factors_prime [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primePrefix_foldr [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primeSuffix_foldl [✔]
      +++ OK, passed 100 tests.
    factorialLaw_factors_foldl [✔]
      +++ OK, passed 100 tests:
      92% allNonNull [a, b]
      83% allUnique [a, b]
      82% allUniqueNonNull [a, b]
    factorialLaw_factors_foldl' [✔]
      +++ OK, passed 100 tests:
      92% allNonNull [a, b]
      83% allUnique [a, b]
      82% allUniqueNonNull [a, b]
    factorialLaw_factors_foldr [✔]
      +++ OK, passed 100 tests:
      92% allNonNull [a, b]
      83% allUnique [a, b]
      82% allUniqueNonNull [a, b]
  Testing FactorialMonoid laws for type Product Natural
    factorialMonoidLaw_coverage [✔]
      +++ OK, passed 400 tests:
      79.2% length a >= 2
      19.0% length a == 1
       1.8% length a == 0
    factorialMonoidLaw_null [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_reverse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_inits [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_tails [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_span [✔]
      +++ OK, passed 100 tests:
      80% any (not . p) (factors a)
      71% any p (factors a)
    factorialMonoidLaw_split [✔]
      +++ OK, passed 100 tests:
      80% any (not . p) (factors a)
      71% any p (factors a)
    factorialMonoidLaw_split_intersperse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitAt [✔]
      +++ OK, passed 100 tests.
  Testing GCDMonoid laws for type Product Natural
    gcdMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% (a </> gcd a b) /= mempty
      94% gcd a b /= mempty
      92% allNonNull [a, b]
      83% allUnique [a, b]
      82% allUniqueNonNull [a, b]
    gcdMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% (b </> gcd a b) /= mempty
      94% gcd a b /= mempty
      92% allNonNull [a, b]
      83% allUnique [a, b]
      82% allUniqueNonNull [a, b]
    gcdMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      91% allNonNull [a, b, c]
      76% c /= gcd a b
      76% not (all isJust [a </> c, b </> c, c </> gcd a b])
      59% allUnique [a, b, c]
      58% allUniqueNonNull [a, b, c]
      24% all isJust [a </> c, b </> c, c </> gcd a b]
      24% c == gcd a b
    gcdMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    gcdMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (99% a /= mempty).
    gcdMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (99% a /= mempty).
    gcdMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      94% gcd a b /= mempty
      92% allNonNull [a, b]
      83% allUnique [a, b]
      82% allUniqueNonNull [a, b]
       6% gcd a b == mempty
    gcdMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      91% allNonNull [a, b, c]
      91% gcd b c /= mempty
      90% gcd a b /= mempty
      59% allUnique [a, b, c]
      58% allUniqueNonNull [a, b, c]
    gcdMonoidLaw_equivalence_commonPrefix [✔]
      +++ OK, passed 100 tests:
      94% commonPrefix a b /= mempty
      94% gcd a b /= mempty
      92% allNonNull [a, b]
      83% allUnique [a, b]
      82% allUniqueNonNull [a, b]
    gcdMonoidLaw_equivalence_commonSuffix [✔]
      +++ OK, passed 100 tests:
      94% commonSuffix a b /= mempty
      94% gcd a b /= mempty
      92% allNonNull [a, b]
      83% allUnique [a, b]
      82% allUniqueNonNull [a, b]
  Testing LCMMonoid laws for type Product Natural
    lcmMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      98% lcm a b /= mempty
      92% allNonNull [a, b]
      83% allUnique [a, b]
      82% allUniqueNonNull [a, b]
      60% (lcm a b </> a) /= Just mempty
    lcmMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      98% lcm a b /= mempty
      92% allNonNull [a, b]
      83% allUnique [a, b]
      82% allUniqueNonNull [a, b]
      64% (lcm a b </> b) /= Just mempty
    lcmMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      91% allNonNull [a, b, c]
      78% c /= lcm a b
      78% not (all isJust [c </> a, c </> b, lcm a b </> c])
      59% allUnique [a, b, c]
      58% allUniqueNonNull [a, b, c]
      22% all isJust [c </> a, c </> b, lcm a b </> c]
      22% c == lcm a b
    lcmMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    lcmMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (99% a /= mempty).
    lcmMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (99% a /= mempty).
    lcmMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      98% lcm a b /= mempty
      92% allNonNull [a, b]
      83% allUnique [a, b]
      82% allUniqueNonNull [a, b]
    lcmMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      99% lcm a b /= mempty
      99% lcm b c /= mempty
      91% allNonNull [a, b, c]
      59% allUnique [a, b, c]
      58% allUniqueNonNull [a, b, c]
    lcmMonoidLaw_absorption_gcd_lcm [✔]
      +++ OK, passed 100 tests:
      94% gcd a b /= mempty
      92% allNonNull [a, b]
      83% allUnique [a, b]
      82% allUniqueNonNull [a, b]
       6% gcd a b == mempty
    lcmMonoidLaw_absorption_lcm_gcd [✔]
      +++ OK, passed 100 tests:
      94% gcd a b /= mempty
      92% allNonNull [a, b]
      83% allUnique [a, b]
      82% allUniqueNonNull [a, b]
       6% gcd a b == mempty
  Testing LeftDistributiveGCDMonoid laws for type Product Natural
    leftDistributiveGCDMonoidLaw_distributivity [✔]
      +++ OK, passed 100 tests:
      91% allNonNull [a, b, c]
      90% commonPrefix b c /= mempty && a /= mempty
      59% allUnique [a, b, c]
      58% allUniqueNonNull [a, b, c]
  Testing LeftGCDMonoid laws for type Product Natural
    leftGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) a /= mempty
      94% commonPrefix a b /= mempty
      92% allNonNull [a, b]
      83% allUnique [a, b]
      82% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) b /= mempty
      94% commonPrefix a b /= mempty
      92% allNonNull [a, b]
      83% allUnique [a, b]
      82% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      97% antecedent == False
      97% consequent == False
      92% allNonNull [a, b]
      83% allUnique [a, b]
      82% allUniqueNonNull [a, b]
       3% antecedent == True
       3% consequent == True
    leftGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    leftGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (99% a /= mempty).
    leftGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (99% a /= mempty).
    leftGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      94% commonPrefix a b /= mempty
      92% allNonNull [a, b]
      83% allUnique [a, b]
      82% allUniqueNonNull [a, b]
       6% commonPrefix a b == mempty
    leftGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      91% allNonNull [a, b, c]
      86% commonPrefix (commonPrefix a b) c /= mempty
      86% commonPrefix a (commonPrefix b c) /= mempty
      59% allUnique [a, b, c]
      58% allUniqueNonNull [a, b, c]
    leftGCDMonoidLaw_stripCommonPrefix_commonPrefix [✔]
      +++ OK, passed 100 tests:
      94% commonPrefix a b /= mempty
      92% allNonNull [a, b]
      83% allUnique [a, b]
      82% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_stripCommonPrefix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      92% allNonNull [a, b]
      83% allUnique [a, b]
      82% allUniqueNonNull [a, b]
      58% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      92% allNonNull [a, b]
      83% allUnique [a, b]
      82% allUniqueNonNull [a, b]
      52% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_1 [✔]
      +++ OK, passed 100 tests:
      92% allNonNull [a, b]
      83% allUnique [a, b]
      82% allUniqueNonNull [a, b]
      58% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_2 [✔]
      +++ OK, passed 100 tests:
      92% allNonNull [a, b]
      83% allUnique [a, b]
      82% allUniqueNonNull [a, b]
      52% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
  Testing LeftReductive laws for type Product Natural
    leftReductiveLaw_isPrefixOf_mappend [✔]
      +++ OK, passed 100 tests:
      92% allNonNull [a, b]
      83% allUnique [a, b]
      82% allUniqueNonNull [a, b]
    leftReductiveLaw_isPrefixOf_stripPrefix [✔]
      +++ OK, passed 100 tests:
      92% allNonNull [a, b]
      83% allUnique [a, b]
      82% allUniqueNonNull [a, b]
    leftReductiveLaw_stripPrefix [✔]
      +++ OK, passed 100 tests:
      92% allNonNull [a, b]
      83% allUnique [a, b]
      82% allUniqueNonNull [a, b]
  Testing MonoidNull laws for type Product Natural
    monoidNullLaw_basic [✔]
      +++ OK, passed 400 tests:
      98.2% a /= mempty
       1.8% a == mempty
  Testing Monus laws for type Product Natural
    monusLaw_axiom_1 [✔]
      +++ OK, passed 400 tests:
      98.2% a /= mempty
       1.8% a == mempty
    monusLaw_axiom_2 [✔]
      +++ OK, passed 400 tests:
      98.2% a /= mempty
       1.8% a == mempty
    monusLaw_axiom_3 [✔]
      +++ OK, passed 100 tests:
      92% allNonNull [a, b]
      83% allUnique [a, b]
      82% allUniqueNonNull [a, b]
      56% (a <\> b) /= mempty
      51% (b <\> a) /= mempty
    monusLaw_axiom_4 [✔]
      +++ OK, passed 100 tests:
      91% allNonNull [a, b, c]
      59% allUnique [a, b, c]
      58% allUniqueNonNull [a, b, c]
      34% (a <\> b) <\> c /= mempty
    monusLaw_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      92% allNonNull [a, b]
      83% allUnique [a, b]
      82% allUniqueNonNull [a, b]
      56% a <\> b /= mempty
    monusLaw_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      92% allNonNull [a, b]
      83% allUnique [a, b]
      82% allUniqueNonNull [a, b]
      56% a <\> b /= mempty
  Testing OverlappingGCDMonoid laws for type Product Natural
    overlappingGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (overlap a b) a /= mempty
      94% overlap a b /= mempty
      92% allNonNull [a, b]
      83% allUnique [a, b]
      82% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (overlap a b) b /= mempty
      94% overlap a b /= mempty
      92% allNonNull [a, b]
      83% allUnique [a, b]
      82% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    overlappingGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (99% a /= mempty).
    overlappingGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (99% a /= mempty).
    overlappingGCDMonoidLaw_overlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      92% allNonNull [a, b]
      83% allUnique [a, b]
      82% allUniqueNonNull [a, b]
      47% overlap a b /= mempty && stripPrefixOverlap a b /= mempty
    overlappingGCDMonoidLaw_overlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      92% allNonNull [a, b]
      83% allUnique [a, b]
      82% allUniqueNonNull [a, b]
      53% stripSuffixOverlap b a /= mempty && overlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_overlap [✔]
      +++ OK, passed 100 tests:
      94% overlap a b /= mempty
      92% allNonNull [a, b]
      83% allUnique [a, b]
      82% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_stripOverlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      92% allNonNull [a, b]
      83% allUnique [a, b]
      82% allUniqueNonNull [a, b]
      51% stripPrefixOverlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      92% allNonNull [a, b]
      83% allUnique [a, b]
      82% allUniqueNonNull [a, b]
      56% stripSuffixOverlap b a /= mempty
  Testing PositiveMonoid laws for type Product Natural
    positiveMonoidLaw_fundamental [✔]
      +++ OK, passed 100 tests:
      98% not (null (a <> b))
      92% allNonNull [a, b]
      83% allUnique [a, b]
      82% allUniqueNonNull [a, b]
       2% null (a <> b)
  Testing Reductive laws for type Product Natural
    reductiveLaw_equivalence_prefix [✔]
      +++ OK, passed 100 tests:
      92% allNonNull [a, b]
      83% allUnique [a, b]
      82% allUniqueNonNull [a, b]
    reductiveLaw_equivalence_suffix [✔]
      +++ OK, passed 100 tests:
      92% allNonNull [a, b]
      83% allUnique [a, b]
      82% allUniqueNonNull [a, b]
    reductiveLaw_inversion_prefix [✔]
      +++ OK, passed 100 tests:
      92% allNonNull [a, b]
      83% allUnique [a, b]
      82% allUniqueNonNull [a, b]
    reductiveLaw_inversion_suffix [✔]
      +++ OK, passed 100 tests:
      92% allNonNull [a, b]
      83% allUnique [a, b]
      82% allUniqueNonNull [a, b]
  Testing RightDistributiveGCDMonoid laws for type Product Natural
    rightDistributiveGCDMonoidLaw_distributivity [✔]
      +++ OK, passed 100 tests:
      91% allNonNull [a, b, c]
      90% commonSuffix a b /= mempty && c /= mempty
      59% allUnique [a, b, c]
      58% allUniqueNonNull [a, b, c]
  Testing RightGCDMonoid laws for type Product Natural
    rightGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (commonSuffix a b) a /= mempty
      94% commonSuffix a b /= mempty
      92% allNonNull [a, b]
      83% allUnique [a, b]
      82% allUniqueNonNull [a, b]
    rightGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (commonSuffix a b) b /= mempty
      94% commonSuffix a b /= mempty
      92% allNonNull [a, b]
      83% allUnique [a, b]
      82% allUniqueNonNull [a, b]
    rightGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      97% antecedent == False
      97% consequent == False
      92% allNonNull [a, b]
      83% allUnique [a, b]
      82% allUniqueNonNull [a, b]
       3% antecedent == True
       3% consequent == True
    rightGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    rightGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (99% a /= mempty).
    rightGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (99% a /= mempty).
    rightGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      94% commonSuffix a b /= mempty
      92% allNonNull [a, b]
      83% allUnique [a, b]
      82% allUniqueNonNull [a, b]
       6% commonSuffix a b == mempty
    rightGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      91% allNonNull [a, b, c]
      86% commonSuffix (commonSuffix a b) c /= mempty
      86% commonSuffix a (commonSuffix b c) /= mempty
      59% allUnique [a, b, c]
      58% allUniqueNonNull [a, b, c]
    rightGCDMonoidLaw_stripCommonSuffix_commonSuffix [✔]
      +++ OK, passed 100 tests:
      94% commonSuffix a b /= mempty
      92% allNonNull [a, b]
      83% allUnique [a, b]
      82% allUniqueNonNull [a, b]
    rightGCDMonoidLaw_stripCommonSuffix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      92% allNonNull [a, b]
      83% allUnique [a, b]
      82% allUniqueNonNull [a, b]
      58% stripCommonSuffix a b & \(x, _, s) -> x /= mempty && s /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      92% allNonNull [a, b]
      83% allUnique [a, b]
      82% allUniqueNonNull [a, b]
      52% stripCommonSuffix a b & \(_, x, s) -> x /= mempty && s /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_stripSuffix_1 [✔]
      +++ OK, passed 100 tests:
      92% allNonNull [a, b]
      83% allUnique [a, b]
      82% allUniqueNonNull [a, b]
      58% stripCommonSuffix a b & \(x, _, s) -> x /= mempty && s /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_stripSuffix_2 [✔]
      +++ OK, passed 100 tests:
      92% allNonNull [a, b]
      83% allUnique [a, b]
      82% allUniqueNonNull [a, b]
      52% stripCommonSuffix a b & \(_, x, s) -> x /= mempty && s /= mempty
  Testing RightReductive laws for type Product Natural
    rightReductiveLaw_isSuffixOf_mappend [✔]
      +++ OK, passed 100 tests:
      92% allNonNull [a, b]
      83% allUnique [a, b]
      82% allUniqueNonNull [a, b]
    rightReductiveLaw_isSuffixOf_stripSuffix [✔]
      +++ OK, passed 100 tests:
      92% allNonNull [a, b]
      83% allUnique [a, b]
      82% allUniqueNonNull [a, b]
    rightReductiveLaw_stripSuffix [✔]
      +++ OK, passed 100 tests:
      92% allNonNull [a, b]
      83% allUnique [a, b]
      82% allUniqueNonNull [a, b]
  Testing Cancellative laws for type Sum (Small Int)
    cancellativeLaw_cancellation_prefix [✔]
      +++ OK, passed 100 tests:
      89% allNonNull [a, b]
      86% allUnique [a, b]
      79% allUniqueNonNull [a, b]
    cancellativeLaw_cancellation_suffix [✔]
      +++ OK, passed 100 tests:
      89% allNonNull [a, b]
      86% allUnique [a, b]
      79% allUniqueNonNull [a, b]
  Testing Commutative laws for type Sum (Small Int)
    commutativeLaw_basic [✔]
      +++ OK, passed 100 tests:
      89% allNonNull [a, b]
      86% allUnique [a, b]
      79% (a /= b) && (a <> b /= a) && (b <> a /= b)
      79% allUniqueNonNull [a, b]
  Testing Factorial laws for type Sum (Small Int)
    factorialLaw_coverage [✔]
      +++ OK, passed 100 tests:
      90% length a >= 2
       6% length a == 0
       4% length a == 1
    factorialLaw_length_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors_reverse [✔]
      +++ OK, passed 100 tests.
    factorialLaw_all_factors_prime [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primePrefix_foldr [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primeSuffix_foldl [✔]
      +++ OK, passed 100 tests.
    factorialLaw_factors_foldl [✔]
      +++ OK, passed 100 tests:
      89% allNonNull [a, b]
      86% allUnique [a, b]
      79% allUniqueNonNull [a, b]
    factorialLaw_factors_foldl' [✔]
      +++ OK, passed 100 tests:
      89% allNonNull [a, b]
      86% allUnique [a, b]
      79% allUniqueNonNull [a, b]
    factorialLaw_factors_foldr [✔]
      +++ OK, passed 100 tests:
      89% allNonNull [a, b]
      86% allUnique [a, b]
      79% allUniqueNonNull [a, b]
  Testing FactorialMonoid laws for type Sum (Small Int)
    factorialMonoidLaw_coverage [✔]
      +++ OK, passed 100 tests:
      90% length a >= 2
       6% length a == 0
       4% length a == 1
    factorialMonoidLaw_null [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_reverse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_inits [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_tails [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_span [✔]
      +++ OK, passed 100 tests:
      50% any (not . p) (factors a)
      44% any p (factors a)
    factorialMonoidLaw_split [✔]
      +++ OK, passed 100 tests:
      50% any (not . p) (factors a)
      44% any p (factors a)
    factorialMonoidLaw_split_intersperse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitAt [✔]
      +++ OK, passed 100 tests.
  Testing LeftCancellative laws for type Sum (Small Int)
    leftCancellativeLaw_cancellation [✔]
      +++ OK, passed 100 tests:
      89% allNonNull [a, b]
      86% allUnique [a, b]
      79% allUniqueNonNull [a, b]
  Testing LeftReductive laws for type Sum (Small Int)
    leftReductiveLaw_isPrefixOf_mappend [✔]
      +++ OK, passed 100 tests:
      89% allNonNull [a, b]
      86% allUnique [a, b]
      79% allUniqueNonNull [a, b]
    leftReductiveLaw_isPrefixOf_stripPrefix [✔]
      +++ OK, passed 100 tests:
      89% allNonNull [a, b]
      86% allUnique [a, b]
      79% allUniqueNonNull [a, b]
    leftReductiveLaw_stripPrefix [✔]
      +++ OK, passed 100 tests:
      89% allNonNull [a, b]
      86% allUnique [a, b]
      79% allUniqueNonNull [a, b]
  Testing MonoidNull laws for type Sum (Small Int)
    monoidNullLaw_basic [✔]
      +++ OK, passed 100 tests:
      94% a /= mempty
       6% a == mempty
  Testing Reductive laws for type Sum (Small Int)
    reductiveLaw_equivalence_prefix [✔]
      +++ OK, passed 100 tests:
      89% allNonNull [a, b]
      86% allUnique [a, b]
      79% allUniqueNonNull [a, b]
    reductiveLaw_equivalence_suffix [✔]
      +++ OK, passed 100 tests:
      89% allNonNull [a, b]
      86% allUnique [a, b]
      79% allUniqueNonNull [a, b]
    reductiveLaw_inversion_prefix [✔]
      +++ OK, passed 100 tests:
      89% allNonNull [a, b]
      86% allUnique [a, b]
      79% allUniqueNonNull [a, b]
    reductiveLaw_inversion_suffix [✔]
      +++ OK, passed 100 tests:
      89% allNonNull [a, b]
      86% allUnique [a, b]
      79% allUniqueNonNull [a, b]
  Testing RightCancellative laws for type Sum (Small Int)
    rightCancellativeLaw_cancellation [✔]
      +++ OK, passed 100 tests:
      89% allNonNull [a, b]
      86% allUnique [a, b]
      79% allUniqueNonNull [a, b]
  Testing RightReductive laws for type Sum (Small Int)
    rightReductiveLaw_isSuffixOf_mappend [✔]
      +++ OK, passed 100 tests:
      89% allNonNull [a, b]
      86% allUnique [a, b]
      79% allUniqueNonNull [a, b]
    rightReductiveLaw_isSuffixOf_stripSuffix [✔]
      +++ OK, passed 100 tests:
      89% allNonNull [a, b]
      86% allUnique [a, b]
      79% allUniqueNonNull [a, b]
    rightReductiveLaw_stripSuffix [✔]
      +++ OK, passed 100 tests:
      89% allNonNull [a, b]
      86% allUnique [a, b]
      79% allUniqueNonNull [a, b]
  Testing Cancellative laws for type Sum Natural
    cancellativeLaw_cancellation_prefix [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b]
      88% allUnique [a, b]
      83% allUniqueNonNull [a, b]
    cancellativeLaw_cancellation_suffix [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b]
      88% allUnique [a, b]
      83% allUniqueNonNull [a, b]
  Testing Commutative laws for type Sum Natural
    commutativeLaw_basic [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b]
      88% allUnique [a, b]
      83% (a /= b) && (a <> b /= a) && (b <> a /= b)
      83% allUniqueNonNull [a, b]
  Testing DistributiveGCDMonoid laws for type Sum Natural
    distributiveGCDMonoidLaw_distributivity_left [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b, c]
      70% allUnique [a, b, c]
      66% allUniqueNonNull [a, b, c]
    distributiveGCDMonoidLaw_distributivity_right [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b, c]
      70% allUnique [a, b, c]
      66% allUniqueNonNull [a, b, c]
  Testing DistributiveLCMMonoid laws for type Sum Natural
    distributiveLCMMonoidLaw_distributivity_left [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b, c]
      70% allUnique [a, b, c]
      66% allUniqueNonNull [a, b, c]
    distributiveLCMMonoidLaw_distributivity_right [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b, c]
      70% allUnique [a, b, c]
      66% allUniqueNonNull [a, b, c]
    distributiveLCMMonoidLaw_distributivity_gcd_lcm [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b, c]
      70% allUnique [a, b, c]
      66% allUniqueNonNull [a, b, c]
    distributiveLCMMonoidLaw_distributivity_lcm_gcd [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b, c]
      70% allUnique [a, b, c]
      66% allUniqueNonNull [a, b, c]
  Testing Factorial laws for type Sum Natural
    factorialLaw_coverage [✔]
      +++ OK, passed 100 tests:
      94% length a >= 2
       4% length a == 0
       2% length a == 1
    factorialLaw_length_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors_reverse [✔]
      +++ OK, passed 100 tests.
    factorialLaw_all_factors_prime [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primePrefix_foldr [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primeSuffix_foldl [✔]
      +++ OK, passed 100 tests.
    factorialLaw_factors_foldl [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b]
      88% allUnique [a, b]
      83% allUniqueNonNull [a, b]
    factorialLaw_factors_foldl' [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b]
      88% allUnique [a, b]
      83% allUniqueNonNull [a, b]
    factorialLaw_factors_foldr [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b]
      88% allUnique [a, b]
      83% allUniqueNonNull [a, b]
  Testing FactorialMonoid laws for type Sum Natural
    factorialMonoidLaw_coverage [✔]
      +++ OK, passed 100 tests:
      94% length a >= 2
       4% length a == 0
       2% length a == 1
    factorialMonoidLaw_null [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_reverse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_inits [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_tails [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_span [✔]
      +++ OK, passed 100 tests:
      63% any (not . p) (factors a)
      33% any p (factors a)
    factorialMonoidLaw_split [✔]
      +++ OK, passed 100 tests:
      63% any (not . p) (factors a)
      33% any p (factors a)
    factorialMonoidLaw_split_intersperse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitAt [✔]
      +++ OK, passed 100 tests.
  Testing GCDMonoid laws for type Sum Natural
    gcdMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% (a </> gcd a b) /= mempty
      94% allNonNull [a, b]
      94% gcd a b /= mempty
      88% allUnique [a, b]
      83% allUniqueNonNull [a, b]
    gcdMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% (b </> gcd a b) /= mempty
      94% allNonNull [a, b]
      94% gcd a b /= mempty
      88% allUnique [a, b]
      83% allUniqueNonNull [a, b]
    gcdMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b, c]
      82% c /= gcd a b
      82% not (all isJust [a </> c, b </> c, c </> gcd a b])
      70% allUnique [a, b, c]
      66% allUniqueNonNull [a, b, c]
      18% all isJust [a </> c, b </> c, c </> gcd a b]
      18% c == gcd a b
    gcdMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    gcdMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (96% a /= mempty).
    gcdMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (96% a /= mempty).
    gcdMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b]
      94% gcd a b /= mempty
      88% allUnique [a, b]
      83% allUniqueNonNull [a, b]
       6% gcd a b == mempty
    gcdMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      97% gcd b c /= mempty
      95% gcd a b /= mempty
      94% allNonNull [a, b, c]
      70% allUnique [a, b, c]
      66% allUniqueNonNull [a, b, c]
    gcdMonoidLaw_equivalence_commonPrefix [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b]
      94% commonPrefix a b /= mempty
      94% gcd a b /= mempty
      88% allUnique [a, b]
      83% allUniqueNonNull [a, b]
    gcdMonoidLaw_equivalence_commonSuffix [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b]
      94% commonSuffix a b /= mempty
      94% gcd a b /= mempty
      88% allUnique [a, b]
      83% allUniqueNonNull [a, b]
  Testing LCMMonoid laws for type Sum Natural
    lcmMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      99% lcm a b /= mempty
      94% allNonNull [a, b]
      88% allUnique [a, b]
      83% allUniqueNonNull [a, b]
      45% (lcm a b </> a) /= Just mempty
    lcmMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      99% lcm a b /= mempty
      94% allNonNull [a, b]
      88% allUnique [a, b]
      83% allUniqueNonNull [a, b]
      43% (lcm a b </> b) /= Just mempty
    lcmMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b, c]
      85% c /= lcm a b
      85% not (all isJust [c </> a, c </> b, lcm a b </> c])
      70% allUnique [a, b, c]
      66% allUniqueNonNull [a, b, c]
      15% all isJust [c </> a, c </> b, lcm a b </> c]
      15% c == lcm a b
    lcmMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    lcmMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (96% a /= mempty).
    lcmMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (96% a /= mempty).
    lcmMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      99% lcm a b /= mempty
      94% allNonNull [a, b]
      88% allUnique [a, b]
      83% allUniqueNonNull [a, b]
    lcmMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      99% lcm a b /= mempty
      99% lcm b c /= mempty
      94% allNonNull [a, b, c]
      70% allUnique [a, b, c]
      66% allUniqueNonNull [a, b, c]
    lcmMonoidLaw_absorption_gcd_lcm [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b]
      94% gcd a b /= mempty
      88% allUnique [a, b]
      83% allUniqueNonNull [a, b]
       6% gcd a b == mempty
    lcmMonoidLaw_absorption_lcm_gcd [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b]
      94% gcd a b /= mempty
      88% allUnique [a, b]
      83% allUniqueNonNull [a, b]
       6% gcd a b == mempty
  Testing LeftCancellative laws for type Sum Natural
    leftCancellativeLaw_cancellation [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b]
      88% allUnique [a, b]
      83% allUniqueNonNull [a, b]
  Testing LeftDistributiveGCDMonoid laws for type Sum Natural
    leftDistributiveGCDMonoidLaw_distributivity [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b, c]
      94% commonPrefix b c /= mempty && a /= mempty
      70% allUnique [a, b, c]
      66% allUniqueNonNull [a, b, c]
  Testing LeftGCDMonoid laws for type Sum Natural
    leftGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) a /= mempty
      94% allNonNull [a, b]
      94% commonPrefix a b /= mempty
      88% allUnique [a, b]
      83% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) b /= mempty
      94% allNonNull [a, b]
      94% commonPrefix a b /= mempty
      88% allUnique [a, b]
      83% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      97% antecedent == False
      97% consequent == False
      94% allNonNull [a, b]
      88% allUnique [a, b]
      83% allUniqueNonNull [a, b]
       3% antecedent == True
       3% consequent == True
    leftGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    leftGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (96% a /= mempty).
    leftGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (96% a /= mempty).
    leftGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b]
      94% commonPrefix a b /= mempty
      88% allUnique [a, b]
      83% allUniqueNonNull [a, b]
       6% commonPrefix a b == mempty
    leftGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b, c]
      94% commonPrefix (commonPrefix a b) c /= mempty
      94% commonPrefix a (commonPrefix b c) /= mempty
      70% allUnique [a, b, c]
      66% allUniqueNonNull [a, b, c]
    leftGCDMonoidLaw_stripCommonPrefix_commonPrefix [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b]
      94% commonPrefix a b /= mempty
      88% allUnique [a, b]
      83% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_stripCommonPrefix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b]
      88% allUnique [a, b]
      83% allUniqueNonNull [a, b]
      43% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b]
      88% allUnique [a, b]
      83% allUniqueNonNull [a, b]
      40% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_1 [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b]
      88% allUnique [a, b]
      83% allUniqueNonNull [a, b]
      43% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_2 [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b]
      88% allUnique [a, b]
      83% allUniqueNonNull [a, b]
      40% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
  Testing LeftReductive laws for type Sum Natural
    leftReductiveLaw_isPrefixOf_mappend [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b]
      88% allUnique [a, b]
      83% allUniqueNonNull [a, b]
    leftReductiveLaw_isPrefixOf_stripPrefix [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b]
      88% allUnique [a, b]
      83% allUniqueNonNull [a, b]
    leftReductiveLaw_stripPrefix [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b]
      88% allUnique [a, b]
      83% allUniqueNonNull [a, b]
  Testing MonoidNull laws for type Sum Natural
    monoidNullLaw_basic [✔]
      +++ OK, passed 100 tests:
      96% a /= mempty
       4% a == mempty
  Testing Monus laws for type Sum Natural
    monusLaw_axiom_1 [✔]
      +++ OK, passed 100 tests:
      96% a /= mempty
       4% a == mempty
    monusLaw_axiom_2 [✔]
      +++ OK, passed 100 tests:
      96% a /= mempty
       4% a == mempty
    monusLaw_axiom_3 [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b]
      88% allUnique [a, b]
      83% allUniqueNonNull [a, b]
      45% (b <\> a) /= mempty
      43% (a <\> b) /= mempty
    monusLaw_axiom_4 [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b, c]
      70% allUnique [a, b, c]
      66% allUniqueNonNull [a, b, c]
      15% (a <\> b) <\> c /= mempty
    monusLaw_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b]
      88% allUnique [a, b]
      83% allUniqueNonNull [a, b]
      43% a <\> b /= mempty
    monusLaw_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b]
      88% allUnique [a, b]
      83% allUniqueNonNull [a, b]
      43% a <\> b /= mempty
  Testing OverlappingGCDMonoid laws for type Sum Natural
    overlappingGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (overlap a b) a /= mempty
      94% allNonNull [a, b]
      94% overlap a b /= mempty
      88% allUnique [a, b]
      83% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (overlap a b) b /= mempty
      94% allNonNull [a, b]
      94% overlap a b /= mempty
      88% allUnique [a, b]
      83% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    overlappingGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (96% a /= mempty).
    overlappingGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (96% a /= mempty).
    overlappingGCDMonoidLaw_overlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b]
      88% allUnique [a, b]
      83% allUniqueNonNull [a, b]
      40% overlap a b /= mempty && stripPrefixOverlap a b /= mempty
    overlappingGCDMonoidLaw_overlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b]
      88% allUnique [a, b]
      83% allUniqueNonNull [a, b]
      43% stripSuffixOverlap b a /= mempty && overlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_overlap [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b]
      94% overlap a b /= mempty
      88% allUnique [a, b]
      83% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_stripOverlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b]
      88% allUnique [a, b]
      83% allUniqueNonNull [a, b]
      45% stripPrefixOverlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b]
      88% allUnique [a, b]
      83% allUniqueNonNull [a, b]
      43% stripSuffixOverlap b a /= mempty
  Testing PositiveMonoid laws for type Sum Natural
    positiveMonoidLaw_fundamental [✔]
      +++ OK, passed 200 tests:
      98.5% not (null (a <> b))
      95.0% allNonNull [a, b]
      85.0% allUnique [a, b]
      81.5% allUniqueNonNull [a, b]
       1.5% null (a <> b)
  Testing Reductive laws for type Sum Natural
    reductiveLaw_equivalence_prefix [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b]
      88% allUnique [a, b]
      83% allUniqueNonNull [a, b]
    reductiveLaw_equivalence_suffix [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b]
      88% allUnique [a, b]
      83% allUniqueNonNull [a, b]
    reductiveLaw_inversion_prefix [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b]
      88% allUnique [a, b]
      83% allUniqueNonNull [a, b]
    reductiveLaw_inversion_suffix [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b]
      88% allUnique [a, b]
      83% allUniqueNonNull [a, b]
  Testing RightCancellative laws for type Sum Natural
    rightCancellativeLaw_cancellation [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b]
      88% allUnique [a, b]
      83% allUniqueNonNull [a, b]
  Testing RightDistributiveGCDMonoid laws for type Sum Natural
    rightDistributiveGCDMonoidLaw_distributivity [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b, c]
      94% commonSuffix a b /= mempty && c /= mempty
      70% allUnique [a, b, c]
      66% allUniqueNonNull [a, b, c]
  Testing RightGCDMonoid laws for type Sum Natural
    rightGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (commonSuffix a b) a /= mempty
      94% allNonNull [a, b]
      94% commonSuffix a b /= mempty
      88% allUnique [a, b]
      83% allUniqueNonNull [a, b]
    rightGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (commonSuffix a b) b /= mempty
      94% allNonNull [a, b]
      94% commonSuffix a b /= mempty
      88% allUnique [a, b]
      83% allUniqueNonNull [a, b]
    rightGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      97% antecedent == False
      97% consequent == False
      94% allNonNull [a, b]
      88% allUnique [a, b]
      83% allUniqueNonNull [a, b]
       3% antecedent == True
       3% consequent == True
    rightGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    rightGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (96% a /= mempty).
    rightGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (96% a /= mempty).
    rightGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b]
      94% commonSuffix a b /= mempty
      88% allUnique [a, b]
      83% allUniqueNonNull [a, b]
       6% commonSuffix a b == mempty
    rightGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b, c]
      94% commonSuffix (commonSuffix a b) c /= mempty
      94% commonSuffix a (commonSuffix b c) /= mempty
      70% allUnique [a, b, c]
      66% allUniqueNonNull [a, b, c]
    rightGCDMonoidLaw_stripCommonSuffix_commonSuffix [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b]
      94% commonSuffix a b /= mempty
      88% allUnique [a, b]
      83% allUniqueNonNull [a, b]
    rightGCDMonoidLaw_stripCommonSuffix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b]
      88% allUnique [a, b]
      83% allUniqueNonNull [a, b]
      43% stripCommonSuffix a b & \(x, _, s) -> x /= mempty && s /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b]
      88% allUnique [a, b]
      83% allUniqueNonNull [a, b]
      40% stripCommonSuffix a b & \(_, x, s) -> x /= mempty && s /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_stripSuffix_1 [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b]
      88% allUnique [a, b]
      83% allUniqueNonNull [a, b]
      43% stripCommonSuffix a b & \(x, _, s) -> x /= mempty && s /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_stripSuffix_2 [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b]
      88% allUnique [a, b]
      83% allUniqueNonNull [a, b]
      40% stripCommonSuffix a b & \(_, x, s) -> x /= mempty && s /= mempty
  Testing RightReductive laws for type Sum Natural
    rightReductiveLaw_isSuffixOf_mappend [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b]
      88% allUnique [a, b]
      83% allUniqueNonNull [a, b]
    rightReductiveLaw_isSuffixOf_stripSuffix [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b]
      88% allUnique [a, b]
      83% allUniqueNonNull [a, b]
    rightReductiveLaw_stripSuffix [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b]
      88% allUnique [a, b]
      83% allUniqueNonNull [a, b]
  Testing StableFactorial laws for type Sum Natural
    stableFactorialLaw_factors_mappend [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b]
      88% allUnique [a, b]
      83% allUniqueNonNull [a, b]
    stableFactorialLaw_factors_reverse [✔]
      +++ OK, passed 100 tests.
    stableFactorialLaw_primePrefix_primeSuffix_reverse [✔]
      +++ OK, passed 100 tests.
    stableFactorialLaw_primeSuffix_primePrefix_reverse [✔]
      +++ OK, passed 100 tests.
  Testing Factorial laws for type IntMap (Small Int)
    factorialLaw_coverage [✔]
      +++ OK, passed 100 tests:
      95% length a >= 2
       3% length a == 0
       2% length a == 1
    factorialLaw_length_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors_reverse [✔]
      +++ OK, passed 100 tests.
    factorialLaw_all_factors_prime [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primePrefix_foldr [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primeSuffix_foldl [✔]
      +++ OK, passed 100 tests.
    factorialLaw_factors_foldl [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
    factorialLaw_factors_foldl' [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
    factorialLaw_factors_foldr [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
  Testing FactorialMonoid laws for type IntMap (Small Int)
    factorialMonoidLaw_coverage [✔]
      +++ OK, passed 100 tests:
      95% length a >= 2
       3% length a == 0
       2% length a == 1
    factorialMonoidLaw_null [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_reverse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_inits [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_tails [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_span [✔]
      +++ OK, passed 100 tests:
      96% any p (factors a)
      94% any (not . p) (factors a)
    factorialMonoidLaw_split [✔]
      +++ OK, passed 100 tests:
      96% any p (factors a)
      94% any (not . p) (factors a)
    factorialMonoidLaw_split_intersperse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitAt [✔]
      +++ OK, passed 100 tests.
  Testing LeftGCDMonoid laws for type IntMap (Small Int)
    leftGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) a /= mempty
      90% allUnique [a, b]
      87% commonPrefix a b /= mempty
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) b /= mempty
      90% allUnique [a, b]
      87% commonPrefix a b /= mempty
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      97% antecedent == False
      97% consequent == False
      90% allUnique [a, b]
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
       3% antecedent == True
       3% consequent == True
    leftGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    leftGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    leftGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    leftGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      87% commonPrefix a b /= mempty
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
      13% commonPrefix a b == mempty
    leftGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      80% allUnique [a, b, c]
      75% commonPrefix (commonPrefix a b) c /= mempty
      75% commonPrefix a (commonPrefix b c) /= mempty
      72% allNonNull [a, b, c]
      64% allUniqueNonNull [a, b, c]
    leftGCDMonoidLaw_stripCommonPrefix_commonPrefix [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      87% commonPrefix a b /= mempty
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_stripCommonPrefix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      71% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_stripCommonPrefix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
      67% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_1 [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      71% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_2 [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
      67% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
  Testing LeftReductive laws for type IntMap (Small Int)
    leftReductiveLaw_isPrefixOf_mappend [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
    leftReductiveLaw_isPrefixOf_stripPrefix [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
    leftReductiveLaw_stripPrefix [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
  Testing MonoidNull laws for type IntMap (Small Int)
    monoidNullLaw_basic [✔]
      +++ OK, passed 100 tests:
      97% a /= mempty
       3% a == mempty
  Testing OverlappingGCDMonoid laws for type IntMap (Small Int)
    overlappingGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (overlap a b) a /= mempty
      96% overlap a b /= mempty
      90% allUnique [a, b]
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (overlap a b) b /= mempty
      96% overlap a b /= mempty
      90% allUnique [a, b]
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    overlappingGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    overlappingGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    overlappingGCDMonoidLaw_overlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
      57% overlap a b /= mempty && stripPrefixOverlap a b /= mempty
    overlappingGCDMonoidLaw_overlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      80% stripSuffixOverlap b a /= mempty && overlap a b /= mempty
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_stripOverlap_overlap [✔]
      +++ OK, passed 100 tests:
      96% overlap a b /= mempty
      90% allUnique [a, b]
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_stripOverlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
      59% stripPrefixOverlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      82% stripSuffixOverlap b a /= mempty
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
  Testing PositiveMonoid laws for type IntMap (Small Int)
    positiveMonoidLaw_fundamental [✔]
      +++ OK, passed 400 tests:
      98.5% not (null (a <> b))
      90.2% allUnique [a, b]
      66.8% allNonNull [a, b]
      66.8% allUniqueNonNull [a, b]
       1.5% null (a <> b)
  Testing RightReductive laws for type IntMap (Small Int)
    rightReductiveLaw_isSuffixOf_mappend [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
    rightReductiveLaw_isSuffixOf_stripSuffix [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
    rightReductiveLaw_stripSuffix [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
  Testing Factorial laws for type IntMap Natural
    factorialLaw_coverage [✔]
      +++ OK, passed 100 tests:
      95% length a >= 2
       3% length a == 0
       2% length a == 1
    factorialLaw_length_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors_reverse [✔]
      +++ OK, passed 100 tests.
    factorialLaw_all_factors_prime [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primePrefix_foldr [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primeSuffix_foldl [✔]
      +++ OK, passed 100 tests.
    factorialLaw_factors_foldl [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
    factorialLaw_factors_foldl' [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
    factorialLaw_factors_foldr [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
  Testing FactorialMonoid laws for type IntMap Natural
    factorialMonoidLaw_coverage [✔]
      +++ OK, passed 100 tests:
      95% length a >= 2
       3% length a == 0
       2% length a == 1
    factorialMonoidLaw_null [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_reverse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_inits [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_tails [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_span [✔]
      +++ OK, passed 100 tests:
      95% any p (factors a)
      93% any (not . p) (factors a)
    factorialMonoidLaw_split [✔]
      +++ OK, passed 100 tests:
      95% any p (factors a)
      93% any (not . p) (factors a)
    factorialMonoidLaw_split_intersperse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitAt [✔]
      +++ OK, passed 100 tests.
  Testing LeftGCDMonoid laws for type IntMap Natural
    leftGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) a /= mempty
      90% allUnique [a, b]
      86% commonPrefix a b /= mempty
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) b /= mempty
      90% allUnique [a, b]
      86% commonPrefix a b /= mempty
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      96% antecedent == False
      96% consequent == False
      90% allUnique [a, b]
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
       4% antecedent == True
       4% consequent == True
    leftGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    leftGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    leftGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    leftGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      86% commonPrefix a b /= mempty
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
      14% commonPrefix a b == mempty
    leftGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      80% allUnique [a, b, c]
      75% commonPrefix (commonPrefix a b) c /= mempty
      75% commonPrefix a (commonPrefix b c) /= mempty
      72% allNonNull [a, b, c]
      64% allUniqueNonNull [a, b, c]
    leftGCDMonoidLaw_stripCommonPrefix_commonPrefix [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      86% commonPrefix a b /= mempty
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_stripCommonPrefix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
      70% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
      66% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_1 [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
      70% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_2 [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
      66% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
  Testing LeftReductive laws for type IntMap Natural
    leftReductiveLaw_isPrefixOf_mappend [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
    leftReductiveLaw_isPrefixOf_stripPrefix [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
    leftReductiveLaw_stripPrefix [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
  Testing MonoidNull laws for type IntMap Natural
    monoidNullLaw_basic [✔]
      +++ OK, passed 100 tests:
      97% a /= mempty
       3% a == mempty
  Testing OverlappingGCDMonoid laws for type IntMap Natural
    overlappingGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (overlap a b) a /= mempty
      96% overlap a b /= mempty
      90% allUnique [a, b]
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (overlap a b) b /= mempty
      96% overlap a b /= mempty
      90% allUnique [a, b]
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    overlappingGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    overlappingGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    overlappingGCDMonoidLaw_overlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
      57% overlap a b /= mempty && stripPrefixOverlap a b /= mempty
    overlappingGCDMonoidLaw_overlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      80% stripSuffixOverlap b a /= mempty && overlap a b /= mempty
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_stripOverlap_overlap [✔]
      +++ OK, passed 100 tests:
      96% overlap a b /= mempty
      90% allUnique [a, b]
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_stripOverlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
      59% stripPrefixOverlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      82% stripSuffixOverlap b a /= mempty
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
  Testing PositiveMonoid laws for type IntMap Natural
    positiveMonoidLaw_fundamental [✔]
      +++ OK, passed 400 tests:
      98.5% not (null (a <> b))
      90.2% allUnique [a, b]
      66.8% allNonNull [a, b]
      66.8% allUniqueNonNull [a, b]
       1.5% null (a <> b)
  Testing RightReductive laws for type IntMap Natural
    rightReductiveLaw_isSuffixOf_mappend [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
    rightReductiveLaw_isSuffixOf_stripSuffix [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
    rightReductiveLaw_stripSuffix [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
  Testing Factorial laws for type Map Int (Small Int)
    factorialLaw_coverage [✔]
      +++ OK, passed 100 tests:
      95% length a >= 2
       3% length a == 0
       2% length a == 1
    factorialLaw_length_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors_reverse [✔]
      +++ OK, passed 100 tests.
    factorialLaw_all_factors_prime [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primePrefix_foldr [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primeSuffix_foldl [✔]
      +++ OK, passed 100 tests.
    factorialLaw_factors_foldl [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
    factorialLaw_factors_foldl' [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
    factorialLaw_factors_foldr [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
  Testing FactorialMonoid laws for type Map Int (Small Int)
    factorialMonoidLaw_coverage [✔]
      +++ OK, passed 100 tests:
      95% length a >= 2
       3% length a == 0
       2% length a == 1
    factorialMonoidLaw_null [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_reverse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_inits [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_tails [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_span [✔]
      +++ OK, passed 100 tests:
      96% any p (factors a)
      94% any (not . p) (factors a)
    factorialMonoidLaw_split [✔]
      +++ OK, passed 100 tests:
      96% any p (factors a)
      94% any (not . p) (factors a)
    factorialMonoidLaw_split_intersperse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitAt [✔]
      +++ OK, passed 100 tests.
  Testing LeftGCDMonoid laws for type Map Int (Small Int)
    leftGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) a /= mempty
      90% allUnique [a, b]
      87% commonPrefix a b /= mempty
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) b /= mempty
      90% allUnique [a, b]
      87% commonPrefix a b /= mempty
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      97% antecedent == False
      97% consequent == False
      90% allUnique [a, b]
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
       3% antecedent == True
       3% consequent == True
    leftGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    leftGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    leftGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    leftGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      87% commonPrefix a b /= mempty
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
      13% commonPrefix a b == mempty
    leftGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      80% allUnique [a, b, c]
      75% commonPrefix (commonPrefix a b) c /= mempty
      75% commonPrefix a (commonPrefix b c) /= mempty
      72% allNonNull [a, b, c]
      64% allUniqueNonNull [a, b, c]
    leftGCDMonoidLaw_stripCommonPrefix_commonPrefix [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      87% commonPrefix a b /= mempty
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_stripCommonPrefix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      71% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_stripCommonPrefix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
      67% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_1 [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      71% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_2 [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
      67% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
  Testing LeftReductive laws for type Map Int (Small Int)
    leftReductiveLaw_isPrefixOf_mappend [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
    leftReductiveLaw_isPrefixOf_stripPrefix [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
    leftReductiveLaw_stripPrefix [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
  Testing MonoidNull laws for type Map Int (Small Int)
    monoidNullLaw_basic [✔]
      +++ OK, passed 100 tests:
      97% a /= mempty
       3% a == mempty
  Testing OverlappingGCDMonoid laws for type Map Int (Small Int)
    overlappingGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (overlap a b) a /= mempty
      96% overlap a b /= mempty
      90% allUnique [a, b]
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (overlap a b) b /= mempty
      96% overlap a b /= mempty
      90% allUnique [a, b]
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    overlappingGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    overlappingGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    overlappingGCDMonoidLaw_overlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
      57% overlap a b /= mempty && stripPrefixOverlap a b /= mempty
    overlappingGCDMonoidLaw_overlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      80% stripSuffixOverlap b a /= mempty && overlap a b /= mempty
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_stripOverlap_overlap [✔]
      +++ OK, passed 100 tests:
      96% overlap a b /= mempty
      90% allUnique [a, b]
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_stripOverlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
      59% stripPrefixOverlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      82% stripSuffixOverlap b a /= mempty
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
  Testing PositiveMonoid laws for type Map Int (Small Int)
    positiveMonoidLaw_fundamental [✔]
      +++ OK, passed 400 tests:
      98.5% not (null (a <> b))
      90.2% allUnique [a, b]
      66.8% allNonNull [a, b]
      66.8% allUniqueNonNull [a, b]
       1.5% null (a <> b)
  Testing RightReductive laws for type Map Int (Small Int)
    rightReductiveLaw_isSuffixOf_mappend [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
    rightReductiveLaw_isSuffixOf_stripSuffix [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
    rightReductiveLaw_stripSuffix [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
  Testing Factorial laws for type Map Int Natural
    factorialLaw_coverage [✔]
      +++ OK, passed 100 tests:
      95% length a >= 2
       3% length a == 0
       2% length a == 1
    factorialLaw_length_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors_reverse [✔]
      +++ OK, passed 100 tests.
    factorialLaw_all_factors_prime [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primePrefix_foldr [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primeSuffix_foldl [✔]
      +++ OK, passed 100 tests.
    factorialLaw_factors_foldl [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
    factorialLaw_factors_foldl' [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
    factorialLaw_factors_foldr [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
  Testing FactorialMonoid laws for type Map Int Natural
    factorialMonoidLaw_coverage [✔]
      +++ OK, passed 100 tests:
      95% length a >= 2
       3% length a == 0
       2% length a == 1
    factorialMonoidLaw_null [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_reverse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_inits [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_tails [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_span [✔]
      +++ OK, passed 100 tests:
      95% any p (factors a)
      93% any (not . p) (factors a)
    factorialMonoidLaw_split [✔]
      +++ OK, passed 100 tests:
      95% any p (factors a)
      93% any (not . p) (factors a)
    factorialMonoidLaw_split_intersperse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitAt [✔]
      +++ OK, passed 100 tests.
  Testing LeftGCDMonoid laws for type Map Int Natural
    leftGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) a /= mempty
      90% allUnique [a, b]
      86% commonPrefix a b /= mempty
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) b /= mempty
      90% allUnique [a, b]
      86% commonPrefix a b /= mempty
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      96% antecedent == False
      96% consequent == False
      90% allUnique [a, b]
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
       4% antecedent == True
       4% consequent == True
    leftGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    leftGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    leftGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    leftGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      86% commonPrefix a b /= mempty
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
      14% commonPrefix a b == mempty
    leftGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      80% allUnique [a, b, c]
      75% commonPrefix (commonPrefix a b) c /= mempty
      75% commonPrefix a (commonPrefix b c) /= mempty
      72% allNonNull [a, b, c]
      64% allUniqueNonNull [a, b, c]
    leftGCDMonoidLaw_stripCommonPrefix_commonPrefix [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      86% commonPrefix a b /= mempty
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_stripCommonPrefix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
      70% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
      66% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_1 [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
      70% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_2 [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
      66% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
  Testing LeftReductive laws for type Map Int Natural
    leftReductiveLaw_isPrefixOf_mappend [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
    leftReductiveLaw_isPrefixOf_stripPrefix [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
    leftReductiveLaw_stripPrefix [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
  Testing MonoidNull laws for type Map Int Natural
    monoidNullLaw_basic [✔]
      +++ OK, passed 100 tests:
      97% a /= mempty
       3% a == mempty
  Testing OverlappingGCDMonoid laws for type Map Int Natural
    overlappingGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (overlap a b) a /= mempty
      96% overlap a b /= mempty
      90% allUnique [a, b]
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (overlap a b) b /= mempty
      96% overlap a b /= mempty
      90% allUnique [a, b]
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    overlappingGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    overlappingGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    overlappingGCDMonoidLaw_overlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
      57% overlap a b /= mempty && stripPrefixOverlap a b /= mempty
    overlappingGCDMonoidLaw_overlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      80% stripSuffixOverlap b a /= mempty && overlap a b /= mempty
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_stripOverlap_overlap [✔]
      +++ OK, passed 100 tests:
      96% overlap a b /= mempty
      90% allUnique [a, b]
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_stripOverlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
      59% stripPrefixOverlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      82% stripSuffixOverlap b a /= mempty
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
  Testing PositiveMonoid laws for type Map Int Natural
    positiveMonoidLaw_fundamental [✔]
      +++ OK, passed 400 tests:
      98.5% not (null (a <> b))
      90.2% allUnique [a, b]
      66.8% allNonNull [a, b]
      66.8% allUniqueNonNull [a, b]
       1.5% null (a <> b)
  Testing RightReductive laws for type Map Int Natural
    rightReductiveLaw_isSuffixOf_mappend [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
    rightReductiveLaw_isSuffixOf_stripSuffix [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
    rightReductiveLaw_stripSuffix [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      70% allNonNull [a, b]
      70% allUniqueNonNull [a, b]
  Testing Commutative laws for type Maybe ()
    commutativeLaw_basic [✔]
      +++ OK, passed 100 tests (20% allUnique [a, b]).
      
      Only 0% (a /= b) && (a <> b /= a) && (b <> a /= b), but expected 0%
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
  Testing Factorial laws for type Maybe ()
    factorialLaw_coverage [✔]
      +++ OK, passed 100 tests:
      94% length a == 1
       6% length a == 0
      
      Only 0% length a >= 2, but expected 0%
    factorialLaw_length_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors_reverse [✔]
      +++ OK, passed 100 tests.
    factorialLaw_all_factors_prime [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primePrefix_foldr [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primeSuffix_foldl [✔]
      +++ OK, passed 100 tests.
    factorialLaw_factors_foldl [✔]
      +++ OK, passed 100 tests (20% allUnique [a, b]).
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    factorialLaw_factors_foldl' [✔]
      +++ OK, passed 100 tests (20% allUnique [a, b]).
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    factorialLaw_factors_foldr [✔]
      +++ OK, passed 100 tests (20% allUnique [a, b]).
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
  Testing FactorialMonoid laws for type Maybe ()
    factorialMonoidLaw_coverage [✔]
      +++ OK, passed 100 tests:
      94% length a == 1
       6% length a == 0
      
      Only 0% length a >= 2, but expected 0%
    factorialMonoidLaw_null [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_reverse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_inits [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_tails [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_span [✔]
      +++ OK, passed 100 tests:
      51% any (not . p) (factors a)
      43% any p (factors a)
    factorialMonoidLaw_split [✔]
      +++ OK, passed 100 tests:
      51% any (not . p) (factors a)
      43% any p (factors a)
    factorialMonoidLaw_split_intersperse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitAt [✔]
      +++ OK, passed 100 tests.
  Testing LeftGCDMonoid laws for type Maybe ()
    leftGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) a /= mempty
      78% commonPrefix a b /= mempty
      20% allUnique [a, b]
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    leftGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) b /= mempty
      78% commonPrefix a b /= mempty
      20% allUnique [a, b]
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    leftGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      63% antecedent == True
      63% consequent == True
      37% antecedent == False
      37% consequent == False
      20% allUnique [a, b]
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    leftGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    leftGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (94% a /= mempty).
    leftGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (94% a /= mempty).
    leftGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      78% commonPrefix a b /= mempty
      22% commonPrefix a b == mempty
      20% allUnique [a, b]
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    leftGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      80% commonPrefix (commonPrefix a b) c /= mempty
      80% commonPrefix a (commonPrefix b c) /= mempty
      
      Only 0% allNonNull [a, b, c], but expected 0%
      Only 0% allUnique [a, b, c], but expected 0%
      Only 0% allUniqueNonNull [a, b, c], but expected 0%
    leftGCDMonoidLaw_stripCommonPrefix_commonPrefix [✔]
      +++ OK, passed 100 tests:
      78% commonPrefix a b /= mempty
      20% allUnique [a, b]
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    leftGCDMonoidLaw_stripCommonPrefix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      78% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
      20% allUnique [a, b]
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    leftGCDMonoidLaw_stripCommonPrefix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      78% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
      20% allUnique [a, b]
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_1 [✔]
      +++ OK, passed 100 tests:
      78% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
      20% allUnique [a, b]
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_2 [✔]
      +++ OK, passed 100 tests:
      78% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
      20% allUnique [a, b]
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
  Testing LeftReductive laws for type Maybe ()
    leftReductiveLaw_isPrefixOf_mappend [✔]
      +++ OK, passed 100 tests (20% allUnique [a, b]).
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    leftReductiveLaw_isPrefixOf_stripPrefix [✔]
      +++ OK, passed 100 tests (20% allUnique [a, b]).
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    leftReductiveLaw_stripPrefix [✔]
      +++ OK, passed 100 tests (20% allUnique [a, b]).
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
  Testing MonoidNull laws for type Maybe ()
    monoidNullLaw_basic [✔]
      +++ OK, passed 100 tests:
      94% a /= mempty
       6% a == mempty
  Testing Monus laws for type Maybe ()
    monusLaw_axiom_1 [✔]
      +++ OK, passed 100 tests:
      94% a /= mempty
       6% a == mempty
    monusLaw_axiom_2 [✔]
      +++ OK, passed 100 tests:
      94% a /= mempty
       6% a == mempty
    monusLaw_axiom_3 [✔]
      +++ OK, passed 100 tests:
      20% allUnique [a, b]
      10% (a <\> b) /= mempty
      10% (b <\> a) /= mempty
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    monusLaw_axiom_4 [✔]
      +++ OK, passed 100 tests (2% (a <\> b) <\> c /= mempty).
      
      Only 0% allNonNull [a, b, c], but expected 0%
      Only 0% allUnique [a, b, c], but expected 0%
      Only 0% allUniqueNonNull [a, b, c], but expected 0%
    monusLaw_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      20% allUnique [a, b]
      10% a <\> b /= mempty
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    monusLaw_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      20% allUnique [a, b]
      10% a <\> b /= mempty
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
  Testing OverlappingGCDMonoid laws for type Maybe ()
    overlappingGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (overlap a b) a /= mempty
      78% overlap a b /= mempty
      20% allUnique [a, b]
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    overlappingGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (overlap a b) b /= mempty
      78% overlap a b /= mempty
      20% allUnique [a, b]
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    overlappingGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    overlappingGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (94% a /= mempty).
    overlappingGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (94% a /= mempty).
    overlappingGCDMonoidLaw_overlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests (20% allUnique [a, b]).
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% overlap a b /= mempty && stripPrefixOverlap a b /= mempty, but expected 0%
    overlappingGCDMonoidLaw_overlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests (20% allUnique [a, b]).
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% stripSuffixOverlap b a /= mempty && overlap a b /= mempty, but expected 0%
    overlappingGCDMonoidLaw_stripOverlap_overlap [✔]
      +++ OK, passed 100 tests:
      78% overlap a b /= mempty
      20% allUnique [a, b]
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    overlappingGCDMonoidLaw_stripOverlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      20% allUnique [a, b]
      10% stripPrefixOverlap a b /= mempty
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    overlappingGCDMonoidLaw_stripOverlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      20% allUnique [a, b]
      10% stripSuffixOverlap b a /= mempty
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
  Testing PositiveMonoid laws for type Maybe ()
    positiveMonoidLaw_fundamental [✔]
      +++ OK, passed 100 tests:
      98% not (null (a <> b))
      20% allUnique [a, b]
       2% null (a <> b)
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
  Testing Reductive laws for type Maybe ()
    reductiveLaw_equivalence_prefix [✔]
      +++ OK, passed 100 tests (20% allUnique [a, b]).
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    reductiveLaw_equivalence_suffix [✔]
      +++ OK, passed 100 tests (20% allUnique [a, b]).
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    reductiveLaw_inversion_prefix [✔]
      +++ OK, passed 100 tests (20% allUnique [a, b]).
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    reductiveLaw_inversion_suffix [✔]
      +++ OK, passed 100 tests (20% allUnique [a, b]).
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
  Testing RightGCDMonoid laws for type Maybe ()
    rightGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (commonSuffix a b) a /= mempty
      78% commonSuffix a b /= mempty
      20% allUnique [a, b]
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    rightGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (commonSuffix a b) b /= mempty
      78% commonSuffix a b /= mempty
      20% allUnique [a, b]
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    rightGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      63% antecedent == True
      63% consequent == True
      37% antecedent == False
      37% consequent == False
      20% allUnique [a, b]
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    rightGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    rightGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (94% a /= mempty).
    rightGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (94% a /= mempty).
    rightGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      78% commonSuffix a b /= mempty
      22% commonSuffix a b == mempty
      20% allUnique [a, b]
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    rightGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      80% commonSuffix (commonSuffix a b) c /= mempty
      80% commonSuffix a (commonSuffix b c) /= mempty
      
      Only 0% allNonNull [a, b, c], but expected 0%
      Only 0% allUnique [a, b, c], but expected 0%
      Only 0% allUniqueNonNull [a, b, c], but expected 0%
    rightGCDMonoidLaw_stripCommonSuffix_commonSuffix [✔]
      +++ OK, passed 100 tests:
      78% commonSuffix a b /= mempty
      20% allUnique [a, b]
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    rightGCDMonoidLaw_stripCommonSuffix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      78% stripCommonSuffix a b & \(x, _, s) -> x /= mempty && s /= mempty
      20% allUnique [a, b]
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    rightGCDMonoidLaw_stripCommonSuffix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      78% stripCommonSuffix a b & \(_, x, s) -> x /= mempty && s /= mempty
      20% allUnique [a, b]
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    rightGCDMonoidLaw_stripCommonSuffix_stripSuffix_1 [✔]
      +++ OK, passed 100 tests:
      78% stripCommonSuffix a b & \(x, _, s) -> x /= mempty && s /= mempty
      20% allUnique [a, b]
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    rightGCDMonoidLaw_stripCommonSuffix_stripSuffix_2 [✔]
      +++ OK, passed 100 tests:
      78% stripCommonSuffix a b & \(_, x, s) -> x /= mempty && s /= mempty
      20% allUnique [a, b]
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
  Testing RightReductive laws for type Maybe ()
    rightReductiveLaw_isSuffixOf_mappend [✔]
      +++ OK, passed 100 tests (20% allUnique [a, b]).
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    rightReductiveLaw_isSuffixOf_stripSuffix [✔]
      +++ OK, passed 100 tests (20% allUnique [a, b]).
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    rightReductiveLaw_stripSuffix [✔]
      +++ OK, passed 100 tests (20% allUnique [a, b]).
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
  Testing Commutative laws for type Maybe (Product (Small Int))
    commutativeLaw_basic [✔]
      +++ OK, passed 100 tests:
      78% allUnique [a, b]
      70% allNonNull [a, b]
      54% allUniqueNonNull [a, b]
      53% (a /= b) && (a <> b /= a) && (b <> a /= b)
  Testing Factorial laws for type Maybe (Product (Small Int))
    factorialLaw_coverage [✔]
      +++ OK, passed 100 tests:
      62% length a == 1
      32% length a >= 2
       6% length a == 0
    factorialLaw_length_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors_reverse [✔]
      +++ OK, passed 100 tests.
    factorialLaw_all_factors_prime [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primePrefix_foldr [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primeSuffix_foldl [✔]
      +++ OK, passed 100 tests.
    factorialLaw_factors_foldl [✔]
      +++ OK, passed 100 tests:
      78% allUnique [a, b]
      70% allNonNull [a, b]
      54% allUniqueNonNull [a, b]
    factorialLaw_factors_foldl' [✔]
      +++ OK, passed 100 tests:
      78% allUnique [a, b]
      70% allNonNull [a, b]
      54% allUniqueNonNull [a, b]
    factorialLaw_factors_foldr [✔]
      +++ OK, passed 100 tests:
      78% allUnique [a, b]
      70% allNonNull [a, b]
      54% allUniqueNonNull [a, b]
  Testing FactorialMonoid laws for type Maybe (Product (Small Int))
    factorialMonoidLaw_coverage [✔]
      +++ OK, passed 100 tests:
      62% length a == 1
      32% length a >= 2
       6% length a == 0
    factorialMonoidLaw_null [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_reverse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_inits [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_tails [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_span [✔]
      +++ OK, passed 100 tests:
      57% any p (factors a)
      56% any (not . p) (factors a)
    factorialMonoidLaw_split [✔]
      +++ OK, passed 100 tests:
      57% any p (factors a)
      56% any (not . p) (factors a)
    factorialMonoidLaw_split_intersperse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitAt [✔]
      +++ OK, passed 100 tests.
  Testing LeftReductive laws for type Maybe (Product (Small Int))
    leftReductiveLaw_isPrefixOf_mappend [✔]
      +++ OK, passed 100 tests:
      78% allUnique [a, b]
      70% allNonNull [a, b]
      54% allUniqueNonNull [a, b]
    leftReductiveLaw_isPrefixOf_stripPrefix [✔]
      +++ OK, passed 100 tests:
      78% allUnique [a, b]
      70% allNonNull [a, b]
      54% allUniqueNonNull [a, b]
    leftReductiveLaw_stripPrefix [✔]
      +++ OK, passed 100 tests:
      78% allUnique [a, b]
      70% allNonNull [a, b]
      54% allUniqueNonNull [a, b]
  Testing MonoidNull laws for type Maybe (Product (Small Int))
    monoidNullLaw_basic [✔]
      +++ OK, passed 100 tests:
      94% a /= mempty
       6% a == mempty
  Testing PositiveMonoid laws for type Maybe (Product (Small Int))
    positiveMonoidLaw_fundamental [✔]
      +++ OK, passed 100 tests:
      98% not (null (a <> b))
      78% allUnique [a, b]
      70% allNonNull [a, b]
      54% allUniqueNonNull [a, b]
       2% null (a <> b)
  Testing Reductive laws for type Maybe (Product (Small Int))
    reductiveLaw_equivalence_prefix [✔]
      +++ OK, passed 100 tests:
      78% allUnique [a, b]
      70% allNonNull [a, b]
      54% allUniqueNonNull [a, b]
    reductiveLaw_equivalence_suffix [✔]
      +++ OK, passed 100 tests:
      78% allUnique [a, b]
      70% allNonNull [a, b]
      54% allUniqueNonNull [a, b]
    reductiveLaw_inversion_prefix [✔]
      +++ OK, passed 100 tests:
      78% allUnique [a, b]
      70% allNonNull [a, b]
      54% allUniqueNonNull [a, b]
    reductiveLaw_inversion_suffix [✔]
      +++ OK, passed 100 tests:
      78% allUnique [a, b]
      70% allNonNull [a, b]
      54% allUniqueNonNull [a, b]
  Testing RightReductive laws for type Maybe (Product (Small Int))
    rightReductiveLaw_isSuffixOf_mappend [✔]
      +++ OK, passed 100 tests:
      78% allUnique [a, b]
      70% allNonNull [a, b]
      54% allUniqueNonNull [a, b]
    rightReductiveLaw_isSuffixOf_stripSuffix [✔]
      +++ OK, passed 100 tests:
      78% allUnique [a, b]
      70% allNonNull [a, b]
      54% allUniqueNonNull [a, b]
    rightReductiveLaw_stripSuffix [✔]
      +++ OK, passed 100 tests:
      78% allUnique [a, b]
      70% allNonNull [a, b]
      54% allUniqueNonNull [a, b]
  Testing Commutative laws for type Maybe (Product Natural)
    commutativeLaw_basic [✔]
      +++ OK, passed 100 tests:
      79% allUnique [a, b]
      72% allNonNull [a, b]
      56% allUniqueNonNull [a, b]
      52% (a /= b) && (a <> b /= a) && (b <> a /= b)
  Testing Factorial laws for type Maybe (Product Natural)
    factorialLaw_coverage [✔]
      +++ OK, passed 100 tests:
      74% length a >= 2
      20% length a == 1
       6% length a == 0
    factorialLaw_length_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors_reverse [✔]
      +++ OK, passed 100 tests.
    factorialLaw_all_factors_prime [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primePrefix_foldr [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primeSuffix_foldl [✔]
      +++ OK, passed 100 tests.
    factorialLaw_factors_foldl [✔]
      +++ OK, passed 100 tests:
      79% allUnique [a, b]
      72% allNonNull [a, b]
      56% allUniqueNonNull [a, b]
    factorialLaw_factors_foldl' [✔]
      +++ OK, passed 100 tests:
      79% allUnique [a, b]
      72% allNonNull [a, b]
      56% allUniqueNonNull [a, b]
    factorialLaw_factors_foldr [✔]
      +++ OK, passed 100 tests:
      79% allUnique [a, b]
      72% allNonNull [a, b]
      56% allUniqueNonNull [a, b]
  Testing FactorialMonoid laws for type Maybe (Product Natural)
    factorialMonoidLaw_coverage [✔]
      +++ OK, passed 100 tests:
      74% length a >= 2
      20% length a == 1
       6% length a == 0
    factorialMonoidLaw_null [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_reverse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_inits [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_tails [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_span [✔]
      +++ OK, passed 100 tests:
      68% any (not . p) (factors a)
      68% any p (factors a)
    factorialMonoidLaw_split [✔]
      +++ OK, passed 100 tests:
      68% any (not . p) (factors a)
      68% any p (factors a)
    factorialMonoidLaw_split_intersperse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitAt [✔]
      +++ OK, passed 100 tests.
  Testing LeftGCDMonoid laws for type Maybe (Product Natural)
    leftGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) a /= mempty
      79% allUnique [a, b]
      78% commonPrefix a b /= mempty
      72% allNonNull [a, b]
      56% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) b /= mempty
      79% allUnique [a, b]
      78% commonPrefix a b /= mempty
      72% allNonNull [a, b]
      56% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      91% antecedent == False
      91% consequent == False
      79% allUnique [a, b]
      72% allNonNull [a, b]
      56% allUniqueNonNull [a, b]
       9% antecedent == True
       9% consequent == True
    leftGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    leftGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (94% a /= mempty).
    leftGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (94% a /= mempty).
    leftGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      79% allUnique [a, b]
      78% commonPrefix a b /= mempty
      72% allNonNull [a, b]
      56% allUniqueNonNull [a, b]
      22% commonPrefix a b == mempty
    leftGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      80% commonPrefix (commonPrefix a b) c /= mempty
      80% commonPrefix a (commonPrefix b c) /= mempty
      72% allNonNull [a, b, c]
      42% allUnique [a, b, c]
      30% allUniqueNonNull [a, b, c]
    leftGCDMonoidLaw_stripCommonPrefix_commonPrefix [✔]
      +++ OK, passed 100 tests:
      79% allUnique [a, b]
      78% commonPrefix a b /= mempty
      72% allNonNull [a, b]
      56% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_stripCommonPrefix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      79% allUnique [a, b]
      78% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
      72% allNonNull [a, b]
      56% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_stripCommonPrefix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      79% allUnique [a, b]
      78% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
      72% allNonNull [a, b]
      56% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_1 [✔]
      +++ OK, passed 100 tests:
      79% allUnique [a, b]
      78% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
      72% allNonNull [a, b]
      56% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_2 [✔]
      +++ OK, passed 100 tests:
      79% allUnique [a, b]
      78% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
      72% allNonNull [a, b]
      56% allUniqueNonNull [a, b]
  Testing LeftReductive laws for type Maybe (Product Natural)
    leftReductiveLaw_isPrefixOf_mappend [✔]
      +++ OK, passed 100 tests:
      79% allUnique [a, b]
      72% allNonNull [a, b]
      56% allUniqueNonNull [a, b]
    leftReductiveLaw_isPrefixOf_stripPrefix [✔]
      +++ OK, passed 100 tests:
      79% allUnique [a, b]
      72% allNonNull [a, b]
      56% allUniqueNonNull [a, b]
    leftReductiveLaw_stripPrefix [✔]
      +++ OK, passed 100 tests:
      79% allUnique [a, b]
      72% allNonNull [a, b]
      56% allUniqueNonNull [a, b]
  Testing MonoidNull laws for type Maybe (Product Natural)
    monoidNullLaw_basic [✔]
      +++ OK, passed 100 tests:
      94% a /= mempty
       6% a == mempty
  Testing Monus laws for type Maybe (Product Natural)
    monusLaw_axiom_1 [✔]
      +++ OK, passed 100 tests:
      94% a /= mempty
       6% a == mempty
    monusLaw_axiom_2 [✔]
      +++ OK, passed 100 tests:
      94% a /= mempty
       6% a == mempty
    monusLaw_axiom_3 [✔]
      +++ OK, passed 100 tests:
      79% allUnique [a, b]
      72% allNonNull [a, b]
      56% allUniqueNonNull [a, b]
      50% (a <\> b) /= mempty
      42% (b <\> a) /= mempty
    monusLaw_axiom_4 [✔]
      +++ OK, passed 100 tests:
      72% allNonNull [a, b, c]
      42% allUnique [a, b, c]
      30% allUniqueNonNull [a, b, c]
      29% (a <\> b) <\> c /= mempty
    monusLaw_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      79% allUnique [a, b]
      72% allNonNull [a, b]
      56% allUniqueNonNull [a, b]
      50% a <\> b /= mempty
    monusLaw_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      79% allUnique [a, b]
      72% allNonNull [a, b]
      56% allUniqueNonNull [a, b]
      50% a <\> b /= mempty
  Testing OverlappingGCDMonoid laws for type Maybe (Product Natural)
    overlappingGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (overlap a b) a /= mempty
      79% allUnique [a, b]
      78% overlap a b /= mempty
      72% allNonNull [a, b]
      56% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (overlap a b) b /= mempty
      79% allUnique [a, b]
      78% overlap a b /= mempty
      72% allNonNull [a, b]
      56% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    overlappingGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (94% a /= mempty).
    overlappingGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (94% a /= mempty).
    overlappingGCDMonoidLaw_overlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      79% allUnique [a, b]
      72% allNonNull [a, b]
      56% allUniqueNonNull [a, b]
      32% overlap a b /= mempty && stripPrefixOverlap a b /= mempty
    overlappingGCDMonoidLaw_overlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      79% allUnique [a, b]
      72% allNonNull [a, b]
      56% allUniqueNonNull [a, b]
      40% stripSuffixOverlap b a /= mempty && overlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_overlap [✔]
      +++ OK, passed 100 tests:
      79% allUnique [a, b]
      78% overlap a b /= mempty
      72% allNonNull [a, b]
      56% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_stripOverlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      79% allUnique [a, b]
      72% allNonNull [a, b]
      56% allUniqueNonNull [a, b]
      42% stripPrefixOverlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      79% allUnique [a, b]
      72% allNonNull [a, b]
      56% allUniqueNonNull [a, b]
      50% stripSuffixOverlap b a /= mempty
  Testing PositiveMonoid laws for type Maybe (Product Natural)
    positiveMonoidLaw_fundamental [✔]
      +++ OK, passed 100 tests:
      98% not (null (a <> b))
      79% allUnique [a, b]
      72% allNonNull [a, b]
      56% allUniqueNonNull [a, b]
       2% null (a <> b)
  Testing Reductive laws for type Maybe (Product Natural)
    reductiveLaw_equivalence_prefix [✔]
      +++ OK, passed 100 tests:
      79% allUnique [a, b]
      72% allNonNull [a, b]
      56% allUniqueNonNull [a, b]
    reductiveLaw_equivalence_suffix [✔]
      +++ OK, passed 100 tests:
      79% allUnique [a, b]
      72% allNonNull [a, b]
      56% allUniqueNonNull [a, b]
    reductiveLaw_inversion_prefix [✔]
      +++ OK, passed 100 tests:
      79% allUnique [a, b]
      72% allNonNull [a, b]
      56% allUniqueNonNull [a, b]
    reductiveLaw_inversion_suffix [✔]
      +++ OK, passed 100 tests:
      79% allUnique [a, b]
      72% allNonNull [a, b]
      56% allUniqueNonNull [a, b]
  Testing RightGCDMonoid laws for type Maybe (Product Natural)
    rightGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (commonSuffix a b) a /= mempty
      79% allUnique [a, b]
      78% commonSuffix a b /= mempty
      72% allNonNull [a, b]
      56% allUniqueNonNull [a, b]
    rightGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (commonSuffix a b) b /= mempty
      79% allUnique [a, b]
      78% commonSuffix a b /= mempty
      72% allNonNull [a, b]
      56% allUniqueNonNull [a, b]
    rightGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      91% antecedent == False
      91% consequent == False
      79% allUnique [a, b]
      72% allNonNull [a, b]
      56% allUniqueNonNull [a, b]
       9% antecedent == True
       9% consequent == True
    rightGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    rightGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (94% a /= mempty).
    rightGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (94% a /= mempty).
    rightGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      79% allUnique [a, b]
      78% commonSuffix a b /= mempty
      72% allNonNull [a, b]
      56% allUniqueNonNull [a, b]
      22% commonSuffix a b == mempty
    rightGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      80% commonSuffix (commonSuffix a b) c /= mempty
      80% commonSuffix a (commonSuffix b c) /= mempty
      72% allNonNull [a, b, c]
      42% allUnique [a, b, c]
      30% allUniqueNonNull [a, b, c]
    rightGCDMonoidLaw_stripCommonSuffix_commonSuffix [✔]
      +++ OK, passed 100 tests:
      79% allUnique [a, b]
      78% commonSuffix a b /= mempty
      72% allNonNull [a, b]
      56% allUniqueNonNull [a, b]
    rightGCDMonoidLaw_stripCommonSuffix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      79% allUnique [a, b]
      78% stripCommonSuffix a b & \(x, _, s) -> x /= mempty && s /= mempty
      72% allNonNull [a, b]
      56% allUniqueNonNull [a, b]
    rightGCDMonoidLaw_stripCommonSuffix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      79% allUnique [a, b]
      78% stripCommonSuffix a b & \(_, x, s) -> x /= mempty && s /= mempty
      72% allNonNull [a, b]
      56% allUniqueNonNull [a, b]
    rightGCDMonoidLaw_stripCommonSuffix_stripSuffix_1 [✔]
      +++ OK, passed 100 tests:
      79% allUnique [a, b]
      78% stripCommonSuffix a b & \(x, _, s) -> x /= mempty && s /= mempty
      72% allNonNull [a, b]
      56% allUniqueNonNull [a, b]
    rightGCDMonoidLaw_stripCommonSuffix_stripSuffix_2 [✔]
      +++ OK, passed 100 tests:
      79% allUnique [a, b]
      78% stripCommonSuffix a b & \(_, x, s) -> x /= mempty && s /= mempty
      72% allNonNull [a, b]
      56% allUniqueNonNull [a, b]
  Testing RightReductive laws for type Maybe (Product Natural)
    rightReductiveLaw_isSuffixOf_mappend [✔]
      +++ OK, passed 100 tests:
      79% allUnique [a, b]
      72% allNonNull [a, b]
      56% allUniqueNonNull [a, b]
    rightReductiveLaw_isSuffixOf_stripSuffix [✔]
      +++ OK, passed 100 tests:
      79% allUnique [a, b]
      72% allNonNull [a, b]
      56% allUniqueNonNull [a, b]
    rightReductiveLaw_stripSuffix [✔]
      +++ OK, passed 100 tests:
      79% allUnique [a, b]
      72% allNonNull [a, b]
      56% allUniqueNonNull [a, b]
  Testing Commutative laws for type Maybe (Sum (Small Int))
    commutativeLaw_basic [✔]
      +++ OK, passed 100 tests:
      81% allUnique [a, b]
      73% allNonNull [a, b]
      58% (a /= b) && (a <> b /= a) && (b <> a /= b)
      58% allUniqueNonNull [a, b]
  Testing Factorial laws for type Maybe (Sum (Small Int))
    factorialLaw_coverage [✔]
      +++ OK, passed 100 tests:
      84% length a >= 2
      10% length a == 1
       6% length a == 0
    factorialLaw_length_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors_reverse [✔]
      +++ OK, passed 100 tests.
    factorialLaw_all_factors_prime [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primePrefix_foldr [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primeSuffix_foldl [✔]
      +++ OK, passed 100 tests.
    factorialLaw_factors_foldl [✔]
      +++ OK, passed 100 tests:
      81% allUnique [a, b]
      73% allNonNull [a, b]
      58% allUniqueNonNull [a, b]
    factorialLaw_factors_foldl' [✔]
      +++ OK, passed 100 tests:
      81% allUnique [a, b]
      73% allNonNull [a, b]
      58% allUniqueNonNull [a, b]
    factorialLaw_factors_foldr [✔]
      +++ OK, passed 100 tests:
      81% allUnique [a, b]
      73% allNonNull [a, b]
      58% allUniqueNonNull [a, b]
  Testing FactorialMonoid laws for type Maybe (Sum (Small Int))
    factorialMonoidLaw_coverage [✔]
      +++ OK, passed 100 tests:
      84% length a >= 2
      10% length a == 1
       6% length a == 0
    factorialMonoidLaw_null [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_reverse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_inits [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_tails [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_span [✔]
      +++ OK, passed 100 tests:
      56% any (not . p) (factors a)
      38% any p (factors a)
    factorialMonoidLaw_split [✔]
      +++ OK, passed 100 tests:
      56% any (not . p) (factors a)
      38% any p (factors a)
    factorialMonoidLaw_split_intersperse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitAt [✔]
      +++ OK, passed 100 tests.
  Testing LeftReductive laws for type Maybe (Sum (Small Int))
    leftReductiveLaw_isPrefixOf_mappend [✔]
      +++ OK, passed 100 tests:
      81% allUnique [a, b]
      73% allNonNull [a, b]
      58% allUniqueNonNull [a, b]
    leftReductiveLaw_isPrefixOf_stripPrefix [✔]
      +++ OK, passed 100 tests:
      81% allUnique [a, b]
      73% allNonNull [a, b]
      58% allUniqueNonNull [a, b]
    leftReductiveLaw_stripPrefix [✔]
      +++ OK, passed 100 tests:
      81% allUnique [a, b]
      73% allNonNull [a, b]
      58% allUniqueNonNull [a, b]
  Testing MonoidNull laws for type Maybe (Sum (Small Int))
    monoidNullLaw_basic [✔]
      +++ OK, passed 100 tests:
      94% a /= mempty
       6% a == mempty
  Testing PositiveMonoid laws for type Maybe (Sum (Small Int))
    positiveMonoidLaw_fundamental [✔]
      +++ OK, passed 100 tests:
      98% not (null (a <> b))
      81% allUnique [a, b]
      73% allNonNull [a, b]
      58% allUniqueNonNull [a, b]
       2% null (a <> b)
  Testing Reductive laws for type Maybe (Sum (Small Int))
    reductiveLaw_equivalence_prefix [✔]
      +++ OK, passed 100 tests:
      81% allUnique [a, b]
      73% allNonNull [a, b]
      58% allUniqueNonNull [a, b]
    reductiveLaw_equivalence_suffix [✔]
      +++ OK, passed 100 tests:
      81% allUnique [a, b]
      73% allNonNull [a, b]
      58% allUniqueNonNull [a, b]
    reductiveLaw_inversion_prefix [✔]
      +++ OK, passed 100 tests:
      81% allUnique [a, b]
      73% allNonNull [a, b]
      58% allUniqueNonNull [a, b]
    reductiveLaw_inversion_suffix [✔]
      +++ OK, passed 100 tests:
      81% allUnique [a, b]
      73% allNonNull [a, b]
      58% allUniqueNonNull [a, b]
  Testing RightReductive laws for type Maybe (Sum (Small Int))
    rightReductiveLaw_isSuffixOf_mappend [✔]
      +++ OK, passed 100 tests:
      81% allUnique [a, b]
      73% allNonNull [a, b]
      58% allUniqueNonNull [a, b]
    rightReductiveLaw_isSuffixOf_stripSuffix [✔]
      +++ OK, passed 100 tests:
      81% allUnique [a, b]
      73% allNonNull [a, b]
      58% allUniqueNonNull [a, b]
    rightReductiveLaw_stripSuffix [✔]
      +++ OK, passed 100 tests:
      81% allUnique [a, b]
      73% allNonNull [a, b]
      58% allUniqueNonNull [a, b]
  Testing Commutative laws for type Maybe (Sum Natural)
    commutativeLaw_basic [✔]
      +++ OK, passed 100 tests:
      80% allUnique [a, b]
      74% allNonNull [a, b]
      57% (a /= b) && (a <> b /= a) && (b <> a /= b)
      57% allUniqueNonNull [a, b]
  Testing Factorial laws for type Maybe (Sum Natural)
    factorialLaw_coverage [✔]
      +++ OK, passed 100 tests:
      87% length a >= 2
       7% length a == 1
       6% length a == 0
    factorialLaw_length_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors_reverse [✔]
      +++ OK, passed 100 tests.
    factorialLaw_all_factors_prime [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primePrefix_foldr [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primeSuffix_foldl [✔]
      +++ OK, passed 100 tests.
    factorialLaw_factors_foldl [✔]
      +++ OK, passed 100 tests:
      80% allUnique [a, b]
      74% allNonNull [a, b]
      57% allUniqueNonNull [a, b]
    factorialLaw_factors_foldl' [✔]
      +++ OK, passed 100 tests:
      80% allUnique [a, b]
      74% allNonNull [a, b]
      57% allUniqueNonNull [a, b]
    factorialLaw_factors_foldr [✔]
      +++ OK, passed 100 tests:
      80% allUnique [a, b]
      74% allNonNull [a, b]
      57% allUniqueNonNull [a, b]
  Testing FactorialMonoid laws for type Maybe (Sum Natural)
    factorialMonoidLaw_coverage [✔]
      +++ OK, passed 100 tests:
      87% length a >= 2
       7% length a == 1
       6% length a == 0
    factorialMonoidLaw_null [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_reverse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_inits [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_tails [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_span [✔]
      +++ OK, passed 100 tests:
      55% any (not . p) (factors a)
      39% any p (factors a)
    factorialMonoidLaw_split [✔]
      +++ OK, passed 100 tests:
      55% any (not . p) (factors a)
      39% any p (factors a)
    factorialMonoidLaw_split_intersperse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitAt [✔]
      +++ OK, passed 100 tests.
  Testing LeftGCDMonoid laws for type Maybe (Sum Natural)
    leftGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) a /= mempty
      80% allUnique [a, b]
      78% commonPrefix a b /= mempty
      74% allNonNull [a, b]
      57% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) b /= mempty
      80% allUnique [a, b]
      78% commonPrefix a b /= mempty
      74% allNonNull [a, b]
      57% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      92% antecedent == False
      92% consequent == False
      80% allUnique [a, b]
      74% allNonNull [a, b]
      57% allUniqueNonNull [a, b]
       8% antecedent == True
       8% consequent == True
    leftGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    leftGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (94% a /= mempty).
    leftGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (94% a /= mempty).
    leftGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      80% allUnique [a, b]
      78% commonPrefix a b /= mempty
      74% allNonNull [a, b]
      57% allUniqueNonNull [a, b]
      22% commonPrefix a b == mempty
    leftGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      80% commonPrefix (commonPrefix a b) c /= mempty
      80% commonPrefix a (commonPrefix b c) /= mempty
      77% allNonNull [a, b, c]
      45% allUnique [a, b, c]
      32% allUniqueNonNull [a, b, c]
    leftGCDMonoidLaw_stripCommonPrefix_commonPrefix [✔]
      +++ OK, passed 100 tests:
      80% allUnique [a, b]
      78% commonPrefix a b /= mempty
      74% allNonNull [a, b]
      57% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_stripCommonPrefix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      80% allUnique [a, b]
      78% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
      74% allNonNull [a, b]
      57% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_stripCommonPrefix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      80% allUnique [a, b]
      78% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
      74% allNonNull [a, b]
      57% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_1 [✔]
      +++ OK, passed 100 tests:
      80% allUnique [a, b]
      78% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
      74% allNonNull [a, b]
      57% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_2 [✔]
      +++ OK, passed 100 tests:
      80% allUnique [a, b]
      78% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
      74% allNonNull [a, b]
      57% allUniqueNonNull [a, b]
  Testing LeftReductive laws for type Maybe (Sum Natural)
    leftReductiveLaw_isPrefixOf_mappend [✔]
      +++ OK, passed 100 tests:
      80% allUnique [a, b]
      74% allNonNull [a, b]
      57% allUniqueNonNull [a, b]
    leftReductiveLaw_isPrefixOf_stripPrefix [✔]
      +++ OK, passed 100 tests:
      80% allUnique [a, b]
      74% allNonNull [a, b]
      57% allUniqueNonNull [a, b]
    leftReductiveLaw_stripPrefix [✔]
      +++ OK, passed 100 tests:
      80% allUnique [a, b]
      74% allNonNull [a, b]
      57% allUniqueNonNull [a, b]
  Testing MonoidNull laws for type Maybe (Sum Natural)
    monoidNullLaw_basic [✔]
      +++ OK, passed 100 tests:
      94% a /= mempty
       6% a == mempty
  Testing Monus laws for type Maybe (Sum Natural)
    monusLaw_axiom_1 [✔]
      +++ OK, passed 100 tests:
      94% a /= mempty
       6% a == mempty
    monusLaw_axiom_2 [✔]
      +++ OK, passed 100 tests:
      94% a /= mempty
       6% a == mempty
    monusLaw_axiom_3 [✔]
      +++ OK, passed 100 tests:
      80% allUnique [a, b]
      74% allNonNull [a, b]
      57% allUniqueNonNull [a, b]
      42% (a <\> b) /= mempty
      38% (b <\> a) /= mempty
    monusLaw_axiom_4 [✔]
      +++ OK, passed 100 tests:
      77% allNonNull [a, b, c]
      45% allUnique [a, b, c]
      32% allUniqueNonNull [a, b, c]
      22% (a <\> b) <\> c /= mempty
    monusLaw_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      80% allUnique [a, b]
      74% allNonNull [a, b]
      57% allUniqueNonNull [a, b]
      42% a <\> b /= mempty
    monusLaw_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      80% allUnique [a, b]
      74% allNonNull [a, b]
      57% allUniqueNonNull [a, b]
      42% a <\> b /= mempty
  Testing OverlappingGCDMonoid laws for type Maybe (Sum Natural)
    overlappingGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (overlap a b) a /= mempty
      80% allUnique [a, b]
      78% overlap a b /= mempty
      74% allNonNull [a, b]
      57% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (overlap a b) b /= mempty
      80% allUnique [a, b]
      78% overlap a b /= mempty
      74% allNonNull [a, b]
      57% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    overlappingGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (94% a /= mempty).
    overlappingGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (94% a /= mempty).
    overlappingGCDMonoidLaw_overlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      80% allUnique [a, b]
      74% allNonNull [a, b]
      57% allUniqueNonNull [a, b]
      28% overlap a b /= mempty && stripPrefixOverlap a b /= mempty
    overlappingGCDMonoidLaw_overlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      80% allUnique [a, b]
      74% allNonNull [a, b]
      57% allUniqueNonNull [a, b]
      32% stripSuffixOverlap b a /= mempty && overlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_overlap [✔]
      +++ OK, passed 100 tests:
      80% allUnique [a, b]
      78% overlap a b /= mempty
      74% allNonNull [a, b]
      57% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_stripOverlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      80% allUnique [a, b]
      74% allNonNull [a, b]
      57% allUniqueNonNull [a, b]
      38% stripPrefixOverlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      80% allUnique [a, b]
      74% allNonNull [a, b]
      57% allUniqueNonNull [a, b]
      42% stripSuffixOverlap b a /= mempty
  Testing PositiveMonoid laws for type Maybe (Sum Natural)
    positiveMonoidLaw_fundamental [✔]
      +++ OK, passed 100 tests:
      98% not (null (a <> b))
      80% allUnique [a, b]
      74% allNonNull [a, b]
      57% allUniqueNonNull [a, b]
       2% null (a <> b)
  Testing Reductive laws for type Maybe (Sum Natural)
    reductiveLaw_equivalence_prefix [✔]
      +++ OK, passed 100 tests:
      80% allUnique [a, b]
      74% allNonNull [a, b]
      57% allUniqueNonNull [a, b]
    reductiveLaw_equivalence_suffix [✔]
      +++ OK, passed 100 tests:
      80% allUnique [a, b]
      74% allNonNull [a, b]
      57% allUniqueNonNull [a, b]
    reductiveLaw_inversion_prefix [✔]
      +++ OK, passed 100 tests:
      80% allUnique [a, b]
      74% allNonNull [a, b]
      57% allUniqueNonNull [a, b]
    reductiveLaw_inversion_suffix [✔]
      +++ OK, passed 100 tests:
      80% allUnique [a, b]
      74% allNonNull [a, b]
      57% allUniqueNonNull [a, b]
  Testing RightGCDMonoid laws for type Maybe (Sum Natural)
    rightGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (commonSuffix a b) a /= mempty
      80% allUnique [a, b]
      78% commonSuffix a b /= mempty
      74% allNonNull [a, b]
      57% allUniqueNonNull [a, b]
    rightGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (commonSuffix a b) b /= mempty
      80% allUnique [a, b]
      78% commonSuffix a b /= mempty
      74% allNonNull [a, b]
      57% allUniqueNonNull [a, b]
    rightGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      92% antecedent == False
      92% consequent == False
      80% allUnique [a, b]
      74% allNonNull [a, b]
      57% allUniqueNonNull [a, b]
       8% antecedent == True
       8% consequent == True
    rightGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    rightGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (94% a /= mempty).
    rightGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (94% a /= mempty).
    rightGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      80% allUnique [a, b]
      78% commonSuffix a b /= mempty
      74% allNonNull [a, b]
      57% allUniqueNonNull [a, b]
      22% commonSuffix a b == mempty
    rightGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      80% commonSuffix (commonSuffix a b) c /= mempty
      80% commonSuffix a (commonSuffix b c) /= mempty
      77% allNonNull [a, b, c]
      45% allUnique [a, b, c]
      32% allUniqueNonNull [a, b, c]
    rightGCDMonoidLaw_stripCommonSuffix_commonSuffix [✔]
      +++ OK, passed 100 tests:
      80% allUnique [a, b]
      78% commonSuffix a b /= mempty
      74% allNonNull [a, b]
      57% allUniqueNonNull [a, b]
    rightGCDMonoidLaw_stripCommonSuffix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      80% allUnique [a, b]
      78% stripCommonSuffix a b & \(x, _, s) -> x /= mempty && s /= mempty
      74% allNonNull [a, b]
      57% allUniqueNonNull [a, b]
    rightGCDMonoidLaw_stripCommonSuffix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      80% allUnique [a, b]
      78% stripCommonSuffix a b & \(_, x, s) -> x /= mempty && s /= mempty
      74% allNonNull [a, b]
      57% allUniqueNonNull [a, b]
    rightGCDMonoidLaw_stripCommonSuffix_stripSuffix_1 [✔]
      +++ OK, passed 100 tests:
      80% allUnique [a, b]
      78% stripCommonSuffix a b & \(x, _, s) -> x /= mempty && s /= mempty
      74% allNonNull [a, b]
      57% allUniqueNonNull [a, b]
    rightGCDMonoidLaw_stripCommonSuffix_stripSuffix_2 [✔]
      +++ OK, passed 100 tests:
      80% allUnique [a, b]
      78% stripCommonSuffix a b & \(_, x, s) -> x /= mempty && s /= mempty
      74% allNonNull [a, b]
      57% allUniqueNonNull [a, b]
  Testing RightReductive laws for type Maybe (Sum Natural)
    rightReductiveLaw_isSuffixOf_mappend [✔]
      +++ OK, passed 100 tests:
      80% allUnique [a, b]
      74% allNonNull [a, b]
      57% allUniqueNonNull [a, b]
    rightReductiveLaw_isSuffixOf_stripSuffix [✔]
      +++ OK, passed 100 tests:
      80% allUnique [a, b]
      74% allNonNull [a, b]
      57% allUniqueNonNull [a, b]
    rightReductiveLaw_stripSuffix [✔]
      +++ OK, passed 100 tests:
      80% allUnique [a, b]
      74% allNonNull [a, b]
      57% allUniqueNonNull [a, b]

Finished in 3.0403 seconds
1892 examples, 0 failures
Test suite test: PASS
Test suite logged to:
/tmp/workdir-quickcheck-monoid-subclasses/quickcheck-monoid-subclasses-0.3.0.4/dist-newstyle/build/x86_64-linux/ghc-9.6.6/quickcheck-monoid-subclasses-0.3.0.4/t/test/test/quickcheck-monoid-subclasses-0.3.0.4-test.log
1 of 1 test suites (1 of 1 test cases) passed.
