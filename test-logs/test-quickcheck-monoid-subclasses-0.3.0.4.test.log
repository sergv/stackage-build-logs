Build profile: -w ghc-9.6.6 -O1
In order, the following will be built (use -v for more details):
 - quickcheck-monoid-subclasses-0.3.0.4 (test:test) (ephemeral targets)
Preprocessing test suite 'test' for quickcheck-monoid-subclasses-0.3.0.4...
Building test suite 'test' for quickcheck-monoid-subclasses-0.3.0.4...
Running 1 test suites...
Test suite test: RUNNING...

Class
  Testing Cancellative laws for type ()
    cancellativeLaw_cancellation_prefix [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    cancellativeLaw_cancellation_suffix [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
  Testing Commutative laws for type ()
    commutativeLaw_basic [✔]
      +++ OK, passed 100 tests.
      
      Only 0% (a /= b) && (a <> b /= a) && (b <> a /= b), but expected 0%
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
  Testing DistributiveGCDMonoid laws for type ()
    distributiveGCDMonoidLaw_distributivity_left [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b, c], but expected 0%
      Only 0% allUnique [a, b, c], but expected 0%
      Only 0% allUniqueNonNull [a, b, c], but expected 0%
    distributiveGCDMonoidLaw_distributivity_right [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b, c], but expected 0%
      Only 0% allUnique [a, b, c], but expected 0%
      Only 0% allUniqueNonNull [a, b, c], but expected 0%
  Testing DistributiveLCMMonoid laws for type ()
    distributiveLCMMonoidLaw_distributivity_left [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b, c], but expected 0%
      Only 0% allUnique [a, b, c], but expected 0%
      Only 0% allUniqueNonNull [a, b, c], but expected 0%
    distributiveLCMMonoidLaw_distributivity_right [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b, c], but expected 0%
      Only 0% allUnique [a, b, c], but expected 0%
      Only 0% allUniqueNonNull [a, b, c], but expected 0%
    distributiveLCMMonoidLaw_distributivity_gcd_lcm [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b, c], but expected 0%
      Only 0% allUnique [a, b, c], but expected 0%
      Only 0% allUniqueNonNull [a, b, c], but expected 0%
    distributiveLCMMonoidLaw_distributivity_lcm_gcd [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b, c], but expected 0%
      Only 0% allUnique [a, b, c], but expected 0%
      Only 0% allUniqueNonNull [a, b, c], but expected 0%
  Testing Factorial laws for type ()
    factorialLaw_coverage [✔]
      +++ OK, passed 100 tests (100% length a == 0).
      
      Only 0% length a == 1, but expected 0%
      Only 0% length a >= 2, but expected 0%
    factorialLaw_length_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors_reverse [✔]
      +++ OK, passed 100 tests.
    factorialLaw_all_factors_prime [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primePrefix_foldr [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primeSuffix_foldl [✔]
      +++ OK, passed 100 tests.
    factorialLaw_factors_foldl [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    factorialLaw_factors_foldl' [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    factorialLaw_factors_foldr [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
  Testing FactorialMonoid laws for type ()
    factorialMonoidLaw_coverage [✔]
      +++ OK, passed 100 tests (100% length a == 0).
      
      Only 0% length a == 1, but expected 0%
      Only 0% length a >= 2, but expected 0%
    factorialMonoidLaw_null [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_reverse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_inits [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_tails [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_span [✔]
      +++ OK, passed 100 tests.
      
      Only 0% any (not . p) (factors a), but expected 0%
      Only 0% any p (factors a), but expected 0%
    factorialMonoidLaw_split [✔]
      +++ OK, passed 100 tests.
      
      Only 0% any (not . p) (factors a), but expected 0%
      Only 0% any p (factors a), but expected 0%
    factorialMonoidLaw_split_intersperse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitAt [✔]
      +++ OK, passed 100 tests.
  Testing GCDMonoid laws for type ()
    gcdMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests (100% (a </> gcd a b) /= mempty).
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% gcd a b /= mempty, but expected 0%
    gcdMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests (100% (b </> gcd a b) /= mempty).
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% gcd a b /= mempty, but expected 0%
    gcdMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      100% all isJust [a </> c, b </> c, c </> gcd a b]
      100% c == gcd a b
      
      Only 0% allNonNull [a, b, c], but expected 0%
      Only 0% allUnique [a, b, c], but expected 0%
      Only 0% allUniqueNonNull [a, b, c], but expected 0%
      Only 0% c /= gcd a b, but expected 0%
      Only 0% not (all isJust [a </> c, b </> c, c </> gcd a b]), but expected 0%
    gcdMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    gcdMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests.
      
      Only 0% a /= mempty, but expected 0%
    gcdMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests.
      
      Only 0% a /= mempty, but expected 0%
    gcdMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests (100% gcd a b == mempty).
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% gcd a b /= mempty, but expected 0%
    gcdMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b, c], but expected 0%
      Only 0% allUnique [a, b, c], but expected 0%
      Only 0% allUniqueNonNull [a, b, c], but expected 0%
      Only 0% gcd a b /= mempty, but expected 0%
      Only 0% gcd b c /= mempty, but expected 0%
    gcdMonoidLaw_equivalence_commonPrefix [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% commonPrefix a b /= mempty, but expected 0%
      Only 0% gcd a b /= mempty, but expected 0%
    gcdMonoidLaw_equivalence_commonSuffix [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% commonSuffix a b /= mempty, but expected 0%
      Only 0% gcd a b /= mempty, but expected 0%
  Testing LCMMonoid laws for type ()
    lcmMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests.
      
      Only 0% (lcm a b </> a) /= Just mempty, but expected 0%
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% lcm a b /= mempty, but expected 0%
    lcmMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests.
      
      Only 0% (lcm a b </> b) /= Just mempty, but expected 0%
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% lcm a b /= mempty, but expected 0%
    lcmMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      100% all isJust [c </> a, c </> b, lcm a b </> c]
      100% c == lcm a b
      
      Only 0% allNonNull [a, b, c], but expected 0%
      Only 0% allUnique [a, b, c], but expected 0%
      Only 0% allUniqueNonNull [a, b, c], but expected 0%
      Only 0% c /= lcm a b, but expected 0%
      Only 0% not (all isJust [c </> a, c </> b, lcm a b </> c]), but expected 0%
    lcmMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    lcmMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests.
      
      Only 0% a /= mempty, but expected 0%
    lcmMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests.
      
      Only 0% a /= mempty, but expected 0%
    lcmMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% lcm a b /= mempty, but expected 0%
    lcmMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b, c], but expected 0%
      Only 0% allUnique [a, b, c], but expected 0%
      Only 0% allUniqueNonNull [a, b, c], but expected 0%
      Only 0% lcm a b /= mempty, but expected 0%
      Only 0% lcm b c /= mempty, but expected 0%
    lcmMonoidLaw_absorption_gcd_lcm [✔]
      +++ OK, passed 100 tests (100% gcd a b == mempty).
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% gcd a b /= mempty, but expected 0%
    lcmMonoidLaw_absorption_lcm_gcd [✔]
      +++ OK, passed 100 tests (100% gcd a b == mempty).
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% gcd a b /= mempty, but expected 0%
  Testing LeftCancellative laws for type ()
    leftCancellativeLaw_cancellation [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
  Testing LeftDistributiveGCDMonoid laws for type ()
    leftDistributiveGCDMonoidLaw_distributivity [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b, c], but expected 0%
      Only 0% allUnique [a, b, c], but expected 0%
      Only 0% allUniqueNonNull [a, b, c], but expected 0%
      Only 0% commonPrefix b c /= mempty && a /= mempty, but expected 0%
  Testing LeftGCDMonoid laws for type ()
    leftGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests (100% stripPrefix (commonPrefix a b) a /= mempty).
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% commonPrefix a b /= mempty, but expected 0%
    leftGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests (100% stripPrefix (commonPrefix a b) b /= mempty).
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% commonPrefix a b /= mempty, but expected 0%
    leftGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      100% antecedent == True
      100% consequent == True
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% antecedent == False, but expected 0%
      Only 0% consequent == False, but expected 0%
    leftGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    leftGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests.
      
      Only 0% a /= mempty, but expected 0%
    leftGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests.
      
      Only 0% a /= mempty, but expected 0%
    leftGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests (100% commonPrefix a b == mempty).
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% commonPrefix a b /= mempty, but expected 0%
    leftGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b, c], but expected 0%
      Only 0% allUnique [a, b, c], but expected 0%
      Only 0% allUniqueNonNull [a, b, c], but expected 0%
      Only 0% commonPrefix (commonPrefix a b) c /= mempty, but expected 0%
      Only 0% commonPrefix a (commonPrefix b c) /= mempty, but expected 0%
    leftGCDMonoidLaw_stripCommonPrefix_commonPrefix [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% commonPrefix a b /= mempty, but expected 0%
    leftGCDMonoidLaw_stripCommonPrefix_mappend_1 [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty, but expected 0%
    leftGCDMonoidLaw_stripCommonPrefix_mappend_2 [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty, but expected 0%
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_1 [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty, but expected 0%
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_2 [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty, but expected 0%
  Testing LeftReductive laws for type ()
    leftReductiveLaw_isPrefixOf_mappend [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    leftReductiveLaw_isPrefixOf_stripPrefix [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    leftReductiveLaw_stripPrefix [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
  Testing MonoidNull laws for type ()
    monoidNullLaw_basic [✔]
      +++ OK, passed 100 tests (100% a == mempty).
      
      Only 0% a /= mempty, but expected 0%
  Testing Monus laws for type ()
    monusLaw_axiom_1 [✔]
      +++ OK, passed 100 tests (100% a == mempty).
      
      Only 0% a /= mempty, but expected 0%
    monusLaw_axiom_2 [✔]
      +++ OK, passed 100 tests (100% a == mempty).
      
      Only 0% a /= mempty, but expected 0%
    monusLaw_axiom_3 [✔]
      +++ OK, passed 100 tests.
      
      Only 0% (a <\> b) /= mempty, but expected 0%
      Only 0% (b <\> a) /= mempty, but expected 0%
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    monusLaw_axiom_4 [✔]
      +++ OK, passed 100 tests.
      
      Only 0% (a <\> b) <\> c /= mempty, but expected 0%
      Only 0% allNonNull [a, b, c], but expected 0%
      Only 0% allUnique [a, b, c], but expected 0%
      Only 0% allUniqueNonNull [a, b, c], but expected 0%
    monusLaw_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests.
      
      Only 0% a <\> b /= mempty, but expected 0%
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    monusLaw_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests.
      
      Only 0% a <\> b /= mempty, but expected 0%
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
  Testing OverlappingGCDMonoid laws for type ()
    overlappingGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests (100% stripSuffix (overlap a b) a /= mempty).
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% overlap a b /= mempty, but expected 0%
    overlappingGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests (100% stripPrefix (overlap a b) b /= mempty).
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% overlap a b /= mempty, but expected 0%
    overlappingGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    overlappingGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests.
      
      Only 0% a /= mempty, but expected 0%
    overlappingGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests.
      
      Only 0% a /= mempty, but expected 0%
    overlappingGCDMonoidLaw_overlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% overlap a b /= mempty && stripPrefixOverlap a b /= mempty, but expected 0%
    overlappingGCDMonoidLaw_overlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% stripSuffixOverlap b a /= mempty && overlap a b /= mempty, but expected 0%
    overlappingGCDMonoidLaw_stripOverlap_overlap [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% overlap a b /= mempty, but expected 0%
    overlappingGCDMonoidLaw_stripOverlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% stripPrefixOverlap a b /= mempty, but expected 0%
    overlappingGCDMonoidLaw_stripOverlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% stripSuffixOverlap b a /= mempty, but expected 0%
  Testing PositiveMonoid laws for type ()
    positiveMonoidLaw_fundamental [✔]
      +++ OK, passed 100 tests (100% null (a <> b)).
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% not (null (a <> b)), but expected 0%
  Testing Reductive laws for type ()
    reductiveLaw_equivalence_prefix [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    reductiveLaw_equivalence_suffix [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    reductiveLaw_inversion_prefix [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    reductiveLaw_inversion_suffix [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
  Testing RightCancellative laws for type ()
    rightCancellativeLaw_cancellation [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
  Testing RightDistributiveGCDMonoid laws for type ()
    rightDistributiveGCDMonoidLaw_distributivity [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b, c], but expected 0%
      Only 0% allUnique [a, b, c], but expected 0%
      Only 0% allUniqueNonNull [a, b, c], but expected 0%
      Only 0% commonSuffix a b /= mempty && c /= mempty, but expected 0%
  Testing RightGCDMonoid laws for type ()
    rightGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests (100% stripSuffix (commonSuffix a b) a /= mempty).
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% commonSuffix a b /= mempty, but expected 0%
    rightGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests (100% stripSuffix (commonSuffix a b) b /= mempty).
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% commonSuffix a b /= mempty, but expected 0%
    rightGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      100% antecedent == True
      100% consequent == True
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% antecedent == False, but expected 0%
      Only 0% consequent == False, but expected 0%
    rightGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    rightGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests.
      
      Only 0% a /= mempty, but expected 0%
    rightGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests.
      
      Only 0% a /= mempty, but expected 0%
    rightGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests (100% commonSuffix a b == mempty).
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% commonSuffix a b /= mempty, but expected 0%
    rightGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b, c], but expected 0%
      Only 0% allUnique [a, b, c], but expected 0%
      Only 0% allUniqueNonNull [a, b, c], but expected 0%
      Only 0% commonSuffix (commonSuffix a b) c /= mempty, but expected 0%
      Only 0% commonSuffix a (commonSuffix b c) /= mempty, but expected 0%
    rightGCDMonoidLaw_stripCommonSuffix_commonSuffix [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% commonSuffix a b /= mempty, but expected 0%
    rightGCDMonoidLaw_stripCommonSuffix_mappend_1 [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% stripCommonSuffix a b & \(x, _, s) -> x /= mempty && s /= mempty, but expected 0%
    rightGCDMonoidLaw_stripCommonSuffix_mappend_2 [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% stripCommonSuffix a b & \(_, x, s) -> x /= mempty && s /= mempty, but expected 0%
    rightGCDMonoidLaw_stripCommonSuffix_stripSuffix_1 [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% stripCommonSuffix a b & \(x, _, s) -> x /= mempty && s /= mempty, but expected 0%
    rightGCDMonoidLaw_stripCommonSuffix_stripSuffix_2 [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% stripCommonSuffix a b & \(_, x, s) -> x /= mempty && s /= mempty, but expected 0%
  Testing RightReductive laws for type ()
    rightReductiveLaw_isSuffixOf_mappend [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    rightReductiveLaw_isSuffixOf_stripSuffix [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    rightReductiveLaw_stripSuffix [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
  Testing StableFactorial laws for type ()
    stableFactorialLaw_factors_mappend [✔]
      +++ OK, passed 100 tests.
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUnique [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    stableFactorialLaw_factors_reverse [✔]
      +++ OK, passed 100 tests.
    stableFactorialLaw_primePrefix_primeSuffix_reverse [✔]
      +++ OK, passed 100 tests.
    stableFactorialLaw_primeSuffix_primePrefix_reverse [✔]
      +++ OK, passed 100 tests.
  Testing Factorial laws for type ByteString
    factorialLaw_coverage [✔]
      +++ OK, passed 200 tests:
      96.0% length a >= 2
       2.5% length a == 0
       1.5% length a == 1
    factorialLaw_length_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors_reverse [✔]
      +++ OK, passed 100 tests.
    factorialLaw_all_factors_prime [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primePrefix_foldr [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primeSuffix_foldl [✔]
      +++ OK, passed 100 tests.
    factorialLaw_factors_foldl [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
    factorialLaw_factors_foldl' [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
    factorialLaw_factors_foldr [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
  Testing FactorialMonoid laws for type ByteString
    factorialMonoidLaw_coverage [✔]
      +++ OK, passed 200 tests:
      96.0% length a >= 2
       2.5% length a == 0
       1.5% length a == 1
    factorialMonoidLaw_null [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_reverse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_inits [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_tails [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_span [✔]
      +++ OK, passed 100 tests:
      96% any p (factors a)
      94% any (not . p) (factors a)
    factorialMonoidLaw_split [✔]
      +++ OK, passed 100 tests:
      96% any p (factors a)
      94% any (not . p) (factors a)
    factorialMonoidLaw_split_intersperse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitAt [✔]
      +++ OK, passed 100 tests.
  Testing LeftCancellative laws for type ByteString
    leftCancellativeLaw_cancellation [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
  Testing LeftDistributiveGCDMonoid laws for type ByteString
    leftDistributiveGCDMonoidLaw_distributivity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      78% allUnique [a, b, c]
      75% allUniqueNonNull [a, b, c]
      28% commonPrefix b c /= mempty && a /= mempty
  Testing LeftGCDMonoid laws for type ByteString
    leftGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) a /= mempty
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
      38% commonPrefix a b /= mempty
    leftGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) b /= mempty
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
      38% commonPrefix a b /= mempty
    leftGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      97% antecedent == False
      97% consequent == False
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
       3% antecedent == True
       3% consequent == True
    leftGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    leftGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    leftGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    leftGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
      62% commonPrefix a b == mempty
      38% commonPrefix a b /= mempty
    leftGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      78% allUnique [a, b, c]
      75% allUniqueNonNull [a, b, c]
      22% commonPrefix (commonPrefix a b) c /= mempty
      22% commonPrefix a (commonPrefix b c) /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_commonPrefix [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
      38% commonPrefix a b /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
      23% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
      21% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_1 [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
      23% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_2 [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
      21% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
  Testing LeftReductive laws for type ByteString
    leftReductiveLaw_isPrefixOf_mappend [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
    leftReductiveLaw_isPrefixOf_stripPrefix [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
    leftReductiveLaw_stripPrefix [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
  Testing MonoidNull laws for type ByteString
    monoidNullLaw_basic [✔]
      +++ OK, passed 100 tests:
      97% a /= mempty
       3% a == mempty
  Testing OverlappingGCDMonoid laws for type ByteString
    overlappingGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (overlap a b) a /= mempty
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
      35% overlap a b /= mempty
    overlappingGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (overlap a b) b /= mempty
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
      35% overlap a b /= mempty
    overlappingGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    overlappingGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    overlappingGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    overlappingGCDMonoidLaw_overlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
      17% overlap a b /= mempty && stripPrefixOverlap a b /= mempty
    overlappingGCDMonoidLaw_overlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
      20% stripSuffixOverlap b a /= mempty && overlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_overlap [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
      35% overlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
      77% stripPrefixOverlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
      81% stripSuffixOverlap b a /= mempty
  Testing PositiveMonoid laws for type ByteString
    positiveMonoidLaw_fundamental [✔]
      +++ OK, passed 100 tests:
      98% not (null (a <> b))
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
       2% null (a <> b)
  Testing RightCancellative laws for type ByteString
    rightCancellativeLaw_cancellation [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
  Testing RightDistributiveGCDMonoid laws for type ByteString
    rightDistributiveGCDMonoidLaw_distributivity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      78% allUnique [a, b, c]
      75% allUniqueNonNull [a, b, c]
      42% commonSuffix a b /= mempty && c /= mempty
  Testing RightGCDMonoid laws for type ByteString
    rightGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (commonSuffix a b) a /= mempty
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
      35% commonSuffix a b /= mempty
    rightGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (commonSuffix a b) b /= mempty
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
      35% commonSuffix a b /= mempty
    rightGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      96% antecedent == False
      96% consequent == False
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
       4% antecedent == True
       4% consequent == True
    rightGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    rightGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    rightGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    rightGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
      65% commonSuffix a b == mempty
      35% commonSuffix a b /= mempty
    rightGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      78% allUnique [a, b, c]
      75% allUniqueNonNull [a, b, c]
      29% commonSuffix (commonSuffix a b) c /= mempty
      29% commonSuffix a (commonSuffix b c) /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_commonSuffix [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
      35% commonSuffix a b /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
      21% stripCommonSuffix a b & \(x, _, s) -> x /= mempty && s /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
      17% stripCommonSuffix a b & \(_, x, s) -> x /= mempty && s /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_stripSuffix_1 [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
      21% stripCommonSuffix a b & \(x, _, s) -> x /= mempty && s /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_stripSuffix_2 [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
      17% stripCommonSuffix a b & \(_, x, s) -> x /= mempty && s /= mempty
  Testing RightReductive laws for type ByteString
    rightReductiveLaw_isSuffixOf_mappend [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
    rightReductiveLaw_isSuffixOf_stripSuffix [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
    rightReductiveLaw_stripSuffix [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
  Testing StableFactorial laws for type ByteString
    stableFactorialLaw_factors_mappend [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
    stableFactorialLaw_factors_reverse [✔]
      +++ OK, passed 100 tests.
    stableFactorialLaw_primePrefix_primeSuffix_reverse [✔]
      +++ OK, passed 100 tests.
    stableFactorialLaw_primeSuffix_primePrefix_reverse [✔]
      +++ OK, passed 100 tests.
  Testing Factorial laws for type Dual ByteString
    factorialLaw_coverage [✔]
      +++ OK, passed 200 tests:
      96.0% length a >= 2
       2.5% length a == 0
       1.5% length a == 1
    factorialLaw_length_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors_reverse [✔]
      +++ OK, passed 100 tests.
    factorialLaw_all_factors_prime [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primePrefix_foldr [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primeSuffix_foldl [✔]
      +++ OK, passed 100 tests.
    factorialLaw_factors_foldl [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
    factorialLaw_factors_foldl' [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
    factorialLaw_factors_foldr [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
  Testing FactorialMonoid laws for type Dual ByteString
    factorialMonoidLaw_coverage [✔]
      +++ OK, passed 200 tests:
      96.0% length a >= 2
       2.5% length a == 0
       1.5% length a == 1
    factorialMonoidLaw_null [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_reverse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_inits [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_tails [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_span [✔]
      +++ OK, passed 100 tests:
      96% any (not . p) (factors a)
      94% any p (factors a)
    factorialMonoidLaw_split [✔]
      +++ OK, passed 100 tests:
      96% any (not . p) (factors a)
      94% any p (factors a)
    factorialMonoidLaw_split_intersperse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitAt [✔]
      +++ OK, passed 100 tests.
  Testing LeftCancellative laws for type Dual ByteString
    leftCancellativeLaw_cancellation [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
  Testing LeftDistributiveGCDMonoid laws for type Dual ByteString
    leftDistributiveGCDMonoidLaw_distributivity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      78% allUnique [a, b, c]
      75% allUniqueNonNull [a, b, c]
      28% commonPrefix b c /= mempty && a /= mempty
  Testing LeftGCDMonoid laws for type Dual ByteString
    leftGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) a /= mempty
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
      37% commonPrefix a b /= mempty
    leftGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) b /= mempty
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
      37% commonPrefix a b /= mempty
    leftGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      97% antecedent == False
      97% consequent == False
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
       3% antecedent == True
       3% consequent == True
    leftGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    leftGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    leftGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    leftGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
      63% commonPrefix a b == mempty
      37% commonPrefix a b /= mempty
    leftGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      78% allUnique [a, b, c]
      75% allUniqueNonNull [a, b, c]
      22% commonPrefix (commonPrefix a b) c /= mempty
      22% commonPrefix a (commonPrefix b c) /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_commonPrefix [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
      37% commonPrefix a b /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
      22% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
      20% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_1 [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
      22% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_2 [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
      20% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
  Testing LeftReductive laws for type Dual ByteString
    leftReductiveLaw_isPrefixOf_mappend [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
    leftReductiveLaw_isPrefixOf_stripPrefix [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
    leftReductiveLaw_stripPrefix [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
  Testing MonoidNull laws for type Dual ByteString
    monoidNullLaw_basic [✔]
      +++ OK, passed 100 tests:
      97% a /= mempty
       3% a == mempty
  Testing OverlappingGCDMonoid laws for type Dual ByteString
    overlappingGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (overlap a b) a /= mempty
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
      35% overlap a b /= mempty
    overlappingGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (overlap a b) b /= mempty
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
      35% overlap a b /= mempty
    overlappingGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    overlappingGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    overlappingGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    overlappingGCDMonoidLaw_overlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
      17% overlap a b /= mempty && stripPrefixOverlap a b /= mempty
    overlappingGCDMonoidLaw_overlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
      20% stripSuffixOverlap b a /= mempty && overlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_overlap [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
      35% overlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
      77% stripPrefixOverlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
      81% stripSuffixOverlap b a /= mempty
  Testing PositiveMonoid laws for type Dual ByteString
    positiveMonoidLaw_fundamental [✔]
      +++ OK, passed 100 tests:
      98% not (null (a <> b))
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
       2% null (a <> b)
  Testing RightCancellative laws for type Dual ByteString
    rightCancellativeLaw_cancellation [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
  Testing RightDistributiveGCDMonoid laws for type Dual ByteString
    rightDistributiveGCDMonoidLaw_distributivity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      78% allUnique [a, b, c]
      75% allUniqueNonNull [a, b, c]
      41% commonSuffix a b /= mempty && c /= mempty
  Testing RightGCDMonoid laws for type Dual ByteString
    rightGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (commonSuffix a b) a /= mempty
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
      34% commonSuffix a b /= mempty
    rightGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (commonSuffix a b) b /= mempty
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
      34% commonSuffix a b /= mempty
    rightGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      96% antecedent == False
      96% consequent == False
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
       4% antecedent == True
       4% consequent == True
    rightGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    rightGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    rightGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    rightGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
      66% commonSuffix a b == mempty
      34% commonSuffix a b /= mempty
    rightGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      78% allUnique [a, b, c]
      75% allUniqueNonNull [a, b, c]
      29% commonSuffix (commonSuffix a b) c /= mempty
      29% commonSuffix a (commonSuffix b c) /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_commonSuffix [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
      34% commonSuffix a b /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
      20% stripCommonSuffix a b & \(x, _, s) -> x /= mempty && s /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
      16% stripCommonSuffix a b & \(_, x, s) -> x /= mempty && s /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_stripSuffix_1 [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
      20% stripCommonSuffix a b & \(x, _, s) -> x /= mempty && s /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_stripSuffix_2 [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
      16% stripCommonSuffix a b & \(_, x, s) -> x /= mempty && s /= mempty
  Testing RightReductive laws for type Dual ByteString
    rightReductiveLaw_isSuffixOf_mappend [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
    rightReductiveLaw_isSuffixOf_stripSuffix [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
    rightReductiveLaw_stripSuffix [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
  Testing StableFactorial laws for type Dual ByteString
    stableFactorialLaw_factors_mappend [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      91% allUnique [a, b]
      86% allUniqueNonNull [a, b]
    stableFactorialLaw_factors_reverse [✔]
      +++ OK, passed 100 tests.
    stableFactorialLaw_primePrefix_primeSuffix_reverse [✔]
      +++ OK, passed 100 tests.
    stableFactorialLaw_primeSuffix_primePrefix_reverse [✔]
      +++ OK, passed 100 tests.
  Testing Factorial laws for type Text
    factorialLaw_coverage [✔]
      +++ OK, passed 100 tests:
      94% length a >= 2
       3% length a == 0
       3% length a == 1
    factorialLaw_length_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors_reverse [✔]
      +++ OK, passed 100 tests.
    factorialLaw_all_factors_prime [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primePrefix_foldr [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primeSuffix_foldl [✔]
      +++ OK, passed 100 tests.
    factorialLaw_factors_foldl [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
    factorialLaw_factors_foldl' [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
    factorialLaw_factors_foldr [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
  Testing FactorialMonoid laws for type Text
    factorialMonoidLaw_coverage [✔]
      +++ OK, passed 100 tests:
      94% length a >= 2
       3% length a == 0
       3% length a == 1
    factorialMonoidLaw_null [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_reverse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_inits [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_tails [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_span [✔]
      +++ OK, passed 100 tests:
      94% any p (factors a)
      93% any (not . p) (factors a)
    factorialMonoidLaw_split [✔]
      +++ OK, passed 100 tests:
      94% any p (factors a)
      93% any (not . p) (factors a)
    factorialMonoidLaw_split_intersperse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitAt [✔]
      +++ OK, passed 100 tests.
  Testing LeftCancellative laws for type Text
    leftCancellativeLaw_cancellation [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
  Testing LeftDistributiveGCDMonoid laws for type Text
    leftDistributiveGCDMonoidLaw_distributivity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      81% allUnique [a, b, c]
      78% allUniqueNonNull [a, b, c]
      28% commonPrefix b c /= mempty && a /= mempty
  Testing LeftGCDMonoid laws for type Text
    leftGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) a /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      38% commonPrefix a b /= mempty
    leftGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) b /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      38% commonPrefix a b /= mempty
    leftGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      95% antecedent == False
      95% consequent == False
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
       5% antecedent == True
       5% consequent == True
    leftGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    leftGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    leftGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    leftGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      62% commonPrefix a b == mempty
      38% commonPrefix a b /= mempty
    leftGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      81% allUnique [a, b, c]
      78% allUniqueNonNull [a, b, c]
      22% commonPrefix (commonPrefix a b) c /= mempty
      22% commonPrefix a (commonPrefix b c) /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_commonPrefix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      38% commonPrefix a b /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      22% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      18% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_1 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      22% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_2 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      18% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
  Testing LeftReductive laws for type Text
    leftReductiveLaw_isPrefixOf_mappend [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
    leftReductiveLaw_isPrefixOf_stripPrefix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
    leftReductiveLaw_stripPrefix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
  Testing MonoidNull laws for type Text
    monoidNullLaw_basic [✔]
      +++ OK, passed 100 tests:
      97% a /= mempty
       3% a == mempty
  Testing OverlappingGCDMonoid laws for type Text
    overlappingGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (overlap a b) a /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      37% overlap a b /= mempty
    overlappingGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (overlap a b) b /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      37% overlap a b /= mempty
    overlappingGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    overlappingGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    overlappingGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    overlappingGCDMonoidLaw_overlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      20% overlap a b /= mempty && stripPrefixOverlap a b /= mempty
    overlappingGCDMonoidLaw_overlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      21% stripSuffixOverlap b a /= mempty && overlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_overlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      37% overlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      80% stripPrefixOverlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      82% stripSuffixOverlap b a /= mempty
  Testing PositiveMonoid laws for type Text
    positiveMonoidLaw_fundamental [✔]
      +++ OK, passed 100 tests:
      98% not (null (a <> b))
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
       2% null (a <> b)
  Testing RightCancellative laws for type Text
    rightCancellativeLaw_cancellation [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
  Testing RightDistributiveGCDMonoid laws for type Text
    rightDistributiveGCDMonoidLaw_distributivity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      81% allUnique [a, b, c]
      78% allUniqueNonNull [a, b, c]
      40% commonSuffix a b /= mempty && c /= mempty
  Testing RightGCDMonoid laws for type Text
    rightGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (commonSuffix a b) a /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      35% commonSuffix a b /= mempty
    rightGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (commonSuffix a b) b /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      35% commonSuffix a b /= mempty
    rightGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      96% antecedent == False
      96% consequent == False
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
       4% antecedent == True
       4% consequent == True
    rightGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    rightGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    rightGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    rightGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      65% commonSuffix a b == mempty
      35% commonSuffix a b /= mempty
    rightGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      81% allUnique [a, b, c]
      78% allUniqueNonNull [a, b, c]
      29% commonSuffix (commonSuffix a b) c /= mempty
      29% commonSuffix a (commonSuffix b c) /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_commonSuffix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      35% commonSuffix a b /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      19% stripCommonSuffix a b & \(x, _, s) -> x /= mempty && s /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      18% stripCommonSuffix a b & \(_, x, s) -> x /= mempty && s /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_stripSuffix_1 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      19% stripCommonSuffix a b & \(x, _, s) -> x /= mempty && s /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_stripSuffix_2 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      18% stripCommonSuffix a b & \(_, x, s) -> x /= mempty && s /= mempty
  Testing RightReductive laws for type Text
    rightReductiveLaw_isSuffixOf_mappend [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
    rightReductiveLaw_isSuffixOf_stripSuffix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
    rightReductiveLaw_stripSuffix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
  Testing StableFactorial laws for type Text
    stableFactorialLaw_factors_mappend [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
    stableFactorialLaw_factors_reverse [✔]
      +++ OK, passed 100 tests.
    stableFactorialLaw_primePrefix_primeSuffix_reverse [✔]
      +++ OK, passed 100 tests.
    stableFactorialLaw_primeSuffix_primePrefix_reverse [✔]
      +++ OK, passed 100 tests.
  Testing Factorial laws for type Dual Text
    factorialLaw_coverage [✔]
      +++ OK, passed 100 tests:
      94% length a >= 2
       3% length a == 0
       3% length a == 1
    factorialLaw_length_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors_reverse [✔]
      +++ OK, passed 100 tests.
    factorialLaw_all_factors_prime [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primePrefix_foldr [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primeSuffix_foldl [✔]
      +++ OK, passed 100 tests.
    factorialLaw_factors_foldl [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
    factorialLaw_factors_foldl' [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
    factorialLaw_factors_foldr [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
  Testing FactorialMonoid laws for type Dual Text
    factorialMonoidLaw_coverage [✔]
      +++ OK, passed 100 tests:
      94% length a >= 2
       3% length a == 0
       3% length a == 1
    factorialMonoidLaw_null [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_reverse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_inits [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_tails [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_span [✔]
      +++ OK, passed 100 tests:
      95% any p (factors a)
      94% any (not . p) (factors a)
    factorialMonoidLaw_split [✔]
      +++ OK, passed 100 tests:
      95% any p (factors a)
      94% any (not . p) (factors a)
    factorialMonoidLaw_split_intersperse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitAt [✔]
      +++ OK, passed 100 tests.
  Testing LeftCancellative laws for type Dual Text
    leftCancellativeLaw_cancellation [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
  Testing LeftDistributiveGCDMonoid laws for type Dual Text
    leftDistributiveGCDMonoidLaw_distributivity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      81% allUnique [a, b, c]
      78% allUniqueNonNull [a, b, c]
      28% commonPrefix b c /= mempty && a /= mempty
  Testing LeftGCDMonoid laws for type Dual Text
    leftGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) a /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      38% commonPrefix a b /= mempty
    leftGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) b /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      38% commonPrefix a b /= mempty
    leftGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      95% antecedent == False
      95% consequent == False
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
       5% antecedent == True
       5% consequent == True
    leftGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    leftGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    leftGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    leftGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      62% commonPrefix a b == mempty
      38% commonPrefix a b /= mempty
    leftGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      81% allUnique [a, b, c]
      78% allUniqueNonNull [a, b, c]
      22% commonPrefix (commonPrefix a b) c /= mempty
      22% commonPrefix a (commonPrefix b c) /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_commonPrefix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      38% commonPrefix a b /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      22% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      18% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_1 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      22% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_2 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      18% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
  Testing LeftReductive laws for type Dual Text
    leftReductiveLaw_isPrefixOf_mappend [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
    leftReductiveLaw_isPrefixOf_stripPrefix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
    leftReductiveLaw_stripPrefix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
  Testing MonoidNull laws for type Dual Text
    monoidNullLaw_basic [✔]
      +++ OK, passed 100 tests:
      97% a /= mempty
       3% a == mempty
  Testing OverlappingGCDMonoid laws for type Dual Text
    overlappingGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (overlap a b) a /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      37% overlap a b /= mempty
    overlappingGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (overlap a b) b /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      37% overlap a b /= mempty
    overlappingGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    overlappingGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    overlappingGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    overlappingGCDMonoidLaw_overlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      20% overlap a b /= mempty && stripPrefixOverlap a b /= mempty
    overlappingGCDMonoidLaw_overlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      21% stripSuffixOverlap b a /= mempty && overlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_overlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      37% overlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      80% stripPrefixOverlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      82% stripSuffixOverlap b a /= mempty
  Testing PositiveMonoid laws for type Dual Text
    positiveMonoidLaw_fundamental [✔]
      +++ OK, passed 100 tests:
      98% not (null (a <> b))
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
       2% null (a <> b)
  Testing RightCancellative laws for type Dual Text
    rightCancellativeLaw_cancellation [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
  Testing RightDistributiveGCDMonoid laws for type Dual Text
    rightDistributiveGCDMonoidLaw_distributivity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      81% allUnique [a, b, c]
      78% allUniqueNonNull [a, b, c]
      40% commonSuffix a b /= mempty && c /= mempty
  Testing RightGCDMonoid laws for type Dual Text
    rightGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (commonSuffix a b) a /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      35% commonSuffix a b /= mempty
    rightGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (commonSuffix a b) b /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      35% commonSuffix a b /= mempty
    rightGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      96% antecedent == False
      96% consequent == False
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
       4% antecedent == True
       4% consequent == True
    rightGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    rightGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    rightGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    rightGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      65% commonSuffix a b == mempty
      35% commonSuffix a b /= mempty
    rightGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      81% allUnique [a, b, c]
      78% allUniqueNonNull [a, b, c]
      29% commonSuffix (commonSuffix a b) c /= mempty
      29% commonSuffix a (commonSuffix b c) /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_commonSuffix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      35% commonSuffix a b /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      19% stripCommonSuffix a b & \(x, _, s) -> x /= mempty && s /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      18% stripCommonSuffix a b & \(_, x, s) -> x /= mempty && s /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_stripSuffix_1 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      19% stripCommonSuffix a b & \(x, _, s) -> x /= mempty && s /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_stripSuffix_2 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      18% stripCommonSuffix a b & \(_, x, s) -> x /= mempty && s /= mempty
  Testing RightReductive laws for type Dual Text
    rightReductiveLaw_isSuffixOf_mappend [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
    rightReductiveLaw_isSuffixOf_stripSuffix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
    rightReductiveLaw_stripSuffix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
  Testing StableFactorial laws for type Dual Text
    stableFactorialLaw_factors_mappend [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
    stableFactorialLaw_factors_reverse [✔]
      +++ OK, passed 100 tests.
    stableFactorialLaw_primePrefix_primeSuffix_reverse [✔]
      +++ OK, passed 100 tests.
    stableFactorialLaw_primeSuffix_primePrefix_reverse [✔]
      +++ OK, passed 100 tests.
  Testing Factorial laws for type [Small Int]
    factorialLaw_coverage [✔]
      +++ OK, passed 100 tests:
      94% length a >= 2
       3% length a == 0
       3% length a == 1
    factorialLaw_length_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors_reverse [✔]
      +++ OK, passed 100 tests.
    factorialLaw_all_factors_prime [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primePrefix_foldr [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primeSuffix_foldl [✔]
      +++ OK, passed 100 tests.
    factorialLaw_factors_foldl [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
    factorialLaw_factors_foldl' [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
    factorialLaw_factors_foldr [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
  Testing FactorialMonoid laws for type [Small Int]
    factorialMonoidLaw_coverage [✔]
      +++ OK, passed 100 tests:
      94% length a >= 2
       3% length a == 0
       3% length a == 1
    factorialMonoidLaw_null [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_reverse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_inits [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_tails [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_span [✔]
      +++ OK, passed 100 tests:
      94% any p (factors a)
      93% any (not . p) (factors a)
    factorialMonoidLaw_split [✔]
      +++ OK, passed 100 tests:
      94% any p (factors a)
      93% any (not . p) (factors a)
    factorialMonoidLaw_split_intersperse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitAt [✔]
      +++ OK, passed 100 tests.
  Testing LeftCancellative laws for type [Small Int]
    leftCancellativeLaw_cancellation [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
  Testing LeftDistributiveGCDMonoid laws for type [Small Int]
    leftDistributiveGCDMonoidLaw_distributivity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      81% allUnique [a, b, c]
      78% allUniqueNonNull [a, b, c]
      30% commonPrefix b c /= mempty && a /= mempty
  Testing LeftGCDMonoid laws for type [Small Int]
    leftGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) a /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      40% commonPrefix a b /= mempty
    leftGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) b /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      40% commonPrefix a b /= mempty
    leftGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      95% antecedent == False
      95% consequent == False
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
       5% antecedent == True
       5% consequent == True
    leftGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    leftGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    leftGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    leftGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      60% commonPrefix a b == mempty
      40% commonPrefix a b /= mempty
    leftGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      81% allUnique [a, b, c]
      78% allUniqueNonNull [a, b, c]
      23% commonPrefix (commonPrefix a b) c /= mempty
      23% commonPrefix a (commonPrefix b c) /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_commonPrefix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      40% commonPrefix a b /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      23% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      19% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_1 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      23% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_2 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      19% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
  Testing LeftReductive laws for type [Small Int]
    leftReductiveLaw_isPrefixOf_mappend [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
    leftReductiveLaw_isPrefixOf_stripPrefix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
    leftReductiveLaw_stripPrefix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
  Testing MonoidNull laws for type [Small Int]
    monoidNullLaw_basic [✔]
      +++ OK, passed 100 tests:
      97% a /= mempty
       3% a == mempty
  Testing OverlappingGCDMonoid laws for type [Small Int]
    overlappingGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (overlap a b) a /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      41% overlap a b /= mempty
    overlappingGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (overlap a b) b /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      41% overlap a b /= mempty
    overlappingGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    overlappingGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    overlappingGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    overlappingGCDMonoidLaw_overlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      24% overlap a b /= mempty && stripPrefixOverlap a b /= mempty
    overlappingGCDMonoidLaw_overlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      24% stripSuffixOverlap b a /= mempty && overlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_overlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      41% overlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      80% stripPrefixOverlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      81% stripSuffixOverlap b a /= mempty
  Testing PositiveMonoid laws for type [Small Int]
    positiveMonoidLaw_fundamental [✔]
      +++ OK, passed 100 tests:
      98% not (null (a <> b))
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
       2% null (a <> b)
  Testing RightCancellative laws for type [Small Int]
    rightCancellativeLaw_cancellation [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
  Testing RightDistributiveGCDMonoid laws for type [Small Int]
    rightDistributiveGCDMonoidLaw_distributivity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      81% allUnique [a, b, c]
      78% allUniqueNonNull [a, b, c]
      46% commonSuffix a b /= mempty && c /= mempty
  Testing RightGCDMonoid laws for type [Small Int]
    rightGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (commonSuffix a b) a /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      37% commonSuffix a b /= mempty
    rightGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (commonSuffix a b) b /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      37% commonSuffix a b /= mempty
    rightGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      96% antecedent == False
      96% consequent == False
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
       4% antecedent == True
       4% consequent == True
    rightGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    rightGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    rightGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    rightGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      63% commonSuffix a b == mempty
      37% commonSuffix a b /= mempty
    rightGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      81% allUnique [a, b, c]
      78% allUniqueNonNull [a, b, c]
      31% commonSuffix (commonSuffix a b) c /= mempty
      31% commonSuffix a (commonSuffix b c) /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_commonSuffix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      37% commonSuffix a b /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      21% stripCommonSuffix a b & \(x, _, s) -> x /= mempty && s /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      20% stripCommonSuffix a b & \(_, x, s) -> x /= mempty && s /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_stripSuffix_1 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      21% stripCommonSuffix a b & \(x, _, s) -> x /= mempty && s /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_stripSuffix_2 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      20% stripCommonSuffix a b & \(_, x, s) -> x /= mempty && s /= mempty
  Testing RightReductive laws for type [Small Int]
    rightReductiveLaw_isSuffixOf_mappend [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
    rightReductiveLaw_isSuffixOf_stripSuffix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
    rightReductiveLaw_stripSuffix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
  Testing StableFactorial laws for type [Small Int]
    stableFactorialLaw_factors_mappend [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
    stableFactorialLaw_factors_reverse [✔]
      +++ OK, passed 100 tests.
    stableFactorialLaw_primePrefix_primeSuffix_reverse [✔]
      +++ OK, passed 100 tests.
    stableFactorialLaw_primeSuffix_primePrefix_reverse [✔]
      +++ OK, passed 100 tests.
  Testing Factorial laws for type Dual [Small Int]
    factorialLaw_coverage [✔]
      +++ OK, passed 100 tests:
      94% length a >= 2
       3% length a == 0
       3% length a == 1
    factorialLaw_length_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors_reverse [✔]
      +++ OK, passed 100 tests.
    factorialLaw_all_factors_prime [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primePrefix_foldr [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primeSuffix_foldl [✔]
      +++ OK, passed 100 tests.
    factorialLaw_factors_foldl [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
    factorialLaw_factors_foldl' [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
    factorialLaw_factors_foldr [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
  Testing FactorialMonoid laws for type Dual [Small Int]
    factorialMonoidLaw_coverage [✔]
      +++ OK, passed 100 tests:
      94% length a >= 2
       3% length a == 0
       3% length a == 1
    factorialMonoidLaw_null [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_reverse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_inits [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_tails [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_span [✔]
      +++ OK, passed 100 tests:
      96% any p (factors a)
      94% any (not . p) (factors a)
    factorialMonoidLaw_split [✔]
      +++ OK, passed 100 tests:
      96% any p (factors a)
      94% any (not . p) (factors a)
    factorialMonoidLaw_split_intersperse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitAt [✔]
      +++ OK, passed 100 tests.
  Testing LeftCancellative laws for type Dual [Small Int]
    leftCancellativeLaw_cancellation [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
  Testing LeftDistributiveGCDMonoid laws for type Dual [Small Int]
    leftDistributiveGCDMonoidLaw_distributivity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      81% allUnique [a, b, c]
      78% allUniqueNonNull [a, b, c]
      29% commonPrefix b c /= mempty && a /= mempty
  Testing LeftGCDMonoid laws for type Dual [Small Int]
    leftGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) a /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      40% commonPrefix a b /= mempty
    leftGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) b /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      40% commonPrefix a b /= mempty
    leftGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      95% antecedent == False
      95% consequent == False
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
       5% antecedent == True
       5% consequent == True
    leftGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    leftGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    leftGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    leftGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      60% commonPrefix a b == mempty
      40% commonPrefix a b /= mempty
    leftGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      81% allUnique [a, b, c]
      78% allUniqueNonNull [a, b, c]
      22% commonPrefix (commonPrefix a b) c /= mempty
      22% commonPrefix a (commonPrefix b c) /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_commonPrefix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      40% commonPrefix a b /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      24% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      20% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_1 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      24% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_2 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      20% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
  Testing LeftReductive laws for type Dual [Small Int]
    leftReductiveLaw_isPrefixOf_mappend [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
    leftReductiveLaw_isPrefixOf_stripPrefix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
    leftReductiveLaw_stripPrefix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
  Testing MonoidNull laws for type Dual [Small Int]
    monoidNullLaw_basic [✔]
      +++ OK, passed 100 tests:
      97% a /= mempty
       3% a == mempty
  Testing OverlappingGCDMonoid laws for type Dual [Small Int]
    overlappingGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (overlap a b) a /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      40% overlap a b /= mempty
    overlappingGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (overlap a b) b /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      40% overlap a b /= mempty
    overlappingGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    overlappingGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    overlappingGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    overlappingGCDMonoidLaw_overlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      23% overlap a b /= mempty && stripPrefixOverlap a b /= mempty
    overlappingGCDMonoidLaw_overlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      24% stripSuffixOverlap b a /= mempty && overlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_overlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      40% overlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      80% stripPrefixOverlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      82% stripSuffixOverlap b a /= mempty
  Testing PositiveMonoid laws for type Dual [Small Int]
    positiveMonoidLaw_fundamental [✔]
      +++ OK, passed 100 tests:
      98% not (null (a <> b))
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
       2% null (a <> b)
  Testing RightCancellative laws for type Dual [Small Int]
    rightCancellativeLaw_cancellation [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
  Testing RightDistributiveGCDMonoid laws for type Dual [Small Int]
    rightDistributiveGCDMonoidLaw_distributivity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      81% allUnique [a, b, c]
      78% allUniqueNonNull [a, b, c]
      43% commonSuffix a b /= mempty && c /= mempty
  Testing RightGCDMonoid laws for type Dual [Small Int]
    rightGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (commonSuffix a b) a /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      36% commonSuffix a b /= mempty
    rightGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (commonSuffix a b) b /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      36% commonSuffix a b /= mempty
    rightGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      96% antecedent == False
      96% consequent == False
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
       4% antecedent == True
       4% consequent == True
    rightGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    rightGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    rightGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    rightGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      64% commonSuffix a b == mempty
      36% commonSuffix a b /= mempty
    rightGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      81% allUnique [a, b, c]
      78% allUniqueNonNull [a, b, c]
      31% commonSuffix (commonSuffix a b) c /= mempty
      31% commonSuffix a (commonSuffix b c) /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_commonSuffix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      36% commonSuffix a b /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      19% stripCommonSuffix a b & \(x, _, s) -> x /= mempty && s /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      19% stripCommonSuffix a b & \(_, x, s) -> x /= mempty && s /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_stripSuffix_1 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      19% stripCommonSuffix a b & \(x, _, s) -> x /= mempty && s /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_stripSuffix_2 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      19% stripCommonSuffix a b & \(_, x, s) -> x /= mempty && s /= mempty
  Testing RightReductive laws for type Dual [Small Int]
    rightReductiveLaw_isSuffixOf_mappend [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
    rightReductiveLaw_isSuffixOf_stripSuffix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
    rightReductiveLaw_stripSuffix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
  Testing StableFactorial laws for type Dual [Small Int]
    stableFactorialLaw_factors_mappend [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
    stableFactorialLaw_factors_reverse [✔]
      +++ OK, passed 100 tests.
    stableFactorialLaw_primePrefix_primeSuffix_reverse [✔]
      +++ OK, passed 100 tests.
    stableFactorialLaw_primeSuffix_primePrefix_reverse [✔]
      +++ OK, passed 100 tests.
  Testing Factorial laws for type Seq (Small Int)
    factorialLaw_coverage [✔]
      +++ OK, passed 100 tests:
      94% length a >= 2
       3% length a == 0
       3% length a == 1
    factorialLaw_length_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors_reverse [✔]
      +++ OK, passed 100 tests.
    factorialLaw_all_factors_prime [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primePrefix_foldr [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primeSuffix_foldl [✔]
      +++ OK, passed 100 tests.
    factorialLaw_factors_foldl [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
    factorialLaw_factors_foldl' [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
    factorialLaw_factors_foldr [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
  Testing FactorialMonoid laws for type Seq (Small Int)
    factorialMonoidLaw_coverage [✔]
      +++ OK, passed 100 tests:
      94% length a >= 2
       3% length a == 0
       3% length a == 1
    factorialMonoidLaw_null [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_reverse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_inits [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_tails [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_span [✔]
      +++ OK, passed 100 tests:
      94% any (not . p) (factors a)
      94% any p (factors a)
    factorialMonoidLaw_split [✔]
      +++ OK, passed 100 tests:
      94% any (not . p) (factors a)
      94% any p (factors a)
    factorialMonoidLaw_split_intersperse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitAt [✔]
      +++ OK, passed 100 tests.
  Testing LeftCancellative laws for type Seq (Small Int)
    leftCancellativeLaw_cancellation [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
  Testing LeftDistributiveGCDMonoid laws for type Seq (Small Int)
    leftDistributiveGCDMonoidLaw_distributivity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      81% allUnique [a, b, c]
      78% allUniqueNonNull [a, b, c]
      30% commonPrefix b c /= mempty && a /= mempty
  Testing LeftGCDMonoid laws for type Seq (Small Int)
    leftGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) a /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      40% commonPrefix a b /= mempty
    leftGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) b /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      40% commonPrefix a b /= mempty
    leftGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      95% antecedent == False
      95% consequent == False
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
       5% antecedent == True
       5% consequent == True
    leftGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    leftGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    leftGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    leftGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      60% commonPrefix a b == mempty
      40% commonPrefix a b /= mempty
    leftGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      81% allUnique [a, b, c]
      78% allUniqueNonNull [a, b, c]
      23% commonPrefix (commonPrefix a b) c /= mempty
      23% commonPrefix a (commonPrefix b c) /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_commonPrefix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      40% commonPrefix a b /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      23% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      19% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_1 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      23% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_2 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      19% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
  Testing LeftReductive laws for type Seq (Small Int)
    leftReductiveLaw_isPrefixOf_mappend [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
    leftReductiveLaw_isPrefixOf_stripPrefix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
    leftReductiveLaw_stripPrefix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
  Testing MonoidNull laws for type Seq (Small Int)
    monoidNullLaw_basic [✔]
      +++ OK, passed 100 tests:
      97% a /= mempty
       3% a == mempty
  Testing OverlappingGCDMonoid laws for type Seq (Small Int)
    overlappingGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (overlap a b) a /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      41% overlap a b /= mempty
    overlappingGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (overlap a b) b /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      41% overlap a b /= mempty
    overlappingGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    overlappingGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    overlappingGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    overlappingGCDMonoidLaw_overlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      24% overlap a b /= mempty && stripPrefixOverlap a b /= mempty
    overlappingGCDMonoidLaw_overlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      24% stripSuffixOverlap b a /= mempty && overlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_overlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      41% overlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      80% stripPrefixOverlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      81% stripSuffixOverlap b a /= mempty
  Testing PositiveMonoid laws for type Seq (Small Int)
    positiveMonoidLaw_fundamental [✔]
      +++ OK, passed 100 tests:
      98% not (null (a <> b))
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
       2% null (a <> b)
  Testing RightCancellative laws for type Seq (Small Int)
    rightCancellativeLaw_cancellation [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
  Testing RightDistributiveGCDMonoid laws for type Seq (Small Int)
    rightDistributiveGCDMonoidLaw_distributivity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      81% allUnique [a, b, c]
      78% allUniqueNonNull [a, b, c]
      46% commonSuffix a b /= mempty && c /= mempty
  Testing RightGCDMonoid laws for type Seq (Small Int)
    rightGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (commonSuffix a b) a /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      37% commonSuffix a b /= mempty
    rightGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (commonSuffix a b) b /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      37% commonSuffix a b /= mempty
    rightGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      96% antecedent == False
      96% consequent == False
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
       4% antecedent == True
       4% consequent == True
    rightGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    rightGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    rightGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    rightGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      63% commonSuffix a b == mempty
      37% commonSuffix a b /= mempty
    rightGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      81% allUnique [a, b, c]
      78% allUniqueNonNull [a, b, c]
      31% commonSuffix (commonSuffix a b) c /= mempty
      31% commonSuffix a (commonSuffix b c) /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_commonSuffix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      37% commonSuffix a b /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      21% stripCommonSuffix a b & \(x, _, s) -> x /= mempty && s /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      20% stripCommonSuffix a b & \(_, x, s) -> x /= mempty && s /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_stripSuffix_1 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      21% stripCommonSuffix a b & \(x, _, s) -> x /= mempty && s /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_stripSuffix_2 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      20% stripCommonSuffix a b & \(_, x, s) -> x /= mempty && s /= mempty
  Testing RightReductive laws for type Seq (Small Int)
    rightReductiveLaw_isSuffixOf_mappend [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
    rightReductiveLaw_isSuffixOf_stripSuffix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
    rightReductiveLaw_stripSuffix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
  Testing StableFactorial laws for type Seq (Small Int)
    stableFactorialLaw_factors_mappend [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
    stableFactorialLaw_factors_reverse [✔]
      +++ OK, passed 100 tests.
    stableFactorialLaw_primePrefix_primeSuffix_reverse [✔]
      +++ OK, passed 100 tests.
    stableFactorialLaw_primeSuffix_primePrefix_reverse [✔]
      +++ OK, passed 100 tests.
  Testing Factorial laws for type Dual (Seq (Small Int))
    factorialLaw_coverage [✔]
      +++ OK, passed 100 tests:
      94% length a >= 2
       3% length a == 0
       3% length a == 1
    factorialLaw_length_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors_reverse [✔]
      +++ OK, passed 100 tests.
    factorialLaw_all_factors_prime [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primePrefix_foldr [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primeSuffix_foldl [✔]
      +++ OK, passed 100 tests.
    factorialLaw_factors_foldl [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
    factorialLaw_factors_foldl' [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
    factorialLaw_factors_foldr [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
  Testing FactorialMonoid laws for type Dual (Seq (Small Int))
    factorialMonoidLaw_coverage [✔]
      +++ OK, passed 100 tests:
      94% length a >= 2
       3% length a == 0
       3% length a == 1
    factorialMonoidLaw_null [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_reverse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_inits [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_tails [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_span [✔]
      +++ OK, passed 100 tests:
      94% any p (factors a)
      93% any (not . p) (factors a)
    factorialMonoidLaw_split [✔]
      +++ OK, passed 100 tests:
      94% any p (factors a)
      93% any (not . p) (factors a)
    factorialMonoidLaw_split_intersperse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitAt [✔]
      +++ OK, passed 100 tests.
  Testing LeftCancellative laws for type Dual (Seq (Small Int))
    leftCancellativeLaw_cancellation [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
  Testing LeftDistributiveGCDMonoid laws for type Dual (Seq (Small Int))
    leftDistributiveGCDMonoidLaw_distributivity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      81% allUnique [a, b, c]
      78% allUniqueNonNull [a, b, c]
      29% commonPrefix b c /= mempty && a /= mempty
  Testing LeftGCDMonoid laws for type Dual (Seq (Small Int))
    leftGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) a /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      40% commonPrefix a b /= mempty
    leftGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) b /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      40% commonPrefix a b /= mempty
    leftGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      95% antecedent == False
      95% consequent == False
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
       5% antecedent == True
       5% consequent == True
    leftGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    leftGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    leftGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    leftGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      60% commonPrefix a b == mempty
      40% commonPrefix a b /= mempty
    leftGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      81% allUnique [a, b, c]
      78% allUniqueNonNull [a, b, c]
      22% commonPrefix (commonPrefix a b) c /= mempty
      22% commonPrefix a (commonPrefix b c) /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_commonPrefix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      40% commonPrefix a b /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      24% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      20% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_1 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      24% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_2 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      20% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
  Testing LeftReductive laws for type Dual (Seq (Small Int))
    leftReductiveLaw_isPrefixOf_mappend [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
    leftReductiveLaw_isPrefixOf_stripPrefix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
    leftReductiveLaw_stripPrefix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
  Testing MonoidNull laws for type Dual (Seq (Small Int))
    monoidNullLaw_basic [✔]
      +++ OK, passed 100 tests:
      97% a /= mempty
       3% a == mempty
  Testing OverlappingGCDMonoid laws for type Dual (Seq (Small Int))
    overlappingGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (overlap a b) a /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      40% overlap a b /= mempty
    overlappingGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (overlap a b) b /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      40% overlap a b /= mempty
    overlappingGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    overlappingGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    overlappingGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    overlappingGCDMonoidLaw_overlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      23% overlap a b /= mempty && stripPrefixOverlap a b /= mempty
    overlappingGCDMonoidLaw_overlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      24% stripSuffixOverlap b a /= mempty && overlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_overlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      40% overlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      80% stripPrefixOverlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      82% stripSuffixOverlap b a /= mempty
  Testing PositiveMonoid laws for type Dual (Seq (Small Int))
    positiveMonoidLaw_fundamental [✔]
      +++ OK, passed 100 tests:
      98% not (null (a <> b))
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
       2% null (a <> b)
  Testing RightCancellative laws for type Dual (Seq (Small Int))
    rightCancellativeLaw_cancellation [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
  Testing RightDistributiveGCDMonoid laws for type Dual (Seq (Small Int))
    rightDistributiveGCDMonoidLaw_distributivity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      81% allUnique [a, b, c]
      78% allUniqueNonNull [a, b, c]
      43% commonSuffix a b /= mempty && c /= mempty
  Testing RightGCDMonoid laws for type Dual (Seq (Small Int))
    rightGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (commonSuffix a b) a /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      36% commonSuffix a b /= mempty
    rightGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (commonSuffix a b) b /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      36% commonSuffix a b /= mempty
    rightGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      96% antecedent == False
      96% consequent == False
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
       4% antecedent == True
       4% consequent == True
    rightGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    rightGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    rightGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    rightGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      64% commonSuffix a b == mempty
      36% commonSuffix a b /= mempty
    rightGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      81% allUnique [a, b, c]
      78% allUniqueNonNull [a, b, c]
      31% commonSuffix (commonSuffix a b) c /= mempty
      31% commonSuffix a (commonSuffix b c) /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_commonSuffix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      36% commonSuffix a b /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      19% stripCommonSuffix a b & \(x, _, s) -> x /= mempty && s /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      19% stripCommonSuffix a b & \(_, x, s) -> x /= mempty && s /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_stripSuffix_1 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      19% stripCommonSuffix a b & \(x, _, s) -> x /= mempty && s /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_stripSuffix_2 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      19% stripCommonSuffix a b & \(_, x, s) -> x /= mempty && s /= mempty
  Testing RightReductive laws for type Dual (Seq (Small Int))
    rightReductiveLaw_isSuffixOf_mappend [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
    rightReductiveLaw_isSuffixOf_stripSuffix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
    rightReductiveLaw_stripSuffix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
  Testing StableFactorial laws for type Dual (Seq (Small Int))
    stableFactorialLaw_factors_mappend [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
    stableFactorialLaw_factors_reverse [✔]
      +++ OK, passed 100 tests.
    stableFactorialLaw_primePrefix_primeSuffix_reverse [✔]
      +++ OK, passed 100 tests.
    stableFactorialLaw_primeSuffix_primePrefix_reverse [✔]
      +++ OK, passed 100 tests.
  Testing Factorial laws for type Vector (Small Int)
    factorialLaw_coverage [✔]
      +++ OK, passed 100 tests:
      94% length a >= 2
       3% length a == 0
       3% length a == 1
    factorialLaw_length_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors_reverse [✔]
      +++ OK, passed 100 tests.
    factorialLaw_all_factors_prime [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primePrefix_foldr [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primeSuffix_foldl [✔]
      +++ OK, passed 100 tests.
    factorialLaw_factors_foldl [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
    factorialLaw_factors_foldl' [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
    factorialLaw_factors_foldr [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
  Testing FactorialMonoid laws for type Vector (Small Int)
    factorialMonoidLaw_coverage [✔]
      +++ OK, passed 100 tests:
      94% length a >= 2
       3% length a == 0
       3% length a == 1
    factorialMonoidLaw_null [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_reverse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_inits [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_tails [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_span [✔]
      +++ OK, passed 100 tests:
      94% any p (factors a)
      93% any (not . p) (factors a)
    factorialMonoidLaw_split [✔]
      +++ OK, passed 100 tests:
      94% any p (factors a)
      93% any (not . p) (factors a)
    factorialMonoidLaw_split_intersperse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitAt [✔]
      +++ OK, passed 100 tests.
  Testing LeftCancellative laws for type Vector (Small Int)
    leftCancellativeLaw_cancellation [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
  Testing LeftDistributiveGCDMonoid laws for type Vector (Small Int)
    leftDistributiveGCDMonoidLaw_distributivity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      81% allUnique [a, b, c]
      78% allUniqueNonNull [a, b, c]
      30% commonPrefix b c /= mempty && a /= mempty
  Testing LeftGCDMonoid laws for type Vector (Small Int)
    leftGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) a /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      40% commonPrefix a b /= mempty
    leftGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) b /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      40% commonPrefix a b /= mempty
    leftGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      95% antecedent == False
      95% consequent == False
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
       5% antecedent == True
       5% consequent == True
    leftGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    leftGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    leftGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    leftGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      60% commonPrefix a b == mempty
      40% commonPrefix a b /= mempty
    leftGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      81% allUnique [a, b, c]
      78% allUniqueNonNull [a, b, c]
      23% commonPrefix (commonPrefix a b) c /= mempty
      23% commonPrefix a (commonPrefix b c) /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_commonPrefix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      40% commonPrefix a b /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      23% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      19% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_1 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      23% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_2 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      19% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
  Testing LeftReductive laws for type Vector (Small Int)
    leftReductiveLaw_isPrefixOf_mappend [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
    leftReductiveLaw_isPrefixOf_stripPrefix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
    leftReductiveLaw_stripPrefix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
  Testing MonoidNull laws for type Vector (Small Int)
    monoidNullLaw_basic [✔]
      +++ OK, passed 100 tests:
      97% a /= mempty
       3% a == mempty
  Testing OverlappingGCDMonoid laws for type Vector (Small Int)
    overlappingGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (overlap a b) a /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      41% overlap a b /= mempty
    overlappingGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (overlap a b) b /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      41% overlap a b /= mempty
    overlappingGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    overlappingGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    overlappingGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    overlappingGCDMonoidLaw_overlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      24% overlap a b /= mempty && stripPrefixOverlap a b /= mempty
    overlappingGCDMonoidLaw_overlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      24% stripSuffixOverlap b a /= mempty && overlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_overlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      41% overlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      80% stripPrefixOverlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      81% stripSuffixOverlap b a /= mempty
  Testing PositiveMonoid laws for type Vector (Small Int)
    positiveMonoidLaw_fundamental [✔]
      +++ OK, passed 100 tests:
      98% not (null (a <> b))
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
       2% null (a <> b)
  Testing RightCancellative laws for type Vector (Small Int)
    rightCancellativeLaw_cancellation [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
  Testing RightDistributiveGCDMonoid laws for type Vector (Small Int)
    rightDistributiveGCDMonoidLaw_distributivity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      81% allUnique [a, b, c]
      78% allUniqueNonNull [a, b, c]
      46% commonSuffix a b /= mempty && c /= mempty
  Testing RightGCDMonoid laws for type Vector (Small Int)
    rightGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (commonSuffix a b) a /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      37% commonSuffix a b /= mempty
    rightGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (commonSuffix a b) b /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      37% commonSuffix a b /= mempty
    rightGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      96% antecedent == False
      96% consequent == False
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
       4% antecedent == True
       4% consequent == True
    rightGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    rightGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    rightGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    rightGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      63% commonSuffix a b == mempty
      37% commonSuffix a b /= mempty
    rightGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      81% allUnique [a, b, c]
      78% allUniqueNonNull [a, b, c]
      31% commonSuffix (commonSuffix a b) c /= mempty
      31% commonSuffix a (commonSuffix b c) /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_commonSuffix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      37% commonSuffix a b /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      21% stripCommonSuffix a b & \(x, _, s) -> x /= mempty && s /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      20% stripCommonSuffix a b & \(_, x, s) -> x /= mempty && s /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_stripSuffix_1 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      21% stripCommonSuffix a b & \(x, _, s) -> x /= mempty && s /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_stripSuffix_2 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      20% stripCommonSuffix a b & \(_, x, s) -> x /= mempty && s /= mempty
  Testing RightReductive laws for type Vector (Small Int)
    rightReductiveLaw_isSuffixOf_mappend [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
    rightReductiveLaw_isSuffixOf_stripSuffix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
    rightReductiveLaw_stripSuffix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
  Testing StableFactorial laws for type Vector (Small Int)
    stableFactorialLaw_factors_mappend [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
    stableFactorialLaw_factors_reverse [✔]
      +++ OK, passed 100 tests.
    stableFactorialLaw_primePrefix_primeSuffix_reverse [✔]
      +++ OK, passed 100 tests.
    stableFactorialLaw_primeSuffix_primePrefix_reverse [✔]
      +++ OK, passed 100 tests.
  Testing Factorial laws for type Dual (Vector (Small Int))
    factorialLaw_coverage [✔]
      +++ OK, passed 100 tests:
      94% length a >= 2
       3% length a == 0
       3% length a == 1
    factorialLaw_length_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors_reverse [✔]
      +++ OK, passed 100 tests.
    factorialLaw_all_factors_prime [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primePrefix_foldr [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primeSuffix_foldl [✔]
      +++ OK, passed 100 tests.
    factorialLaw_factors_foldl [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
    factorialLaw_factors_foldl' [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
    factorialLaw_factors_foldr [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
  Testing FactorialMonoid laws for type Dual (Vector (Small Int))
    factorialMonoidLaw_coverage [✔]
      +++ OK, passed 100 tests:
      94% length a >= 2
       3% length a == 0
       3% length a == 1
    factorialMonoidLaw_null [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_reverse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_inits [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_tails [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_span [✔]
      +++ OK, passed 100 tests:
      96% any p (factors a)
      94% any (not . p) (factors a)
    factorialMonoidLaw_split [✔]
      +++ OK, passed 100 tests:
      96% any p (factors a)
      94% any (not . p) (factors a)
    factorialMonoidLaw_split_intersperse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitAt [✔]
      +++ OK, passed 100 tests.
  Testing LeftCancellative laws for type Dual (Vector (Small Int))
    leftCancellativeLaw_cancellation [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
  Testing LeftDistributiveGCDMonoid laws for type Dual (Vector (Small Int))
    leftDistributiveGCDMonoidLaw_distributivity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      81% allUnique [a, b, c]
      78% allUniqueNonNull [a, b, c]
      29% commonPrefix b c /= mempty && a /= mempty
  Testing LeftGCDMonoid laws for type Dual (Vector (Small Int))
    leftGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) a /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      40% commonPrefix a b /= mempty
    leftGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) b /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      40% commonPrefix a b /= mempty
    leftGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      95% antecedent == False
      95% consequent == False
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
       5% antecedent == True
       5% consequent == True
    leftGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    leftGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    leftGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    leftGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      60% commonPrefix a b == mempty
      40% commonPrefix a b /= mempty
    leftGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      81% allUnique [a, b, c]
      78% allUniqueNonNull [a, b, c]
      22% commonPrefix (commonPrefix a b) c /= mempty
      22% commonPrefix a (commonPrefix b c) /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_commonPrefix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      40% commonPrefix a b /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      24% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      20% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_1 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      24% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_2 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      20% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
  Testing LeftReductive laws for type Dual (Vector (Small Int))
    leftReductiveLaw_isPrefixOf_mappend [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
    leftReductiveLaw_isPrefixOf_stripPrefix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
    leftReductiveLaw_stripPrefix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
  Testing MonoidNull laws for type Dual (Vector (Small Int))
    monoidNullLaw_basic [✔]
      +++ OK, passed 100 tests:
      97% a /= mempty
       3% a == mempty
  Testing OverlappingGCDMonoid laws for type Dual (Vector (Small Int))
    overlappingGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (overlap a b) a /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      40% overlap a b /= mempty
    overlappingGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (overlap a b) b /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      40% overlap a b /= mempty
    overlappingGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    overlappingGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    overlappingGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    overlappingGCDMonoidLaw_overlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      23% overlap a b /= mempty && stripPrefixOverlap a b /= mempty
    overlappingGCDMonoidLaw_overlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      24% stripSuffixOverlap b a /= mempty && overlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_overlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      40% overlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      80% stripPrefixOverlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      82% stripSuffixOverlap b a /= mempty
  Testing PositiveMonoid laws for type Dual (Vector (Small Int))
    positiveMonoidLaw_fundamental [✔]
      +++ OK, passed 100 tests:
      98% not (null (a <> b))
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
       2% null (a <> b)
  Testing RightCancellative laws for type Dual (Vector (Small Int))
    rightCancellativeLaw_cancellation [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
  Testing RightDistributiveGCDMonoid laws for type Dual (Vector (Small Int))
    rightDistributiveGCDMonoidLaw_distributivity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      81% allUnique [a, b, c]
      78% allUniqueNonNull [a, b, c]
      43% commonSuffix a b /= mempty && c /= mempty
  Testing RightGCDMonoid laws for type Dual (Vector (Small Int))
    rightGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (commonSuffix a b) a /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      36% commonSuffix a b /= mempty
    rightGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (commonSuffix a b) b /= mempty
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      36% commonSuffix a b /= mempty
    rightGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      96% antecedent == False
      96% consequent == False
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
       4% antecedent == True
       4% consequent == True
    rightGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    rightGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    rightGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    rightGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      64% commonSuffix a b == mempty
      36% commonSuffix a b /= mempty
    rightGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      81% allUnique [a, b, c]
      78% allUniqueNonNull [a, b, c]
      31% commonSuffix (commonSuffix a b) c /= mempty
      31% commonSuffix a (commonSuffix b c) /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_commonSuffix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      36% commonSuffix a b /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      19% stripCommonSuffix a b & \(x, _, s) -> x /= mempty && s /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      19% stripCommonSuffix a b & \(_, x, s) -> x /= mempty && s /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_stripSuffix_1 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      19% stripCommonSuffix a b & \(x, _, s) -> x /= mempty && s /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_stripSuffix_2 [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
      19% stripCommonSuffix a b & \(_, x, s) -> x /= mempty && s /= mempty
  Testing RightReductive laws for type Dual (Vector (Small Int))
    rightReductiveLaw_isSuffixOf_mappend [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
    rightReductiveLaw_isSuffixOf_stripSuffix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
    rightReductiveLaw_stripSuffix [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
  Testing StableFactorial laws for type Dual (Vector (Small Int))
    stableFactorialLaw_factors_mappend [✔]
      +++ OK, passed 100 tests:
      97% allNonNull [a, b]
      91% allUnique [a, b]
      90% allUniqueNonNull [a, b]
    stableFactorialLaw_factors_reverse [✔]
      +++ OK, passed 100 tests.
    stableFactorialLaw_primePrefix_primeSuffix_reverse [✔]
      +++ OK, passed 100 tests.
    stableFactorialLaw_primeSuffix_primePrefix_reverse [✔]
      +++ OK, passed 100 tests.
  Testing Commutative laws for type Set (Small Int)
    commutativeLaw_basic [✔]
      +++ OK, passed 100 tests:
      86% allUnique [a, b]
      26% (a /= b) && (a <> b /= a) && (b <> a /= b)
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
  Testing DistributiveGCDMonoid laws for type Set (Small Int)
    distributiveGCDMonoidLaw_distributivity_left [✔]
      +++ OK, passed 100 tests:
      71% allUnique [a, b, c]
      39% allNonNull [a, b, c]
      33% allUniqueNonNull [a, b, c]
    distributiveGCDMonoidLaw_distributivity_right [✔]
      +++ OK, passed 100 tests:
      71% allUnique [a, b, c]
      39% allNonNull [a, b, c]
      33% allUniqueNonNull [a, b, c]
  Testing DistributiveLCMMonoid laws for type Set (Small Int)
    distributiveLCMMonoidLaw_distributivity_left [✔]
      +++ OK, passed 100 tests:
      71% allUnique [a, b, c]
      39% allNonNull [a, b, c]
      33% allUniqueNonNull [a, b, c]
    distributiveLCMMonoidLaw_distributivity_right [✔]
      +++ OK, passed 100 tests:
      71% allUnique [a, b, c]
      39% allNonNull [a, b, c]
      33% allUniqueNonNull [a, b, c]
    distributiveLCMMonoidLaw_distributivity_gcd_lcm [✔]
      +++ OK, passed 100 tests:
      71% allUnique [a, b, c]
      39% allNonNull [a, b, c]
      33% allUniqueNonNull [a, b, c]
    distributiveLCMMonoidLaw_distributivity_lcm_gcd [✔]
      +++ OK, passed 100 tests:
      71% allUnique [a, b, c]
      39% allNonNull [a, b, c]
      33% allUniqueNonNull [a, b, c]
  Testing Factorial laws for type Set (Small Int)
    factorialLaw_coverage [✔]
      +++ OK, passed 100 tests:
      93% length a >= 2
       4% length a == 1
       3% length a == 0
    factorialLaw_length_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors_reverse [✔]
      +++ OK, passed 100 tests.
    factorialLaw_all_factors_prime [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primePrefix_foldr [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primeSuffix_foldl [✔]
      +++ OK, passed 100 tests.
    factorialLaw_factors_foldl [✔]
      +++ OK, passed 100 tests:
      86% allUnique [a, b]
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
    factorialLaw_factors_foldl' [✔]
      +++ OK, passed 100 tests:
      86% allUnique [a, b]
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
    factorialLaw_factors_foldr [✔]
      +++ OK, passed 100 tests:
      86% allUnique [a, b]
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
  Testing FactorialMonoid laws for type Set (Small Int)
    factorialMonoidLaw_coverage [✔]
      +++ OK, passed 100 tests:
      93% length a >= 2
       4% length a == 1
       3% length a == 0
    factorialMonoidLaw_null [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_reverse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_inits [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_tails [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_span [✔]
      +++ OK, passed 100 tests:
      94% any (not . p) (factors a)
      94% any p (factors a)
    factorialMonoidLaw_split [✔]
      +++ OK, passed 100 tests:
      94% any (not . p) (factors a)
      94% any p (factors a)
    factorialMonoidLaw_split_intersperse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitAt [✔]
      +++ OK, passed 100 tests.
  Testing GCDMonoid laws for type Set (Small Int)
    gcdMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% (a </> gcd a b) /= mempty
      96% gcd a b /= mempty
      86% allUnique [a, b]
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
    gcdMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% (b </> gcd a b) /= mempty
      96% gcd a b /= mempty
      86% allUnique [a, b]
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
    gcdMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      90% c /= gcd a b
      90% not (all isJust [a </> c, b </> c, c </> gcd a b])
      71% allUnique [a, b, c]
      39% allNonNull [a, b, c]
      33% allUniqueNonNull [a, b, c]
      10% all isJust [a </> c, b </> c, c </> gcd a b]
      10% c == gcd a b
    gcdMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    gcdMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    gcdMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    gcdMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      96% gcd a b /= mempty
      86% allUnique [a, b]
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
       4% gcd a b == mempty
    gcdMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      95% gcd a b /= mempty
      93% gcd b c /= mempty
      71% allUnique [a, b, c]
      39% allNonNull [a, b, c]
      33% allUniqueNonNull [a, b, c]
    gcdMonoidLaw_equivalence_commonPrefix [✔]
      +++ OK, passed 100 tests:
      96% commonPrefix a b /= mempty
      96% gcd a b /= mempty
      86% allUnique [a, b]
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
    gcdMonoidLaw_equivalence_commonSuffix [✔]
      +++ OK, passed 100 tests:
      96% commonSuffix a b /= mempty
      96% gcd a b /= mempty
      86% allUnique [a, b]
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
  Testing LCMMonoid laws for type Set (Small Int)
    lcmMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      98% lcm a b /= mempty
      86% allUnique [a, b]
      50% (lcm a b </> a) /= Just mempty
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
    lcmMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      98% lcm a b /= mempty
      86% allUnique [a, b]
      62% (lcm a b </> b) /= Just mempty
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
    lcmMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      85% c /= lcm a b
      85% not (all isJust [c </> a, c </> b, lcm a b </> c])
      71% allUnique [a, b, c]
      39% allNonNull [a, b, c]
      33% allUniqueNonNull [a, b, c]
      15% all isJust [c </> a, c </> b, lcm a b </> c]
      15% c == lcm a b
    lcmMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    lcmMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    lcmMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    lcmMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      98% lcm a b /= mempty
      86% allUnique [a, b]
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
    lcmMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      98% lcm a b /= mempty
      98% lcm b c /= mempty
      71% allUnique [a, b, c]
      39% allNonNull [a, b, c]
      33% allUniqueNonNull [a, b, c]
    lcmMonoidLaw_absorption_gcd_lcm [✔]
      +++ OK, passed 100 tests:
      96% gcd a b /= mempty
      86% allUnique [a, b]
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
       4% gcd a b == mempty
    lcmMonoidLaw_absorption_lcm_gcd [✔]
      +++ OK, passed 100 tests:
      96% gcd a b /= mempty
      86% allUnique [a, b]
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
       4% gcd a b == mempty
  Testing LeftDistributiveGCDMonoid laws for type Set (Small Int)
    leftDistributiveGCDMonoidLaw_distributivity [✔]
      +++ OK, passed 100 tests:
      93% commonPrefix b c /= mempty && a /= mempty
      71% allUnique [a, b, c]
      39% allNonNull [a, b, c]
      33% allUniqueNonNull [a, b, c]
  Testing LeftGCDMonoid laws for type Set (Small Int)
    leftGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) a /= mempty
      96% commonPrefix a b /= mempty
      86% allUnique [a, b]
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) b /= mempty
      96% commonPrefix a b /= mempty
      86% allUnique [a, b]
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      98% antecedent == False
      98% consequent == False
      86% allUnique [a, b]
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
       2% antecedent == True
       2% consequent == True
    leftGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    leftGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    leftGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    leftGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      96% commonPrefix a b /= mempty
      86% allUnique [a, b]
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
       4% commonPrefix a b == mempty
    leftGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      93% commonPrefix (commonPrefix a b) c /= mempty
      93% commonPrefix a (commonPrefix b c) /= mempty
      71% allUnique [a, b, c]
      39% allNonNull [a, b, c]
      33% allUniqueNonNull [a, b, c]
    leftGCDMonoidLaw_stripCommonPrefix_commonPrefix [✔]
      +++ OK, passed 100 tests:
      96% commonPrefix a b /= mempty
      86% allUnique [a, b]
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_stripCommonPrefix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      86% allUnique [a, b]
      60% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_stripCommonPrefix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      86% allUnique [a, b]
      49% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_1 [✔]
      +++ OK, passed 100 tests:
      86% allUnique [a, b]
      60% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_2 [✔]
      +++ OK, passed 100 tests:
      86% allUnique [a, b]
      49% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
  Testing LeftReductive laws for type Set (Small Int)
    leftReductiveLaw_isPrefixOf_mappend [✔]
      +++ OK, passed 100 tests:
      86% allUnique [a, b]
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
    leftReductiveLaw_isPrefixOf_stripPrefix [✔]
      +++ OK, passed 100 tests:
      86% allUnique [a, b]
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
    leftReductiveLaw_stripPrefix [✔]
      +++ OK, passed 100 tests:
      86% allUnique [a, b]
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
  Testing MonoidNull laws for type Set (Small Int)
    monoidNullLaw_basic [✔]
      +++ OK, passed 100 tests:
      97% a /= mempty
       3% a == mempty
  Testing Monus laws for type Set (Small Int)
    monusLaw_axiom_1 [✔]
      +++ OK, passed 100 tests:
      97% a /= mempty
       3% a == mempty
    monusLaw_axiom_2 [✔]
      +++ OK, passed 100 tests:
      97% a /= mempty
       3% a == mempty
    monusLaw_axiom_3 [✔]
      +++ OK, passed 100 tests:
      86% allUnique [a, b]
      62% (a <\> b) /= mempty
      50% (b <\> a) /= mempty
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
    monusLaw_axiom_4 [✔]
      +++ OK, passed 100 tests:
      71% allUnique [a, b, c]
      39% allNonNull [a, b, c]
      38% (a <\> b) <\> c /= mempty
      33% allUniqueNonNull [a, b, c]
    monusLaw_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      86% allUnique [a, b]
      62% a <\> b /= mempty
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
    monusLaw_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      86% allUnique [a, b]
      62% a <\> b /= mempty
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
  Testing OverlappingGCDMonoid laws for type Set (Small Int)
    overlappingGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (overlap a b) a /= mempty
      96% overlap a b /= mempty
      86% allUnique [a, b]
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (overlap a b) b /= mempty
      96% overlap a b /= mempty
      86% allUnique [a, b]
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    overlappingGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    overlappingGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    overlappingGCDMonoidLaw_overlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      86% allUnique [a, b]
      49% overlap a b /= mempty && stripPrefixOverlap a b /= mempty
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_overlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      86% allUnique [a, b]
      60% stripSuffixOverlap b a /= mempty && overlap a b /= mempty
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_stripOverlap_overlap [✔]
      +++ OK, passed 100 tests:
      96% overlap a b /= mempty
      86% allUnique [a, b]
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_stripOverlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      86% allUnique [a, b]
      50% stripPrefixOverlap a b /= mempty
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_stripOverlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      86% allUnique [a, b]
      62% stripSuffixOverlap b a /= mempty
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
  Testing PositiveMonoid laws for type Set (Small Int)
    positiveMonoidLaw_fundamental [✔]
      +++ OK, passed 100 tests:
      98% not (null (a <> b))
      86% allUnique [a, b]
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
       2% null (a <> b)
  Testing Reductive laws for type Set (Small Int)
    reductiveLaw_equivalence_prefix [✔]
      +++ OK, passed 100 tests:
      86% allUnique [a, b]
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
    reductiveLaw_equivalence_suffix [✔]
      +++ OK, passed 100 tests:
      86% allUnique [a, b]
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
    reductiveLaw_inversion_prefix [✔]
      +++ OK, passed 100 tests:
      86% allUnique [a, b]
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
    reductiveLaw_inversion_suffix [✔]
      +++ OK, passed 100 tests:
      86% allUnique [a, b]
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
  Testing RightDistributiveGCDMonoid laws for type Set (Small Int)
    rightDistributiveGCDMonoidLaw_distributivity [✔]
      +++ OK, passed 100 tests:
      94% commonSuffix a b /= mempty && c /= mempty
      71% allUnique [a, b, c]
      39% allNonNull [a, b, c]
      33% allUniqueNonNull [a, b, c]
  Testing RightGCDMonoid laws for type Set (Small Int)
    rightGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (commonSuffix a b) a /= mempty
      96% commonSuffix a b /= mempty
      86% allUnique [a, b]
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
    rightGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (commonSuffix a b) b /= mempty
      96% commonSuffix a b /= mempty
      86% allUnique [a, b]
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
    rightGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      98% antecedent == False
      98% consequent == False
      86% allUnique [a, b]
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
       2% antecedent == True
       2% consequent == True
    rightGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    rightGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    rightGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    rightGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      96% commonSuffix a b /= mempty
      86% allUnique [a, b]
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
       4% commonSuffix a b == mempty
    rightGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      93% commonSuffix (commonSuffix a b) c /= mempty
      93% commonSuffix a (commonSuffix b c) /= mempty
      71% allUnique [a, b, c]
      39% allNonNull [a, b, c]
      33% allUniqueNonNull [a, b, c]
    rightGCDMonoidLaw_stripCommonSuffix_commonSuffix [✔]
      +++ OK, passed 100 tests:
      96% commonSuffix a b /= mempty
      86% allUnique [a, b]
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
    rightGCDMonoidLaw_stripCommonSuffix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      86% allUnique [a, b]
      60% stripCommonSuffix a b & \(x, _, s) -> x /= mempty && s /= mempty
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
    rightGCDMonoidLaw_stripCommonSuffix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      86% allUnique [a, b]
      49% stripCommonSuffix a b & \(_, x, s) -> x /= mempty && s /= mempty
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
    rightGCDMonoidLaw_stripCommonSuffix_stripSuffix_1 [✔]
      +++ OK, passed 100 tests:
      86% allUnique [a, b]
      60% stripCommonSuffix a b & \(x, _, s) -> x /= mempty && s /= mempty
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
    rightGCDMonoidLaw_stripCommonSuffix_stripSuffix_2 [✔]
      +++ OK, passed 100 tests:
      86% allUnique [a, b]
      49% stripCommonSuffix a b & \(_, x, s) -> x /= mempty && s /= mempty
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
  Testing RightReductive laws for type Set (Small Int)
    rightReductiveLaw_isSuffixOf_mappend [✔]
      +++ OK, passed 100 tests:
      86% allUnique [a, b]
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
    rightReductiveLaw_isSuffixOf_stripSuffix [✔]
      +++ OK, passed 100 tests:
      86% allUnique [a, b]
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
    rightReductiveLaw_stripSuffix [✔]
      +++ OK, passed 100 tests:
      86% allUnique [a, b]
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
  Testing Commutative laws for type Set Natural
    commutativeLaw_basic [✔]
      +++ OK, passed 100 tests:
      87% allUnique [a, b]
      26% (a /= b) && (a <> b /= a) && (b <> a /= b)
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
  Testing DistributiveGCDMonoid laws for type Set Natural
    distributiveGCDMonoidLaw_distributivity_left [✔]
      +++ OK, passed 100 tests:
      71% allUnique [a, b, c]
      39% allNonNull [a, b, c]
      33% allUniqueNonNull [a, b, c]
    distributiveGCDMonoidLaw_distributivity_right [✔]
      +++ OK, passed 100 tests:
      71% allUnique [a, b, c]
      39% allNonNull [a, b, c]
      33% allUniqueNonNull [a, b, c]
  Testing DistributiveLCMMonoid laws for type Set Natural
    distributiveLCMMonoidLaw_distributivity_left [✔]
      +++ OK, passed 100 tests:
      71% allUnique [a, b, c]
      39% allNonNull [a, b, c]
      33% allUniqueNonNull [a, b, c]
    distributiveLCMMonoidLaw_distributivity_right [✔]
      +++ OK, passed 100 tests:
      71% allUnique [a, b, c]
      39% allNonNull [a, b, c]
      33% allUniqueNonNull [a, b, c]
    distributiveLCMMonoidLaw_distributivity_gcd_lcm [✔]
      +++ OK, passed 100 tests:
      71% allUnique [a, b, c]
      39% allNonNull [a, b, c]
      33% allUniqueNonNull [a, b, c]
    distributiveLCMMonoidLaw_distributivity_lcm_gcd [✔]
      +++ OK, passed 100 tests:
      71% allUnique [a, b, c]
      39% allNonNull [a, b, c]
      33% allUniqueNonNull [a, b, c]
  Testing Factorial laws for type Set Natural
    factorialLaw_coverage [✔]
      +++ OK, passed 100 tests:
      93% length a >= 2
       4% length a == 1
       3% length a == 0
    factorialLaw_length_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors_reverse [✔]
      +++ OK, passed 100 tests.
    factorialLaw_all_factors_prime [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primePrefix_foldr [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primeSuffix_foldl [✔]
      +++ OK, passed 100 tests.
    factorialLaw_factors_foldl [✔]
      +++ OK, passed 100 tests:
      87% allUnique [a, b]
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
    factorialLaw_factors_foldl' [✔]
      +++ OK, passed 100 tests:
      87% allUnique [a, b]
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
    factorialLaw_factors_foldr [✔]
      +++ OK, passed 100 tests:
      87% allUnique [a, b]
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
  Testing FactorialMonoid laws for type Set Natural
    factorialMonoidLaw_coverage [✔]
      +++ OK, passed 100 tests:
      93% length a >= 2
       4% length a == 1
       3% length a == 0
    factorialMonoidLaw_null [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_reverse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_inits [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_tails [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_span [✔]
      +++ OK, passed 100 tests:
      94% any (not . p) (factors a)
      94% any p (factors a)
    factorialMonoidLaw_split [✔]
      +++ OK, passed 100 tests:
      94% any (not . p) (factors a)
      94% any p (factors a)
    factorialMonoidLaw_split_intersperse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitAt [✔]
      +++ OK, passed 100 tests.
  Testing GCDMonoid laws for type Set Natural
    gcdMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% (a </> gcd a b) /= mempty
      96% gcd a b /= mempty
      87% allUnique [a, b]
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
    gcdMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% (b </> gcd a b) /= mempty
      96% gcd a b /= mempty
      87% allUnique [a, b]
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
    gcdMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      90% c /= gcd a b
      90% not (all isJust [a </> c, b </> c, c </> gcd a b])
      71% allUnique [a, b, c]
      39% allNonNull [a, b, c]
      33% allUniqueNonNull [a, b, c]
      10% all isJust [a </> c, b </> c, c </> gcd a b]
      10% c == gcd a b
    gcdMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    gcdMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    gcdMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    gcdMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      96% gcd a b /= mempty
      87% allUnique [a, b]
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
       4% gcd a b == mempty
    gcdMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      95% gcd a b /= mempty
      93% gcd b c /= mempty
      71% allUnique [a, b, c]
      39% allNonNull [a, b, c]
      33% allUniqueNonNull [a, b, c]
    gcdMonoidLaw_equivalence_commonPrefix [✔]
      +++ OK, passed 100 tests:
      96% commonPrefix a b /= mempty
      96% gcd a b /= mempty
      87% allUnique [a, b]
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
    gcdMonoidLaw_equivalence_commonSuffix [✔]
      +++ OK, passed 100 tests:
      96% commonSuffix a b /= mempty
      96% gcd a b /= mempty
      87% allUnique [a, b]
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
  Testing LCMMonoid laws for type Set Natural
    lcmMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      98% lcm a b /= mempty
      87% allUnique [a, b]
      51% (lcm a b </> a) /= Just mempty
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
    lcmMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      98% lcm a b /= mempty
      87% allUnique [a, b]
      62% (lcm a b </> b) /= Just mempty
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
    lcmMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      85% c /= lcm a b
      85% not (all isJust [c </> a, c </> b, lcm a b </> c])
      71% allUnique [a, b, c]
      39% allNonNull [a, b, c]
      33% allUniqueNonNull [a, b, c]
      15% all isJust [c </> a, c </> b, lcm a b </> c]
      15% c == lcm a b
    lcmMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    lcmMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    lcmMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    lcmMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      98% lcm a b /= mempty
      87% allUnique [a, b]
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
    lcmMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      98% lcm a b /= mempty
      98% lcm b c /= mempty
      71% allUnique [a, b, c]
      39% allNonNull [a, b, c]
      33% allUniqueNonNull [a, b, c]
    lcmMonoidLaw_absorption_gcd_lcm [✔]
      +++ OK, passed 100 tests:
      96% gcd a b /= mempty
      87% allUnique [a, b]
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
       4% gcd a b == mempty
    lcmMonoidLaw_absorption_lcm_gcd [✔]
      +++ OK, passed 100 tests:
      96% gcd a b /= mempty
      87% allUnique [a, b]
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
       4% gcd a b == mempty
  Testing LeftDistributiveGCDMonoid laws for type Set Natural
    leftDistributiveGCDMonoidLaw_distributivity [✔]
      +++ OK, passed 100 tests:
      93% commonPrefix b c /= mempty && a /= mempty
      71% allUnique [a, b, c]
      39% allNonNull [a, b, c]
      33% allUniqueNonNull [a, b, c]
  Testing LeftGCDMonoid laws for type Set Natural
    leftGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) a /= mempty
      96% commonPrefix a b /= mempty
      87% allUnique [a, b]
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) b /= mempty
      96% commonPrefix a b /= mempty
      87% allUnique [a, b]
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      98% antecedent == False
      98% consequent == False
      87% allUnique [a, b]
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
       2% antecedent == True
       2% consequent == True
    leftGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    leftGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    leftGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    leftGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      96% commonPrefix a b /= mempty
      87% allUnique [a, b]
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
       4% commonPrefix a b == mempty
    leftGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      93% commonPrefix (commonPrefix a b) c /= mempty
      93% commonPrefix a (commonPrefix b c) /= mempty
      71% allUnique [a, b, c]
      39% allNonNull [a, b, c]
      33% allUniqueNonNull [a, b, c]
    leftGCDMonoidLaw_stripCommonPrefix_commonPrefix [✔]
      +++ OK, passed 100 tests:
      96% commonPrefix a b /= mempty
      87% allUnique [a, b]
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_stripCommonPrefix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      87% allUnique [a, b]
      60% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_stripCommonPrefix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      87% allUnique [a, b]
      50% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_1 [✔]
      +++ OK, passed 100 tests:
      87% allUnique [a, b]
      60% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_2 [✔]
      +++ OK, passed 100 tests:
      87% allUnique [a, b]
      50% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
  Testing LeftReductive laws for type Set Natural
    leftReductiveLaw_isPrefixOf_mappend [✔]
      +++ OK, passed 100 tests:
      87% allUnique [a, b]
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
    leftReductiveLaw_isPrefixOf_stripPrefix [✔]
      +++ OK, passed 100 tests:
      87% allUnique [a, b]
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
    leftReductiveLaw_stripPrefix [✔]
      +++ OK, passed 100 tests:
      87% allUnique [a, b]
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
  Testing MonoidNull laws for type Set Natural
    monoidNullLaw_basic [✔]
      +++ OK, passed 100 tests:
      97% a /= mempty
       3% a == mempty
  Testing Monus laws for type Set Natural
    monusLaw_axiom_1 [✔]
      +++ OK, passed 100 tests:
      97% a /= mempty
       3% a == mempty
    monusLaw_axiom_2 [✔]
      +++ OK, passed 100 tests:
      97% a /= mempty
       3% a == mempty
    monusLaw_axiom_3 [✔]
      +++ OK, passed 100 tests:
      87% allUnique [a, b]
      62% (a <\> b) /= mempty
      51% (b <\> a) /= mempty
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
    monusLaw_axiom_4 [✔]
      +++ OK, passed 100 tests:
      71% allUnique [a, b, c]
      39% allNonNull [a, b, c]
      38% (a <\> b) <\> c /= mempty
      33% allUniqueNonNull [a, b, c]
    monusLaw_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      87% allUnique [a, b]
      62% a <\> b /= mempty
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
    monusLaw_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      87% allUnique [a, b]
      62% a <\> b /= mempty
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
  Testing OverlappingGCDMonoid laws for type Set Natural
    overlappingGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (overlap a b) a /= mempty
      96% overlap a b /= mempty
      87% allUnique [a, b]
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (overlap a b) b /= mempty
      96% overlap a b /= mempty
      87% allUnique [a, b]
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    overlappingGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    overlappingGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    overlappingGCDMonoidLaw_overlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      87% allUnique [a, b]
      50% overlap a b /= mempty && stripPrefixOverlap a b /= mempty
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_overlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      87% allUnique [a, b]
      60% stripSuffixOverlap b a /= mempty && overlap a b /= mempty
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_stripOverlap_overlap [✔]
      +++ OK, passed 100 tests:
      96% overlap a b /= mempty
      87% allUnique [a, b]
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_stripOverlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      87% allUnique [a, b]
      51% stripPrefixOverlap a b /= mempty
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_stripOverlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      87% allUnique [a, b]
      62% stripSuffixOverlap b a /= mempty
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
  Testing PositiveMonoid laws for type Set Natural
    positiveMonoidLaw_fundamental [✔]
      +++ OK, passed 100 tests:
      98% not (null (a <> b))
      87% allUnique [a, b]
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
       2% null (a <> b)
  Testing Reductive laws for type Set Natural
    reductiveLaw_equivalence_prefix [✔]
      +++ OK, passed 100 tests:
      87% allUnique [a, b]
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
    reductiveLaw_equivalence_suffix [✔]
      +++ OK, passed 100 tests:
      87% allUnique [a, b]
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
    reductiveLaw_inversion_prefix [✔]
      +++ OK, passed 100 tests:
      87% allUnique [a, b]
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
    reductiveLaw_inversion_suffix [✔]
      +++ OK, passed 100 tests:
      87% allUnique [a, b]
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
  Testing RightDistributiveGCDMonoid laws for type Set Natural
    rightDistributiveGCDMonoidLaw_distributivity [✔]
      +++ OK, passed 100 tests:
      94% commonSuffix a b /= mempty && c /= mempty
      71% allUnique [a, b, c]
      39% allNonNull [a, b, c]
      33% allUniqueNonNull [a, b, c]
  Testing RightGCDMonoid laws for type Set Natural
    rightGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (commonSuffix a b) a /= mempty
      96% commonSuffix a b /= mempty
      87% allUnique [a, b]
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
    rightGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (commonSuffix a b) b /= mempty
      96% commonSuffix a b /= mempty
      87% allUnique [a, b]
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
    rightGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      98% antecedent == False
      98% consequent == False
      87% allUnique [a, b]
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
       2% antecedent == True
       2% consequent == True
    rightGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    rightGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    rightGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    rightGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      96% commonSuffix a b /= mempty
      87% allUnique [a, b]
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
       4% commonSuffix a b == mempty
    rightGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      93% commonSuffix (commonSuffix a b) c /= mempty
      93% commonSuffix a (commonSuffix b c) /= mempty
      71% allUnique [a, b, c]
      39% allNonNull [a, b, c]
      33% allUniqueNonNull [a, b, c]
    rightGCDMonoidLaw_stripCommonSuffix_commonSuffix [✔]
      +++ OK, passed 100 tests:
      96% commonSuffix a b /= mempty
      87% allUnique [a, b]
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
    rightGCDMonoidLaw_stripCommonSuffix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      87% allUnique [a, b]
      60% stripCommonSuffix a b & \(x, _, s) -> x /= mempty && s /= mempty
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
    rightGCDMonoidLaw_stripCommonSuffix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      87% allUnique [a, b]
      50% stripCommonSuffix a b & \(_, x, s) -> x /= mempty && s /= mempty
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
    rightGCDMonoidLaw_stripCommonSuffix_stripSuffix_1 [✔]
      +++ OK, passed 100 tests:
      87% allUnique [a, b]
      60% stripCommonSuffix a b & \(x, _, s) -> x /= mempty && s /= mempty
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
    rightGCDMonoidLaw_stripCommonSuffix_stripSuffix_2 [✔]
      +++ OK, passed 100 tests:
      87% allUnique [a, b]
      50% stripCommonSuffix a b & \(_, x, s) -> x /= mempty && s /= mempty
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
  Testing RightReductive laws for type Set Natural
    rightReductiveLaw_isSuffixOf_mappend [✔]
      +++ OK, passed 100 tests:
      87% allUnique [a, b]
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
    rightReductiveLaw_isSuffixOf_stripSuffix [✔]
      +++ OK, passed 100 tests:
      87% allUnique [a, b]
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
    rightReductiveLaw_stripSuffix [✔]
      +++ OK, passed 100 tests:
      87% allUnique [a, b]
      26% allNonNull [a, b]
      26% allUniqueNonNull [a, b]
  Testing Commutative laws for type Product (Small Int)
    commutativeLaw_basic [✔]
      +++ OK, passed 100 tests:
      91% allNonNull [a, b]
      86% allUnique [a, b]
      84% allUniqueNonNull [a, b]
      78% (a /= b) && (a <> b /= a) && (b <> a /= b)
  Testing Factorial laws for type Product (Small Int)
    factorialLaw_coverage [✔]
      +++ OK, passed 100 tests:
      58% length a == 1
      39% length a >= 2
       3% length a == 0
    factorialLaw_length_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors_reverse [✔]
      +++ OK, passed 100 tests.
    factorialLaw_all_factors_prime [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primePrefix_foldr [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primeSuffix_foldl [✔]
      +++ OK, passed 100 tests.
    factorialLaw_factors_foldl [✔]
      +++ OK, passed 100 tests:
      91% allNonNull [a, b]
      86% allUnique [a, b]
      84% allUniqueNonNull [a, b]
    factorialLaw_factors_foldl' [✔]
      +++ OK, passed 100 tests:
      91% allNonNull [a, b]
      86% allUnique [a, b]
      84% allUniqueNonNull [a, b]
    factorialLaw_factors_foldr [✔]
      +++ OK, passed 100 tests:
      91% allNonNull [a, b]
      86% allUnique [a, b]
      84% allUniqueNonNull [a, b]
  Testing FactorialMonoid laws for type Product (Small Int)
    factorialMonoidLaw_coverage [✔]
      +++ OK, passed 100 tests:
      58% length a == 1
      39% length a >= 2
       3% length a == 0
    factorialMonoidLaw_null [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_reverse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_inits [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_tails [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_span [✔]
      +++ OK, passed 100 tests:
      66% any (not . p) (factors a)
      55% any p (factors a)
    factorialMonoidLaw_split [✔]
      +++ OK, passed 100 tests:
      66% any (not . p) (factors a)
      55% any p (factors a)
    factorialMonoidLaw_split_intersperse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitAt [✔]
      +++ OK, passed 100 tests.
  Testing LeftReductive laws for type Product (Small Int)
    leftReductiveLaw_isPrefixOf_mappend [✔]
      +++ OK, passed 100 tests:
      91% allNonNull [a, b]
      86% allUnique [a, b]
      84% allUniqueNonNull [a, b]
    leftReductiveLaw_isPrefixOf_stripPrefix [✔]
      +++ OK, passed 100 tests:
      91% allNonNull [a, b]
      86% allUnique [a, b]
      84% allUniqueNonNull [a, b]
    leftReductiveLaw_stripPrefix [✔]
      +++ OK, passed 100 tests:
      91% allNonNull [a, b]
      86% allUnique [a, b]
      84% allUniqueNonNull [a, b]
  Testing MonoidNull laws for type Product (Small Int)
    monoidNullLaw_basic [✔]
      +++ OK, passed 100 tests:
      97% a /= mempty
       3% a == mempty
  Testing Reductive laws for type Product (Small Int)
    reductiveLaw_equivalence_prefix [✔]
      +++ OK, passed 100 tests:
      91% allNonNull [a, b]
      86% allUnique [a, b]
      84% allUniqueNonNull [a, b]
    reductiveLaw_equivalence_suffix [✔]
      +++ OK, passed 100 tests:
      91% allNonNull [a, b]
      86% allUnique [a, b]
      84% allUniqueNonNull [a, b]
    reductiveLaw_inversion_prefix [✔]
      +++ OK, passed 100 tests:
      91% allNonNull [a, b]
      86% allUnique [a, b]
      84% allUniqueNonNull [a, b]
    reductiveLaw_inversion_suffix [✔]
      +++ OK, passed 100 tests:
      91% allNonNull [a, b]
      86% allUnique [a, b]
      84% allUniqueNonNull [a, b]
  Testing RightReductive laws for type Product (Small Int)
    rightReductiveLaw_isSuffixOf_mappend [✔]
      +++ OK, passed 100 tests:
      91% allNonNull [a, b]
      86% allUnique [a, b]
      84% allUniqueNonNull [a, b]
    rightReductiveLaw_isSuffixOf_stripSuffix [✔]
      +++ OK, passed 100 tests:
      91% allNonNull [a, b]
      86% allUnique [a, b]
      84% allUniqueNonNull [a, b]
    rightReductiveLaw_stripSuffix [✔]
      +++ OK, passed 100 tests:
      91% allNonNull [a, b]
      86% allUnique [a, b]
      84% allUniqueNonNull [a, b]
  Testing Commutative laws for type Product Natural
    commutativeLaw_basic [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      84% allUnique [a, b]
      83% allUniqueNonNull [a, b]
      78% (a /= b) && (a <> b /= a) && (b <> a /= b)
  Testing DistributiveGCDMonoid laws for type Product Natural
    distributiveGCDMonoidLaw_distributivity_left [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b, c]
      68% allUnique [a, b, c]
      67% allUniqueNonNull [a, b, c]
    distributiveGCDMonoidLaw_distributivity_right [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b, c]
      68% allUnique [a, b, c]
      67% allUniqueNonNull [a, b, c]
  Testing DistributiveLCMMonoid laws for type Product Natural
    distributiveLCMMonoidLaw_distributivity_left [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b, c]
      68% allUnique [a, b, c]
      67% allUniqueNonNull [a, b, c]
    distributiveLCMMonoidLaw_distributivity_right [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b, c]
      68% allUnique [a, b, c]
      67% allUniqueNonNull [a, b, c]
    distributiveLCMMonoidLaw_distributivity_gcd_lcm [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b, c]
      68% allUnique [a, b, c]
      67% allUniqueNonNull [a, b, c]
    distributiveLCMMonoidLaw_distributivity_lcm_gcd [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b, c]
      68% allUnique [a, b, c]
      67% allUniqueNonNull [a, b, c]
  Testing Factorial laws for type Product Natural
    factorialLaw_coverage [✔]
      +++ OK, passed 800 tests:
      77.6% length a >= 2
      21.6% length a == 1
       0.8% length a == 0
    factorialLaw_length_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors_reverse [✔]
      +++ OK, passed 100 tests.
    factorialLaw_all_factors_prime [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primePrefix_foldr [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primeSuffix_foldl [✔]
      +++ OK, passed 100 tests.
    factorialLaw_factors_foldl [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      84% allUnique [a, b]
      83% allUniqueNonNull [a, b]
    factorialLaw_factors_foldl' [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      84% allUnique [a, b]
      83% allUniqueNonNull [a, b]
    factorialLaw_factors_foldr [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      84% allUnique [a, b]
      83% allUniqueNonNull [a, b]
  Testing FactorialMonoid laws for type Product Natural
    factorialMonoidLaw_coverage [✔]
      +++ OK, passed 800 tests:
      77.6% length a >= 2
      21.6% length a == 1
       0.8% length a == 0
    factorialMonoidLaw_null [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_reverse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_inits [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_tails [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_span [✔]
      +++ OK, passed 100 tests:
      85% any p (factors a)
      68% any (not . p) (factors a)
    factorialMonoidLaw_split [✔]
      +++ OK, passed 100 tests:
      85% any p (factors a)
      68% any (not . p) (factors a)
    factorialMonoidLaw_split_intersperse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitAt [✔]
      +++ OK, passed 100 tests.
  Testing GCDMonoid laws for type Product Natural
    gcdMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% (a </> gcd a b) /= mempty
      94% gcd a b /= mempty
      93% allNonNull [a, b]
      84% allUnique [a, b]
      83% allUniqueNonNull [a, b]
    gcdMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% (b </> gcd a b) /= mempty
      94% gcd a b /= mempty
      93% allNonNull [a, b]
      84% allUnique [a, b]
      83% allUniqueNonNull [a, b]
    gcdMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b, c]
      90% c /= gcd a b
      90% not (all isJust [a </> c, b </> c, c </> gcd a b])
      68% allUnique [a, b, c]
      67% allUniqueNonNull [a, b, c]
      10% all isJust [a </> c, b </> c, c </> gcd a b]
      10% c == gcd a b
    gcdMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    gcdMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (99% a /= mempty).
    gcdMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (99% a /= mempty).
    gcdMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      94% gcd a b /= mempty
      93% allNonNull [a, b]
      84% allUnique [a, b]
      83% allUniqueNonNull [a, b]
       6% gcd a b == mempty
    gcdMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b, c]
      94% gcd a b /= mempty
      94% gcd b c /= mempty
      68% allUnique [a, b, c]
      67% allUniqueNonNull [a, b, c]
    gcdMonoidLaw_equivalence_commonPrefix [✔]
      +++ OK, passed 100 tests:
      94% commonPrefix a b /= mempty
      94% gcd a b /= mempty
      93% allNonNull [a, b]
      84% allUnique [a, b]
      83% allUniqueNonNull [a, b]
    gcdMonoidLaw_equivalence_commonSuffix [✔]
      +++ OK, passed 100 tests:
      94% commonSuffix a b /= mempty
      94% gcd a b /= mempty
      93% allNonNull [a, b]
      84% allUnique [a, b]
      83% allUniqueNonNull [a, b]
  Testing LCMMonoid laws for type Product Natural
    lcmMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% lcm a b /= mempty
      93% allNonNull [a, b]
      84% allUnique [a, b]
      83% allUniqueNonNull [a, b]
      60% (lcm a b </> a) /= Just mempty
    lcmMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% lcm a b /= mempty
      93% allNonNull [a, b]
      84% allUnique [a, b]
      83% allUniqueNonNull [a, b]
      64% (lcm a b </> b) /= Just mempty
    lcmMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b, c]
      84% c /= lcm a b
      84% not (all isJust [c </> a, c </> b, lcm a b </> c])
      68% allUnique [a, b, c]
      67% allUniqueNonNull [a, b, c]
      16% all isJust [c </> a, c </> b, lcm a b </> c]
      16% c == lcm a b
    lcmMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    lcmMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (99% a /= mempty).
    lcmMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (99% a /= mempty).
    lcmMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      100% lcm a b /= mempty
      93% allNonNull [a, b]
      84% allUnique [a, b]
      83% allUniqueNonNull [a, b]
    lcmMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      100% lcm b c /= mempty
      99% lcm a b /= mempty
      94% allNonNull [a, b, c]
      68% allUnique [a, b, c]
      67% allUniqueNonNull [a, b, c]
    lcmMonoidLaw_absorption_gcd_lcm [✔]
      +++ OK, passed 100 tests:
      94% gcd a b /= mempty
      93% allNonNull [a, b]
      84% allUnique [a, b]
      83% allUniqueNonNull [a, b]
       6% gcd a b == mempty
    lcmMonoidLaw_absorption_lcm_gcd [✔]
      +++ OK, passed 100 tests:
      94% gcd a b /= mempty
      93% allNonNull [a, b]
      84% allUnique [a, b]
      83% allUniqueNonNull [a, b]
       6% gcd a b == mempty
  Testing LeftDistributiveGCDMonoid laws for type Product Natural
    leftDistributiveGCDMonoidLaw_distributivity [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b, c]
      93% commonPrefix b c /= mempty && a /= mempty
      68% allUnique [a, b, c]
      67% allUniqueNonNull [a, b, c]
  Testing LeftGCDMonoid laws for type Product Natural
    leftGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) a /= mempty
      94% commonPrefix a b /= mempty
      93% allNonNull [a, b]
      84% allUnique [a, b]
      83% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) b /= mempty
      94% commonPrefix a b /= mempty
      93% allNonNull [a, b]
      84% allUnique [a, b]
      83% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      94% antecedent == False
      94% consequent == False
      93% allNonNull [a, b]
      84% allUnique [a, b]
      83% allUniqueNonNull [a, b]
       6% antecedent == True
       6% consequent == True
    leftGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    leftGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (99% a /= mempty).
    leftGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (99% a /= mempty).
    leftGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      94% commonPrefix a b /= mempty
      93% allNonNull [a, b]
      84% allUnique [a, b]
      83% allUniqueNonNull [a, b]
       6% commonPrefix a b == mempty
    leftGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b, c]
      88% commonPrefix (commonPrefix a b) c /= mempty
      88% commonPrefix a (commonPrefix b c) /= mempty
      68% allUnique [a, b, c]
      67% allUniqueNonNull [a, b, c]
    leftGCDMonoidLaw_stripCommonPrefix_commonPrefix [✔]
      +++ OK, passed 100 tests:
      94% commonPrefix a b /= mempty
      93% allNonNull [a, b]
      84% allUnique [a, b]
      83% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_stripCommonPrefix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      84% allUnique [a, b]
      83% allUniqueNonNull [a, b]
      55% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      84% allUnique [a, b]
      83% allUniqueNonNull [a, b]
      53% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_1 [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      84% allUnique [a, b]
      83% allUniqueNonNull [a, b]
      55% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_2 [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      84% allUnique [a, b]
      83% allUniqueNonNull [a, b]
      53% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
  Testing LeftReductive laws for type Product Natural
    leftReductiveLaw_isPrefixOf_mappend [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      84% allUnique [a, b]
      83% allUniqueNonNull [a, b]
    leftReductiveLaw_isPrefixOf_stripPrefix [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      84% allUnique [a, b]
      83% allUniqueNonNull [a, b]
    leftReductiveLaw_stripPrefix [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      84% allUnique [a, b]
      83% allUniqueNonNull [a, b]
  Testing MonoidNull laws for type Product Natural
    monoidNullLaw_basic [✔]
      +++ OK, passed 800 tests:
      99.2% a /= mempty
       0.8% a == mempty
  Testing Monus laws for type Product Natural
    monusLaw_axiom_1 [✔]
      +++ OK, passed 800 tests:
      99.2% a /= mempty
       0.8% a == mempty
    monusLaw_axiom_2 [✔]
      +++ OK, passed 800 tests:
      99.2% a /= mempty
       0.8% a == mempty
    monusLaw_axiom_3 [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      84% allUnique [a, b]
      83% allUniqueNonNull [a, b]
      55% (a <\> b) /= mempty
      52% (b <\> a) /= mempty
    monusLaw_axiom_4 [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b, c]
      68% allUnique [a, b, c]
      67% allUniqueNonNull [a, b, c]
      34% (a <\> b) <\> c /= mempty
    monusLaw_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      84% allUnique [a, b]
      83% allUniqueNonNull [a, b]
      55% a <\> b /= mempty
    monusLaw_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      84% allUnique [a, b]
      83% allUniqueNonNull [a, b]
      55% a <\> b /= mempty
  Testing OverlappingGCDMonoid laws for type Product Natural
    overlappingGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (overlap a b) a /= mempty
      94% overlap a b /= mempty
      93% allNonNull [a, b]
      84% allUnique [a, b]
      83% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (overlap a b) b /= mempty
      94% overlap a b /= mempty
      93% allNonNull [a, b]
      84% allUnique [a, b]
      83% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    overlappingGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (99% a /= mempty).
    overlappingGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (99% a /= mempty).
    overlappingGCDMonoidLaw_overlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      84% allUnique [a, b]
      83% allUniqueNonNull [a, b]
      47% overlap a b /= mempty && stripPrefixOverlap a b /= mempty
    overlappingGCDMonoidLaw_overlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      84% allUnique [a, b]
      83% allUniqueNonNull [a, b]
      49% stripSuffixOverlap b a /= mempty && overlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_overlap [✔]
      +++ OK, passed 100 tests:
      94% overlap a b /= mempty
      93% allNonNull [a, b]
      84% allUnique [a, b]
      83% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_stripOverlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      84% allUnique [a, b]
      83% allUniqueNonNull [a, b]
      52% stripPrefixOverlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      84% allUnique [a, b]
      83% allUniqueNonNull [a, b]
      55% stripSuffixOverlap b a /= mempty
  Testing PositiveMonoid laws for type Product Natural
    positiveMonoidLaw_fundamental [✔]
      +++ OK, passed 3200 tests:
      99.47% not (null (a <> b))
      91.22% allNonNull [a, b]
      81.72% allUnique [a, b]
      79.56% allUniqueNonNull [a, b]
       0.53% null (a <> b)
  Testing Reductive laws for type Product Natural
    reductiveLaw_equivalence_prefix [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      84% allUnique [a, b]
      83% allUniqueNonNull [a, b]
    reductiveLaw_equivalence_suffix [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      84% allUnique [a, b]
      83% allUniqueNonNull [a, b]
    reductiveLaw_inversion_prefix [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      84% allUnique [a, b]
      83% allUniqueNonNull [a, b]
    reductiveLaw_inversion_suffix [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      84% allUnique [a, b]
      83% allUniqueNonNull [a, b]
  Testing RightDistributiveGCDMonoid laws for type Product Natural
    rightDistributiveGCDMonoidLaw_distributivity [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b, c]
      93% commonSuffix a b /= mempty && c /= mempty
      68% allUnique [a, b, c]
      67% allUniqueNonNull [a, b, c]
  Testing RightGCDMonoid laws for type Product Natural
    rightGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (commonSuffix a b) a /= mempty
      94% commonSuffix a b /= mempty
      93% allNonNull [a, b]
      84% allUnique [a, b]
      83% allUniqueNonNull [a, b]
    rightGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (commonSuffix a b) b /= mempty
      94% commonSuffix a b /= mempty
      93% allNonNull [a, b]
      84% allUnique [a, b]
      83% allUniqueNonNull [a, b]
    rightGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      94% antecedent == False
      94% consequent == False
      93% allNonNull [a, b]
      84% allUnique [a, b]
      83% allUniqueNonNull [a, b]
       6% antecedent == True
       6% consequent == True
    rightGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    rightGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (99% a /= mempty).
    rightGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (99% a /= mempty).
    rightGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      94% commonSuffix a b /= mempty
      93% allNonNull [a, b]
      84% allUnique [a, b]
      83% allUniqueNonNull [a, b]
       6% commonSuffix a b == mempty
    rightGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b, c]
      88% commonSuffix (commonSuffix a b) c /= mempty
      88% commonSuffix a (commonSuffix b c) /= mempty
      68% allUnique [a, b, c]
      67% allUniqueNonNull [a, b, c]
    rightGCDMonoidLaw_stripCommonSuffix_commonSuffix [✔]
      +++ OK, passed 100 tests:
      94% commonSuffix a b /= mempty
      93% allNonNull [a, b]
      84% allUnique [a, b]
      83% allUniqueNonNull [a, b]
    rightGCDMonoidLaw_stripCommonSuffix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      84% allUnique [a, b]
      83% allUniqueNonNull [a, b]
      55% stripCommonSuffix a b & \(x, _, s) -> x /= mempty && s /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      84% allUnique [a, b]
      83% allUniqueNonNull [a, b]
      53% stripCommonSuffix a b & \(_, x, s) -> x /= mempty && s /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_stripSuffix_1 [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      84% allUnique [a, b]
      83% allUniqueNonNull [a, b]
      55% stripCommonSuffix a b & \(x, _, s) -> x /= mempty && s /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_stripSuffix_2 [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      84% allUnique [a, b]
      83% allUniqueNonNull [a, b]
      53% stripCommonSuffix a b & \(_, x, s) -> x /= mempty && s /= mempty
  Testing RightReductive laws for type Product Natural
    rightReductiveLaw_isSuffixOf_mappend [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      84% allUnique [a, b]
      83% allUniqueNonNull [a, b]
    rightReductiveLaw_isSuffixOf_stripSuffix [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      84% allUnique [a, b]
      83% allUniqueNonNull [a, b]
    rightReductiveLaw_stripSuffix [✔]
      +++ OK, passed 100 tests:
      93% allNonNull [a, b]
      84% allUnique [a, b]
      83% allUniqueNonNull [a, b]
  Testing Cancellative laws for type Sum (Small Int)
    cancellativeLaw_cancellation_prefix [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b]
      84% allUnique [a, b]
      82% allUniqueNonNull [a, b]
    cancellativeLaw_cancellation_suffix [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b]
      84% allUnique [a, b]
      82% allUniqueNonNull [a, b]
  Testing Commutative laws for type Sum (Small Int)
    commutativeLaw_basic [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b]
      84% allUnique [a, b]
      82% (a /= b) && (a <> b /= a) && (b <> a /= b)
      82% allUniqueNonNull [a, b]
  Testing Factorial laws for type Sum (Small Int)
    factorialLaw_coverage [✔]
      +++ OK, passed 100 tests:
      87% length a >= 2
       7% length a == 1
       6% length a == 0
    factorialLaw_length_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors_reverse [✔]
      +++ OK, passed 100 tests.
    factorialLaw_all_factors_prime [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primePrefix_foldr [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primeSuffix_foldl [✔]
      +++ OK, passed 100 tests.
    factorialLaw_factors_foldl [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b]
      84% allUnique [a, b]
      82% allUniqueNonNull [a, b]
    factorialLaw_factors_foldl' [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b]
      84% allUnique [a, b]
      82% allUniqueNonNull [a, b]
    factorialLaw_factors_foldr [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b]
      84% allUnique [a, b]
      82% allUniqueNonNull [a, b]
  Testing FactorialMonoid laws for type Sum (Small Int)
    factorialMonoidLaw_coverage [✔]
      +++ OK, passed 100 tests:
      87% length a >= 2
       7% length a == 1
       6% length a == 0
    factorialMonoidLaw_null [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_reverse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_inits [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_tails [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_span [✔]
      +++ OK, passed 100 tests:
      58% any (not . p) (factors a)
      36% any p (factors a)
    factorialMonoidLaw_split [✔]
      +++ OK, passed 100 tests:
      58% any (not . p) (factors a)
      36% any p (factors a)
    factorialMonoidLaw_split_intersperse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitAt [✔]
      +++ OK, passed 100 tests.
  Testing LeftCancellative laws for type Sum (Small Int)
    leftCancellativeLaw_cancellation [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b]
      84% allUnique [a, b]
      82% allUniqueNonNull [a, b]
  Testing LeftReductive laws for type Sum (Small Int)
    leftReductiveLaw_isPrefixOf_mappend [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b]
      84% allUnique [a, b]
      82% allUniqueNonNull [a, b]
    leftReductiveLaw_isPrefixOf_stripPrefix [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b]
      84% allUnique [a, b]
      82% allUniqueNonNull [a, b]
    leftReductiveLaw_stripPrefix [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b]
      84% allUnique [a, b]
      82% allUniqueNonNull [a, b]
  Testing MonoidNull laws for type Sum (Small Int)
    monoidNullLaw_basic [✔]
      +++ OK, passed 100 tests:
      94% a /= mempty
       6% a == mempty
  Testing Reductive laws for type Sum (Small Int)
    reductiveLaw_equivalence_prefix [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b]
      84% allUnique [a, b]
      82% allUniqueNonNull [a, b]
    reductiveLaw_equivalence_suffix [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b]
      84% allUnique [a, b]
      82% allUniqueNonNull [a, b]
    reductiveLaw_inversion_prefix [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b]
      84% allUnique [a, b]
      82% allUniqueNonNull [a, b]
    reductiveLaw_inversion_suffix [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b]
      84% allUnique [a, b]
      82% allUniqueNonNull [a, b]
  Testing RightCancellative laws for type Sum (Small Int)
    rightCancellativeLaw_cancellation [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b]
      84% allUnique [a, b]
      82% allUniqueNonNull [a, b]
  Testing RightReductive laws for type Sum (Small Int)
    rightReductiveLaw_isSuffixOf_mappend [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b]
      84% allUnique [a, b]
      82% allUniqueNonNull [a, b]
    rightReductiveLaw_isSuffixOf_stripSuffix [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b]
      84% allUnique [a, b]
      82% allUniqueNonNull [a, b]
    rightReductiveLaw_stripSuffix [✔]
      +++ OK, passed 100 tests:
      94% allNonNull [a, b]
      84% allUnique [a, b]
      82% allUniqueNonNull [a, b]
  Testing Cancellative laws for type Sum Natural
    cancellativeLaw_cancellation_prefix [✔]
      +++ OK, passed 100 tests:
      96% allNonNull [a, b]
      86% allUnique [a, b]
      84% allUniqueNonNull [a, b]
    cancellativeLaw_cancellation_suffix [✔]
      +++ OK, passed 100 tests:
      96% allNonNull [a, b]
      86% allUnique [a, b]
      84% allUniqueNonNull [a, b]
  Testing Commutative laws for type Sum Natural
    commutativeLaw_basic [✔]
      +++ OK, passed 100 tests:
      96% allNonNull [a, b]
      86% allUnique [a, b]
      84% (a /= b) && (a <> b /= a) && (b <> a /= b)
      84% allUniqueNonNull [a, b]
  Testing DistributiveGCDMonoid laws for type Sum Natural
    distributiveGCDMonoidLaw_distributivity_left [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      75% allUnique [a, b, c]
      73% allUniqueNonNull [a, b, c]
    distributiveGCDMonoidLaw_distributivity_right [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      75% allUnique [a, b, c]
      73% allUniqueNonNull [a, b, c]
  Testing DistributiveLCMMonoid laws for type Sum Natural
    distributiveLCMMonoidLaw_distributivity_left [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      75% allUnique [a, b, c]
      73% allUniqueNonNull [a, b, c]
    distributiveLCMMonoidLaw_distributivity_right [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      75% allUnique [a, b, c]
      73% allUniqueNonNull [a, b, c]
    distributiveLCMMonoidLaw_distributivity_gcd_lcm [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      75% allUnique [a, b, c]
      73% allUniqueNonNull [a, b, c]
    distributiveLCMMonoidLaw_distributivity_lcm_gcd [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      75% allUnique [a, b, c]
      73% allUniqueNonNull [a, b, c]
  Testing Factorial laws for type Sum Natural
    factorialLaw_coverage [✔]
      +++ OK, passed 200 tests:
      96.5% length a >= 2
       2.0% length a == 1
       1.5% length a == 0
    factorialLaw_length_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors_reverse [✔]
      +++ OK, passed 100 tests.
    factorialLaw_all_factors_prime [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primePrefix_foldr [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primeSuffix_foldl [✔]
      +++ OK, passed 100 tests.
    factorialLaw_factors_foldl [✔]
      +++ OK, passed 100 tests:
      96% allNonNull [a, b]
      86% allUnique [a, b]
      84% allUniqueNonNull [a, b]
    factorialLaw_factors_foldl' [✔]
      +++ OK, passed 100 tests:
      96% allNonNull [a, b]
      86% allUnique [a, b]
      84% allUniqueNonNull [a, b]
    factorialLaw_factors_foldr [✔]
      +++ OK, passed 100 tests:
      96% allNonNull [a, b]
      86% allUnique [a, b]
      84% allUniqueNonNull [a, b]
  Testing FactorialMonoid laws for type Sum Natural
    factorialMonoidLaw_coverage [✔]
      +++ OK, passed 200 tests:
      96.5% length a >= 2
       2.0% length a == 1
       1.5% length a == 0
    factorialMonoidLaw_null [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_reverse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_inits [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_tails [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_span [✔]
      +++ OK, passed 100 tests:
      51% any (not . p) (factors a)
      48% any p (factors a)
    factorialMonoidLaw_split [✔]
      +++ OK, passed 100 tests:
      51% any (not . p) (factors a)
      48% any p (factors a)
    factorialMonoidLaw_split_intersperse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitAt [✔]
      +++ OK, passed 100 tests.
  Testing GCDMonoid laws for type Sum Natural
    gcdMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% (a </> gcd a b) /= mempty
      96% allNonNull [a, b]
      96% gcd a b /= mempty
      86% allUnique [a, b]
      84% allUniqueNonNull [a, b]
    gcdMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% (b </> gcd a b) /= mempty
      96% allNonNull [a, b]
      96% gcd a b /= mempty
      86% allUnique [a, b]
      84% allUniqueNonNull [a, b]
    gcdMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      90% c /= gcd a b
      90% not (all isJust [a </> c, b </> c, c </> gcd a b])
      75% allUnique [a, b, c]
      73% allUniqueNonNull [a, b, c]
      10% all isJust [a </> c, b </> c, c </> gcd a b]
      10% c == gcd a b
    gcdMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    gcdMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (99% a /= mempty).
    gcdMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (99% a /= mempty).
    gcdMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      96% allNonNull [a, b]
      96% gcd a b /= mempty
      86% allUnique [a, b]
      84% allUniqueNonNull [a, b]
       4% gcd a b == mempty
    gcdMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      96% gcd a b /= mempty
      95% allNonNull [a, b, c]
      95% gcd b c /= mempty
      75% allUnique [a, b, c]
      73% allUniqueNonNull [a, b, c]
    gcdMonoidLaw_equivalence_commonPrefix [✔]
      +++ OK, passed 100 tests:
      96% allNonNull [a, b]
      96% commonPrefix a b /= mempty
      96% gcd a b /= mempty
      86% allUnique [a, b]
      84% allUniqueNonNull [a, b]
    gcdMonoidLaw_equivalence_commonSuffix [✔]
      +++ OK, passed 100 tests:
      96% allNonNull [a, b]
      96% commonSuffix a b /= mempty
      96% gcd a b /= mempty
      86% allUnique [a, b]
      84% allUniqueNonNull [a, b]
  Testing LCMMonoid laws for type Sum Natural
    lcmMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      98% lcm a b /= mempty
      96% allNonNull [a, b]
      86% allUnique [a, b]
      84% allUniqueNonNull [a, b]
      37% (lcm a b </> a) /= Just mempty
    lcmMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      98% lcm a b /= mempty
      96% allNonNull [a, b]
      86% allUnique [a, b]
      84% allUniqueNonNull [a, b]
      49% (lcm a b </> b) /= Just mempty
    lcmMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      87% c /= lcm a b
      87% not (all isJust [c </> a, c </> b, lcm a b </> c])
      75% allUnique [a, b, c]
      73% allUniqueNonNull [a, b, c]
      13% all isJust [c </> a, c </> b, lcm a b </> c]
      13% c == lcm a b
    lcmMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    lcmMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (99% a /= mempty).
    lcmMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (99% a /= mempty).
    lcmMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      98% lcm a b /= mempty
      96% allNonNull [a, b]
      86% allUnique [a, b]
      84% allUniqueNonNull [a, b]
    lcmMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      97% lcm a b /= mempty
      97% lcm b c /= mempty
      95% allNonNull [a, b, c]
      75% allUnique [a, b, c]
      73% allUniqueNonNull [a, b, c]
    lcmMonoidLaw_absorption_gcd_lcm [✔]
      +++ OK, passed 100 tests:
      96% allNonNull [a, b]
      96% gcd a b /= mempty
      86% allUnique [a, b]
      84% allUniqueNonNull [a, b]
       4% gcd a b == mempty
    lcmMonoidLaw_absorption_lcm_gcd [✔]
      +++ OK, passed 100 tests:
      96% allNonNull [a, b]
      96% gcd a b /= mempty
      86% allUnique [a, b]
      84% allUniqueNonNull [a, b]
       4% gcd a b == mempty
  Testing LeftCancellative laws for type Sum Natural
    leftCancellativeLaw_cancellation [✔]
      +++ OK, passed 100 tests:
      96% allNonNull [a, b]
      86% allUnique [a, b]
      84% allUniqueNonNull [a, b]
  Testing LeftDistributiveGCDMonoid laws for type Sum Natural
    leftDistributiveGCDMonoidLaw_distributivity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      95% commonPrefix b c /= mempty && a /= mempty
      75% allUnique [a, b, c]
      73% allUniqueNonNull [a, b, c]
  Testing LeftGCDMonoid laws for type Sum Natural
    leftGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) a /= mempty
      96% allNonNull [a, b]
      96% commonPrefix a b /= mempty
      86% allUnique [a, b]
      84% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) b /= mempty
      96% allNonNull [a, b]
      96% commonPrefix a b /= mempty
      86% allUnique [a, b]
      84% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      96% allNonNull [a, b]
      94% antecedent == False
      94% consequent == False
      86% allUnique [a, b]
      84% allUniqueNonNull [a, b]
       6% antecedent == True
       6% consequent == True
    leftGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    leftGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (99% a /= mempty).
    leftGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (99% a /= mempty).
    leftGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      96% allNonNull [a, b]
      96% commonPrefix a b /= mempty
      86% allUnique [a, b]
      84% allUniqueNonNull [a, b]
       4% commonPrefix a b == mempty
    leftGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      95% commonPrefix (commonPrefix a b) c /= mempty
      95% commonPrefix a (commonPrefix b c) /= mempty
      75% allUnique [a, b, c]
      73% allUniqueNonNull [a, b, c]
    leftGCDMonoidLaw_stripCommonPrefix_commonPrefix [✔]
      +++ OK, passed 100 tests:
      96% allNonNull [a, b]
      96% commonPrefix a b /= mempty
      86% allUnique [a, b]
      84% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_stripCommonPrefix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      96% allNonNull [a, b]
      86% allUnique [a, b]
      84% allUniqueNonNull [a, b]
      47% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      96% allNonNull [a, b]
      86% allUnique [a, b]
      84% allUniqueNonNull [a, b]
      37% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_1 [✔]
      +++ OK, passed 100 tests:
      96% allNonNull [a, b]
      86% allUnique [a, b]
      84% allUniqueNonNull [a, b]
      47% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_2 [✔]
      +++ OK, passed 100 tests:
      96% allNonNull [a, b]
      86% allUnique [a, b]
      84% allUniqueNonNull [a, b]
      37% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
  Testing LeftReductive laws for type Sum Natural
    leftReductiveLaw_isPrefixOf_mappend [✔]
      +++ OK, passed 100 tests:
      96% allNonNull [a, b]
      86% allUnique [a, b]
      84% allUniqueNonNull [a, b]
    leftReductiveLaw_isPrefixOf_stripPrefix [✔]
      +++ OK, passed 100 tests:
      96% allNonNull [a, b]
      86% allUnique [a, b]
      84% allUniqueNonNull [a, b]
    leftReductiveLaw_stripPrefix [✔]
      +++ OK, passed 100 tests:
      96% allNonNull [a, b]
      86% allUnique [a, b]
      84% allUniqueNonNull [a, b]
  Testing MonoidNull laws for type Sum Natural
    monoidNullLaw_basic [✔]
      +++ OK, passed 200 tests:
      98.5% a /= mempty
       1.5% a == mempty
  Testing Monus laws for type Sum Natural
    monusLaw_axiom_1 [✔]
      +++ OK, passed 200 tests:
      98.5% a /= mempty
       1.5% a == mempty
    monusLaw_axiom_2 [✔]
      +++ OK, passed 200 tests:
      98.5% a /= mempty
       1.5% a == mempty
    monusLaw_axiom_3 [✔]
      +++ OK, passed 100 tests:
      96% allNonNull [a, b]
      86% allUnique [a, b]
      84% allUniqueNonNull [a, b]
      49% (a <\> b) /= mempty
      37% (b <\> a) /= mempty
    monusLaw_axiom_4 [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      75% allUnique [a, b, c]
      73% allUniqueNonNull [a, b, c]
      13% (a <\> b) <\> c /= mempty
    monusLaw_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      96% allNonNull [a, b]
      86% allUnique [a, b]
      84% allUniqueNonNull [a, b]
      49% a <\> b /= mempty
    monusLaw_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      96% allNonNull [a, b]
      86% allUnique [a, b]
      84% allUniqueNonNull [a, b]
      49% a <\> b /= mempty
  Testing OverlappingGCDMonoid laws for type Sum Natural
    overlappingGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (overlap a b) a /= mempty
      96% allNonNull [a, b]
      96% overlap a b /= mempty
      86% allUnique [a, b]
      84% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (overlap a b) b /= mempty
      96% allNonNull [a, b]
      96% overlap a b /= mempty
      86% allUnique [a, b]
      84% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    overlappingGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (99% a /= mempty).
    overlappingGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (99% a /= mempty).
    overlappingGCDMonoidLaw_overlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      96% allNonNull [a, b]
      86% allUnique [a, b]
      84% allUniqueNonNull [a, b]
      37% overlap a b /= mempty && stripPrefixOverlap a b /= mempty
    overlappingGCDMonoidLaw_overlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      96% allNonNull [a, b]
      86% allUnique [a, b]
      84% allUniqueNonNull [a, b]
      47% stripSuffixOverlap b a /= mempty && overlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_overlap [✔]
      +++ OK, passed 100 tests:
      96% allNonNull [a, b]
      96% overlap a b /= mempty
      86% allUnique [a, b]
      84% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_stripOverlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      96% allNonNull [a, b]
      86% allUnique [a, b]
      84% allUniqueNonNull [a, b]
      37% stripPrefixOverlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      96% allNonNull [a, b]
      86% allUnique [a, b]
      84% allUniqueNonNull [a, b]
      49% stripSuffixOverlap b a /= mempty
  Testing PositiveMonoid laws for type Sum Natural
    positiveMonoidLaw_fundamental [✔]
      +++ OK, passed 100 tests:
      98% not (null (a <> b))
      96% allNonNull [a, b]
      86% allUnique [a, b]
      84% allUniqueNonNull [a, b]
       2% null (a <> b)
  Testing Reductive laws for type Sum Natural
    reductiveLaw_equivalence_prefix [✔]
      +++ OK, passed 100 tests:
      96% allNonNull [a, b]
      86% allUnique [a, b]
      84% allUniqueNonNull [a, b]
    reductiveLaw_equivalence_suffix [✔]
      +++ OK, passed 100 tests:
      96% allNonNull [a, b]
      86% allUnique [a, b]
      84% allUniqueNonNull [a, b]
    reductiveLaw_inversion_prefix [✔]
      +++ OK, passed 100 tests:
      96% allNonNull [a, b]
      86% allUnique [a, b]
      84% allUniqueNonNull [a, b]
    reductiveLaw_inversion_suffix [✔]
      +++ OK, passed 100 tests:
      96% allNonNull [a, b]
      86% allUnique [a, b]
      84% allUniqueNonNull [a, b]
  Testing RightCancellative laws for type Sum Natural
    rightCancellativeLaw_cancellation [✔]
      +++ OK, passed 100 tests:
      96% allNonNull [a, b]
      86% allUnique [a, b]
      84% allUniqueNonNull [a, b]
  Testing RightDistributiveGCDMonoid laws for type Sum Natural
    rightDistributiveGCDMonoidLaw_distributivity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      95% commonSuffix a b /= mempty && c /= mempty
      75% allUnique [a, b, c]
      73% allUniqueNonNull [a, b, c]
  Testing RightGCDMonoid laws for type Sum Natural
    rightGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (commonSuffix a b) a /= mempty
      96% allNonNull [a, b]
      96% commonSuffix a b /= mempty
      86% allUnique [a, b]
      84% allUniqueNonNull [a, b]
    rightGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (commonSuffix a b) b /= mempty
      96% allNonNull [a, b]
      96% commonSuffix a b /= mempty
      86% allUnique [a, b]
      84% allUniqueNonNull [a, b]
    rightGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      96% allNonNull [a, b]
      94% antecedent == False
      94% consequent == False
      86% allUnique [a, b]
      84% allUniqueNonNull [a, b]
       6% antecedent == True
       6% consequent == True
    rightGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    rightGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (99% a /= mempty).
    rightGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (99% a /= mempty).
    rightGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      96% allNonNull [a, b]
      96% commonSuffix a b /= mempty
      86% allUnique [a, b]
      84% allUniqueNonNull [a, b]
       4% commonSuffix a b == mempty
    rightGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      95% allNonNull [a, b, c]
      95% commonSuffix (commonSuffix a b) c /= mempty
      95% commonSuffix a (commonSuffix b c) /= mempty
      75% allUnique [a, b, c]
      73% allUniqueNonNull [a, b, c]
    rightGCDMonoidLaw_stripCommonSuffix_commonSuffix [✔]
      +++ OK, passed 100 tests:
      96% allNonNull [a, b]
      96% commonSuffix a b /= mempty
      86% allUnique [a, b]
      84% allUniqueNonNull [a, b]
    rightGCDMonoidLaw_stripCommonSuffix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      96% allNonNull [a, b]
      86% allUnique [a, b]
      84% allUniqueNonNull [a, b]
      47% stripCommonSuffix a b & \(x, _, s) -> x /= mempty && s /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      96% allNonNull [a, b]
      86% allUnique [a, b]
      84% allUniqueNonNull [a, b]
      37% stripCommonSuffix a b & \(_, x, s) -> x /= mempty && s /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_stripSuffix_1 [✔]
      +++ OK, passed 100 tests:
      96% allNonNull [a, b]
      86% allUnique [a, b]
      84% allUniqueNonNull [a, b]
      47% stripCommonSuffix a b & \(x, _, s) -> x /= mempty && s /= mempty
    rightGCDMonoidLaw_stripCommonSuffix_stripSuffix_2 [✔]
      +++ OK, passed 100 tests:
      96% allNonNull [a, b]
      86% allUnique [a, b]
      84% allUniqueNonNull [a, b]
      37% stripCommonSuffix a b & \(_, x, s) -> x /= mempty && s /= mempty
  Testing RightReductive laws for type Sum Natural
    rightReductiveLaw_isSuffixOf_mappend [✔]
      +++ OK, passed 100 tests:
      96% allNonNull [a, b]
      86% allUnique [a, b]
      84% allUniqueNonNull [a, b]
    rightReductiveLaw_isSuffixOf_stripSuffix [✔]
      +++ OK, passed 100 tests:
      96% allNonNull [a, b]
      86% allUnique [a, b]
      84% allUniqueNonNull [a, b]
    rightReductiveLaw_stripSuffix [✔]
      +++ OK, passed 100 tests:
      96% allNonNull [a, b]
      86% allUnique [a, b]
      84% allUniqueNonNull [a, b]
  Testing StableFactorial laws for type Sum Natural
    stableFactorialLaw_factors_mappend [✔]
      +++ OK, passed 100 tests:
      96% allNonNull [a, b]
      86% allUnique [a, b]
      84% allUniqueNonNull [a, b]
    stableFactorialLaw_factors_reverse [✔]
      +++ OK, passed 100 tests.
    stableFactorialLaw_primePrefix_primeSuffix_reverse [✔]
      +++ OK, passed 100 tests.
    stableFactorialLaw_primeSuffix_primePrefix_reverse [✔]
      +++ OK, passed 100 tests.
  Testing Factorial laws for type IntMap (Small Int)
    factorialLaw_coverage [✔]
      +++ OK, passed 100 tests:
      93% length a >= 2
       4% length a == 1
       3% length a == 0
    factorialLaw_length_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors_reverse [✔]
      +++ OK, passed 100 tests.
    factorialLaw_all_factors_prime [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primePrefix_foldr [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primeSuffix_foldl [✔]
      +++ OK, passed 100 tests.
    factorialLaw_factors_foldl [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
    factorialLaw_factors_foldl' [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
    factorialLaw_factors_foldr [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
  Testing FactorialMonoid laws for type IntMap (Small Int)
    factorialMonoidLaw_coverage [✔]
      +++ OK, passed 100 tests:
      93% length a >= 2
       4% length a == 1
       3% length a == 0
    factorialMonoidLaw_null [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_reverse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_inits [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_tails [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_span [✔]
      +++ OK, passed 100 tests:
      95% any p (factors a)
      93% any (not . p) (factors a)
    factorialMonoidLaw_split [✔]
      +++ OK, passed 100 tests:
      95% any p (factors a)
      93% any (not . p) (factors a)
    factorialMonoidLaw_split_intersperse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitAt [✔]
      +++ OK, passed 100 tests.
  Testing LeftGCDMonoid laws for type IntMap (Small Int)
    leftGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) a /= mempty
      90% allUnique [a, b]
      88% commonPrefix a b /= mempty
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) b /= mempty
      90% allUnique [a, b]
      88% commonPrefix a b /= mempty
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      98% antecedent == False
      98% consequent == False
      90% allUnique [a, b]
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
       2% antecedent == True
       2% consequent == True
    leftGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    leftGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    leftGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    leftGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      88% commonPrefix a b /= mempty
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
      12% commonPrefix a b == mempty
    leftGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      79% allUnique [a, b, c]
      76% allNonNull [a, b, c]
      75% commonPrefix (commonPrefix a b) c /= mempty
      75% commonPrefix a (commonPrefix b c) /= mempty
      66% allUniqueNonNull [a, b, c]
    leftGCDMonoidLaw_stripCommonPrefix_commonPrefix [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      88% commonPrefix a b /= mempty
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_stripCommonPrefix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      70% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_stripCommonPrefix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      64% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_1 [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      70% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_2 [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      64% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
  Testing LeftReductive laws for type IntMap (Small Int)
    leftReductiveLaw_isPrefixOf_mappend [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
    leftReductiveLaw_isPrefixOf_stripPrefix [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
    leftReductiveLaw_stripPrefix [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
  Testing MonoidNull laws for type IntMap (Small Int)
    monoidNullLaw_basic [✔]
      +++ OK, passed 100 tests:
      97% a /= mempty
       3% a == mempty
  Testing OverlappingGCDMonoid laws for type IntMap (Small Int)
    overlappingGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (overlap a b) a /= mempty
      92% overlap a b /= mempty
      90% allUnique [a, b]
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (overlap a b) b /= mempty
      92% overlap a b /= mempty
      90% allUnique [a, b]
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    overlappingGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    overlappingGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    overlappingGCDMonoidLaw_overlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
      50% overlap a b /= mempty && stripPrefixOverlap a b /= mempty
    overlappingGCDMonoidLaw_overlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      74% stripSuffixOverlap b a /= mempty && overlap a b /= mempty
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_stripOverlap_overlap [✔]
      +++ OK, passed 100 tests:
      92% overlap a b /= mempty
      90% allUnique [a, b]
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_stripOverlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
      55% stripPrefixOverlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      80% stripSuffixOverlap b a /= mempty
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
  Testing PositiveMonoid laws for type IntMap (Small Int)
    positiveMonoidLaw_fundamental [✔]
      +++ OK, passed 100 tests:
      98% not (null (a <> b))
      90% allUnique [a, b]
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
       2% null (a <> b)
  Testing RightReductive laws for type IntMap (Small Int)
    rightReductiveLaw_isSuffixOf_mappend [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
    rightReductiveLaw_isSuffixOf_stripSuffix [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
    rightReductiveLaw_stripSuffix [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
  Testing Factorial laws for type IntMap Natural
    factorialLaw_coverage [✔]
      +++ OK, passed 100 tests:
      93% length a >= 2
       4% length a == 1
       3% length a == 0
    factorialLaw_length_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors_reverse [✔]
      +++ OK, passed 100 tests.
    factorialLaw_all_factors_prime [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primePrefix_foldr [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primeSuffix_foldl [✔]
      +++ OK, passed 100 tests.
    factorialLaw_factors_foldl [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
    factorialLaw_factors_foldl' [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
    factorialLaw_factors_foldr [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
  Testing FactorialMonoid laws for type IntMap Natural
    factorialMonoidLaw_coverage [✔]
      +++ OK, passed 100 tests:
      93% length a >= 2
       4% length a == 1
       3% length a == 0
    factorialMonoidLaw_null [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_reverse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_inits [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_tails [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_span [✔]
      +++ OK, passed 100 tests:
      95% any (not . p) (factors a)
      92% any p (factors a)
    factorialMonoidLaw_split [✔]
      +++ OK, passed 100 tests:
      95% any (not . p) (factors a)
      92% any p (factors a)
    factorialMonoidLaw_split_intersperse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitAt [✔]
      +++ OK, passed 100 tests.
  Testing LeftGCDMonoid laws for type IntMap Natural
    leftGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) a /= mempty
      90% allUnique [a, b]
      88% commonPrefix a b /= mempty
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) b /= mempty
      90% allUnique [a, b]
      88% commonPrefix a b /= mempty
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      98% antecedent == False
      98% consequent == False
      90% allUnique [a, b]
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
       2% antecedent == True
       2% consequent == True
    leftGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    leftGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    leftGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    leftGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      88% commonPrefix a b /= mempty
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
      12% commonPrefix a b == mempty
    leftGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      79% allUnique [a, b, c]
      76% allNonNull [a, b, c]
      75% commonPrefix (commonPrefix a b) c /= mempty
      75% commonPrefix a (commonPrefix b c) /= mempty
      66% allUniqueNonNull [a, b, c]
    leftGCDMonoidLaw_stripCommonPrefix_commonPrefix [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      88% commonPrefix a b /= mempty
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_stripCommonPrefix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      70% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_stripCommonPrefix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      64% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_1 [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      70% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_2 [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      64% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
  Testing LeftReductive laws for type IntMap Natural
    leftReductiveLaw_isPrefixOf_mappend [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
    leftReductiveLaw_isPrefixOf_stripPrefix [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
    leftReductiveLaw_stripPrefix [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
  Testing MonoidNull laws for type IntMap Natural
    monoidNullLaw_basic [✔]
      +++ OK, passed 100 tests:
      97% a /= mempty
       3% a == mempty
  Testing OverlappingGCDMonoid laws for type IntMap Natural
    overlappingGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (overlap a b) a /= mempty
      92% overlap a b /= mempty
      90% allUnique [a, b]
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (overlap a b) b /= mempty
      92% overlap a b /= mempty
      90% allUnique [a, b]
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    overlappingGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    overlappingGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    overlappingGCDMonoidLaw_overlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
      50% overlap a b /= mempty && stripPrefixOverlap a b /= mempty
    overlappingGCDMonoidLaw_overlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      74% stripSuffixOverlap b a /= mempty && overlap a b /= mempty
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_stripOverlap_overlap [✔]
      +++ OK, passed 100 tests:
      92% overlap a b /= mempty
      90% allUnique [a, b]
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_stripOverlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
      55% stripPrefixOverlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      80% stripSuffixOverlap b a /= mempty
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
  Testing PositiveMonoid laws for type IntMap Natural
    positiveMonoidLaw_fundamental [✔]
      +++ OK, passed 100 tests:
      98% not (null (a <> b))
      90% allUnique [a, b]
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
       2% null (a <> b)
  Testing RightReductive laws for type IntMap Natural
    rightReductiveLaw_isSuffixOf_mappend [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
    rightReductiveLaw_isSuffixOf_stripSuffix [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
    rightReductiveLaw_stripSuffix [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
  Testing Factorial laws for type Map Int (Small Int)
    factorialLaw_coverage [✔]
      +++ OK, passed 100 tests:
      93% length a >= 2
       4% length a == 1
       3% length a == 0
    factorialLaw_length_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors_reverse [✔]
      +++ OK, passed 100 tests.
    factorialLaw_all_factors_prime [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primePrefix_foldr [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primeSuffix_foldl [✔]
      +++ OK, passed 100 tests.
    factorialLaw_factors_foldl [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
    factorialLaw_factors_foldl' [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
    factorialLaw_factors_foldr [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
  Testing FactorialMonoid laws for type Map Int (Small Int)
    factorialMonoidLaw_coverage [✔]
      +++ OK, passed 100 tests:
      93% length a >= 2
       4% length a == 1
       3% length a == 0
    factorialMonoidLaw_null [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_reverse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_inits [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_tails [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_span [✔]
      +++ OK, passed 100 tests:
      95% any p (factors a)
      93% any (not . p) (factors a)
    factorialMonoidLaw_split [✔]
      +++ OK, passed 100 tests:
      95% any p (factors a)
      93% any (not . p) (factors a)
    factorialMonoidLaw_split_intersperse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitAt [✔]
      +++ OK, passed 100 tests.
  Testing LeftGCDMonoid laws for type Map Int (Small Int)
    leftGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) a /= mempty
      90% allUnique [a, b]
      88% commonPrefix a b /= mempty
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) b /= mempty
      90% allUnique [a, b]
      88% commonPrefix a b /= mempty
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      98% antecedent == False
      98% consequent == False
      90% allUnique [a, b]
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
       2% antecedent == True
       2% consequent == True
    leftGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    leftGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    leftGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    leftGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      88% commonPrefix a b /= mempty
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
      12% commonPrefix a b == mempty
    leftGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      79% allUnique [a, b, c]
      76% allNonNull [a, b, c]
      75% commonPrefix (commonPrefix a b) c /= mempty
      75% commonPrefix a (commonPrefix b c) /= mempty
      66% allUniqueNonNull [a, b, c]
    leftGCDMonoidLaw_stripCommonPrefix_commonPrefix [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      88% commonPrefix a b /= mempty
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_stripCommonPrefix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      70% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_stripCommonPrefix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      64% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_1 [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      70% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_2 [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      64% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
  Testing LeftReductive laws for type Map Int (Small Int)
    leftReductiveLaw_isPrefixOf_mappend [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
    leftReductiveLaw_isPrefixOf_stripPrefix [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
    leftReductiveLaw_stripPrefix [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
  Testing MonoidNull laws for type Map Int (Small Int)
    monoidNullLaw_basic [✔]
      +++ OK, passed 100 tests:
      97% a /= mempty
       3% a == mempty
  Testing OverlappingGCDMonoid laws for type Map Int (Small Int)
    overlappingGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (overlap a b) a /= mempty
      92% overlap a b /= mempty
      90% allUnique [a, b]
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (overlap a b) b /= mempty
      92% overlap a b /= mempty
      90% allUnique [a, b]
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    overlappingGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    overlappingGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    overlappingGCDMonoidLaw_overlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
      50% overlap a b /= mempty && stripPrefixOverlap a b /= mempty
    overlappingGCDMonoidLaw_overlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      74% stripSuffixOverlap b a /= mempty && overlap a b /= mempty
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_stripOverlap_overlap [✔]
      +++ OK, passed 100 tests:
      92% overlap a b /= mempty
      90% allUnique [a, b]
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_stripOverlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
      55% stripPrefixOverlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      80% stripSuffixOverlap b a /= mempty
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
  Testing PositiveMonoid laws for type Map Int (Small Int)
    positiveMonoidLaw_fundamental [✔]
      +++ OK, passed 100 tests:
      98% not (null (a <> b))
      90% allUnique [a, b]
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
       2% null (a <> b)
  Testing RightReductive laws for type Map Int (Small Int)
    rightReductiveLaw_isSuffixOf_mappend [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
    rightReductiveLaw_isSuffixOf_stripSuffix [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
    rightReductiveLaw_stripSuffix [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
  Testing Factorial laws for type Map Int Natural
    factorialLaw_coverage [✔]
      +++ OK, passed 100 tests:
      93% length a >= 2
       4% length a == 1
       3% length a == 0
    factorialLaw_length_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors_reverse [✔]
      +++ OK, passed 100 tests.
    factorialLaw_all_factors_prime [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primePrefix_foldr [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primeSuffix_foldl [✔]
      +++ OK, passed 100 tests.
    factorialLaw_factors_foldl [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
    factorialLaw_factors_foldl' [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
    factorialLaw_factors_foldr [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
  Testing FactorialMonoid laws for type Map Int Natural
    factorialMonoidLaw_coverage [✔]
      +++ OK, passed 100 tests:
      93% length a >= 2
       4% length a == 1
       3% length a == 0
    factorialMonoidLaw_null [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_reverse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_inits [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_tails [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_span [✔]
      +++ OK, passed 100 tests:
      95% any (not . p) (factors a)
      92% any p (factors a)
    factorialMonoidLaw_split [✔]
      +++ OK, passed 100 tests:
      95% any (not . p) (factors a)
      92% any p (factors a)
    factorialMonoidLaw_split_intersperse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitAt [✔]
      +++ OK, passed 100 tests.
  Testing LeftGCDMonoid laws for type Map Int Natural
    leftGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) a /= mempty
      90% allUnique [a, b]
      88% commonPrefix a b /= mempty
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) b /= mempty
      90% allUnique [a, b]
      88% commonPrefix a b /= mempty
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      98% antecedent == False
      98% consequent == False
      90% allUnique [a, b]
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
       2% antecedent == True
       2% consequent == True
    leftGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    leftGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    leftGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    leftGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      88% commonPrefix a b /= mempty
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
      12% commonPrefix a b == mempty
    leftGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      79% allUnique [a, b, c]
      76% allNonNull [a, b, c]
      75% commonPrefix (commonPrefix a b) c /= mempty
      75% commonPrefix a (commonPrefix b c) /= mempty
      66% allUniqueNonNull [a, b, c]
    leftGCDMonoidLaw_stripCommonPrefix_commonPrefix [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      88% commonPrefix a b /= mempty
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_stripCommonPrefix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      70% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_stripCommonPrefix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      64% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_1 [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      70% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_2 [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      64% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
  Testing LeftReductive laws for type Map Int Natural
    leftReductiveLaw_isPrefixOf_mappend [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
    leftReductiveLaw_isPrefixOf_stripPrefix [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
    leftReductiveLaw_stripPrefix [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
  Testing MonoidNull laws for type Map Int Natural
    monoidNullLaw_basic [✔]
      +++ OK, passed 100 tests:
      97% a /= mempty
       3% a == mempty
  Testing OverlappingGCDMonoid laws for type Map Int Natural
    overlappingGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (overlap a b) a /= mempty
      92% overlap a b /= mempty
      90% allUnique [a, b]
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (overlap a b) b /= mempty
      92% overlap a b /= mempty
      90% allUnique [a, b]
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    overlappingGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    overlappingGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (97% a /= mempty).
    overlappingGCDMonoidLaw_overlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
      50% overlap a b /= mempty && stripPrefixOverlap a b /= mempty
    overlappingGCDMonoidLaw_overlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      74% stripSuffixOverlap b a /= mempty && overlap a b /= mempty
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_stripOverlap_overlap [✔]
      +++ OK, passed 100 tests:
      92% overlap a b /= mempty
      90% allUnique [a, b]
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_stripOverlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
      55% stripPrefixOverlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      80% stripSuffixOverlap b a /= mempty
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
  Testing PositiveMonoid laws for type Map Int Natural
    positiveMonoidLaw_fundamental [✔]
      +++ OK, passed 100 tests:
      98% not (null (a <> b))
      90% allUnique [a, b]
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
       2% null (a <> b)
  Testing RightReductive laws for type Map Int Natural
    rightReductiveLaw_isSuffixOf_mappend [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
    rightReductiveLaw_isSuffixOf_stripSuffix [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
    rightReductiveLaw_stripSuffix [✔]
      +++ OK, passed 100 tests:
      90% allUnique [a, b]
      63% allNonNull [a, b]
      63% allUniqueNonNull [a, b]
  Testing Commutative laws for type Maybe ()
    commutativeLaw_basic [✔]
      +++ OK, passed 100 tests (13% allUnique [a, b]).
      
      Only 0% (a /= b) && (a <> b /= a) && (b <> a /= b), but expected 0%
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
  Testing Factorial laws for type Maybe ()
    factorialLaw_coverage [✔]
      +++ OK, passed 100 tests:
      95% length a == 1
       5% length a == 0
      
      Only 0% length a >= 2, but expected 0%
    factorialLaw_length_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors_reverse [✔]
      +++ OK, passed 100 tests.
    factorialLaw_all_factors_prime [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primePrefix_foldr [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primeSuffix_foldl [✔]
      +++ OK, passed 100 tests.
    factorialLaw_factors_foldl [✔]
      +++ OK, passed 100 tests (13% allUnique [a, b]).
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    factorialLaw_factors_foldl' [✔]
      +++ OK, passed 100 tests (13% allUnique [a, b]).
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    factorialLaw_factors_foldr [✔]
      +++ OK, passed 100 tests (13% allUnique [a, b]).
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
  Testing FactorialMonoid laws for type Maybe ()
    factorialMonoidLaw_coverage [✔]
      +++ OK, passed 100 tests:
      95% length a == 1
       5% length a == 0
      
      Only 0% length a >= 2, but expected 0%
    factorialMonoidLaw_null [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_reverse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_inits [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_tails [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_span [✔]
      +++ OK, passed 100 tests:
      52% any p (factors a)
      43% any (not . p) (factors a)
    factorialMonoidLaw_split [✔]
      +++ OK, passed 100 tests:
      52% any p (factors a)
      43% any (not . p) (factors a)
    factorialMonoidLaw_split_intersperse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitAt [✔]
      +++ OK, passed 100 tests.
  Testing LeftGCDMonoid laws for type Maybe ()
    leftGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) a /= mempty
      83% commonPrefix a b /= mempty
      13% allUnique [a, b]
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    leftGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) b /= mempty
      83% commonPrefix a b /= mempty
      13% allUnique [a, b]
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    leftGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      74% antecedent == True
      74% consequent == True
      26% antecedent == False
      26% consequent == False
      13% allUnique [a, b]
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    leftGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    leftGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (95% a /= mempty).
    leftGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (95% a /= mempty).
    leftGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      83% commonPrefix a b /= mempty
      17% commonPrefix a b == mempty
      13% allUnique [a, b]
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    leftGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      73% commonPrefix (commonPrefix a b) c /= mempty
      73% commonPrefix a (commonPrefix b c) /= mempty
      
      Only 0% allNonNull [a, b, c], but expected 0%
      Only 0% allUnique [a, b, c], but expected 0%
      Only 0% allUniqueNonNull [a, b, c], but expected 0%
    leftGCDMonoidLaw_stripCommonPrefix_commonPrefix [✔]
      +++ OK, passed 100 tests:
      83% commonPrefix a b /= mempty
      13% allUnique [a, b]
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    leftGCDMonoidLaw_stripCommonPrefix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      83% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
      13% allUnique [a, b]
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    leftGCDMonoidLaw_stripCommonPrefix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      83% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
      13% allUnique [a, b]
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_1 [✔]
      +++ OK, passed 100 tests:
      83% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
      13% allUnique [a, b]
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_2 [✔]
      +++ OK, passed 100 tests:
      83% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
      13% allUnique [a, b]
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
  Testing LeftReductive laws for type Maybe ()
    leftReductiveLaw_isPrefixOf_mappend [✔]
      +++ OK, passed 100 tests (13% allUnique [a, b]).
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    leftReductiveLaw_isPrefixOf_stripPrefix [✔]
      +++ OK, passed 100 tests (13% allUnique [a, b]).
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    leftReductiveLaw_stripPrefix [✔]
      +++ OK, passed 100 tests (13% allUnique [a, b]).
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
  Testing MonoidNull laws for type Maybe ()
    monoidNullLaw_basic [✔]
      +++ OK, passed 100 tests:
      95% a /= mempty
       5% a == mempty
  Testing Monus laws for type Maybe ()
    monusLaw_axiom_1 [✔]
      +++ OK, passed 100 tests:
      95% a /= mempty
       5% a == mempty
    monusLaw_axiom_2 [✔]
      +++ OK, passed 100 tests:
      95% a /= mempty
       5% a == mempty
    monusLaw_axiom_3 [✔]
      +++ OK, passed 100 tests:
      13% allUnique [a, b]
       7% (a <\> b) /= mempty
       6% (b <\> a) /= mempty
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    monusLaw_axiom_4 [✔]
      +++ OK, passed 100 tests (1% (a <\> b) <\> c /= mempty).
      
      Only 0% allNonNull [a, b, c], but expected 0%
      Only 0% allUnique [a, b, c], but expected 0%
      Only 0% allUniqueNonNull [a, b, c], but expected 0%
    monusLaw_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      13% allUnique [a, b]
       7% a <\> b /= mempty
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    monusLaw_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      13% allUnique [a, b]
       7% a <\> b /= mempty
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
  Testing OverlappingGCDMonoid laws for type Maybe ()
    overlappingGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (overlap a b) a /= mempty
      83% overlap a b /= mempty
      13% allUnique [a, b]
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    overlappingGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (overlap a b) b /= mempty
      83% overlap a b /= mempty
      13% allUnique [a, b]
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    overlappingGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    overlappingGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (95% a /= mempty).
    overlappingGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (95% a /= mempty).
    overlappingGCDMonoidLaw_overlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests (13% allUnique [a, b]).
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% overlap a b /= mempty && stripPrefixOverlap a b /= mempty, but expected 0%
    overlappingGCDMonoidLaw_overlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests (13% allUnique [a, b]).
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
      Only 0% stripSuffixOverlap b a /= mempty && overlap a b /= mempty, but expected 0%
    overlappingGCDMonoidLaw_stripOverlap_overlap [✔]
      +++ OK, passed 100 tests:
      83% overlap a b /= mempty
      13% allUnique [a, b]
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    overlappingGCDMonoidLaw_stripOverlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      13% allUnique [a, b]
       6% stripPrefixOverlap a b /= mempty
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    overlappingGCDMonoidLaw_stripOverlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      13% allUnique [a, b]
       7% stripSuffixOverlap b a /= mempty
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
  Testing PositiveMonoid laws for type Maybe ()
    positiveMonoidLaw_fundamental [✔]
      +++ OK, passed 100 tests:
      96% not (null (a <> b))
      13% allUnique [a, b]
       4% null (a <> b)
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
  Testing Reductive laws for type Maybe ()
    reductiveLaw_equivalence_prefix [✔]
      +++ OK, passed 100 tests (13% allUnique [a, b]).
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    reductiveLaw_equivalence_suffix [✔]
      +++ OK, passed 100 tests (13% allUnique [a, b]).
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    reductiveLaw_inversion_prefix [✔]
      +++ OK, passed 100 tests (13% allUnique [a, b]).
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    reductiveLaw_inversion_suffix [✔]
      +++ OK, passed 100 tests (13% allUnique [a, b]).
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
  Testing RightGCDMonoid laws for type Maybe ()
    rightGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (commonSuffix a b) a /= mempty
      83% commonSuffix a b /= mempty
      13% allUnique [a, b]
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    rightGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (commonSuffix a b) b /= mempty
      83% commonSuffix a b /= mempty
      13% allUnique [a, b]
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    rightGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      74% antecedent == True
      74% consequent == True
      26% antecedent == False
      26% consequent == False
      13% allUnique [a, b]
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    rightGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    rightGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (95% a /= mempty).
    rightGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (95% a /= mempty).
    rightGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      83% commonSuffix a b /= mempty
      17% commonSuffix a b == mempty
      13% allUnique [a, b]
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    rightGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      73% commonSuffix (commonSuffix a b) c /= mempty
      73% commonSuffix a (commonSuffix b c) /= mempty
      
      Only 0% allNonNull [a, b, c], but expected 0%
      Only 0% allUnique [a, b, c], but expected 0%
      Only 0% allUniqueNonNull [a, b, c], but expected 0%
    rightGCDMonoidLaw_stripCommonSuffix_commonSuffix [✔]
      +++ OK, passed 100 tests:
      83% commonSuffix a b /= mempty
      13% allUnique [a, b]
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    rightGCDMonoidLaw_stripCommonSuffix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      83% stripCommonSuffix a b & \(x, _, s) -> x /= mempty && s /= mempty
      13% allUnique [a, b]
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    rightGCDMonoidLaw_stripCommonSuffix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      83% stripCommonSuffix a b & \(_, x, s) -> x /= mempty && s /= mempty
      13% allUnique [a, b]
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    rightGCDMonoidLaw_stripCommonSuffix_stripSuffix_1 [✔]
      +++ OK, passed 100 tests:
      83% stripCommonSuffix a b & \(x, _, s) -> x /= mempty && s /= mempty
      13% allUnique [a, b]
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    rightGCDMonoidLaw_stripCommonSuffix_stripSuffix_2 [✔]
      +++ OK, passed 100 tests:
      83% stripCommonSuffix a b & \(_, x, s) -> x /= mempty && s /= mempty
      13% allUnique [a, b]
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
  Testing RightReductive laws for type Maybe ()
    rightReductiveLaw_isSuffixOf_mappend [✔]
      +++ OK, passed 100 tests (13% allUnique [a, b]).
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    rightReductiveLaw_isSuffixOf_stripSuffix [✔]
      +++ OK, passed 100 tests (13% allUnique [a, b]).
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
    rightReductiveLaw_stripSuffix [✔]
      +++ OK, passed 100 tests (13% allUnique [a, b]).
      
      Only 0% allNonNull [a, b], but expected 0%
      Only 0% allUniqueNonNull [a, b], but expected 0%
  Testing Commutative laws for type Maybe (Product (Small Int))
    commutativeLaw_basic [✔]
      +++ OK, passed 100 tests:
      72% allNonNull [a, b]
      71% allUnique [a, b]
      56% allUniqueNonNull [a, b]
      54% (a /= b) && (a <> b /= a) && (b <> a /= b)
  Testing Factorial laws for type Maybe (Product (Small Int))
    factorialLaw_coverage [✔]
      +++ OK, passed 100 tests:
      62% length a == 1
      33% length a >= 2
       5% length a == 0
    factorialLaw_length_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors_reverse [✔]
      +++ OK, passed 100 tests.
    factorialLaw_all_factors_prime [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primePrefix_foldr [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primeSuffix_foldl [✔]
      +++ OK, passed 100 tests.
    factorialLaw_factors_foldl [✔]
      +++ OK, passed 100 tests:
      72% allNonNull [a, b]
      71% allUnique [a, b]
      56% allUniqueNonNull [a, b]
    factorialLaw_factors_foldl' [✔]
      +++ OK, passed 100 tests:
      72% allNonNull [a, b]
      71% allUnique [a, b]
      56% allUniqueNonNull [a, b]
    factorialLaw_factors_foldr [✔]
      +++ OK, passed 100 tests:
      72% allNonNull [a, b]
      71% allUnique [a, b]
      56% allUniqueNonNull [a, b]
  Testing FactorialMonoid laws for type Maybe (Product (Small Int))
    factorialMonoidLaw_coverage [✔]
      +++ OK, passed 100 tests:
      62% length a == 1
      33% length a >= 2
       5% length a == 0
    factorialMonoidLaw_null [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_reverse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_inits [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_tails [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_span [✔]
      +++ OK, passed 100 tests:
      63% any (not . p) (factors a)
      49% any p (factors a)
    factorialMonoidLaw_split [✔]
      +++ OK, passed 100 tests:
      63% any (not . p) (factors a)
      49% any p (factors a)
    factorialMonoidLaw_split_intersperse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitAt [✔]
      +++ OK, passed 100 tests.
  Testing LeftReductive laws for type Maybe (Product (Small Int))
    leftReductiveLaw_isPrefixOf_mappend [✔]
      +++ OK, passed 100 tests:
      72% allNonNull [a, b]
      71% allUnique [a, b]
      56% allUniqueNonNull [a, b]
    leftReductiveLaw_isPrefixOf_stripPrefix [✔]
      +++ OK, passed 100 tests:
      72% allNonNull [a, b]
      71% allUnique [a, b]
      56% allUniqueNonNull [a, b]
    leftReductiveLaw_stripPrefix [✔]
      +++ OK, passed 100 tests:
      72% allNonNull [a, b]
      71% allUnique [a, b]
      56% allUniqueNonNull [a, b]
  Testing MonoidNull laws for type Maybe (Product (Small Int))
    monoidNullLaw_basic [✔]
      +++ OK, passed 100 tests:
      95% a /= mempty
       5% a == mempty
  Testing PositiveMonoid laws for type Maybe (Product (Small Int))
    positiveMonoidLaw_fundamental [✔]
      +++ OK, passed 100 tests:
      96% not (null (a <> b))
      72% allNonNull [a, b]
      71% allUnique [a, b]
      56% allUniqueNonNull [a, b]
       4% null (a <> b)
  Testing Reductive laws for type Maybe (Product (Small Int))
    reductiveLaw_equivalence_prefix [✔]
      +++ OK, passed 100 tests:
      72% allNonNull [a, b]
      71% allUnique [a, b]
      56% allUniqueNonNull [a, b]
    reductiveLaw_equivalence_suffix [✔]
      +++ OK, passed 100 tests:
      72% allNonNull [a, b]
      71% allUnique [a, b]
      56% allUniqueNonNull [a, b]
    reductiveLaw_inversion_prefix [✔]
      +++ OK, passed 100 tests:
      72% allNonNull [a, b]
      71% allUnique [a, b]
      56% allUniqueNonNull [a, b]
    reductiveLaw_inversion_suffix [✔]
      +++ OK, passed 100 tests:
      72% allNonNull [a, b]
      71% allUnique [a, b]
      56% allUniqueNonNull [a, b]
  Testing RightReductive laws for type Maybe (Product (Small Int))
    rightReductiveLaw_isSuffixOf_mappend [✔]
      +++ OK, passed 100 tests:
      72% allNonNull [a, b]
      71% allUnique [a, b]
      56% allUniqueNonNull [a, b]
    rightReductiveLaw_isSuffixOf_stripSuffix [✔]
      +++ OK, passed 100 tests:
      72% allNonNull [a, b]
      71% allUnique [a, b]
      56% allUniqueNonNull [a, b]
    rightReductiveLaw_stripSuffix [✔]
      +++ OK, passed 100 tests:
      72% allNonNull [a, b]
      71% allUnique [a, b]
      56% allUniqueNonNull [a, b]
  Testing Commutative laws for type Maybe (Product Natural)
    commutativeLaw_basic [✔]
      +++ OK, passed 100 tests:
      78% allNonNull [a, b]
      77% allUnique [a, b]
      62% allUniqueNonNull [a, b]
      60% (a /= b) && (a <> b /= a) && (b <> a /= b)
  Testing Factorial laws for type Maybe (Product Natural)
    factorialLaw_coverage [✔]
      +++ OK, passed 100 tests:
      72% length a >= 2
      23% length a == 1
       5% length a == 0
    factorialLaw_length_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors_reverse [✔]
      +++ OK, passed 100 tests.
    factorialLaw_all_factors_prime [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primePrefix_foldr [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primeSuffix_foldl [✔]
      +++ OK, passed 100 tests.
    factorialLaw_factors_foldl [✔]
      +++ OK, passed 100 tests:
      78% allNonNull [a, b]
      77% allUnique [a, b]
      62% allUniqueNonNull [a, b]
    factorialLaw_factors_foldl' [✔]
      +++ OK, passed 100 tests:
      78% allNonNull [a, b]
      77% allUnique [a, b]
      62% allUniqueNonNull [a, b]
    factorialLaw_factors_foldr [✔]
      +++ OK, passed 100 tests:
      78% allNonNull [a, b]
      77% allUnique [a, b]
      62% allUniqueNonNull [a, b]
  Testing FactorialMonoid laws for type Maybe (Product Natural)
    factorialMonoidLaw_coverage [✔]
      +++ OK, passed 100 tests:
      72% length a >= 2
      23% length a == 1
       5% length a == 0
    factorialMonoidLaw_null [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_reverse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_inits [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_tails [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_span [✔]
      +++ OK, passed 100 tests:
      71% any (not . p) (factors a)
      66% any p (factors a)
    factorialMonoidLaw_split [✔]
      +++ OK, passed 100 tests:
      71% any (not . p) (factors a)
      66% any p (factors a)
    factorialMonoidLaw_split_intersperse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitAt [✔]
      +++ OK, passed 100 tests.
  Testing LeftGCDMonoid laws for type Maybe (Product Natural)
    leftGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) a /= mempty
      83% commonPrefix a b /= mempty
      78% allNonNull [a, b]
      77% allUnique [a, b]
      62% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) b /= mempty
      83% commonPrefix a b /= mempty
      78% allNonNull [a, b]
      77% allUnique [a, b]
      62% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      87% antecedent == False
      87% consequent == False
      78% allNonNull [a, b]
      77% allUnique [a, b]
      62% allUniqueNonNull [a, b]
      13% antecedent == True
      13% consequent == True
    leftGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    leftGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (95% a /= mempty).
    leftGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (95% a /= mempty).
    leftGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      83% commonPrefix a b /= mempty
      78% allNonNull [a, b]
      77% allUnique [a, b]
      62% allUniqueNonNull [a, b]
      17% commonPrefix a b == mempty
    leftGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      73% commonPrefix (commonPrefix a b) c /= mempty
      73% commonPrefix a (commonPrefix b c) /= mempty
      71% allNonNull [a, b, c]
      51% allUnique [a, b, c]
      33% allUniqueNonNull [a, b, c]
    leftGCDMonoidLaw_stripCommonPrefix_commonPrefix [✔]
      +++ OK, passed 100 tests:
      83% commonPrefix a b /= mempty
      78% allNonNull [a, b]
      77% allUnique [a, b]
      62% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_stripCommonPrefix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      83% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
      78% allNonNull [a, b]
      77% allUnique [a, b]
      62% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_stripCommonPrefix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      83% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
      78% allNonNull [a, b]
      77% allUnique [a, b]
      62% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_1 [✔]
      +++ OK, passed 100 tests:
      83% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
      78% allNonNull [a, b]
      77% allUnique [a, b]
      62% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_2 [✔]
      +++ OK, passed 100 tests:
      83% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
      78% allNonNull [a, b]
      77% allUnique [a, b]
      62% allUniqueNonNull [a, b]
  Testing LeftReductive laws for type Maybe (Product Natural)
    leftReductiveLaw_isPrefixOf_mappend [✔]
      +++ OK, passed 100 tests:
      78% allNonNull [a, b]
      77% allUnique [a, b]
      62% allUniqueNonNull [a, b]
    leftReductiveLaw_isPrefixOf_stripPrefix [✔]
      +++ OK, passed 100 tests:
      78% allNonNull [a, b]
      77% allUnique [a, b]
      62% allUniqueNonNull [a, b]
    leftReductiveLaw_stripPrefix [✔]
      +++ OK, passed 100 tests:
      78% allNonNull [a, b]
      77% allUnique [a, b]
      62% allUniqueNonNull [a, b]
  Testing MonoidNull laws for type Maybe (Product Natural)
    monoidNullLaw_basic [✔]
      +++ OK, passed 100 tests:
      95% a /= mempty
       5% a == mempty
  Testing Monus laws for type Maybe (Product Natural)
    monusLaw_axiom_1 [✔]
      +++ OK, passed 100 tests:
      95% a /= mempty
       5% a == mempty
    monusLaw_axiom_2 [✔]
      +++ OK, passed 100 tests:
      95% a /= mempty
       5% a == mempty
    monusLaw_axiom_3 [✔]
      +++ OK, passed 100 tests:
      78% allNonNull [a, b]
      77% allUnique [a, b]
      62% allUniqueNonNull [a, b]
      46% (a <\> b) /= mempty
      45% (b <\> a) /= mempty
    monusLaw_axiom_4 [✔]
      +++ OK, passed 100 tests:
      71% allNonNull [a, b, c]
      51% allUnique [a, b, c]
      33% allUniqueNonNull [a, b, c]
      26% (a <\> b) <\> c /= mempty
    monusLaw_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      78% allNonNull [a, b]
      77% allUnique [a, b]
      62% allUniqueNonNull [a, b]
      46% a <\> b /= mempty
    monusLaw_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      78% allNonNull [a, b]
      77% allUnique [a, b]
      62% allUniqueNonNull [a, b]
      46% a <\> b /= mempty
  Testing OverlappingGCDMonoid laws for type Maybe (Product Natural)
    overlappingGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (overlap a b) a /= mempty
      83% overlap a b /= mempty
      78% allNonNull [a, b]
      77% allUnique [a, b]
      62% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (overlap a b) b /= mempty
      83% overlap a b /= mempty
      78% allNonNull [a, b]
      77% allUnique [a, b]
      62% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    overlappingGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (95% a /= mempty).
    overlappingGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (95% a /= mempty).
    overlappingGCDMonoidLaw_overlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      78% allNonNull [a, b]
      77% allUnique [a, b]
      62% allUniqueNonNull [a, b]
      39% overlap a b /= mempty && stripPrefixOverlap a b /= mempty
    overlappingGCDMonoidLaw_overlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      78% allNonNull [a, b]
      77% allUnique [a, b]
      62% allUniqueNonNull [a, b]
      39% stripSuffixOverlap b a /= mempty && overlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_overlap [✔]
      +++ OK, passed 100 tests:
      83% overlap a b /= mempty
      78% allNonNull [a, b]
      77% allUnique [a, b]
      62% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_stripOverlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      78% allNonNull [a, b]
      77% allUnique [a, b]
      62% allUniqueNonNull [a, b]
      45% stripPrefixOverlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      78% allNonNull [a, b]
      77% allUnique [a, b]
      62% allUniqueNonNull [a, b]
      46% stripSuffixOverlap b a /= mempty
  Testing PositiveMonoid laws for type Maybe (Product Natural)
    positiveMonoidLaw_fundamental [✔]
      +++ OK, passed 100 tests:
      96% not (null (a <> b))
      78% allNonNull [a, b]
      77% allUnique [a, b]
      62% allUniqueNonNull [a, b]
       4% null (a <> b)
  Testing Reductive laws for type Maybe (Product Natural)
    reductiveLaw_equivalence_prefix [✔]
      +++ OK, passed 100 tests:
      78% allNonNull [a, b]
      77% allUnique [a, b]
      62% allUniqueNonNull [a, b]
    reductiveLaw_equivalence_suffix [✔]
      +++ OK, passed 100 tests:
      78% allNonNull [a, b]
      77% allUnique [a, b]
      62% allUniqueNonNull [a, b]
    reductiveLaw_inversion_prefix [✔]
      +++ OK, passed 100 tests:
      78% allNonNull [a, b]
      77% allUnique [a, b]
      62% allUniqueNonNull [a, b]
    reductiveLaw_inversion_suffix [✔]
      +++ OK, passed 100 tests:
      78% allNonNull [a, b]
      77% allUnique [a, b]
      62% allUniqueNonNull [a, b]
  Testing RightGCDMonoid laws for type Maybe (Product Natural)
    rightGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (commonSuffix a b) a /= mempty
      83% commonSuffix a b /= mempty
      78% allNonNull [a, b]
      77% allUnique [a, b]
      62% allUniqueNonNull [a, b]
    rightGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (commonSuffix a b) b /= mempty
      83% commonSuffix a b /= mempty
      78% allNonNull [a, b]
      77% allUnique [a, b]
      62% allUniqueNonNull [a, b]
    rightGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      87% antecedent == False
      87% consequent == False
      78% allNonNull [a, b]
      77% allUnique [a, b]
      62% allUniqueNonNull [a, b]
      13% antecedent == True
      13% consequent == True
    rightGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    rightGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (95% a /= mempty).
    rightGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (95% a /= mempty).
    rightGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      83% commonSuffix a b /= mempty
      78% allNonNull [a, b]
      77% allUnique [a, b]
      62% allUniqueNonNull [a, b]
      17% commonSuffix a b == mempty
    rightGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      73% commonSuffix (commonSuffix a b) c /= mempty
      73% commonSuffix a (commonSuffix b c) /= mempty
      71% allNonNull [a, b, c]
      51% allUnique [a, b, c]
      33% allUniqueNonNull [a, b, c]
    rightGCDMonoidLaw_stripCommonSuffix_commonSuffix [✔]
      +++ OK, passed 100 tests:
      83% commonSuffix a b /= mempty
      78% allNonNull [a, b]
      77% allUnique [a, b]
      62% allUniqueNonNull [a, b]
    rightGCDMonoidLaw_stripCommonSuffix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      83% stripCommonSuffix a b & \(x, _, s) -> x /= mempty && s /= mempty
      78% allNonNull [a, b]
      77% allUnique [a, b]
      62% allUniqueNonNull [a, b]
    rightGCDMonoidLaw_stripCommonSuffix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      83% stripCommonSuffix a b & \(_, x, s) -> x /= mempty && s /= mempty
      78% allNonNull [a, b]
      77% allUnique [a, b]
      62% allUniqueNonNull [a, b]
    rightGCDMonoidLaw_stripCommonSuffix_stripSuffix_1 [✔]
      +++ OK, passed 100 tests:
      83% stripCommonSuffix a b & \(x, _, s) -> x /= mempty && s /= mempty
      78% allNonNull [a, b]
      77% allUnique [a, b]
      62% allUniqueNonNull [a, b]
    rightGCDMonoidLaw_stripCommonSuffix_stripSuffix_2 [✔]
      +++ OK, passed 100 tests:
      83% stripCommonSuffix a b & \(_, x, s) -> x /= mempty && s /= mempty
      78% allNonNull [a, b]
      77% allUnique [a, b]
      62% allUniqueNonNull [a, b]
  Testing RightReductive laws for type Maybe (Product Natural)
    rightReductiveLaw_isSuffixOf_mappend [✔]
      +++ OK, passed 100 tests:
      78% allNonNull [a, b]
      77% allUnique [a, b]
      62% allUniqueNonNull [a, b]
    rightReductiveLaw_isSuffixOf_stripSuffix [✔]
      +++ OK, passed 100 tests:
      78% allNonNull [a, b]
      77% allUnique [a, b]
      62% allUniqueNonNull [a, b]
    rightReductiveLaw_stripSuffix [✔]
      +++ OK, passed 100 tests:
      78% allNonNull [a, b]
      77% allUnique [a, b]
      62% allUniqueNonNull [a, b]
  Testing Commutative laws for type Maybe (Sum (Small Int))
    commutativeLaw_basic [✔]
      +++ OK, passed 100 tests:
      78% allUnique [a, b]
      75% allNonNull [a, b]
      59% (a /= b) && (a <> b /= a) && (b <> a /= b)
      59% allUniqueNonNull [a, b]
  Testing Factorial laws for type Maybe (Sum (Small Int))
    factorialLaw_coverage [✔]
      +++ OK, passed 100 tests:
      82% length a >= 2
      13% length a == 1
       5% length a == 0
    factorialLaw_length_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors_reverse [✔]
      +++ OK, passed 100 tests.
    factorialLaw_all_factors_prime [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primePrefix_foldr [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primeSuffix_foldl [✔]
      +++ OK, passed 100 tests.
    factorialLaw_factors_foldl [✔]
      +++ OK, passed 100 tests:
      78% allUnique [a, b]
      75% allNonNull [a, b]
      59% allUniqueNonNull [a, b]
    factorialLaw_factors_foldl' [✔]
      +++ OK, passed 100 tests:
      78% allUnique [a, b]
      75% allNonNull [a, b]
      59% allUniqueNonNull [a, b]
    factorialLaw_factors_foldr [✔]
      +++ OK, passed 100 tests:
      78% allUnique [a, b]
      75% allNonNull [a, b]
      59% allUniqueNonNull [a, b]
  Testing FactorialMonoid laws for type Maybe (Sum (Small Int))
    factorialMonoidLaw_coverage [✔]
      +++ OK, passed 100 tests:
      82% length a >= 2
      13% length a == 1
       5% length a == 0
    factorialMonoidLaw_null [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_reverse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_inits [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_tails [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_span [✔]
      +++ OK, passed 100 tests:
      48% any (not . p) (factors a)
      47% any p (factors a)
    factorialMonoidLaw_split [✔]
      +++ OK, passed 100 tests:
      48% any (not . p) (factors a)
      47% any p (factors a)
    factorialMonoidLaw_split_intersperse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitAt [✔]
      +++ OK, passed 100 tests.
  Testing LeftReductive laws for type Maybe (Sum (Small Int))
    leftReductiveLaw_isPrefixOf_mappend [✔]
      +++ OK, passed 100 tests:
      78% allUnique [a, b]
      75% allNonNull [a, b]
      59% allUniqueNonNull [a, b]
    leftReductiveLaw_isPrefixOf_stripPrefix [✔]
      +++ OK, passed 100 tests:
      78% allUnique [a, b]
      75% allNonNull [a, b]
      59% allUniqueNonNull [a, b]
    leftReductiveLaw_stripPrefix [✔]
      +++ OK, passed 100 tests:
      78% allUnique [a, b]
      75% allNonNull [a, b]
      59% allUniqueNonNull [a, b]
  Testing MonoidNull laws for type Maybe (Sum (Small Int))
    monoidNullLaw_basic [✔]
      +++ OK, passed 100 tests:
      95% a /= mempty
       5% a == mempty
  Testing PositiveMonoid laws for type Maybe (Sum (Small Int))
    positiveMonoidLaw_fundamental [✔]
      +++ OK, passed 100 tests:
      96% not (null (a <> b))
      78% allUnique [a, b]
      75% allNonNull [a, b]
      59% allUniqueNonNull [a, b]
       4% null (a <> b)
  Testing Reductive laws for type Maybe (Sum (Small Int))
    reductiveLaw_equivalence_prefix [✔]
      +++ OK, passed 100 tests:
      78% allUnique [a, b]
      75% allNonNull [a, b]
      59% allUniqueNonNull [a, b]
    reductiveLaw_equivalence_suffix [✔]
      +++ OK, passed 100 tests:
      78% allUnique [a, b]
      75% allNonNull [a, b]
      59% allUniqueNonNull [a, b]
    reductiveLaw_inversion_prefix [✔]
      +++ OK, passed 100 tests:
      78% allUnique [a, b]
      75% allNonNull [a, b]
      59% allUniqueNonNull [a, b]
    reductiveLaw_inversion_suffix [✔]
      +++ OK, passed 100 tests:
      78% allUnique [a, b]
      75% allNonNull [a, b]
      59% allUniqueNonNull [a, b]
  Testing RightReductive laws for type Maybe (Sum (Small Int))
    rightReductiveLaw_isSuffixOf_mappend [✔]
      +++ OK, passed 100 tests:
      78% allUnique [a, b]
      75% allNonNull [a, b]
      59% allUniqueNonNull [a, b]
    rightReductiveLaw_isSuffixOf_stripSuffix [✔]
      +++ OK, passed 100 tests:
      78% allUnique [a, b]
      75% allNonNull [a, b]
      59% allUniqueNonNull [a, b]
    rightReductiveLaw_stripSuffix [✔]
      +++ OK, passed 100 tests:
      78% allUnique [a, b]
      75% allNonNull [a, b]
      59% allUniqueNonNull [a, b]
  Testing Commutative laws for type Maybe (Sum Natural)
    commutativeLaw_basic [✔]
      +++ OK, passed 100 tests:
      80% allNonNull [a, b]
      78% allUnique [a, b]
      63% (a /= b) && (a <> b /= a) && (b <> a /= b)
      63% allUniqueNonNull [a, b]
  Testing Factorial laws for type Maybe (Sum Natural)
    factorialLaw_coverage [✔]
      +++ OK, passed 100 tests:
      91% length a >= 2
       5% length a == 0
       4% length a == 1
    factorialLaw_length_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors [✔]
      +++ OK, passed 100 tests.
    factorialLaw_maybe_sconcat_nonEmpty_factors_reverse [✔]
      +++ OK, passed 100 tests.
    factorialLaw_all_factors_prime [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primePrefix_foldr [✔]
      +++ OK, passed 100 tests.
    factorialLaw_primeSuffix_foldl [✔]
      +++ OK, passed 100 tests.
    factorialLaw_factors_foldl [✔]
      +++ OK, passed 100 tests:
      80% allNonNull [a, b]
      78% allUnique [a, b]
      63% allUniqueNonNull [a, b]
    factorialLaw_factors_foldl' [✔]
      +++ OK, passed 100 tests:
      80% allNonNull [a, b]
      78% allUnique [a, b]
      63% allUniqueNonNull [a, b]
    factorialLaw_factors_foldr [✔]
      +++ OK, passed 100 tests:
      80% allNonNull [a, b]
      78% allUnique [a, b]
      63% allUniqueNonNull [a, b]
  Testing FactorialMonoid laws for type Maybe (Sum Natural)
    factorialMonoidLaw_coverage [✔]
      +++ OK, passed 100 tests:
      91% length a >= 2
       5% length a == 0
       4% length a == 1
    factorialMonoidLaw_null [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitPrimeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_reverse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primePrefix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_primeSuffix [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_inits [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_tails [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_span [✔]
      +++ OK, passed 100 tests:
      49% any p (factors a)
      46% any (not . p) (factors a)
    factorialMonoidLaw_split [✔]
      +++ OK, passed 100 tests:
      49% any p (factors a)
      46% any (not . p) (factors a)
    factorialMonoidLaw_split_intersperse [✔]
      +++ OK, passed 100 tests.
    factorialMonoidLaw_splitAt [✔]
      +++ OK, passed 100 tests.
  Testing LeftGCDMonoid laws for type Maybe (Sum Natural)
    leftGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) a /= mempty
      83% commonPrefix a b /= mempty
      80% allNonNull [a, b]
      78% allUnique [a, b]
      63% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (commonPrefix a b) b /= mempty
      83% commonPrefix a b /= mempty
      80% allNonNull [a, b]
      78% allUnique [a, b]
      63% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      87% antecedent == False
      87% consequent == False
      80% allNonNull [a, b]
      78% allUnique [a, b]
      63% allUniqueNonNull [a, b]
      13% antecedent == True
      13% consequent == True
    leftGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    leftGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (95% a /= mempty).
    leftGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (95% a /= mempty).
    leftGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      83% commonPrefix a b /= mempty
      80% allNonNull [a, b]
      78% allUnique [a, b]
      63% allUniqueNonNull [a, b]
      17% commonPrefix a b == mempty
    leftGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      73% commonPrefix (commonPrefix a b) c /= mempty
      73% commonPrefix a (commonPrefix b c) /= mempty
      70% allNonNull [a, b, c]
      53% allUnique [a, b, c]
      34% allUniqueNonNull [a, b, c]
    leftGCDMonoidLaw_stripCommonPrefix_commonPrefix [✔]
      +++ OK, passed 100 tests:
      83% commonPrefix a b /= mempty
      80% allNonNull [a, b]
      78% allUnique [a, b]
      63% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_stripCommonPrefix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      83% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
      80% allNonNull [a, b]
      78% allUnique [a, b]
      63% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_stripCommonPrefix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      83% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
      80% allNonNull [a, b]
      78% allUnique [a, b]
      63% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_1 [✔]
      +++ OK, passed 100 tests:
      83% stripCommonPrefix a b & \(p, x, _) -> p /= mempty && x /= mempty
      80% allNonNull [a, b]
      78% allUnique [a, b]
      63% allUniqueNonNull [a, b]
    leftGCDMonoidLaw_stripCommonPrefix_stripPrefix_2 [✔]
      +++ OK, passed 100 tests:
      83% stripCommonPrefix a b & \(p, _, x) -> p /= mempty && x /= mempty
      80% allNonNull [a, b]
      78% allUnique [a, b]
      63% allUniqueNonNull [a, b]
  Testing LeftReductive laws for type Maybe (Sum Natural)
    leftReductiveLaw_isPrefixOf_mappend [✔]
      +++ OK, passed 100 tests:
      80% allNonNull [a, b]
      78% allUnique [a, b]
      63% allUniqueNonNull [a, b]
    leftReductiveLaw_isPrefixOf_stripPrefix [✔]
      +++ OK, passed 100 tests:
      80% allNonNull [a, b]
      78% allUnique [a, b]
      63% allUniqueNonNull [a, b]
    leftReductiveLaw_stripPrefix [✔]
      +++ OK, passed 100 tests:
      80% allNonNull [a, b]
      78% allUnique [a, b]
      63% allUniqueNonNull [a, b]
  Testing MonoidNull laws for type Maybe (Sum Natural)
    monoidNullLaw_basic [✔]
      +++ OK, passed 100 tests:
      95% a /= mempty
       5% a == mempty
  Testing Monus laws for type Maybe (Sum Natural)
    monusLaw_axiom_1 [✔]
      +++ OK, passed 100 tests:
      95% a /= mempty
       5% a == mempty
    monusLaw_axiom_2 [✔]
      +++ OK, passed 100 tests:
      95% a /= mempty
       5% a == mempty
    monusLaw_axiom_3 [✔]
      +++ OK, passed 100 tests:
      80% allNonNull [a, b]
      78% allUnique [a, b]
      63% allUniqueNonNull [a, b]
      39% (a <\> b) /= mempty
      39% (b <\> a) /= mempty
    monusLaw_axiom_4 [✔]
      +++ OK, passed 100 tests:
      70% allNonNull [a, b, c]
      53% allUnique [a, b, c]
      34% allUniqueNonNull [a, b, c]
       7% (a <\> b) <\> c /= mempty
    monusLaw_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      80% allNonNull [a, b]
      78% allUnique [a, b]
      63% allUniqueNonNull [a, b]
      39% a <\> b /= mempty
    monusLaw_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      80% allNonNull [a, b]
      78% allUnique [a, b]
      63% allUniqueNonNull [a, b]
      39% a <\> b /= mempty
  Testing OverlappingGCDMonoid laws for type Maybe (Sum Natural)
    overlappingGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (overlap a b) a /= mempty
      83% overlap a b /= mempty
      80% allNonNull [a, b]
      78% allUnique [a, b]
      63% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripPrefix (overlap a b) b /= mempty
      83% overlap a b /= mempty
      80% allNonNull [a, b]
      78% allUnique [a, b]
      63% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    overlappingGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (95% a /= mempty).
    overlappingGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (95% a /= mempty).
    overlappingGCDMonoidLaw_overlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      80% allNonNull [a, b]
      78% allUnique [a, b]
      63% allUniqueNonNull [a, b]
      33% overlap a b /= mempty && stripPrefixOverlap a b /= mempty
    overlappingGCDMonoidLaw_overlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      80% allNonNull [a, b]
      78% allUnique [a, b]
      63% allUniqueNonNull [a, b]
      32% stripSuffixOverlap b a /= mempty && overlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_overlap [✔]
      +++ OK, passed 100 tests:
      83% overlap a b /= mempty
      80% allNonNull [a, b]
      78% allUnique [a, b]
      63% allUniqueNonNull [a, b]
    overlappingGCDMonoidLaw_stripOverlap_stripPrefixOverlap [✔]
      +++ OK, passed 100 tests:
      80% allNonNull [a, b]
      78% allUnique [a, b]
      63% allUniqueNonNull [a, b]
      39% stripPrefixOverlap a b /= mempty
    overlappingGCDMonoidLaw_stripOverlap_stripSuffixOverlap [✔]
      +++ OK, passed 100 tests:
      80% allNonNull [a, b]
      78% allUnique [a, b]
      63% allUniqueNonNull [a, b]
      39% stripSuffixOverlap b a /= mempty
  Testing PositiveMonoid laws for type Maybe (Sum Natural)
    positiveMonoidLaw_fundamental [✔]
      +++ OK, passed 100 tests:
      96% not (null (a <> b))
      80% allNonNull [a, b]
      78% allUnique [a, b]
      63% allUniqueNonNull [a, b]
       4% null (a <> b)
  Testing Reductive laws for type Maybe (Sum Natural)
    reductiveLaw_equivalence_prefix [✔]
      +++ OK, passed 100 tests:
      80% allNonNull [a, b]
      78% allUnique [a, b]
      63% allUniqueNonNull [a, b]
    reductiveLaw_equivalence_suffix [✔]
      +++ OK, passed 100 tests:
      80% allNonNull [a, b]
      78% allUnique [a, b]
      63% allUniqueNonNull [a, b]
    reductiveLaw_inversion_prefix [✔]
      +++ OK, passed 100 tests:
      80% allNonNull [a, b]
      78% allUnique [a, b]
      63% allUniqueNonNull [a, b]
    reductiveLaw_inversion_suffix [✔]
      +++ OK, passed 100 tests:
      80% allNonNull [a, b]
      78% allUnique [a, b]
      63% allUniqueNonNull [a, b]
  Testing RightGCDMonoid laws for type Maybe (Sum Natural)
    rightGCDMonoidLaw_reductivity_left [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (commonSuffix a b) a /= mempty
      83% commonSuffix a b /= mempty
      80% allNonNull [a, b]
      78% allUnique [a, b]
      63% allUniqueNonNull [a, b]
    rightGCDMonoidLaw_reductivity_right [✔]
      +++ OK, passed 100 tests:
      100% stripSuffix (commonSuffix a b) b /= mempty
      83% commonSuffix a b /= mempty
      80% allNonNull [a, b]
      78% allUnique [a, b]
      63% allUniqueNonNull [a, b]
    rightGCDMonoidLaw_uniqueness [✔]
      +++ OK, passed 100 tests:
      87% antecedent == False
      87% consequent == False
      80% allNonNull [a, b]
      78% allUnique [a, b]
      63% allUniqueNonNull [a, b]
      13% antecedent == True
      13% consequent == True
    rightGCDMonoidLaw_idempotence [✔]
      +++ OK, passed 100 tests.
    rightGCDMonoidLaw_identity_left [✔]
      +++ OK, passed 100 tests (95% a /= mempty).
    rightGCDMonoidLaw_identity_right [✔]
      +++ OK, passed 100 tests (95% a /= mempty).
    rightGCDMonoidLaw_commutativity [✔]
      +++ OK, passed 100 tests:
      83% commonSuffix a b /= mempty
      80% allNonNull [a, b]
      78% allUnique [a, b]
      63% allUniqueNonNull [a, b]
      17% commonSuffix a b == mempty
    rightGCDMonoidLaw_associativity [✔]
      +++ OK, passed 100 tests:
      73% commonSuffix (commonSuffix a b) c /= mempty
      73% commonSuffix a (commonSuffix b c) /= mempty
      70% allNonNull [a, b, c]
      53% allUnique [a, b, c]
      34% allUniqueNonNull [a, b, c]
    rightGCDMonoidLaw_stripCommonSuffix_commonSuffix [✔]
      +++ OK, passed 100 tests:
      83% commonSuffix a b /= mempty
      80% allNonNull [a, b]
      78% allUnique [a, b]
      63% allUniqueNonNull [a, b]
    rightGCDMonoidLaw_stripCommonSuffix_mappend_1 [✔]
      +++ OK, passed 100 tests:
      83% stripCommonSuffix a b & \(x, _, s) -> x /= mempty && s /= mempty
      80% allNonNull [a, b]
      78% allUnique [a, b]
      63% allUniqueNonNull [a, b]
    rightGCDMonoidLaw_stripCommonSuffix_mappend_2 [✔]
      +++ OK, passed 100 tests:
      83% stripCommonSuffix a b & \(_, x, s) -> x /= mempty && s /= mempty
      80% allNonNull [a, b]
      78% allUnique [a, b]
      63% allUniqueNonNull [a, b]
    rightGCDMonoidLaw_stripCommonSuffix_stripSuffix_1 [✔]
      +++ OK, passed 100 tests:
      83% stripCommonSuffix a b & \(x, _, s) -> x /= mempty && s /= mempty
      80% allNonNull [a, b]
      78% allUnique [a, b]
      63% allUniqueNonNull [a, b]
    rightGCDMonoidLaw_stripCommonSuffix_stripSuffix_2 [✔]
      +++ OK, passed 100 tests:
      83% stripCommonSuffix a b & \(_, x, s) -> x /= mempty && s /= mempty
      80% allNonNull [a, b]
      78% allUnique [a, b]
      63% allUniqueNonNull [a, b]
  Testing RightReductive laws for type Maybe (Sum Natural)
    rightReductiveLaw_isSuffixOf_mappend [✔]
      +++ OK, passed 100 tests:
      80% allNonNull [a, b]
      78% allUnique [a, b]
      63% allUniqueNonNull [a, b]
    rightReductiveLaw_isSuffixOf_stripSuffix [✔]
      +++ OK, passed 100 tests:
      80% allNonNull [a, b]
      78% allUnique [a, b]
      63% allUniqueNonNull [a, b]
    rightReductiveLaw_stripSuffix [✔]
      +++ OK, passed 100 tests:
      80% allNonNull [a, b]
      78% allUnique [a, b]
      63% allUniqueNonNull [a, b]

Finished in 3.2664 seconds
1892 examples, 0 failures
Test suite test: PASS
Test suite logged to:
/tmp/workdir-quickcheck-monoid-subclasses/quickcheck-monoid-subclasses-0.3.0.4/dist-newstyle/build/x86_64-linux/ghc-9.6.6/quickcheck-monoid-subclasses-0.3.0.4/t/test/test/quickcheck-monoid-subclasses-0.3.0.4-test.log
1 of 1 test suites (1 of 1 test cases) passed.
