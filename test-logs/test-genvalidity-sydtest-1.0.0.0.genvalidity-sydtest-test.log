Build profile: -w ghc-9.6.6 -O1
In order, the following will be built (use -v for more details):
 - genvalidity-sydtest-1.0.0.0 (test:genvalidity-sydtest-test) (ephemeral targets)
Preprocessing test suite 'genvalidity-sydtest-test' for genvalidity-sydtest-1.0.0.0...
Building test suite 'genvalidity-sydtest-test' for genvalidity-sydtest-1.0.0.0...
Running 1 test suites...
Test suite genvalidity-sydtest-test: RUNNING...
[34mTests:[m

[33mTest.Syd.Validity.MonoidSpec[m
  [33mMonoid [Int][m
    [33mmappend :: [Int] -> [Int] -> [Int][m
      [32mâœ“ [m[32mis an associative operation for "valid :: ([Int],[Int],[Int])"[m                                                                                                                                                                                                              [32m      5.93 ms[m
        passed for all of [32m100[m inputs.
    [33mmempty :: [Int][m
      [32mâœ“ [m[32mis the identity for mappend :: [Int] -> [Int] -> [Int] for "valid :: [Int]"[m                                                                                                                                                                                                 [32m      4.69 ms[m
        passed for all of [32m100[m inputs.
    [33mmconcat :: [[Int]] -> [Int][m
      [32mâœ“ [m[32mis equivalent to its default implementation for "valid :: [[Int]]"[m                                                                                                                                                                                                          [32m      4.94 ms[m
        passed for all of [32m100[m inputs.
  [33mMonoid [Int][m
    [33mmconcat :: [[Int]] -> [Int][m
      [32mâœ“ [m[32mis equivalent to its default implementation for "arbitrary :: [[Int]]"[m                                                                                                                                                                                                      [32m      4.36 ms[m
        passed for all of [32m100[m inputs.
    [33mmempty :: [Int][m
      [32mâœ“ [m[32mis the identity for mappend :: [Int] -> [Int] -> [Int] for "arbitrary :: [Int]"[m                                                                                                                                                                                             [32m      4.13 ms[m
        passed for all of [32m100[m inputs.
    [33mmappend :: [Int] -> [Int] -> [Int][m
      [32mâœ“ [m[32mis an associative operation for "arbitrary :: ([Int],[Int],[Int])"[m                                                                                                                                                                                                          [32m      4.95 ms[m
        passed for all of [32m100[m inputs.
  [33mMonoid ([Ratio Integer])[m
    [33mmappend :: ([Ratio Integer]) -> ([Ratio Integer]) -> ([Ratio Integer])[m
      [32mâœ“ [m[32mis an associative operation for "valid :: (([Ratio Integer],[Ratio Integer],[Ratio Integer]))"[m                                                                                                                                                                              [33m     26.85 ms[m
        passed for all of [32m100[m inputs.
    [33mmempty :: ([Ratio Integer])[m
      [32mâœ“ [m[32mis the identity for mappend :: ([Ratio Integer]) -> ([Ratio Integer]) -> ([Ratio Integer]) for "valid :: ([Ratio Integer])"[m                                                                                                                                                 [33m     18.79 ms[m
        passed for all of [32m100[m inputs.
    [33mmconcat :: [([Ratio Integer])] -> ([Ratio Integer])[m
      [32mâœ“ [m[32mis equivalent to its default implementation for "valid :: ([[Ratio Integer]])"[m                                                                                                                                                                                              [33m     18.45 ms[m
        passed for all of [32m100[m inputs.
  [33mMonoid [Char][m
    [33mmappend :: [Char] -> [Char] -> [Char][m
      [32mâœ“ [m[32mis an associative operation for "singleton list of 'a' :: ([Char],[Char],[Char])"[m                                                                                                                                                                                           [32m      0.71 ms[m
        passed for all of [32m100[m inputs.
    [33mmempty :: [Char][m
      [32mâœ“ [m[32mis the identity for mappend :: [Char] -> [Char] -> [Char] for "singleton list of 'a' :: [Char]"[m                                                                                                                                                                             [32m      1.18 ms[m
        passed for all of [32m100[m inputs.
    [33mmconcat :: [[Char]] -> [Char][m
      [32mâœ“ [m[32mis equivalent to its default implementation for "singleton list of 'a' :: [[Char]]"[m                                                                                                                                                                                         [32m      2.74 ms[m
        passed for all of [32m100[m inputs.
[33mTest.Syd.Validity.OrdSpec[m
  [33mOrd (Ratio Integer)[m
    [33m"max :: (Ratio Integer -> Ratio Integer -> Ratio Integer)"[m
      [32mâœ“ [m[32mis equivalent to (\a b -> if a >= b then a else b) for "valid (Ratio Integer)"'s[m                                                                                                                                                                                            [32m      4.30 ms[m
        passed for all of [32m100[m inputs.
    [33m(>=) :: (Ratio Integer) -> (Ratio Integer) -> Bool[m
      [32mâœ“ [m[32mis transitive for "valid (Ratio Integer)"'s[m                                                                                                                                                                                                                                 [32m      8.21 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32mis antisymmetric for "valid (Ratio Integer)"'s[m                                                                                                                                                                                                                              [33m     11.27 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32mis reflexive for "valid (Ratio Integer)"'s[m                                                                                                                                                                                                                                  [32m      2.14 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32mis equivalent to (\a b -> compare a b /= LT) for "valid (Ratio Integer)"'s[m                                                                                                                                                                                                  [32m      4.09 ms[m
        passed for all of [32m100[m inputs.
    [33m"min :: (Ratio Integer -> Ratio Integer -> Ratio Integer)"[m
      [32mâœ“ [m[32mis equivalent to (\a b -> if a <= b then a else b) for "valid (Ratio Integer)"'s[m                                                                                                                                                                                            [32m      4.67 ms[m
        passed for all of [32m100[m inputs.
    [33m(<=) :: (Ratio Integer) -> (Ratio Integer) -> Bool[m
      [32mâœ“ [m[32mis equivalent to (\a b -> compare a b /= GT) for "valid (Ratio Integer)"'s[m                                                                                                                                                                                                  [32m      3.33 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32mis reflexive for "valid (Ratio Integer)"'s[m                                                                                                                                                                                                                                  [32m      1.97 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32mis transitive for "valid (Ratio Integer)"'s[m                                                                                                                                                                                                                                 [32m      2.34 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32mis antisymmetric for "valid (Ratio Integer)"'s[m                                                                                                                                                                                                                              [32m      8.40 ms[m
        passed for all of [32m100[m inputs.
    [33m(>) :: (Ratio Integer) -> (Ratio Integer) -> Bool[m
      [32mâœ“ [m[32mis equivalent to (\a b -> compare a b == GT) for "valid (Ratio Integer)"'s[m                                                                                                                                                                                                  [32m      3.96 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32mis transitive for "valid (Ratio Integer)"'s[m                                                                                                                                                                                                                                 [32m      5.98 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32mis antireflexive for "valid (Ratio Integer)"'s[m                                                                                                                                                                                                                              [32m      4.72 ms[m
        passed for all of [32m100[m inputs.
    [33m(<) :: (Ratio Integer) -> (Ratio Integer) -> Bool[m
      [32mâœ“ [m[32mis antireflexive for "valid (Ratio Integer)"'s[m                                                                                                                                                                                                                              [32m      1.90 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32mis equivalent to (\a b -> compare a b == LT) for "valid (Ratio Integer)"'s[m                                                                                                                                                                                                  [32m      7.57 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32mis transitive for "valid (Ratio Integer)"'s[m                                                                                                                                                                                                                                 [32m      4.03 ms[m
        passed for all of [32m100[m inputs.
  [33mOrd Int[m
    [33m(<=) :: Int -> Int -> Bool[m
      [32mâœ“ [m[32mis equivalent to (\a b -> compare a b /= GT) for "arbitrary Int"'s[m                                                                                                                                                                                                          [32m      0.85 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32mis transitive for "arbitrary Int"'s[m                                                                                                                                                                                                                                         [32m      3.93 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32mis reflexive for "arbitrary Int"'s[m                                                                                                                                                                                                                                          [32m      3.95 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32mis antisymmetric for "arbitrary Int"'s[m                                                                                                                                                                                                                                      [32m      0.48 ms[m
        passed for all of [32m100[m inputs.
    [33m"min :: (Int -> Int -> Int)"[m
      [32mâœ“ [m[32mis equivalent to (\a b -> if a <= b then a else b) for "arbitrary Int"'s[m                                                                                                                                                                                                    [32m      1.00 ms[m
        passed for all of [32m100[m inputs.
    [33m(>) :: Int -> Int -> Bool[m
      [32mâœ“ [m[32mis antireflexive for "arbitrary Int"'s[m                                                                                                                                                                                                                                      [32m      0.72 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32mis transitive for "arbitrary Int"'s[m                                                                                                                                                                                                                                         [32m      0.83 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32mis equivalent to (\a b -> compare a b == GT) for "arbitrary Int"'s[m                                                                                                                                                                                                          [32m      0.82 ms[m
        passed for all of [32m100[m inputs.
    [33m"max :: (Int -> Int -> Int)"[m
      [32mâœ“ [m[32mis equivalent to (\a b -> if a >= b then a else b) for "arbitrary Int"'s[m                                                                                                                                                                                                    [32m      0.91 ms[m
        passed for all of [32m100[m inputs.
    [33m(<) :: Int -> Int -> Bool[m
      [32mâœ“ [m[32mis transitive for "arbitrary Int"'s[m                                                                                                                                                                                                                                         [32m      0.79 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32mis equivalent to (\a b -> compare a b == LT) for "arbitrary Int"'s[m                                                                                                                                                                                                          [32m      0.85 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32mis antireflexive for "arbitrary Int"'s[m                                                                                                                                                                                                                                      [32m      0.74 ms[m
        passed for all of [32m100[m inputs.
    [33m(>=) :: Int -> Int -> Bool[m
      [32mâœ“ [m[32mis transitive for "arbitrary Int"'s[m                                                                                                                                                                                                                                         [32m      0.78 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32mis equivalent to (\a b -> compare a b /= LT) for "arbitrary Int"'s[m                                                                                                                                                                                                          [32m      1.01 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32mis reflexive for "arbitrary Int"'s[m                                                                                                                                                                                                                                          [32m      0.73 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32mis antisymmetric for "arbitrary Int"'s[m                                                                                                                                                                                                                                      [32m      0.75 ms[m
        passed for all of [32m100[m inputs.
  [33mOrd Int[m
    [33m(>=) :: Int -> Int -> Bool[m
      [32mâœ“ [m[32mis antisymmetric for "valid Int"'s[m                                                                                                                                                                                                                                          [32m      0.72 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32mis equivalent to (\a b -> compare a b /= LT) for "valid Int"'s[m                                                                                                                                                                                                              [32m      0.77 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32mis transitive for "valid Int"'s[m                                                                                                                                                                                                                                             [32m      0.71 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32mis reflexive for "valid Int"'s[m                                                                                                                                                                                                                                              [32m      0.71 ms[m
        passed for all of [32m100[m inputs.
    [33m"max :: (Int -> Int -> Int)"[m
      [32mâœ“ [m[32mis equivalent to (\a b -> if a >= b then a else b) for "valid Int"'s[m                                                                                                                                                                                                        [32m      0.99 ms[m
        passed for all of [32m100[m inputs.
    [33m"min :: (Int -> Int -> Int)"[m
      [32mâœ“ [m[32mis equivalent to (\a b -> if a <= b then a else b) for "valid Int"'s[m                                                                                                                                                                                                        [32m      3.13 ms[m
        passed for all of [32m100[m inputs.
    [33m(>) :: Int -> Int -> Bool[m
      [32mâœ“ [m[32mis antireflexive for "valid Int"'s[m                                                                                                                                                                                                                                          [32m      2.80 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32mis equivalent to (\a b -> compare a b == GT) for "valid Int"'s[m                                                                                                                                                                                                              [32m      0.82 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32mis transitive for "valid Int"'s[m                                                                                                                                                                                                                                             [32m      0.55 ms[m
        passed for all of [32m100[m inputs.
    [33m(<) :: Int -> Int -> Bool[m
      [32mâœ“ [m[32mis antireflexive for "valid Int"'s[m                                                                                                                                                                                                                                          [32m      0.74 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32mis transitive for "valid Int"'s[m                                                                                                                                                                                                                                             [32m      2.56 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32mis equivalent to (\a b -> compare a b == LT) for "valid Int"'s[m                                                                                                                                                                                                              [32m      0.75 ms[m
        passed for all of [32m100[m inputs.
    [33m(<=) :: Int -> Int -> Bool[m
      [32mâœ“ [m[32mis antisymmetric for "valid Int"'s[m                                                                                                                                                                                                                                          [32m      0.71 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32mis equivalent to (\a b -> compare a b /= GT) for "valid Int"'s[m                                                                                                                                                                                                              [32m      0.79 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32mis transitive for "valid Int"'s[m                                                                                                                                                                                                                                             [32m      0.67 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32mis reflexive for "valid Int"'s[m                                                                                                                                                                                                                                              [32m      0.49 ms[m
        passed for all of [32m100[m inputs.
  [33mOrd Int[m
    [33m(>=) :: Int -> Int -> Bool[m
      [32mâœ“ [m[32mis transitive for "even Int"'s[m                                                                                                                                                                                                                                              [32m      1.81 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32mis equivalent to (\a b -> compare a b /= LT) for "even Int"'s[m                                                                                                                                                                                                               [32m      0.31 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32mis antisymmetric for "even Int"'s[m                                                                                                                                                                                                                                           [32m      0.30 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32mis reflexive for "even Int"'s[m                                                                                                                                                                                                                                               [32m      0.17 ms[m
        passed for all of [32m100[m inputs.
    [33m(<) :: Int -> Int -> Bool[m
      [32mâœ“ [m[32mis equivalent to (\a b -> compare a b == LT) for "even Int"'s[m                                                                                                                                                                                                               [32m      0.57 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32mis antireflexive for "even Int"'s[m                                                                                                                                                                                                                                           [32m      0.90 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32mis transitive for "even Int"'s[m                                                                                                                                                                                                                                              [32m      0.66 ms[m
        passed for all of [32m100[m inputs.
    [33m(>) :: Int -> Int -> Bool[m
      [32mâœ“ [m[32mis transitive for "even Int"'s[m                                                                                                                                                                                                                                              [32m      0.98 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32mis equivalent to (\a b -> compare a b == GT) for "even Int"'s[m                                                                                                                                                                                                               [32m      0.24 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32mis antireflexive for "even Int"'s[m                                                                                                                                                                                                                                           [32m      0.08 ms[m
        passed for all of [32m100[m inputs.
    [33m"max :: (Int -> Int -> Int)"[m
      [32mâœ“ [m[32mis equivalent to (\a b -> if a >= b then a else b) for "even Int"'s[m                                                                                                                                                                                                         [32m      0.95 ms[m
        passed for all of [32m100[m inputs.
    [33m"min :: (Int -> Int -> Int)"[m
      [32mâœ“ [m[32mis equivalent to (\a b -> if a <= b then a else b) for "even Int"'s[m                                                                                                                                                                                                         [32m      0.17 ms[m
        passed for all of [32m100[m inputs.
    [33m(<=) :: Int -> Int -> Bool[m
      [32mâœ“ [m[32mis transitive for "even Int"'s[m                                                                                                                                                                                                                                              [32m      1.01 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32mis reflexive for "even Int"'s[m                                                                                                                                                                                                                                               [32m      0.11 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32mis equivalent to (\a b -> compare a b /= GT) for "even Int"'s[m                                                                                                                                                                                                               [32m      4.57 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32mis antisymmetric for "even Int"'s[m                                                                                                                                                                                                                                           [32m      1.06 ms[m
        passed for all of [32m100[m inputs.
[33mTest.Syd.Validity.MonadSpec[m
  [33mMonad [][m
    [33mrelation with Applicative [][m
      [32mâœ“ [m[32msatisfies 'pure = return' for "[] of ints :: [Int]"[m                                                                                                                                                                                                                         [32m      0.99 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32msatisfies '(>>) = (*>)' for "[] of ints :: [Int]" and "[] of ints :: [Int]"[m                                                                                                                                                                                                 [33m     10.16 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32msatisfies '(<*>) = ap' for "[] of additions :: ([Int -> Int])" and "[] of ints :: [Int]"[m                                                                                                                                                                                    [32m      1.29 ms[m
        passed for all of [32m100[m inputs.
    [33mrelation with Functor [][m
      [32mâœ“ [m[32msatisfies 'fmap f xs = xs >>= return . f' for "increments :: (Int -> Int)" and "[] of ints :: [Int]"[m                                                                                                                                                                        [32m      0.65 ms[m
        passed for all of [32m100[m inputs.
    [33m(>>=) :: [] a -> (b -> [] a) -> [] b[m
      [32mâœ“ [m[32msatisfies the third Monad law: 'm >>= (x -> k x >>= h) = (m >>= k) >>= h' for "[] of ints :: [Int]" "perturbations using the int :: (Int -> [Int])" and "perturbations using the double the int :: (Int -> [Int])"[m                                                              138.65 ms
        passed for all of [32m100[m inputs.
    [33mreturn :: a -> [] a and (>>=) :: [] a -> (b -> [] a) -> [] b[m
      [32mâœ“ [m[32msatisfy the first Monad law: 'return a >>= k = k a' for "int :: Int" and "perturbations using the int :: (Int -> [Int])"[m                                                                                                                                                    [32m      0.40 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32msatisfy the second Monad law: 'm >>= return = m' for "[] of ints :: [Int]"[m                                                                                                                                                                                                  [32m      0.59 ms[m
        passed for all of [32m100[m inputs.
  [33mMonad Maybe[m
    [33m(>>=) :: Maybe a -> (b -> Maybe a) -> Maybe b[m
      [32mâœ“ [m[32msatisfies the third Monad law: 'm >>= (x -> k x >>= h) = (m >>= k) >>= h' for "Maybe of ints :: (Maybe Int)" "perturbations using the int :: (Int -> Maybe Int)" and "perturbations using the double the int :: (Int -> Maybe Int)"[m                                         [32m      0.39 ms[m
        passed for all of [32m100[m inputs.
    [33mreturn :: a -> Maybe a and (>>=) :: Maybe a -> (b -> Maybe a) -> Maybe b[m
      [32mâœ“ [m[32msatisfy the second Monad law: 'm >>= return = m' for "Maybe of ints :: (Maybe Int)"[m                                                                                                                                                                                         [32m      0.35 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32msatisfy the first Monad law: 'return a >>= k = k a' for "int :: Int" and "perturbations using the int :: (Int -> Maybe Int)"[m                                                                                                                                                [32m      0.14 ms[m
        passed for all of [32m100[m inputs.
    [33mrelation with Functor Maybe[m
      [32mâœ“ [m[32msatisfies 'fmap f xs = xs >>= return . f' for "increments :: (Int -> Int)" and "Maybe of ints :: (Maybe Int)"[m                                                                                                                                                               [32m      0.18 ms[m
        passed for all of [32m100[m inputs.
    [33mrelation with Applicative Maybe[m
      [32mâœ“ [m[32msatisfies '(<*>) = ap' for "Maybe of additions :: (Maybe (Int -> Int))" and "Maybe of ints :: (Maybe Int)"[m                                                                                                                                                                  [32m      0.22 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32msatisfies 'pure = return' for "Maybe of ints :: (Maybe Int)"[m                                                                                                                                                                                                                [32m      0.28 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32msatisfies '(>>) = (*>)' for "Maybe of ints :: (Maybe Int)" and "Maybe of ints :: (Maybe Int)"[m                                                                                                                                                                               [32m      0.13 ms[m
        passed for all of [32m100[m inputs.
  [33mMonad Maybe[m
    [33m(>>=) :: Maybe a -> (b -> Maybe a) -> Maybe b[m
      [32mâœ“ [m[32msatisfies the third Monad law: 'm >>= (x -> k x >>= h) = (m >>= k) >>= h' for "Maybe of ints :: (Maybe Int)" "perturbations using the int :: (Int -> Maybe Int)" and "perturbations using the double the int :: (Int -> Maybe Int)"[m                                         [32m      0.26 ms[m
        passed for all of [32m100[m inputs.
    [33mrelation with Applicative Maybe[m
      [32mâœ“ [m[32msatisfies 'pure = return' for "Maybe of ints :: (Maybe Int)"[m                                                                                                                                                                                                                [32m      0.13 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32msatisfies '(>>) = (*>)' for "Maybe of ints :: (Maybe Int)" and "Maybe of ints :: (Maybe Int)"[m                                                                                                                                                                               [32m      0.12 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32msatisfies '(<*>) = ap' for "Maybe of additions :: (Maybe (Int -> Int))" and "Maybe of ints :: (Maybe Int)"[m                                                                                                                                                                  [32m      0.37 ms[m
        passed for all of [32m100[m inputs.
    [33mreturn :: a -> Maybe a and (>>=) :: Maybe a -> (b -> Maybe a) -> Maybe b[m
      [32mâœ“ [m[32msatisfy the second Monad law: 'm >>= return = m' for "Maybe of ints :: (Maybe Int)"[m                                                                                                                                                                                         [32m      0.19 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32msatisfy the first Monad law: 'return a >>= k = k a' for "int :: Int" and "perturbations using the int :: (Int -> Maybe Int)"[m                                                                                                                                                [32m      0.23 ms[m
        passed for all of [32m100[m inputs.
    [33mrelation with Functor Maybe[m
      [32mâœ“ [m[32msatisfies 'fmap f xs = xs >>= return . f' for "increments :: (Int -> Int)" and "Maybe of ints :: (Maybe Int)"[m                                                                                                                                                               [32m      0.34 ms[m
        passed for all of [32m100[m inputs.
  [33mMonad (Either Int)[m
    [33mreturn :: a -> (Either Int) a and (>>=) :: (Either Int) a -> (b -> (Either Int) a) -> (Either Int) b[m
      [32mâœ“ [m[32msatisfy the second Monad law: 'm >>= return = m' for "(Either Int) of ints :: (Either Int Int)"[m                                                                                                                                                                             [32m      0.16 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32msatisfy the first Monad law: 'return a >>= k = k a' for "int :: Int" and "perturbations using the int :: (Int -> Either Int Int)"[m                                                                                                                                           [32m      1.23 ms[m
        passed for all of [32m100[m inputs.
    [33mrelation with Applicative (Either Int)[m
      [32mâœ“ [m[32msatisfies '(<*>) = ap' for "(Either Int) of additions :: (Either Int (Int -> Int))" and "(Either Int) of ints :: (Either Int Int)"[m                                                                                                                                          [32m      0.36 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32msatisfies 'pure = return' for "(Either Int) of ints :: (Either Int Int)"[m                                                                                                                                                                                                    [32m      1.20 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32msatisfies '(>>) = (*>)' for "(Either Int) of ints :: (Either Int Int)" and "(Either Int) of ints :: (Either Int Int)"[m                                                                                                                                                       [32m      0.19 ms[m
        passed for all of [32m100[m inputs.
    [33m(>>=) :: (Either Int) a -> (b -> (Either Int) a) -> (Either Int) b[m
      [32mâœ“ [m[32msatisfies the third Monad law: 'm >>= (x -> k x >>= h) = (m >>= k) >>= h' for "(Either Int) of ints :: (Either Int Int)" "perturbations using the int :: (Int -> Either Int Int)" and "perturbations using the double the int :: (Int -> Either Int Int)"[m                   [32m      0.29 ms[m
        passed for all of [32m100[m inputs.
    [33mrelation with Functor (Either Int)[m
      [32mâœ“ [m[32msatisfies 'fmap f xs = xs >>= return . f' for "increments :: (Int -> Int)" and "(Either Int) of ints :: (Either Int Int)"[m                                                                                                                                                   [32m      0.50 ms[m
        passed for all of [32m100[m inputs.
  [33mMonad Maybe[m
    [33mrelation with Functor Maybe[m
      [32mâœ“ [m[32msatisfies 'fmap f xs = xs >>= return . f' for "appends :: ([Char] -> [Char])" and "Just an ABC :: (Maybe [Char])"[m                                                                                                                                                           [32m      1.42 ms[m
        passed for all of [32m100[m inputs.
    [33mrelation with Applicative Maybe[m
      [32mâœ“ [m[32msatisfies 'pure = return' for "Just an ABC :: (Maybe [Char])"[m                                                                                                                                                                                                               [32m      0.12 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32msatisfies '(>>) = (*>)' for "Just an ABC :: (Maybe [Char])" and "Just an ABC :: (Maybe [Char])"[m                                                                                                                                                                             [32m      0.29 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32msatisfies '(<*>) = ap' for "append 'a' in Just :: (Maybe ([Char] -> [Char]))" and "Just an ABC :: (Maybe [Char])"[m                                                                                                                                                           [32m      0.16 ms[m
        passed for all of [32m100[m inputs.
    [33m(>>=) :: Maybe a -> (b -> Maybe a) -> Maybe b[m
      [32mâœ“ [m[32msatisfies the third Monad law: 'm >>= (x -> k x >>= h) = (m >>= k) >>= h' for "Just an ABC :: (Maybe [Char])" "justisation :: ([Char] -> Maybe [Char])" and "justisation :: ([Char] -> Maybe [Char])"[m                                                                       [32m      0.20 ms[m
        passed for all of [32m100[m inputs.
    [33mreturn :: a -> Maybe a and (>>=) :: Maybe a -> (b -> Maybe a) -> Maybe b[m
      [32mâœ“ [m[32msatisfy the second Monad law: 'm >>= return = m' for "Just an ABC :: (Maybe [Char])"[m                                                                                                                                                                                        [32m      0.15 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32msatisfy the first Monad law: 'return a >>= k = k a' for "ABC :: [Char]" and "justisation :: ([Char] -> Maybe [Char])"[m                                                                                                                                                       [32m      0.27 ms[m
        passed for all of [32m100[m inputs.
  [33mMonad [][m
    [33m(>>=) :: [] a -> (b -> [] a) -> [] b[m
      [32mâœ“ [m[32msatisfies the third Monad law: 'm >>= (x -> k x >>= h) = (m >>= k) >>= h' for "list of fives :: [Int]" "singletonisation :: (Int -> [Int])" and "singletonisation :: (Int -> [Int])"[m                                                                                        [32m      1.28 ms[m
        passed for all of [32m100[m inputs.
    [33mreturn :: a -> [] a and (>>=) :: [] a -> (b -> [] a) -> [] b[m
      [32mâœ“ [m[32msatisfy the second Monad law: 'm >>= return = m' for "list of fives :: [Int]"[m                                                                                                                                                                                               [32m      1.01 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32msatisfy the first Monad law: 'return a >>= k = k a' for "four :: Int" and "singletonisation :: (Int -> [Int])"[m                                                                                                                                                              [32m      0.22 ms[m
        passed for all of [32m100[m inputs.
    [33mrelation with Applicative [][m
      [32mâœ“ [m[32msatisfies 'pure = return' for "list of fives :: [Int]"[m                                                                                                                                                                                                                      [32m      0.93 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32msatisfies '(>>) = (*>)' for "list of fives :: [Int]" and "list of sixes :: [Int]"[m                                                                                                                                                                                           [32m      7.82 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32msatisfies '(<*>) = ap' for "increment in list :: ([Int -> Int])" and "list of fives :: [Int]"[m                                                                                                                                                                               [32m      1.30 ms[m
        passed for all of [32m100[m inputs.
    [33mrelation with Functor [][m
      [32mâœ“ [m[32msatisfies 'fmap f xs = xs >>= return . f' for "factorisations :: (Int -> Int)" and "list of fives :: [Int]"[m                                                                                                                                                                 [32m      3.74 ms[m
        passed for all of [32m100[m inputs.
  [33mMonad [][m
    [33mrelation with Functor [][m
      [32mâœ“ [m[32msatisfies 'fmap f xs = xs >>= return . f' for "increments :: (Int -> Int)" and "[] of ints :: [Int]"[m                                                                                                                                                                        [32m      1.41 ms[m
        passed for all of [32m100[m inputs.
    [33m(>>=) :: [] a -> (b -> [] a) -> [] b[m
      [32mâœ“ [m[32msatisfies the third Monad law: 'm >>= (x -> k x >>= h) = (m >>= k) >>= h' for "[] of ints :: [Int]" "perturbations using the int :: (Int -> [Int])" and "perturbations using the double the int :: (Int -> [Int])"[m                                                              106.90 ms
        passed for all of [32m100[m inputs.
    [33mrelation with Applicative [][m
      [32mâœ“ [m[32msatisfies '(>>) = (*>)' for "[] of ints :: [Int]" and "[] of ints :: [Int]"[m                                                                                                                                                                                                 [32m      8.18 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32msatisfies 'pure = return' for "[] of ints :: [Int]"[m                                                                                                                                                                                                                         [32m      0.22 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32msatisfies '(<*>) = ap' for "[] of additions :: ([Int -> Int])" and "[] of ints :: [Int]"[m                                                                                                                                                                                    [32m      1.18 ms[m
        passed for all of [32m100[m inputs.
    [33mreturn :: a -> [] a and (>>=) :: [] a -> (b -> [] a) -> [] b[m
      [32mâœ“ [m[32msatisfy the first Monad law: 'return a >>= k = k a' for "int :: Int" and "perturbations using the int :: (Int -> [Int])"[m                                                                                                                                                    [32m      0.93 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32msatisfy the second Monad law: 'm >>= return = m' for "[] of ints :: [Int]"[m                                                                                                                                                                                                  [32m      2.66 ms[m
        passed for all of [32m100[m inputs.
[33mTest.Syd.Validity.EqSpec[m
  [33mEq (Ratio Integer)[m
    [33m(==) :: (Ratio Integer) -> (Ratio Integer) -> Bool[m
      [32mâœ“ [m[32mis equivalent to (\a b -> not $ a /= b) for "valid (Ratio Integer)"s[m                                                                                                                                                                                                        [32m      5.92 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32mis transitive for "valid (Ratio Integer)"s[m                                                                                                                                                                                                                                  [32m      4.19 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32mis reflexive for "valid (Ratio Integer)"s[m                                                                                                                                                                                                                                   [32m      0.94 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32mis symmetric for "valid (Ratio Integer)"s[m                                                                                                                                                                                                                                   [32m      3.56 ms[m
        passed for all of [32m100[m inputs.
    [33m(/=) :: (Ratio Integer) -> (Ratio Integer) -> Bool[m
      [32mâœ“ [m[32mis equivalent to (\a b -> not $ a == b) for "valid (Ratio Integer)"s[m                                                                                                                                                                                                        [32m      2.15 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32mis antireflexive for "valid (Ratio Integer)"s[m                                                                                                                                                                                                                               [32m      2.17 ms[m
        passed for all of [32m100[m inputs.
  [33mEq Int[m
    [33m(==) :: Int -> Int -> Bool[m
      [32mâœ“ [m[32mis equivalent to (\a b -> not $ a /= b) for "valid Int"s[m                                                                                                                                                                                                                    [32m      0.11 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32mis reflexive for "valid Int"s[m                                                                                                                                                                                                                                               [32m      0.09 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32mis transitive for "valid Int"s[m                                                                                                                                                                                                                                              [32m      0.12 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32mis symmetric for "valid Int"s[m                                                                                                                                                                                                                                               [32m      0.08 ms[m
        passed for all of [32m100[m inputs.
    [33m(/=) :: Int -> Int -> Bool[m
      [32mâœ“ [m[32mis equivalent to (\a b -> not $ a == b) for "valid Int"s[m                                                                                                                                                                                                                    [32m      0.21 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32mis antireflexive for "valid Int"s[m                                                                                                                                                                                                                                           [32m      0.10 ms[m
        passed for all of [32m100[m inputs.
  [33mEq Int[m
    [33m(==) :: Int -> Int -> Bool[m
      [32mâœ“ [m[32mis transitive for "arbitrary Int"s[m                                                                                                                                                                                                                                          [32m      0.09 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32mis symmetric for "arbitrary Int"s[m                                                                                                                                                                                                                                           [32m      0.08 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32mis reflexive for "arbitrary Int"s[m                                                                                                                                                                                                                                           [32m      0.08 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32mis equivalent to (\a b -> not $ a /= b) for "arbitrary Int"s[m                                                                                                                                                                                                                [32m      0.37 ms[m
        passed for all of [32m100[m inputs.
    [33m(/=) :: Int -> Int -> Bool[m
      [32mâœ“ [m[32mis antireflexive for "arbitrary Int"s[m                                                                                                                                                                                                                                       [32m      0.08 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32mis equivalent to (\a b -> not $ a == b) for "arbitrary Int"s[m                                                                                                                                                                                                                [32m      0.11 ms[m
        passed for all of [32m100[m inputs.
  [33mEq Int[m
    [33m(/=) :: Int -> Int -> Bool[m
      [32mâœ“ [m[32mis antireflexive for "even Int"s[m                                                                                                                                                                                                                                            [32m      0.09 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32mis equivalent to (\a b -> not $ a == b) for "even Int"s[m                                                                                                                                                                                                                     [32m      0.09 ms[m
        passed for all of [32m100[m inputs.
    [33m(==) :: Int -> Int -> Bool[m
      [32mâœ“ [m[32mis equivalent to (\a b -> not $ a /= b) for "even Int"s[m                                                                                                                                                                                                                     [32m      0.14 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32mis symmetric for "even Int"s[m                                                                                                                                                                                                                                                [32m      0.20 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32mis reflexive for "even Int"s[m                                                                                                                                                                                                                                                [32m      0.08 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32mis transitive for "even Int"s[m                                                                                                                                                                                                                                               [32m      0.12 ms[m
        passed for all of [32m100[m inputs.
[33mTest.Syd.Validity.ArbitrarySpec[m
  [33mArbitrary Int[m
    [33marbitrary :: Gen Int[m
      [32mâœ“ [m[32monly generates valid values[m                                                                                                                                                                                                                                                 [32m      0.24 ms[m
        passed for all of [32m100[m inputs.
[33mTest.Syd.Validity.Operations.CommutativitySpec[m
  [33mcommutative[m
    [32mâœ“ [m[32mcross product is not commutative[m                                                                                                                                                                                                                                              [32m      0.25 ms[m
      passed for all of [32m1[m inputs.
    [32mâœ“ [m[32m+ is commutative[m                                                                                                                                                                                                                                                              [32m      0.17 ms[m
      passed for all of [32m100[m inputs.
    [32mâœ“ [m[32m* is commutative[m                                                                                                                                                                                                                                                              [32m      0.21 ms[m
      passed for all of [32m100[m inputs.
    [32mâœ“ [m[32m- is not commutative[m                                                                                                                                                                                                                                                          [32m      0.49 ms[m
      passed for all of [32m1[m inputs.
    [32mâœ“ [m[32mdot product is commutative[m                                                                                                                                                                                                                                                    [32m      0.79 ms[m
      passed for all of [32m100[m inputs.
[33mTest.Syd.Validity.GenValiditySpec[m
  [33mGenValid (Ratio Integer)[m
    [33mgenValid   :: Gen (Ratio Integer)[m
      [32mâœ“ [m[32monly generates valid '(Ratio Integer)'s[m                                                                                                                                                                                                                                     [32m      0.90 ms[m
        passed for all of [32m100[m inputs.
  [33mGenValid (Ratio Integer)[m
    [33mgenValid   :: Gen (Ratio Integer)[m
      [32mâœ“ [m[32monly generates valid '(Ratio Integer)'s[m                                                                                                                                                                                                                                     [32m      0.91 ms[m
        passed for all of [32m100[m inputs.
[33mTest.Syd.Validity.ShrinkingSpec[m
  [33mshrinkValid :: (Int -> [Int])[m
    [32mâœ“ [m[32mpreserves validity[m                                                                                                                                                                                                                                                            [32m      2.73 ms[m
      passed for all of [32m100[m inputs.
    [32mâœ“ [m[32mnever shrinks to itself for valid values[m                                                                                                                                                                                                                                      [32m      6.39 ms[m
      passed for all of [32m100[m inputs.
  [33mshrinkValidPreservesValidOnGenValid[m
    [32mâœ“ [m[32m[Ordering][m                                                                                                                                                                                                                                                                    [32m      8.20 ms[m
      passed for all of [32m100[m inputs.
    [32mâœ“ [m[32mOrdering[m                                                                                                                                                                                                                                                                      [32m      0.22 ms[m
      passed for all of [32m100[m inputs.
  [33mshrinkValid :: (Ratio Int8 -> [Ratio Int8])[m
    [32mâœ“ [m[32mnever shrinks to itself for valid values[m                                                                                                                                                                                                                                      [32m      4.76 ms[m
      passed for all of [32m100[m inputs.
    [32mâœ“ [m[32mpreserves validity[m                                                                                                                                                                                                                                                            [32m      6.24 ms[m
      passed for all of [32m100[m inputs.
  [33mshrinkValidDoesNotShrinkToItself[m
    [32mâœ“ [m[32m[Int][m                                                                                                                                                                                                                                                                         [33m     74.55 ms[m
      passed for all of [32m100[m inputs.
    [32mâœ“ [m[32mInt[m                                                                                                                                                                                                                                                                           [32m      6.68 ms[m
      passed for all of [32m100[m inputs.
  [33mshrinkValidDoesNotShrinkToItself[m
    [32mâœ“ [m[32m[Ordering][m                                                                                                                                                                                                                                                                    [32m      8.79 ms[m
      passed for all of [32m100[m inputs.
    [32mâœ“ [m[32mOrdering[m                                                                                                                                                                                                                                                                      [32m      0.59 ms[m
      passed for all of [32m100[m inputs.
  [33mshrinkValidPreservesValidOnGenValid[m
    [32mâœ“ [m[32mOrdering[m                                                                                                                                                                                                                                                                      [32m      0.40 ms[m
      passed for all of [32m100[m inputs.
    [32mâœ“ [m[32m[Ordering][m                                                                                                                                                                                                                                                                    [33m     10.42 ms[m
      passed for all of [32m100[m inputs.
[33mTest.Syd.Validity.FunctorSpec[m
  [33mFunctor Maybe[m
    [33mfmap :: (a -> b) -> Maybe a -> Maybe b[m
      [32mâœ“ [m[32msatisfieds the second Functor law: 'fmap (f . g) == fmap f . fmap g' for "Just an ABC :: (Maybe [Char])" 's given to "prepends :: ([Char] -> [Char])" and "appends :: ([Char] -> [Char])"[m                                                                                   [32m      1.54 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32msatisfies the first Fuctor law: 'fmap id == id' for "Just an ABC :: (Maybe [Char])"[m                                                                                                                                                                                         [32m      0.09 ms[m
        passed for all of [32m100[m inputs.
    [33m(<$) :: a -> Maybe b -> Maybe a[m
      [32mâœ“ [m[32mis equivalent to its default implementation for "ABC :: [Char]" and "Just an ABC :: (Maybe [Char])"[m                                                                                                                                                                         [32m      0.23 ms[m
        passed for all of [32m100[m inputs.
  [33mFunctor [][m
    [33mfmap :: (a -> b) -> [] a -> [] b[m
      [32mâœ“ [m[32msatisfies the first Fuctor law: 'fmap id == id' for "list of fives :: [Int]"[m                                                                                                                                                                                                [32m      1.43 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32msatisfieds the second Functor law: 'fmap (f . g) == fmap f . fmap g' for "list of fives :: [Int]" 's given to "increments :: (Int -> Int)" and "scalings :: (Int -> Int)"[m                                                                                                   [32m      1.31 ms[m
        passed for all of [32m100[m inputs.
    [33m(<$) :: a -> [] b -> [] a[m
      [32mâœ“ [m[32mis equivalent to its default implementation for "four :: Int" and "list of fives :: [Int]"[m                                                                                                                                                                                  [32m      0.32 ms[m
        passed for all of [32m100[m inputs.
  [33mFunctor [][m
    [33m(<$) :: a -> [] b -> [] a[m
      [32mâœ“ [m[32mis equivalent to its default implementation for "int :: Int" and "[] of ints :: [Int]"[m                                                                                                                                                                                      [32m      2.83 ms[m
        passed for all of [32m100[m inputs.
    [33mfmap :: (a -> b) -> [] a -> [] b[m
      [32mâœ“ [m[32msatisfieds the second Functor law: 'fmap (f . g) == fmap f . fmap g' for "[] of ints :: [Int]" 's given to "increments :: (Int -> Int)" and "scalings :: (Int -> Int)"[m                                                                                                      [32m      2.98 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32msatisfies the first Fuctor law: 'fmap id == id' for "[] of ints :: [Int]"[m                                                                                                                                                                                                   [32m      1.00 ms[m
        passed for all of [32m100[m inputs.
  [33mFunctor (Either Int)[m
    [33mfmap :: (a -> b) -> (Either Int) a -> (Either Int) b[m
      [32mâœ“ [m[32msatisfies the first Fuctor law: 'fmap id == id' for "(Either Int) of ints :: (Either Int Int)"[m                                                                                                                                                                              [32m      0.18 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32msatisfieds the second Functor law: 'fmap (f . g) == fmap f . fmap g' for "(Either Int) of ints :: (Either Int Int)" 's given to "increments :: (Int -> Int)" and "scalings :: (Int -> Int)"[m                                                                                 [32m      1.10 ms[m
        passed for all of [32m100[m inputs.
    [33m(<$) :: a -> (Either Int) b -> (Either Int) a[m
      [32mâœ“ [m[32mis equivalent to its default implementation for "int :: Int" and "(Either Int) of ints :: (Either Int Int)"[m                                                                                                                                                                 [32m      0.32 ms[m
        passed for all of [32m100[m inputs.
  [33mFunctor [][m
    [33m(<$) :: a -> [] b -> [] a[m
      [32mâœ“ [m[32mis equivalent to its default implementation for "int :: Int" and "[] of ints :: [Int]"[m                                                                                                                                                                                      [32m      1.21 ms[m
        passed for all of [32m100[m inputs.
    [33mfmap :: (a -> b) -> [] a -> [] b[m
      [32mâœ“ [m[32msatisfies the first Fuctor law: 'fmap id == id' for "[] of ints :: [Int]"[m                                                                                                                                                                                                   [32m      0.82 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32msatisfieds the second Functor law: 'fmap (f . g) == fmap f . fmap g' for "[] of ints :: [Int]" 's given to "increments :: (Int -> Int)" and "scalings :: (Int -> Int)"[m                                                                                                      [32m      3.04 ms[m
        passed for all of [32m100[m inputs.
  [33mFunctor Maybe[m
    [33m(<$) :: a -> Maybe b -> Maybe a[m
      [32mâœ“ [m[32mis equivalent to its default implementation for "int :: Int" and "Maybe of ints :: (Maybe Int)"[m                                                                                                                                                                             [32m      0.57 ms[m
        passed for all of [32m100[m inputs.
    [33mfmap :: (a -> b) -> Maybe a -> Maybe b[m
      [32mâœ“ [m[32msatisfieds the second Functor law: 'fmap (f . g) == fmap f . fmap g' for "Maybe of ints :: (Maybe Int)" 's given to "increments :: (Int -> Int)" and "scalings :: (Int -> Int)"[m                                                                                             [32m      0.29 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32msatisfies the first Fuctor law: 'fmap id == id' for "Maybe of ints :: (Maybe Int)"[m                                                                                                                                                                                          [32m      0.11 ms[m
        passed for all of [32m100[m inputs.
  [33mFunctor ((,) Int)[m
    [33mfmap :: (a -> b) -> ((,) Int) a -> ((,) Int) b[m
      [32mâœ“ [m[32msatisfieds the second Functor law: 'fmap (f . g) == fmap f . fmap g' for "((,) Int) of ints :: (Int,Int)" 's given to "increments :: (Int -> Int)" and "scalings :: (Int -> Int)"[m                                                                                           [32m      0.42 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32msatisfies the first Fuctor law: 'fmap id == id' for "((,) Int) of ints :: (Int,Int)"[m                                                                                                                                                                                        [32m      0.17 ms[m
        passed for all of [32m100[m inputs.
    [33m(<$) :: a -> ((,) Int) b -> ((,) Int) a[m
      [32mâœ“ [m[32mis equivalent to its default implementation for "int :: Int" and "((,) Int) of ints :: (Int,Int)"[m                                                                                                                                                                           [32m      0.19 ms[m
        passed for all of [32m100[m inputs.
  [33mFunctor Maybe[m
    [33m(<$) :: a -> Maybe b -> Maybe a[m
      [32mâœ“ [m[32mis equivalent to its default implementation for "int :: Int" and "Maybe of ints :: (Maybe Int)"[m                                                                                                                                                                             [32m      0.18 ms[m
        passed for all of [32m100[m inputs.
    [33mfmap :: (a -> b) -> Maybe a -> Maybe b[m
      [32mâœ“ [m[32msatisfieds the second Functor law: 'fmap (f . g) == fmap f . fmap g' for "Maybe of ints :: (Maybe Int)" 's given to "increments :: (Int -> Int)" and "scalings :: (Int -> Int)"[m                                                                                             [32m      0.40 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32msatisfies the first Fuctor law: 'fmap id == id' for "Maybe of ints :: (Maybe Int)"[m                                                                                                                                                                                          [32m      0.13 ms[m
        passed for all of [32m100[m inputs.
[33mTest.Syd.Validity.ShowSpec[m
  [33mShow (Ratio Integer) and Read (Ratio Integer)[m
    [32mâœ“ [m[32mare implemented such that read . show == id for arbitrary values[m                                                                                                                                                                                                              [32m      0.73 ms[m
      passed for all of [32m100[m inputs.
  [33mShow Int and Read Int[m
    [32mâœ“ [m[32mare implemented such that read . show == id for valid values[m                                                                                                                                                                                                                  [32m      0.60 ms[m
      passed for all of [32m100[m inputs.
  [33mShow (Ratio Integer) and Read (Ratio Integer)[m
    [32mâœ“ [m[32mare implemented such that read . show == id for valid values[m                                                                                                                                                                                                                  [32m      1.81 ms[m
      passed for all of [32m100[m inputs.
  [33mShow Int and Read Int[m
    [32mâœ“ [m[32mare implemented such that read . show == id for even values[m                                                                                                                                                                                                                   [32m      0.72 ms[m
      passed for all of [32m100[m inputs.
[33mTest.Syd.Validity.ApplicativeSpec[m
  [33mApplicative [][m
    [33m(*>) :: [] a -> [] b -> [] b[m
      [32mâœ“ [m[32mis equivalent to its default implementation 'u Type> v = pure (const id) <*> u <*> v' for "[] of ints :: [Int]" in front of "[] of ints :: Int"[m                                                                                                                             [32m      6.36 ms[m
        passed for all of [32m100[m inputs.
    [33mpure :: a -> [] a and (<*>) :: [] (a -> b) -> [] a -> [] b[m
      [32mâœ“ [m[32msatisfy the interchange law: 'u <*> pure y = pure ($ y) <*> u' for "[] of increments :: ([Int -> Int])" sequenced with "int :: Int"[m                                                                                                                                         [32m      0.20 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32msatisfy the law about the functor instance: fmap f x = pure f <*> x for "increments :: (Int -> Int)" mapped over "[] of ints :: [Int]"[m                                                                                                                                      [32m      1.27 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32msatisfy the identity law: 'pure id <*> v = v' for "[] of ints :: [Int]"[m                                                                                                                                                                                                     [32m      1.02 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32msatisfy the composition law: 'pure (.) <*> u <*> v <*> w = u <*> (v <*> w)' for "[] of scalings :: ([Int -> Int])" composed with "[] of increments :: ([Int -> Int])" and applied to "[] of ints :: [Int]"[m                                                                  [32m      1.22 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32msatisfy the homomorphism law: 'pure f <*> pure x = pure (f x)' for "increments :: (Int -> Int)" sequenced with "int :: Int"[m                                                                                                                                                 [32m      0.83 ms[m
        passed for all of [32m100[m inputs.
    [33m(<*) :: [] a -> [] b -> [] a[m
      [32mâœ“ [m[32mis equivalent to its default implementation 'u <* v = pure const <*> u <*> v' for "[] of ints :: Int" behind "[] of ints :: [Int]"[m                                                                                                                                          [32m      5.29 ms[m
        passed for all of [32m100[m inputs.
  [33mApplicative (Either Int)[m
    [33m(*>) :: (Either Int) a -> (Either Int) b -> (Either Int) b[m
      [32mâœ“ [m[32mis equivalent to its default implementation 'u Type> v = pure (const id) <*> u <*> v' for "(Either Int) of ints :: (Either Int Int)" in front of "(Either Int) of ints :: Int"[m                                                                                              [32m      0.16 ms[m
        passed for all of [32m100[m inputs.
    [33m(<*) :: (Either Int) a -> (Either Int) b -> (Either Int) a[m
      [32mâœ“ [m[32mis equivalent to its default implementation 'u <* v = pure const <*> u <*> v' for "(Either Int) of ints :: Int" behind "(Either Int) of ints :: (Either Int Int)"[m                                                                                                           [32m      0.62 ms[m
        passed for all of [32m100[m inputs.
    [33mpure :: a -> (Either Int) a and (<*>) :: (Either Int) (a -> b) -> (Either Int) a -> (Either Int) b[m
      [32mâœ“ [m[32msatisfy the identity law: 'pure id <*> v = v' for "(Either Int) of ints :: (Either Int Int)"[m                                                                                                                                                                                [32m      0.53 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32msatisfy the law about the functor instance: fmap f x = pure f <*> x for "increments :: (Int -> Int)" mapped over "(Either Int) of ints :: (Either Int Int)"[m                                                                                                                 [32m      0.47 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32msatisfy the composition law: 'pure (.) <*> u <*> v <*> w = u <*> (v <*> w)' for "(Either Int) of scalings :: (Either Int (Int -> Int))" composed with "(Either Int) of increments :: (Either Int (Int -> Int))" and applied to "(Either Int) of ints :: (Either Int Int)"[m   [32m      0.45 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32msatisfy the homomorphism law: 'pure f <*> pure x = pure (f x)' for "increments :: (Int -> Int)" sequenced with "int :: Int"[m                                                                                                                                                 [32m      0.48 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32msatisfy the interchange law: 'u <*> pure y = pure ($ y) <*> u' for "(Either Int) of increments :: (Either Int (Int -> Int))" sequenced with "int :: Int"[m                                                                                                                    [32m      0.13 ms[m
        passed for all of [32m100[m inputs.
  [33mApplicative Maybe[m
    [33mpure :: a -> Maybe a and (<*>) :: Maybe (a -> b) -> Maybe a -> Maybe b[m
      [32mâœ“ [m[32msatisfy the homomorphism law: 'pure f <*> pure x = pure (f x)' for "increments :: (Int -> Int)" sequenced with "int :: Int"[m                                                                                                                                                 [32m      0.12 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32msatisfy the interchange law: 'u <*> pure y = pure ($ y) <*> u' for "Maybe of increments :: (Maybe (Int -> Int))" sequenced with "int :: Int"[m                                                                                                                                [32m      0.10 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32msatisfy the law about the functor instance: fmap f x = pure f <*> x for "increments :: (Int -> Int)" mapped over "Maybe of ints :: (Maybe Int)"[m                                                                                                                             [32m      0.12 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32msatisfy the composition law: 'pure (.) <*> u <*> v <*> w = u <*> (v <*> w)' for "Maybe of scalings :: (Maybe (Int -> Int))" composed with "Maybe of increments :: (Maybe (Int -> Int))" and applied to "Maybe of ints :: (Maybe Int)"[m                                       [32m      0.41 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32msatisfy the identity law: 'pure id <*> v = v' for "Maybe of ints :: (Maybe Int)"[m                                                                                                                                                                                            [32m      0.11 ms[m
        passed for all of [32m100[m inputs.
    [33m(<*) :: Maybe a -> Maybe b -> Maybe a[m
      [32mâœ“ [m[32mis equivalent to its default implementation 'u <* v = pure const <*> u <*> v' for "Maybe of ints :: Int" behind "Maybe of ints :: (Maybe Int)"[m                                                                                                                              [32m      0.35 ms[m
        passed for all of [32m100[m inputs.
    [33m(*>) :: Maybe a -> Maybe b -> Maybe b[m
      [32mâœ“ [m[32mis equivalent to its default implementation 'u Type> v = pure (const id) <*> u <*> v' for "Maybe of ints :: (Maybe Int)" in front of "Maybe of ints :: Int"[m                                                                                                                 [32m      0.27 ms[m
        passed for all of [32m100[m inputs.
  [33mApplicative Maybe[m
    [33m(<*) :: Maybe a -> Maybe b -> Maybe a[m
      [32mâœ“ [m[32mis equivalent to its default implementation 'u <* v = pure const <*> u <*> v' for "purely Nothing :: [Char]" behind "Just an ABC :: (Maybe [Char])"[m                                                                                                                         [32m      0.08 ms[m
        passed for all of [32m100[m inputs.
    [33m(*>) :: Maybe a -> Maybe b -> Maybe b[m
      [32mâœ“ [m[32mis equivalent to its default implementation 'u Type> v = pure (const id) <*> u <*> v' for "Just an ABC :: (Maybe [Char])" in front of "purely Nothing :: [Char]"[m                                                                                                            [32m      0.10 ms[m
        passed for all of [32m100[m inputs.
    [33mpure :: a -> Maybe a and (<*>) :: Maybe (a -> b) -> Maybe a -> Maybe b[m
      [32mâœ“ [m[32msatisfy the identity law: 'pure id <*> v = v' for "Just an ABC :: (Maybe [Char])"[m                                                                                                                                                                                           [32m      0.09 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32msatisfy the law about the functor instance: fmap f x = pure f <*> x for "prepends :: ([Char] -> [Char])" mapped over "Just an ABC :: (Maybe [Char])"[m                                                                                                                        [32m      0.41 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32msatisfy the homomorphism law: 'pure f <*> pure x = pure (f x)' for "prepends :: ([Char] -> [Char])" sequenced with "ABC :: [Char]"[m                                                                                                                                          [32m      0.43 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32msatisfy the composition law: 'pure (.) <*> u <*> v <*> w = u <*> (v <*> w)' for "appends in a Just :: (Maybe ([Char] -> [Char]))" composed with "prepends in a Just :: (Maybe ([Char] -> [Char]))" and applied to "Just an ABC :: (Maybe [Char])"[m                           [32m      1.34 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32msatisfy the interchange law: 'u <*> pure y = pure ($ y) <*> u' for "prepends in a Just :: (Maybe ([Char] -> [Char]))" sequenced with "ABC :: [Char]"[m                                                                                                                        [32m      1.25 ms[m
        passed for all of [32m100[m inputs.
  [33mApplicative [][m
    [33m(*>) :: [] a -> [] b -> [] b[m
      [32mâœ“ [m[32mis equivalent to its default implementation 'u Type> v = pure (const id) <*> u <*> v' for "[] of ints :: [Int]" in front of "[] of ints :: Int"[m                                                                                                                             [32m      7.36 ms[m
        passed for all of [32m100[m inputs.
    [33mpure :: a -> [] a and (<*>) :: [] (a -> b) -> [] a -> [] b[m
      [32mâœ“ [m[32msatisfy the homomorphism law: 'pure f <*> pure x = pure (f x)' for "increments :: (Int -> Int)" sequenced with "int :: Int"[m                                                                                                                                                 [32m      0.17 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32msatisfy the composition law: 'pure (.) <*> u <*> v <*> w = u <*> (v <*> w)' for "[] of scalings :: ([Int -> Int])" composed with "[] of increments :: ([Int -> Int])" and applied to "[] of ints :: [Int]"[m                                                                  [32m      1.09 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32msatisfy the law about the functor instance: fmap f x = pure f <*> x for "increments :: (Int -> Int)" mapped over "[] of ints :: [Int]"[m                                                                                                                                      [32m      0.89 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32msatisfy the identity law: 'pure id <*> v = v' for "[] of ints :: [Int]"[m                                                                                                                                                                                                     [32m      0.79 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32msatisfy the interchange law: 'u <*> pure y = pure ($ y) <*> u' for "[] of increments :: ([Int -> Int])" sequenced with "int :: Int"[m                                                                                                                                         [32m      0.17 ms[m
        passed for all of [32m100[m inputs.
    [33m(<*) :: [] a -> [] b -> [] a[m
      [32mâœ“ [m[32mis equivalent to its default implementation 'u <* v = pure const <*> u <*> v' for "[] of ints :: Int" behind "[] of ints :: [Int]"[m                                                                                                                                          [33m     10.42 ms[m
        passed for all of [32m100[m inputs.
  [33mApplicative [][m
    [33mpure :: a -> [] a and (<*>) :: [] (a -> b) -> [] a -> [] b[m
      [32mâœ“ [m[32msatisfy the homomorphism law: 'pure f <*> pure x = pure (f x)' for "increments :: (Int -> Int)" sequenced with "four :: Int"[m                                                                                                                                                [32m      0.18 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32msatisfy the interchange law: 'u <*> pure y = pure ($ y) <*> u' for "increments in a list :: ([Int -> Int])" sequenced with "four :: Int"[m                                                                                                                                    [32m      0.12 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32msatisfy the composition law: 'pure (.) <*> u <*> v <*> w = u <*> (v <*> w)' for "scalings in a list :: ([Int -> Int])" composed with "increments in a list :: ([Int -> Int])" and applied to "list of fives :: [Int]"[m                                                       [32m      0.98 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32msatisfy the identity law: 'pure id <*> v = v' for "list of fives :: [Int]"[m                                                                                                                                                                                                  [32m      1.31 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32msatisfy the law about the functor instance: fmap f x = pure f <*> x for "increments :: (Int -> Int)" mapped over "list of fives :: [Int]"[m                                                                                                                                   [32m      1.38 ms[m
        passed for all of [32m100[m inputs.
    [33m(<*) :: [] a -> [] b -> [] a[m
      [32mâœ“ [m[32mis equivalent to its default implementation 'u <* v = pure const <*> u <*> v' for "purely empty list :: Int" behind "list of fives :: [Int]"[m                                                                                                                                [32m      0.61 ms[m
        passed for all of [32m100[m inputs.
    [33m(*>) :: [] a -> [] b -> [] b[m
      [32mâœ“ [m[32mis equivalent to its default implementation 'u Type> v = pure (const id) <*> u <*> v' for "list of fives :: [Int]" in front of "purely empty list :: Int"[m                                                                                                                   [32m      0.55 ms[m
        passed for all of [32m100[m inputs.
  [33mApplicative Maybe[m
    [33m(*>) :: Maybe a -> Maybe b -> Maybe b[m
      [32mâœ“ [m[32mis equivalent to its default implementation 'u Type> v = pure (const id) <*> u <*> v' for "Maybe of ints :: (Maybe Int)" in front of "Maybe of ints :: Int"[m                                                                                                                 [32m      0.11 ms[m
        passed for all of [32m100[m inputs.
    [33m(<*) :: Maybe a -> Maybe b -> Maybe a[m
      [32mâœ“ [m[32mis equivalent to its default implementation 'u <* v = pure const <*> u <*> v' for "Maybe of ints :: Int" behind "Maybe of ints :: (Maybe Int)"[m                                                                                                                              [32m      0.10 ms[m
        passed for all of [32m100[m inputs.
    [33mpure :: a -> Maybe a and (<*>) :: Maybe (a -> b) -> Maybe a -> Maybe b[m
      [32mâœ“ [m[32msatisfy the composition law: 'pure (.) <*> u <*> v <*> w = u <*> (v <*> w)' for "Maybe of scalings :: (Maybe (Int -> Int))" composed with "Maybe of increments :: (Maybe (Int -> Int))" and applied to "Maybe of ints :: (Maybe Int)"[m                                       [32m      0.26 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32msatisfy the identity law: 'pure id <*> v = v' for "Maybe of ints :: (Maybe Int)"[m                                                                                                                                                                                            [32m      0.12 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32msatisfy the law about the functor instance: fmap f x = pure f <*> x for "increments :: (Int -> Int)" mapped over "Maybe of ints :: (Maybe Int)"[m                                                                                                                             [32m      0.11 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32msatisfy the homomorphism law: 'pure f <*> pure x = pure (f x)' for "increments :: (Int -> Int)" sequenced with "int :: Int"[m                                                                                                                                                 [32m      0.11 ms[m
        passed for all of [32m100[m inputs.
      [32mâœ“ [m[32msatisfy the interchange law: 'u <*> pure y = pure ($ y) <*> u' for "Maybe of increments :: (Maybe (Int -> Int))" sequenced with "int :: Int"[m                                                                                                                                [32m      0.12 ms[m
        passed for all of [32m100[m inputs.
 
 
  Examples:                     [32m24402[m
  Passed:                       [32m246[m
  Failed:                       [32m0[m
  Sum of test runtimes:[33m         0.76 seconds[m
  Test suite took:     [33m         0.15 seconds[m
 
Test suite genvalidity-sydtest-test: PASS
Test suite logged to:
/tmp/workdir-genvalidity-sydtest/genvalidity-sydtest-1.0.0.0/dist-newstyle/build/x86_64-linux/ghc-9.6.6/genvalidity-sydtest-1.0.0.0/t/genvalidity-sydtest-test/test/genvalidity-sydtest-1.0.0.0-genvalidity-sydtest-test.log
1 of 1 test suites (1 of 1 test cases) passed.
