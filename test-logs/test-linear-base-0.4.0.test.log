Build profile: -w ghc-9.6.6 -O1
In order, the following will be built (use -v for more details):
 - linear-base-0.4.0 (test:test) (ephemeral targets)
Preprocessing test suite 'test' for linear-base-0.4.0...
Building test suite 'test' for linear-base-0.4.0...
Running 1 test suites...
Test suite test: RUNNING...
All tests
  Functional tests
    Mutable array tests
      ∀ s,i,x. read (alloc s x) i = x:                                                  OK (0.01s)
          ✓ readAlloc passed 100 tests.
      ∀ a,s,x,i. read (snd (allocBeside s x a)) i = x:                                  OK (0.14s)
          ✓ allocBeside passed 100 tests.
      ∀ s,a,i. i < length a, read (resize s 42 a) i = read a i:                         OK (0.19s)
          ✓ readResize passed 100 tests.
      ∀ a,i,x. read (write a i x) i = x :                                               OK (0.16s)
          ✓ readWrite1 passed 100 tests.
      ∀ a,i,j/=i,x. read (write a j x) i = read a i:                                    OK (0.19s)
          ✓ readWrite2 passed 100 tests.
      ∀ s,x. len (alloc s x) = s:                                                       OK
          ✓ lenAlloc passed 100 tests.
      ∀ a,i,x. len (write a i x) = len a:                                               OK (0.23s)
          ✓ lenWrite passed 100 tests.
      ∀ a,s,x. len (resize s x a) = s:                                                  OK (0.21s)
          ✓ lenResizeSeed passed 100 tests.
      ∀ a,ix. toList . write a ix = (\l -> take ix l ++ [a] ++ drop (ix+1) l) . toList: OK (0.16s)
          ✓ writeRef passed 100 tests.
      ∀ ix. read ix a = (toList a) !! i:                                                OK (0.22s)
          ✓ readRef passed 100 tests.
      size = length . toList:                                                           OK (0.17s)
          ✓ sizeRef passed 100 tests.
      ∀ a,s,x. resize s x a = take s (toList a ++ repeat x):                            OK (0.21s)
          ✓ resizeRef passed 100 tests.
      ∀ s,n. slice s n = take s . drop n:                                               OK (0.24s)
          ✓ sliceRef passed 100 tests.
      f <$> fromList xs == fromList (f <$> xs):                                         OK (0.14s)
          ✓ refFmap passed 100 tests.
      toList . fromList = id:                                                           OK (0.14s)
          ✓ refToListFromList passed 100 tests.
      toList . freeze . fromList = id:                                                  OK (0.21s)
          ✓ refFreeze passed 100 tests.
      dup2 produces identical arrays:                                                   OK (0.20s)
          ✓ refDupable passed 100 tests.
      do not reorder reads and writes:                                                  OK
          ✓ readAndWriteTest passed 1 test.
      do not evaluate values unnecesesarily:                                            OK
          ✓ strictnessTest passed 1 test.
    Mutable vector tests
      ∀ s,i,x. read (constant s x) i = x:                                               OK
          ✓ readConst passed 100 tests.
      ∀ a,i,x. read (write a i x) i = x :                                               OK (0.19s)
          ✓ readWrite1 passed 100 tests.
      ∀ a,i,j/=i,x. read (write a j x) i = read a i:                                    OK (0.19s)
          ✓ readWrite2 passed 100 tests.
      ∀ a,x,(i < len a). read (push a x) i = read a i:                                  OK (0.20s)
          ✓ readPush1 passed 100 tests.
      ∀ a,x. read (push a x) (len a) = x:                                               OK (0.19s)
          ✓ readPush2 passed 100 tests.
      ∀ s,x. len (constant s x) = s:                                                    OK
          ✓ lenConst passed 100 tests.
      ∀ a,i,x. len (write a i x) = len a:                                               OK (0.22s)
          ✓ lenWrite passed 100 tests.
      ∀ a,x. len (push a x) = 1 + len a:                                                OK (0.19s)
          ✓ lenPush passed 100 tests.
      write ix a v = (\l -> take ix l ++ [a] ++ drop (ix+1) l) . toList:                OK (0.18s)
          ✓ refWrite passed 100 tests.
      fst $ modify f ix v = snd $ f ((toList v) !! ix):                                 OK (0.17s)
          ✓ refModify1 passed 100 tests.
      snd (modify f i v) = write (toList v) i (fst (f ((toList v) !! i)))):             OK (0.23s)
          ✓ refModify2 passed 100 tests.
      toList . push x = snoc x . toList:                                                OK (0.21s)
          ✓ refPush passed 100 tests.
      toList . pop = init . toList:                                                     OK (0.20s)
          ✓ refPop passed 100 tests.
      read ix v = (toList v) !! ix:                                                     OK (0.25s)
          ✓ refRead passed 100 tests.
      size = length . toList:                                                           OK (0.16s)
          ✓ refSize passed 100 tests.
      toList . shrinkToFit = toList:                                                    OK (0.22s)
          ✓ refShrinkToFit passed 100 tests.
      pop . push _ = id:                                                                OK (0.19s)
          ✓ refPopPush passed 100 tests.
      push . pop = id:                                                                  OK (0.22s)
          ✓ refPushPop passed 100 tests.
      slice s n = take s . drop n:                                                      OK (0.22s)
          ✓ refSlice passed 100 tests.
      toList . fromList = id:                                                           OK (0.18s)
          ✓ refToListFromList passed 100 tests.
      toList can be implemented with repeated pops:                                     OK (0.22s)
          ✓ refToListViaPop passed 100 tests.
      fromList can be implemented with repeated pushes:                                 OK (0.23s)
          ✓ refFromListViaPush passed 100 tests.
      toList works with extra capacity:                                                 OK (0.20s)
          ✓ refToListWithExtraCapacity passed 100 tests.
      fromList xs <> fromList ys = fromList (xs <> ys):                                 OK (0.47s)
          ✓ refMappend passed 100 tests.
      mapMaybe f (fromList xs) = fromList (mapMaybe f xs):                              OK (0.19s)
          ✓ refMapMaybe passed 100 tests.
      filter f (fromList xs) = fromList (filter f xs):                                  OK (0.22s)
          ✓ refFilter passed 100 tests.
      f <$> fromList xs == fromList (f <$> xs):                                         OK (0.21s)
          ✓ refFmap passed 100 tests.
      toList . freeze . fromList = id:                                                  OK (0.21s)
          ✓ refFreeze passed 100 tests.
      push on an empty vector should succeed:                                           OK
          ✓ snocOnEmptyVector passed 1 test.
      do not reorder reads and writes:                                                  OK
          ✓ readAndWriteTest passed 1 test.
    Mutable hashmap tests
      ∀ k,v,m. lookup k (insert m k v) = Just v:                                        OK (5.84s)
          ✓ lookupInsert1 passed 1000 tests.
      ∀ k,v,m,k'/=k. lookup k'(insert m k v) = lookup k' m:                             OK (6.02s)
          ✓ lookuInsert2 passed 1000 tests.
      ∀ k,m. lookup k (delete m k) = Nothing:                                           OK (6.04s)
          ✓ lookupDelete1 passed 1000 tests.
      ∀ k,m,k'/=k. lookup k' (delete m k) = lookup k' m:                                OK (5.80s)
          ✓ lookupDelete2 passed 1000 tests.
      ∀ k,v,m. member k (insert m k v) = True:                                          OK (6.00s)
          ✓ memberInsert passed 1000 tests.
      ∀ k,m. member k (delete m k) = False:                                             OK (5.66s)
          ✓ memberDelete passed 1000 tests.
      ∀ k,v,m. size (insert (m-k) k v) = 1+ size (m-k):                                 OK (6.09s)
          ✓ sizeInsert passed 1000 tests.
      ∀ k,m with k. size (delete m k) + 1 = size m:                                     OK (6.07s)
          ✓ deleteSize passed 1000 tests.
      insert k v h = fromList (toList h ++ [(k,v)]):                                    OK (6.06s)
          ✓ refInsert passed 1000 tests.
      delete k h = fromList (filter (!= k . fst) (toList h)):                           OK (5.74s)
          ✓ refDelete passed 1000 tests.
      fst . lookup k h = lookup k (toList h):                                           OK (6.04s)
          ✓ refLookup passed 1000 tests.
      mapMaybe f h = fromList . mapMaybe (uncurry f) . toList:                          OK (6.15s)
          ✓ refMap passed 1000 tests.
      size = length . toList:                                                           OK (6.04s)
          ✓ refSize passed 1000 tests.
      toList . fromList = id:                                                           OK (5.99s)
          ✓ refToListFromList passed 1000 tests.
      filter f (fromList xs) = fromList (filter f xs):                                  OK (6.08s)
          ✓ refFilter passed 1000 tests.
      fromList xs <> fromList ys = fromList (xs <> ys):                                 OK (8.24s)
          ✓ refMappend passed 1000 tests.
      unionWith reference:                                                              OK (8.22s)
          ✓ refUnionWith passed 1000 tests.
      intersectionWith reference:                                                       OK (8.05s)
          ✓ refIntersectionWith passed 1000 tests.
      toList . shrinkToFit = toList:                                                    OK (6.10s)
          ✓ shrinkToFitTest passed 1000 tests.
    Mutable set tests
      ∀ x. member (insert s x) x = True:                                                OK (0.27s)
          ✓ memberInsert1 passed 100 tests.
      ∀ x,y/=x. member (insert s x) y = member s y:                                     OK (0.24s)
          ✓ memberInsert2 passed 100 tests.
      ∀ x. member (delete s x) x = False:                                               OK (0.26s)
          ✓ memberDelete1 passed 100 tests.
      ∀ x,y/=x. member (delete s x) y = member s y:                                     OK (0.21s)
          ✓ memberDelete2 passed 100 tests.
      ∀ s, x \in s. size (insert s x) = size s:                                         OK (0.28s)
          ✓ sizeInsert1 passed 100 tests.
      ∀ s, x \notin s. size (insert s x) = size s + 1:                                  OK (0.25s)
          ✓ sizeInsert2 passed 100 tests.
      ∀ s, x \in s. size (delete s x) = size s - 1:                                     OK (0.32s)
          ✓ sizeDelete1 passed 100 tests.
      ∀ s, x \notin s. size (delete s x) = size s:                                      OK (0.21s)
          ✓ sizeDelete2 passed 100 tests.
      sort . nub = sort . toList:                                                       OK (0.20s)
          ✓ toListFromList passed 100 tests.
      member x s = elem x (toList s):                                                   OK (0.28s)
          ✓ memberHomomorphism passed 100 tests.
      size = length . toList:                                                           OK (0.30s)
          ✓ sizeHomomorphism passed 100 tests.
      sort . nub ((toList s) ∪ (toList s')) = sort . toList (s ∪ s'):                   OK (0.57s)
          ✓ unionHomomorphism passed 100 tests.
      sort . nub ((toList s) ∩ (toList s')) = sort . toList (s ∩ s'):                   OK (0.65s)
          ✓ intersecHomomorphism passed 100 tests.
    Destination array tests
      alloc . mirror = id:                                                              OK (0.30s)
          ✓ roundTrip passed 100 tests.
      alloc . replicate = V.replicate:                                                  OK
          ✓ replicateTest passed 100 tests.
      alloc . fill = V.singleton:                                                       OK
          ✓ fillTest passed 100 tests.
      alloc n . fromFunction (+s) = V.fromEnum n s:                                     OK (0.01s)
          ✓ fromFuncEnum passed 100 tests.
    Polarized arrays
      Push.alloc . transfer . Pull.fromVector = id:                                     OK (0.25s)
          ✓ polarRoundTrip passed 100 tests.
      Push.append ~ Vec.append:                                                         OK (0.46s)
          ✓ pushAppend passed 100 tests.
      Push.make ~ Vec.replicate:                                                        OK
          ✓ pushMake passed 100 tests.
      Pull.append ~ Vec.append:                                                         OK (0.49s)
          ✓ pullAppend passed 100 tests.
      Pull.asList . Pull.fromVector ~ id:                                               OK (0.23s)
          ✓ pullAsList passed 100 tests.
      Pull.singleton x = [x]:                                                           OK
          ✓ pullSingleton passed 100 tests.
      Pull.splitAt ~ splitAt:                                                           OK (0.29s)
          ✓ pullSplitAt passed 100 tests.
      Pull.make ~ Vec.replicate:                                                        OK
          ✓ pullMake passed 100 tests.
      Pull.zip ~ zip:                                                                   OK (0.41s)
          ✓ pullZip passed 100 tests.
  Inspection tests
    Inspection testing of elim and make for V
      make3 ==- manualMake3:                                                            OK
      elim3 ==- manualElim3:                                                            OK
    Inspection testing of elim for Replicator
      elim3 === manualElim3:                                                            OK

All 97 tests passed (8.46s)
Test suite test: PASS
Test suite logged to:
/tmp/workdir-linear-base/linear-base-0.4.0/dist-newstyle/build/x86_64-linux/ghc-9.6.6/linear-base-0.4.0/t/test/test/linear-base-0.4.0-test.log
1 of 1 test suites (1 of 1 test cases) passed.
