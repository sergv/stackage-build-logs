Build profile: -w ghc-9.6.6 -O1
In order, the following will be built (use -v for more details):
 - concise-0.1.0.1 (lib) (first run)
 - concise-0.1.0.1 (test:tests) (first run)
Configuring library for concise-0.1.0.1...
Preprocessing library for concise-0.1.0.1...
Building library for concise-0.1.0.1...
[1 of 1] Compiling Control.Lens.Cons.Extras

src/Control/Lens/Cons/Extras.hs:45:1: warning: [-Wunused-imports]
    The import of ‘Control.Lens’ is redundant
      except perhaps to import instances from ‘Control.Lens’
    To import instances alone, use: import Control.Lens()
   |
45 | import Control.Lens ((#))
   | ^^^^^^^^^^^^^^^^^^^^^^^^^

src/Control/Lens/Cons/Extras.hs:46:1: warning: [-Wunused-imports]
    The import of ‘Control.Lens.Cons’ is redundant
      except perhaps to import instances from ‘Control.Lens.Cons’
    To import instances alone, use: import Control.Lens.Cons()
   |
46 | import Control.Lens.Cons (Cons, cons, uncons)
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

src/Control/Lens/Cons/Extras.hs:47:1: warning: [-Wunused-imports]
    The import of ‘Control.Lens.Empty’ is redundant
      except perhaps to import instances from ‘Control.Lens.Empty’
    To import instances alone, use: import Control.Lens.Empty()
   |
47 | import Control.Lens.Empty (AsEmpty(..))
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

src/Control/Lens/Cons/Extras.hs:48:1: warning: [-Wunused-imports]
    The import of ‘Control.Lens.Fold’ is redundant
      except perhaps to import instances from ‘Control.Lens.Fold’
    To import instances alone, use: import Control.Lens.Fold()
   |
48 | import Control.Lens.Fold (foldrOf, unfolded)
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

src/Control/Lens/Cons/Extras.hs:50:1: warning: [-Wunused-imports]
    The import of ‘Control.Lens.Iso’ is redundant
      except perhaps to import instances from ‘Control.Lens.Iso’
    To import instances alone, use: import Control.Lens.Iso()
   |
50 | import Control.Lens.Iso (lazy, strict)
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Configuring test suite 'tests' for concise-0.1.0.1...
Preprocessing test suite 'tests' for concise-0.1.0.1...
Building test suite 'tests' for concise-0.1.0.1...
[1 of 1] Compiling Main
Rule fired
    Rule: Class op ==
    Module: (BUILTIN)
    Before: GHC.Classes.==
              TyArg Main.List a_a9hh
              ValArg Main.$fEqList @a_a9hh $dEq_a9hi
              ValArg eta_B0
              ValArg eta_B1
    After:  $c==_a9hk @a_a9hh $dEq_a9hi ValArg eta_B0 ValArg eta_B1
    Cont:   Select nodup wild_aaY2
            Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: Class op ==
    Module: (BUILTIN)
    Before: GHC.Classes.==
              TyArg Main.List a_a9hh ValArg $dEq_aaXZ ValArg x_aaY0 ValArg y_aaY1
    After:  $c==_a9hk @a_a9hh $dEq_a9hi ValArg x_aaY0 ValArg y_aaY1
    Cont:   Select nodup wild_aaY2
            Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: Class op ==
    Module: (BUILTIN)
    Before: GHC.Classes.==
              TyArg Main.List a_a9hh
              ValArg $dEq_a9hF
              ValArg a2_a8PG
              ValArg b2_a8PI
    After:  $c==_a9hk @a_a9hh $dEq_a9hi ValArg a2_a8PG ValArg b2_a8PI
    Cont:   Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: USPEC $fEqList @Int
    Module: (GHC.Classes)
    Before: GHC.Classes.$fEqList
              TyArg GHC.Types.Int ValArg GHC.Classes.$fEqInt
    After:  (\ ($dEq_ab5K :: GHC.Classes.Eq GHC.Types.Int) ->
               GHC.Classes.$fEqList_$s$fEqList)
              GHC.Classes.$fEqInt
    Cont:   Stop[RhsCtxt(NonRecursive)] GHC.Classes.Eq [GHC.Types.Int]
Rule fired
    Rule: USPEC $fEqList @Char
    Module: (GHC.Classes)
    Before: GHC.Classes.$fEqList
              TyArg GHC.Types.Char ValArg GHC.Classes.$fEqChar
    After:  (\ ($dEq_ab5L :: GHC.Classes.Eq GHC.Types.Char) ->
               GHC.Classes.$fEqList_$s$fEqList1)
              GHC.Classes.$fEqChar
    Cont:   Stop[RhsCtxt(NonRecursive)] GHC.Classes.Eq [GHC.Types.Char]
Rule fired
    Rule: USPEC $fShowList @Char
    Module: (GHC.Show)
    Before: GHC.Show.$fShowList
              TyArg GHC.Types.Char ValArg GHC.Show.$fShowChar
    After:  (\ ($dShow_ab5O :: GHC.Show.Show GHC.Types.Char) ->
               GHC.Show.$fShowList_$s$fShowList1)
              GHC.Show.$fShowChar
    Cont:   Stop[RhsCtxt(NonRecursive)] GHC.Show.Show [GHC.Types.Char]
Rule fired
    Rule: unpack
    Module: (GHC.Base)
    Before: GHC.CString.unpackCString# ValArg "Properties"#
    After:  (\ (a_ab5Y :: GHC.Prim.Addr#) ->
               GHC.Base.build
                 @GHC.Types.Char
                 (\ (@b_ab5Z) -> GHC.CString.unpackFoldrCString# @b_ab5Z a_ab5Y))
              "Properties"#
    Cont:   Stop[BoringCtxt] Test.Tasty.Core.TestName
Rule fired
    Rule: unpack
    Module: (GHC.Base)
    Before: GHC.CString.unpackCString# ValArg "[a] -> [a]"#
    After:  (\ (a_ab5Y :: GHC.Prim.Addr#) ->
               GHC.Base.build
                 @GHC.Types.Char
                 (\ (@b_ab5Z) -> GHC.CString.unpackFoldrCString# @b_ab5Z a_ab5Y))
              "[a] -> [a]"#
    Cont:   Stop[BoringCtxt] Test.Tasty.Core.TestName
Rule fired
    Rule: Class op property
    Module: (BUILTIN)
    Before: Test.QuickCheck.Property.property
              TyArg GHC.Base.String -> GHC.Types.Bool ValArg $dTestable_a911
    After:  Test.QuickCheck.Property.$fTestableFUN_$cproperty
              @[GHC.Types.Char]
              @GHC.Types.Bool
              $dArbitrary_a9Ip
              GHC.Show.$fShowList_$s$fShowList1
              Test.QuickCheck.Property.$fTestableBool
    Cont:   ApplyToVal nodup hole (GHC.Base.String -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              prop_ab6b
            CastIt (Sym (Test.Tasty.QuickCheck.N:QC[0])
                    :: Test.QuickCheck.Property.Property ~R# Test.Tasty.QuickCheck.QC)
            Stop[BoringCtxt] Test.Tasty.QuickCheck.QC
Rule fired
    Rule: Class op propertyForAllShrinkShow
    Module: (BUILTIN)
    Before: Test.QuickCheck.Property.propertyForAllShrinkShow
              TyArg GHC.Types.Bool ValArg Test.QuickCheck.Property.$fTestableBool
    After:  Test.QuickCheck.Property.$fTestableBool1
            `cast` (forall (a :: <*>_N).
                    <Test.QuickCheck.Gen.Gen a>_R
                    %<'GHC.Types.Many>_N ->_R <a -> [a]>_R
                    %<'GHC.Types.Many>_N ->_R <a -> [GHC.Base.String]>_R
                    %<'GHC.Types.Many>_N ->_R <a -> GHC.Types.Bool>_R
                    %<'GHC.Types.Many>_N ->_R Sym (Test.QuickCheck.Gen.N:Gen[0]
                                                       (Test.QuickCheck.Property.N:Prop[0]))
                                              ; Sym (Test.QuickCheck.Property.N:Property[0])
                    :: (forall {a}.
                        Test.QuickCheck.Gen.Gen a
                        -> (a -> [a])
                        -> (a -> [GHC.Base.String])
                        -> (a -> GHC.Types.Bool)
                        -> Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int
                        -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result)
                       ~R# (forall {a}.
                            Test.QuickCheck.Gen.Gen a
                            -> (a -> [a])
                            -> (a -> [GHC.Base.String])
                            -> (a -> GHC.Types.Bool)
                            -> Test.QuickCheck.Property.Property))
    Cont:   ApplyToTy [GHC.Types.Char]
            ApplyToVal nodup hole Test.QuickCheck.Gen.Gen [GHC.Types.Char]
                                  -> ([GHC.Types.Char] -> [[GHC.Types.Char]])
                                  -> ([GHC.Types.Char] -> [GHC.Base.String])
                                  -> ([GHC.Types.Char] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (Test.QuickCheck.Arbitrary.arbitrary @a_ab7T $dArbitrary_ab7V)
            ApplyToVal nodup hole ([GHC.Types.Char] -> [[GHC.Types.Char]])
                                  -> ([GHC.Types.Char] -> [GHC.Base.String])
                                  -> ([GHC.Types.Char] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (Test.QuickCheck.Arbitrary.shrink @a_ab7T $dArbitrary_ab7V)
            ApplyToVal nodup hole ([GHC.Types.Char] -> [GHC.Base.String])
                                  -> ([GHC.Types.Char] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (let {
                 g_ab7Z [Occ=OnceL1!] :: a_ab7T -> GHC.Base.String
                 [LclId]
                 g_ab7Z = GHC.Show.show @a_ab7T $dShow_ab7W } in
               \ (x_ab80 [Occ=Once1] :: a_ab7T) ->
                 GHC.Types.:
                   @GHC.Base.String (g_ab7Z x_ab80) (GHC.Types.[] @GHC.Base.String))
            ApplyToVal nodup hole ([GHC.Types.Char] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              f_ab7Y
            CastIt (Sym (Test.Tasty.QuickCheck.N:QC[0])
                    :: Test.QuickCheck.Property.Property ~R# Test.Tasty.QuickCheck.QC)
            Stop[BoringCtxt] Test.Tasty.QuickCheck.QC
Rule fired
    Rule: Class op arbitrary
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.arbitrary
              TyArg [GHC.Types.Char] ValArg $dArbitrary_a9Ip
    After:  (Test.QuickCheck.Arbitrary.$fArbitraryList1
               @GHC.Types.Char Test.QuickCheck.Arbitrary.$fArbitraryChar)
            `cast` (Sym (Test.QuickCheck.Gen.N:Gen[0] <[GHC.Types.Char]>_R)
                    :: (Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int -> [GHC.Types.Char])
                       ~R# Test.QuickCheck.Gen.Gen [GHC.Types.Char])
    Cont:   Stop[BoringCtxt] Test.QuickCheck.Gen.Gen [GHC.Types.Char]
Rule fired
    Rule: Class op arbitrary
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.arbitrary
              TyArg GHC.Types.Char
              ValArg Test.QuickCheck.Arbitrary.$fArbitraryChar
    After:  Test.QuickCheck.Arbitrary.$fArbitraryChar_$carbitrary
    Cont:   Stop[BoringCtxt, C(S,C(1,L))] Test.QuickCheck.Gen.Gen
                                            GHC.Types.Char
Rule fired
    Rule: Class op shrink
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.shrink
              TyArg [GHC.Types.Char] ValArg $dArbitrary_a9Ip
    After:  Test.QuickCheck.Arbitrary.$fArbitraryList_$cshrink
              @GHC.Types.Char Test.QuickCheck.Arbitrary.$fArbitraryChar
    Cont:   Stop[BoringCtxt] [GHC.Types.Char] -> [[GHC.Types.Char]]
Rule fired
    Rule: Class op shrink
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.shrink
              TyArg GHC.Types.Char
              ValArg Test.QuickCheck.Arbitrary.$fArbitraryChar
    After:  Test.QuickCheck.Arbitrary.$fArbitraryChar_$cshrink
    Cont:   Stop[DiscArgCtxt, C(S,L)] GHC.Types.Char
                                      -> [GHC.Types.Char]
Rule fired
    Rule: Class op show
    Module: (BUILTIN)
    Before: GHC.Show.show
              TyArg [GHC.Types.Char] ValArg GHC.Show.$fShowList_$s$fShowList1
    After:  GHC.Show.$fShowList_$s$cshow1
    Cont:   Stop[RhsCtxt(NonRecursive)] [GHC.Types.Char]
                                        -> GHC.Base.String
Rule fired
    Rule: Class op reader
    Module: (BUILTIN)
    Before: Control.Monad.Reader.Class.reader
              TyArg [GHC.Types.Char]
              TyArg (->) GHC.Base.String
              ValArg Control.Monad.Reader.Class.$fMonadReaderrFUN
                       @[GHC.Types.Char]
    After:  \ (@a_abdo) -> GHC.Base.id @([GHC.Types.Char] -> a_abdo)
    Cont:   ApplyToTy GHC.Base.String
            ApplyToVal nodup hole ([GHC.Types.Char] -> GHC.Base.String)
                                  -> GHC.Base.String -> GHC.Base.String
              ((l_abdi
                  ((\ (ds_abdj [Occ=Once1] :: a_abdg) -> ds_abdj)
                   `cast` (<a_abdg>_R
                           %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                              <*>_N <a_abdg>_R <a_abdg>_P)
                           :: (a_abdg -> a_abdg)
                              ~R# (a_abdg -> Data.Functor.Const.Const a_abdg a_abdg))))
               `cast` (<s_abde>_R
                       %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                     <*>_N <a_abdg>_R <s_abde>_P
                       :: (s_abde -> Data.Functor.Const.Const a_abdg s_abde)
                          ~R# (s_abde -> a_abdg)))
            ApplyToVal nodup hole GHC.Base.String -> GHC.Base.String s_a8IO
            Stop[RuleArgCtxt] GHC.Base.String
Rule fired
    Rule: recons/id
    Module: (Control.Lens.Cons.Extras)
    Before: Control.Lens.Cons.Extras.recons
              TyArg [GHC.Types.Char]
              TyArg GHC.Types.Char
              TyArg GHC.Base.String
              ValArg (\ (@(p_abeP :: * -> * -> *))
                        (@(f_abeQ :: * -> *))
                        ($dChoice_abeR :: Data.Profunctor.Choice.Choice p_abeP)
                        ($dApplicative_abeS :: GHC.Base.Applicative f_abeQ) ->
                        let {
                          f1_abeT
                            :: p_abeP
                                 (Data.Either.Either
                                    [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                                 (Data.Either.Either
                                    [GHC.Types.Char] (f_abeQ (GHC.Types.Char, [GHC.Types.Char])))
                               -> p_abeP [GHC.Types.Char] (f_abeQ [GHC.Types.Char])
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 320 0}]
                          f1_abeT
                            = Data.Profunctor.Unsafe.dimap
                                @p_abeP
                                (Data.Profunctor.Choice.$p1Choice @p_abeP $dChoice_abeR)
                                @[GHC.Types.Char]
                                @(Data.Either.Either
                                    [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                                @(Data.Either.Either
                                    [GHC.Types.Char] (f_abeQ (GHC.Types.Char, [GHC.Types.Char])))
                                @(f_abeQ [GHC.Types.Char])
                                (\ (aas_abeU :: [GHC.Types.Char]) ->
                                   case aas_abeU of {
                                     [] ->
                                       Data.Either.Left
                                         @[GHC.Types.Char]
                                         @(GHC.Types.Char, [GHC.Types.Char])
                                         (GHC.Types.[] @GHC.Types.Char);
                                     : a1_abeW as_abeX ->
                                       Data.Either.Right
                                         @[GHC.Types.Char]
                                         @(GHC.Types.Char, [GHC.Types.Char])
                                         (a1_abeW, as_abeX)
                                   })
                                (let {
                                   f2_abeZ :: [GHC.Types.Char] -> f_abeQ [GHC.Types.Char]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abeZ
                                     = GHC.Base.pure
                                         @f_abeQ $dApplicative_abeS @[GHC.Types.Char] } in
                                 let {
                                   ds2_abf0
                                     :: f_abeQ (GHC.Types.Char, [GHC.Types.Char])
                                        -> f_abeQ [GHC.Types.Char]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 90 0}]
                                   ds2_abf0
                                     = GHC.Base.fmap
                                         @f_abeQ
                                         (GHC.Base.$p1Applicative @f_abeQ $dApplicative_abeS)
                                         @(GHC.Types.Char, [GHC.Types.Char])
                                         @[GHC.Types.Char]
                                         (\ (p1_abf1 :: (GHC.Types.Char, [GHC.Types.Char])) ->
                                            GHC.Types.:
                                              @GHC.Types.Char
                                              (case p1_abf1 of { (x_abf3, ds_abf4) -> x_abf3 })
                                              (case p1_abf1 of { (ds_abf7, y_abf8) ->
                                               y_abf8
                                               })) } in
                                 \ (ds3_abfa
                                      :: Data.Either.Either
                                           [GHC.Types.Char]
                                           (f_abeQ (GHC.Types.Char, [GHC.Types.Char]))) ->
                                   case ds3_abfa of {
                                     Data.Either.Left x_abfc -> f2_abeZ x_abfc;
                                     Data.Either.Right y_abfe -> ds2_abf0 y_abfe
                                   }) } in
                        let {
                          g_abfg
                            :: p_abeP
                                 (GHC.Types.Char, [GHC.Types.Char])
                                 (f_abeQ (GHC.Types.Char, [GHC.Types.Char]))
                               -> p_abeP
                                    (Data.Either.Either
                                       [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                                    (Data.Either.Either
                                       [GHC.Types.Char] (f_abeQ (GHC.Types.Char, [GHC.Types.Char])))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abfg
                            = Data.Profunctor.Choice.right'
                                @p_abeP
                                $dChoice_abeR
                                @(GHC.Types.Char, [GHC.Types.Char])
                                @(f_abeQ (GHC.Types.Char, [GHC.Types.Char]))
                                @[GHC.Types.Char] } in
                        \ (x_abfh
                             :: p_abeP
                                  (GHC.Types.Char, [GHC.Types.Char])
                                  (f_abeQ (GHC.Types.Char, [GHC.Types.Char]))) ->
                          f1_abeT (g_abfg x_abfh))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <[GHC.Types.Char]>_N
                                      <[GHC.Types.Char]>_N
                                      <GHC.Types.Char>_N
                                      <GHC.Types.Char>_N)
                             :: Control.Lens.Type.Prism
                                  [GHC.Types.Char]
                                  [GHC.Types.Char]
                                  (GHC.Types.Char, [GHC.Types.Char])
                                  (GHC.Types.Char, [GHC.Types.Char])
                                ~R# Control.Lens.Cons.Cons
                                      [GHC.Types.Char]
                                      [GHC.Types.Char]
                                      GHC.Types.Char
                                      GHC.Types.Char)
              ValArg (\ (@(p_abeP :: * -> * -> *))
                        (@(f_abeQ :: * -> *))
                        ($dChoice_abeR :: Data.Profunctor.Choice.Choice p_abeP)
                        ($dApplicative_abeS :: GHC.Base.Applicative f_abeQ) ->
                        let {
                          f1_abeT
                            :: p_abeP
                                 (Data.Either.Either
                                    [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                                 (Data.Either.Either
                                    [GHC.Types.Char] (f_abeQ (GHC.Types.Char, [GHC.Types.Char])))
                               -> p_abeP [GHC.Types.Char] (f_abeQ [GHC.Types.Char])
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 320 0}]
                          f1_abeT
                            = Data.Profunctor.Unsafe.dimap
                                @p_abeP
                                (Data.Profunctor.Choice.$p1Choice @p_abeP $dChoice_abeR)
                                @[GHC.Types.Char]
                                @(Data.Either.Either
                                    [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                                @(Data.Either.Either
                                    [GHC.Types.Char] (f_abeQ (GHC.Types.Char, [GHC.Types.Char])))
                                @(f_abeQ [GHC.Types.Char])
                                (\ (aas_abeU :: [GHC.Types.Char]) ->
                                   case aas_abeU of {
                                     [] ->
                                       Data.Either.Left
                                         @[GHC.Types.Char]
                                         @(GHC.Types.Char, [GHC.Types.Char])
                                         (GHC.Types.[] @GHC.Types.Char);
                                     : a1_abeW as_abeX ->
                                       Data.Either.Right
                                         @[GHC.Types.Char]
                                         @(GHC.Types.Char, [GHC.Types.Char])
                                         (a1_abeW, as_abeX)
                                   })
                                (let {
                                   f2_abeZ :: [GHC.Types.Char] -> f_abeQ [GHC.Types.Char]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abeZ
                                     = GHC.Base.pure
                                         @f_abeQ $dApplicative_abeS @[GHC.Types.Char] } in
                                 let {
                                   ds2_abf0
                                     :: f_abeQ (GHC.Types.Char, [GHC.Types.Char])
                                        -> f_abeQ [GHC.Types.Char]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 90 0}]
                                   ds2_abf0
                                     = GHC.Base.fmap
                                         @f_abeQ
                                         (GHC.Base.$p1Applicative @f_abeQ $dApplicative_abeS)
                                         @(GHC.Types.Char, [GHC.Types.Char])
                                         @[GHC.Types.Char]
                                         (\ (p1_abf1 :: (GHC.Types.Char, [GHC.Types.Char])) ->
                                            GHC.Types.:
                                              @GHC.Types.Char
                                              (case p1_abf1 of { (x_abf3, ds_abf4) -> x_abf3 })
                                              (case p1_abf1 of { (ds_abf7, y_abf8) ->
                                               y_abf8
                                               })) } in
                                 \ (ds3_abfa
                                      :: Data.Either.Either
                                           [GHC.Types.Char]
                                           (f_abeQ (GHC.Types.Char, [GHC.Types.Char]))) ->
                                   case ds3_abfa of {
                                     Data.Either.Left x_abfc -> f2_abeZ x_abfc;
                                     Data.Either.Right y_abfe -> ds2_abf0 y_abfe
                                   }) } in
                        let {
                          g_abfg
                            :: p_abeP
                                 (GHC.Types.Char, [GHC.Types.Char])
                                 (f_abeQ (GHC.Types.Char, [GHC.Types.Char]))
                               -> p_abeP
                                    (Data.Either.Either
                                       [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                                    (Data.Either.Either
                                       [GHC.Types.Char] (f_abeQ (GHC.Types.Char, [GHC.Types.Char])))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abfg
                            = Data.Profunctor.Choice.right'
                                @p_abeP
                                $dChoice_abeR
                                @(GHC.Types.Char, [GHC.Types.Char])
                                @(f_abeQ (GHC.Types.Char, [GHC.Types.Char]))
                                @[GHC.Types.Char] } in
                        \ (x_abfh
                             :: p_abeP
                                  (GHC.Types.Char, [GHC.Types.Char])
                                  (f_abeQ (GHC.Types.Char, [GHC.Types.Char]))) ->
                          f1_abeT (g_abfg x_abfh))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <[GHC.Types.Char]>_N
                                      <[GHC.Types.Char]>_N
                                      <GHC.Types.Char>_N
                                      <GHC.Types.Char>_N)
                             :: Control.Lens.Type.Prism
                                  [GHC.Types.Char]
                                  [GHC.Types.Char]
                                  (GHC.Types.Char, [GHC.Types.Char])
                                  (GHC.Types.Char, [GHC.Types.Char])
                                ~R# Control.Lens.Cons.Cons
                                      [GHC.Types.Char]
                                      [GHC.Types.Char]
                                      GHC.Types.Char
                                      GHC.Types.Char)
              ValArg (\ (@(p_abfm :: * -> * -> *))
                        (@(f_abfn :: * -> *))
                        ($dChoice_abfo :: Data.Profunctor.Choice.Choice p_abfm)
                        ($dApplicative_abfp :: GHC.Base.Applicative f_abfn) ->
                        let {
                          f1_abfq
                            :: p_abfm
                                 (Data.Either.Either [GHC.Types.Char] ())
                                 (Data.Either.Either [GHC.Types.Char] (f_abfn ()))
                               -> p_abfm [GHC.Types.Char] (f_abfn [GHC.Types.Char])
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 290 0}]
                          f1_abfq
                            = Data.Profunctor.Unsafe.dimap
                                @p_abfm
                                (Data.Profunctor.Choice.$p1Choice @p_abfm $dChoice_abfo)
                                @[GHC.Types.Char]
                                @(Data.Either.Either [GHC.Types.Char] ())
                                @(Data.Either.Either [GHC.Types.Char] (f_abfn ()))
                                @(f_abfn [GHC.Types.Char])
                                (\ (s_abfr :: [GHC.Types.Char]) ->
                                   case s_abfr of wild_abfs {
                                     [] ->
                                       Data.Either.Right @[GHC.Types.Char] @() GHC.Tuple.Prim.();
                                     : ds1_abft ds2_abfu ->
                                       Data.Either.Left @[GHC.Types.Char] @() wild_abfs
                                   })
                                (let {
                                   f2_abfw :: [GHC.Types.Char] -> f_abfn [GHC.Types.Char]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abfw
                                     = GHC.Base.pure
                                         @f_abfn $dApplicative_abfp @[GHC.Types.Char] } in
                                 let {
                                   ds2_abfx :: f_abfn () -> f_abfn [GHC.Types.Char]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 70 0}]
                                   ds2_abfx
                                     = GHC.Base.fmap
                                         @f_abfn
                                         (GHC.Base.$p1Applicative @f_abfn $dApplicative_abfp)
                                         @()
                                         @[GHC.Types.Char]
                                         (\ (ds3_abfy :: ()) ->
                                            case ds3_abfy of { () ->
                                            GHC.Types.[] @GHC.Types.Char
                                            }) } in
                                 \ (ds3_abfA :: Data.Either.Either [GHC.Types.Char] (f_abfn ())) ->
                                   case ds3_abfA of {
                                     Data.Either.Left x_abfC -> f2_abfw x_abfC;
                                     Data.Either.Right y_abfE -> ds2_abfx y_abfE
                                   }) } in
                        let {
                          g_abfG
                            :: p_abfm () (f_abfn ())
                               -> p_abfm
                                    (Data.Either.Either [GHC.Types.Char] ())
                                    (Data.Either.Either [GHC.Types.Char] (f_abfn ()))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abfG
                            = Data.Profunctor.Choice.right'
                                @p_abfm $dChoice_abfo @() @(f_abfn ()) @[GHC.Types.Char] } in
                        \ (x_abfH :: p_abfm () (f_abfn ())) -> f1_abfq (g_abfG x_abfH))
                     `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0] <[GHC.Types.Char]>_N)
                             :: Control.Lens.Type.Prism' [GHC.Types.Char] ()
                                ~R# Control.Lens.Empty.AsEmpty [GHC.Types.Char])
              TyArg Data.Functor.Const.Const GHC.Base.String
              ValArg Data.Functor.Contravariant.$fContravariantConst
                       @[GHC.Types.Char]
              ValArg Data.Functor.Const.$fFunctorConst @[GHC.Types.Char]
    After:  (\ (@s1_aben)
               (@(f_abeo :: * -> *))
               (@a_abep)
               ($dCons_abeq
                  :: Control.Lens.Cons.Cons s1_aben s1_aben a_abep a_abep)
               ($dCons1_aber
                  :: Control.Lens.Cons.Cons s1_aben s1_aben a_abep a_abep)
               ($dAsEmpty_abes :: Control.Lens.Empty.AsEmpty s1_aben)
               ($dContravariant_abet
                  :: Data.Functor.Contravariant.Contravariant f_abeo)
               ($dFunctor_abeu :: GHC.Base.Functor f_abeo) ->
               GHC.Base.id @(s1_aben -> f_abeo s1_aben))
              @[GHC.Types.Char]
              @(Data.Functor.Const.Const GHC.Base.String)
              @GHC.Types.Char
              ((\ (@(p_abeP :: * -> * -> *))
                  (@(f_abeQ :: * -> *))
                  ($dChoice_abeR :: Data.Profunctor.Choice.Choice p_abeP)
                  ($dApplicative_abeS :: GHC.Base.Applicative f_abeQ) ->
                  let {
                    f1_abeT
                      :: p_abeP
                           (Data.Either.Either
                              [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                           (Data.Either.Either
                              [GHC.Types.Char] (f_abeQ (GHC.Types.Char, [GHC.Types.Char])))
                         -> p_abeP [GHC.Types.Char] (f_abeQ [GHC.Types.Char])
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 320 0}]
                    f1_abeT
                      = Data.Profunctor.Unsafe.dimap
                          @p_abeP
                          (Data.Profunctor.Choice.$p1Choice @p_abeP $dChoice_abeR)
                          @[GHC.Types.Char]
                          @(Data.Either.Either
                              [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                          @(Data.Either.Either
                              [GHC.Types.Char] (f_abeQ (GHC.Types.Char, [GHC.Types.Char])))
                          @(f_abeQ [GHC.Types.Char])
                          (\ (aas_abeU :: [GHC.Types.Char]) ->
                             case aas_abeU of {
                               [] ->
                                 Data.Either.Left
                                   @[GHC.Types.Char]
                                   @(GHC.Types.Char, [GHC.Types.Char])
                                   (GHC.Types.[] @GHC.Types.Char);
                               : a1_abeW as_abeX ->
                                 Data.Either.Right
                                   @[GHC.Types.Char]
                                   @(GHC.Types.Char, [GHC.Types.Char])
                                   (a1_abeW, as_abeX)
                             })
                          (let {
                             f2_abeZ :: [GHC.Types.Char] -> f_abeQ [GHC.Types.Char]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abeZ
                               = GHC.Base.pure @f_abeQ $dApplicative_abeS @[GHC.Types.Char] } in
                           let {
                             ds2_abf0
                               :: f_abeQ (GHC.Types.Char, [GHC.Types.Char])
                                  -> f_abeQ [GHC.Types.Char]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 90 0}]
                             ds2_abf0
                               = GHC.Base.fmap
                                   @f_abeQ
                                   (GHC.Base.$p1Applicative @f_abeQ $dApplicative_abeS)
                                   @(GHC.Types.Char, [GHC.Types.Char])
                                   @[GHC.Types.Char]
                                   (\ (p1_abf1 :: (GHC.Types.Char, [GHC.Types.Char])) ->
                                      GHC.Types.:
                                        @GHC.Types.Char
                                        (case p1_abf1 of { (x_abf3, ds_abf4) -> x_abf3 })
                                        (case p1_abf1 of { (ds_abf7, y_abf8) -> y_abf8 })) } in
                           \ (ds3_abfa
                                :: Data.Either.Either
                                     [GHC.Types.Char]
                                     (f_abeQ (GHC.Types.Char, [GHC.Types.Char]))) ->
                             case ds3_abfa of {
                               Data.Either.Left x_abfc -> f2_abeZ x_abfc;
                               Data.Either.Right y_abfe -> ds2_abf0 y_abfe
                             }) } in
                  let {
                    g_abfg
                      :: p_abeP
                           (GHC.Types.Char, [GHC.Types.Char])
                           (f_abeQ (GHC.Types.Char, [GHC.Types.Char]))
                         -> p_abeP
                              (Data.Either.Either
                                 [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                              (Data.Either.Either
                                 [GHC.Types.Char] (f_abeQ (GHC.Types.Char, [GHC.Types.Char])))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abfg
                      = Data.Profunctor.Choice.right'
                          @p_abeP
                          $dChoice_abeR
                          @(GHC.Types.Char, [GHC.Types.Char])
                          @(f_abeQ (GHC.Types.Char, [GHC.Types.Char]))
                          @[GHC.Types.Char] } in
                  \ (x_abfh
                       :: p_abeP
                            (GHC.Types.Char, [GHC.Types.Char])
                            (f_abeQ (GHC.Types.Char, [GHC.Types.Char]))) ->
                    f1_abeT (g_abfg x_abfh))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <[GHC.Types.Char]>_N
                                <[GHC.Types.Char]>_N
                                <GHC.Types.Char>_N
                                <GHC.Types.Char>_N)
                       :: Control.Lens.Type.Prism
                            [GHC.Types.Char]
                            [GHC.Types.Char]
                            (GHC.Types.Char, [GHC.Types.Char])
                            (GHC.Types.Char, [GHC.Types.Char])
                          ~R# Control.Lens.Cons.Cons
                                [GHC.Types.Char] [GHC.Types.Char] GHC.Types.Char GHC.Types.Char))
              ((\ (@(p_abeP :: * -> * -> *))
                  (@(f_abeQ :: * -> *))
                  ($dChoice_abeR :: Data.Profunctor.Choice.Choice p_abeP)
                  ($dApplicative_abeS :: GHC.Base.Applicative f_abeQ) ->
                  let {
                    f1_abeT
                      :: p_abeP
                           (Data.Either.Either
                              [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                           (Data.Either.Either
                              [GHC.Types.Char] (f_abeQ (GHC.Types.Char, [GHC.Types.Char])))
                         -> p_abeP [GHC.Types.Char] (f_abeQ [GHC.Types.Char])
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 320 0}]
                    f1_abeT
                      = Data.Profunctor.Unsafe.dimap
                          @p_abeP
                          (Data.Profunctor.Choice.$p1Choice @p_abeP $dChoice_abeR)
                          @[GHC.Types.Char]
                          @(Data.Either.Either
                              [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                          @(Data.Either.Either
                              [GHC.Types.Char] (f_abeQ (GHC.Types.Char, [GHC.Types.Char])))
                          @(f_abeQ [GHC.Types.Char])
                          (\ (aas_abeU :: [GHC.Types.Char]) ->
                             case aas_abeU of {
                               [] ->
                                 Data.Either.Left
                                   @[GHC.Types.Char]
                                   @(GHC.Types.Char, [GHC.Types.Char])
                                   (GHC.Types.[] @GHC.Types.Char);
                               : a1_abeW as_abeX ->
                                 Data.Either.Right
                                   @[GHC.Types.Char]
                                   @(GHC.Types.Char, [GHC.Types.Char])
                                   (a1_abeW, as_abeX)
                             })
                          (let {
                             f2_abeZ :: [GHC.Types.Char] -> f_abeQ [GHC.Types.Char]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abeZ
                               = GHC.Base.pure @f_abeQ $dApplicative_abeS @[GHC.Types.Char] } in
                           let {
                             ds2_abf0
                               :: f_abeQ (GHC.Types.Char, [GHC.Types.Char])
                                  -> f_abeQ [GHC.Types.Char]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 90 0}]
                             ds2_abf0
                               = GHC.Base.fmap
                                   @f_abeQ
                                   (GHC.Base.$p1Applicative @f_abeQ $dApplicative_abeS)
                                   @(GHC.Types.Char, [GHC.Types.Char])
                                   @[GHC.Types.Char]
                                   (\ (p1_abf1 :: (GHC.Types.Char, [GHC.Types.Char])) ->
                                      GHC.Types.:
                                        @GHC.Types.Char
                                        (case p1_abf1 of { (x_abf3, ds_abf4) -> x_abf3 })
                                        (case p1_abf1 of { (ds_abf7, y_abf8) -> y_abf8 })) } in
                           \ (ds3_abfa
                                :: Data.Either.Either
                                     [GHC.Types.Char]
                                     (f_abeQ (GHC.Types.Char, [GHC.Types.Char]))) ->
                             case ds3_abfa of {
                               Data.Either.Left x_abfc -> f2_abeZ x_abfc;
                               Data.Either.Right y_abfe -> ds2_abf0 y_abfe
                             }) } in
                  let {
                    g_abfg
                      :: p_abeP
                           (GHC.Types.Char, [GHC.Types.Char])
                           (f_abeQ (GHC.Types.Char, [GHC.Types.Char]))
                         -> p_abeP
                              (Data.Either.Either
                                 [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                              (Data.Either.Either
                                 [GHC.Types.Char] (f_abeQ (GHC.Types.Char, [GHC.Types.Char])))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abfg
                      = Data.Profunctor.Choice.right'
                          @p_abeP
                          $dChoice_abeR
                          @(GHC.Types.Char, [GHC.Types.Char])
                          @(f_abeQ (GHC.Types.Char, [GHC.Types.Char]))
                          @[GHC.Types.Char] } in
                  \ (x_abfh
                       :: p_abeP
                            (GHC.Types.Char, [GHC.Types.Char])
                            (f_abeQ (GHC.Types.Char, [GHC.Types.Char]))) ->
                    f1_abeT (g_abfg x_abfh))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <[GHC.Types.Char]>_N
                                <[GHC.Types.Char]>_N
                                <GHC.Types.Char>_N
                                <GHC.Types.Char>_N)
                       :: Control.Lens.Type.Prism
                            [GHC.Types.Char]
                            [GHC.Types.Char]
                            (GHC.Types.Char, [GHC.Types.Char])
                            (GHC.Types.Char, [GHC.Types.Char])
                          ~R# Control.Lens.Cons.Cons
                                [GHC.Types.Char] [GHC.Types.Char] GHC.Types.Char GHC.Types.Char))
              ((\ (@(p_abfm :: * -> * -> *))
                  (@(f_abfn :: * -> *))
                  ($dChoice_abfo :: Data.Profunctor.Choice.Choice p_abfm)
                  ($dApplicative_abfp :: GHC.Base.Applicative f_abfn) ->
                  let {
                    f1_abfq
                      :: p_abfm
                           (Data.Either.Either [GHC.Types.Char] ())
                           (Data.Either.Either [GHC.Types.Char] (f_abfn ()))
                         -> p_abfm [GHC.Types.Char] (f_abfn [GHC.Types.Char])
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 290 0}]
                    f1_abfq
                      = Data.Profunctor.Unsafe.dimap
                          @p_abfm
                          (Data.Profunctor.Choice.$p1Choice @p_abfm $dChoice_abfo)
                          @[GHC.Types.Char]
                          @(Data.Either.Either [GHC.Types.Char] ())
                          @(Data.Either.Either [GHC.Types.Char] (f_abfn ()))
                          @(f_abfn [GHC.Types.Char])
                          (\ (s_abfr :: [GHC.Types.Char]) ->
                             case s_abfr of wild_abfs {
                               [] -> Data.Either.Right @[GHC.Types.Char] @() GHC.Tuple.Prim.();
                               : ds1_abft ds2_abfu ->
                                 Data.Either.Left @[GHC.Types.Char] @() wild_abfs
                             })
                          (let {
                             f2_abfw :: [GHC.Types.Char] -> f_abfn [GHC.Types.Char]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abfw
                               = GHC.Base.pure @f_abfn $dApplicative_abfp @[GHC.Types.Char] } in
                           let {
                             ds2_abfx :: f_abfn () -> f_abfn [GHC.Types.Char]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 70 0}]
                             ds2_abfx
                               = GHC.Base.fmap
                                   @f_abfn
                                   (GHC.Base.$p1Applicative @f_abfn $dApplicative_abfp)
                                   @()
                                   @[GHC.Types.Char]
                                   (\ (ds3_abfy :: ()) ->
                                      case ds3_abfy of { () -> GHC.Types.[] @GHC.Types.Char }) } in
                           \ (ds3_abfA :: Data.Either.Either [GHC.Types.Char] (f_abfn ())) ->
                             case ds3_abfA of {
                               Data.Either.Left x_abfC -> f2_abfw x_abfC;
                               Data.Either.Right y_abfE -> ds2_abfx y_abfE
                             }) } in
                  let {
                    g_abfG
                      :: p_abfm () (f_abfn ())
                         -> p_abfm
                              (Data.Either.Either [GHC.Types.Char] ())
                              (Data.Either.Either [GHC.Types.Char] (f_abfn ()))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abfG
                      = Data.Profunctor.Choice.right'
                          @p_abfm $dChoice_abfo @() @(f_abfn ()) @[GHC.Types.Char] } in
                  \ (x_abfH :: p_abfm () (f_abfn ())) -> f1_abfq (g_abfG x_abfH))
               `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0] <[GHC.Types.Char]>_N)
                       :: Control.Lens.Type.Prism' [GHC.Types.Char] ()
                          ~R# Control.Lens.Empty.AsEmpty [GHC.Types.Char]))
              (Data.Functor.Contravariant.$fContravariantConst @[GHC.Types.Char])
              (Data.Functor.Const.$fFunctorConst @[GHC.Types.Char])
    Cont:   ApplyToVal nodup hole Control.Lens.Getter.Getting
                                    GHC.Base.String [GHC.Types.Char] GHC.Base.String
              ((\ (ds_abdj [Occ=Once1] :: a_abdg) -> ds_abdj)
               `cast` (<a_abdg>_R
                       %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                          <*>_N <a_abdg>_R <a_abdg>_P)
                       :: (a_abdg -> a_abdg)
                          ~R# (a_abdg -> Data.Functor.Const.Const a_abdg a_abdg)))
            ApplyToVal nodup hole [GHC.Types.Char]
                                  -> Data.Functor.Const.Const GHC.Base.String [GHC.Types.Char]
              s_a8IO
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N <GHC.Base.String>_R <[GHC.Types.Char]>_P
                    :: Data.Functor.Const.Const GHC.Base.String [GHC.Types.Char]
                       ~R# GHC.Base.String)
            Stop[RuleArgCtxt] GHC.Base.String
Rule fired
    Rule: eqString
    Module: (GHC.Base)
    Before: GHC.Classes.==
              TyArg GHC.Base.String
              ValArg GHC.Classes.$fEqList_$s$fEqList1
              ValArg s_a8IO
              ValArg s_a8IO
    After:  (\ ($dEq_aaYU :: GHC.Classes.Eq GHC.Base.String) ->
               GHC.Base.eqString)
              GHC.Classes.$fEqList_$s$fEqList1
              ValArg s_a8IO ValArg s_a8IO
    Cont:   Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: unpack
    Module: (GHC.Base)
    Before: GHC.CString.unpackCString# ValArg "T -> T"#
    After:  (\ (a_ab5Y :: GHC.Prim.Addr#) ->
               GHC.Base.build
                 @GHC.Types.Char
                 (\ (@b_ab5Z) -> GHC.CString.unpackFoldrCString# @b_ab5Z a_ab5Y))
              "T -> T"#
    Cont:   Stop[BoringCtxt] Test.Tasty.Core.TestName
Rule fired
    Rule: Class op property
    Module: (BUILTIN)
    Before: Test.QuickCheck.Property.property
              TyArg Data.Text.Internal.Text -> GHC.Types.Bool
              ValArg $dTestable_a97v
    After:  Test.QuickCheck.Property.$fTestableFUN_$cproperty
              @Data.Text.Internal.Text
              @GHC.Types.Bool
              Test.QuickCheck.Instances.Text.$fArbitraryText0
              Data.Text.Show.$fShowText
              Test.QuickCheck.Property.$fTestableBool
    Cont:   ApplyToVal nodup hole (Data.Text.Internal.Text
                                   -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              prop_ab6b
            CastIt (Sym (Test.Tasty.QuickCheck.N:QC[0])
                    :: Test.QuickCheck.Property.Property ~R# Test.Tasty.QuickCheck.QC)
            Stop[BoringCtxt] Test.Tasty.QuickCheck.QC
Rule fired
    Rule: Class op propertyForAllShrinkShow
    Module: (BUILTIN)
    Before: Test.QuickCheck.Property.propertyForAllShrinkShow
              TyArg GHC.Types.Bool ValArg Test.QuickCheck.Property.$fTestableBool
    After:  Test.QuickCheck.Property.$fTestableBool1
            `cast` (forall (a :: <*>_N).
                    <Test.QuickCheck.Gen.Gen a>_R
                    %<'GHC.Types.Many>_N ->_R <a -> [a]>_R
                    %<'GHC.Types.Many>_N ->_R <a -> [GHC.Base.String]>_R
                    %<'GHC.Types.Many>_N ->_R <a -> GHC.Types.Bool>_R
                    %<'GHC.Types.Many>_N ->_R Sym (Test.QuickCheck.Gen.N:Gen[0]
                                                       (Test.QuickCheck.Property.N:Prop[0]))
                                              ; Sym (Test.QuickCheck.Property.N:Property[0])
                    :: (forall {a}.
                        Test.QuickCheck.Gen.Gen a
                        -> (a -> [a])
                        -> (a -> [GHC.Base.String])
                        -> (a -> GHC.Types.Bool)
                        -> Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int
                        -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result)
                       ~R# (forall {a}.
                            Test.QuickCheck.Gen.Gen a
                            -> (a -> [a])
                            -> (a -> [GHC.Base.String])
                            -> (a -> GHC.Types.Bool)
                            -> Test.QuickCheck.Property.Property))
    Cont:   ApplyToTy Data.Text.Internal.Text
            ApplyToVal nodup hole Test.QuickCheck.Gen.Gen
                                    Data.Text.Internal.Text
                                  -> (Data.Text.Internal.Text -> [Data.Text.Internal.Text])
                                  -> (Data.Text.Internal.Text -> [GHC.Base.String])
                                  -> (Data.Text.Internal.Text -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (Test.QuickCheck.Arbitrary.arbitrary @a_ab7T $dArbitrary_ab7V)
            ApplyToVal nodup hole (Data.Text.Internal.Text
                                   -> [Data.Text.Internal.Text])
                                  -> (Data.Text.Internal.Text -> [GHC.Base.String])
                                  -> (Data.Text.Internal.Text -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (Test.QuickCheck.Arbitrary.shrink @a_ab7T $dArbitrary_ab7V)
            ApplyToVal nodup hole (Data.Text.Internal.Text
                                   -> [GHC.Base.String])
                                  -> (Data.Text.Internal.Text -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (let {
                 g_ab7Z [Occ=OnceL1!] :: a_ab7T -> GHC.Base.String
                 [LclId]
                 g_ab7Z = GHC.Show.show @a_ab7T $dShow_ab7W } in
               \ (x_ab80 [Occ=Once1] :: a_ab7T) ->
                 GHC.Types.:
                   @GHC.Base.String (g_ab7Z x_ab80) (GHC.Types.[] @GHC.Base.String))
            ApplyToVal nodup hole (Data.Text.Internal.Text -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              f_ab7Y
            CastIt (Sym (Test.Tasty.QuickCheck.N:QC[0])
                    :: Test.QuickCheck.Property.Property ~R# Test.Tasty.QuickCheck.QC)
            Stop[BoringCtxt] Test.Tasty.QuickCheck.QC
Rule fired
    Rule: Class op arbitrary
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.arbitrary
              TyArg Data.Text.Internal.Text
              ValArg Test.QuickCheck.Instances.Text.$fArbitraryText0
    After:  Test.QuickCheck.Instances.Text.$fArbitraryText3
            `cast` (Sym (Test.QuickCheck.Gen.N:Gen[0]
                             <Data.Text.Internal.Text>_R)
                    :: (Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int -> Data.Text.Internal.Text)
                       ~R# Test.QuickCheck.Gen.Gen Data.Text.Internal.Text)
    Cont:   Stop[BoringCtxt] Test.QuickCheck.Gen.Gen
                               Data.Text.Internal.Text
Rule fired
    Rule: Class op shrink
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.shrink
              TyArg Data.Text.Internal.Text
              ValArg Test.QuickCheck.Instances.Text.$fArbitraryText0
    After:  Test.QuickCheck.Instances.Text.$fArbitraryText0_$cshrink
    Cont:   Stop[BoringCtxt] Data.Text.Internal.Text
                             -> [Data.Text.Internal.Text]
Rule fired
    Rule: Class op show
    Module: (BUILTIN)
    Before: GHC.Show.show
              TyArg Data.Text.Internal.Text ValArg Data.Text.Show.$fShowText
    After:  Data.Text.Show.$fShowText_$cshow
    Cont:   Stop[RhsCtxt(NonRecursive)] Data.Text.Internal.Text
                                        -> GHC.Base.String
Rule fired
    Rule: Class op reader
    Module: (BUILTIN)
    Before: Control.Monad.Reader.Class.reader
              TyArg Data.Text.Internal.Text
              TyArg (->) Data.Text.Internal.Text
              ValArg Control.Monad.Reader.Class.$fMonadReaderrFUN
                       @Data.Text.Internal.Text
    After:  \ (@a_abdo) ->
              GHC.Base.id @(Data.Text.Internal.Text -> a_abdo)
    Cont:   ApplyToTy Data.Text.Internal.Text
            ApplyToVal nodup hole (Data.Text.Internal.Text
                                   -> Data.Text.Internal.Text)
                                  -> Data.Text.Internal.Text -> Data.Text.Internal.Text
              ((l_abdi
                  ((\ (ds_abdj [Occ=Once1] :: a_abdg) -> ds_abdj)
                   `cast` (<a_abdg>_R
                           %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                              <*>_N <a_abdg>_R <a_abdg>_P)
                           :: (a_abdg -> a_abdg)
                              ~R# (a_abdg -> Data.Functor.Const.Const a_abdg a_abdg))))
               `cast` (<s_abde>_R
                       %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                     <*>_N <a_abdg>_R <s_abde>_P
                       :: (s_abde -> Data.Functor.Const.Const a_abdg s_abde)
                          ~R# (s_abde -> a_abdg)))
            ApplyToVal nodup hole Data.Text.Internal.Text
                                  -> Data.Text.Internal.Text
              s_a8IV
            Stop[RuleArgCtxt] Data.Text.Internal.Text
Rule fired
    Rule: recons/id
    Module: (Control.Lens.Cons.Extras)
    Before: Control.Lens.Cons.Extras.recons
              TyArg Data.Text.Internal.Text
              TyArg GHC.Types.Char
              TyArg Data.Text.Internal.Text
              ValArg (\ (@(p_abgP :: * -> * -> *))
                        (@(f_abgQ :: * -> *))
                        ($dChoice_abgR :: Data.Profunctor.Choice.Choice p_abgP)
                        ($dApplicative_abgS :: GHC.Base.Applicative f_abgQ) ->
                        let {
                          f1_abgT
                            :: p_abgP
                                 (Data.Either.Either
                                    Data.Text.Internal.Text
                                    (GHC.Types.Char, Data.Text.Internal.Text))
                                 (Data.Either.Either
                                    Data.Text.Internal.Text
                                    (f_abgQ (GHC.Types.Char, Data.Text.Internal.Text)))
                               -> p_abgP Data.Text.Internal.Text (f_abgQ Data.Text.Internal.Text)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 340 0}]
                          f1_abgT
                            = Data.Profunctor.Unsafe.dimap
                                @p_abgP
                                (Data.Profunctor.Choice.$p1Choice @p_abgP $dChoice_abgR)
                                @Data.Text.Internal.Text
                                @(Data.Either.Either
                                    Data.Text.Internal.Text
                                    (GHC.Types.Char, Data.Text.Internal.Text))
                                @(Data.Either.Either
                                    Data.Text.Internal.Text
                                    (f_abgQ (GHC.Types.Char, Data.Text.Internal.Text)))
                                @(f_abgQ Data.Text.Internal.Text)
                                (\ (s1_abgU :: Data.Text.Internal.Text) ->
                                   case Data.Text.uncons s1_abgU of {
                                     GHC.Maybe.Nothing ->
                                       Data.Either.Left
                                         @Data.Text.Internal.Text
                                         @(GHC.Types.Char, Data.Text.Internal.Text)
                                         s1_abgU;
                                     GHC.Maybe.Just x_abgX ->
                                       Data.Either.Right
                                         @Data.Text.Internal.Text
                                         @(GHC.Types.Char, Data.Text.Internal.Text)
                                         x_abgX
                                   })
                                (let {
                                   f2_abgZ
                                     :: Data.Text.Internal.Text -> f_abgQ Data.Text.Internal.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abgZ
                                     = GHC.Base.pure
                                         @f_abgQ $dApplicative_abgS @Data.Text.Internal.Text } in
                                 let {
                                   ds2_abh0
                                     :: f_abgQ (GHC.Types.Char, Data.Text.Internal.Text)
                                        -> f_abgQ Data.Text.Internal.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 100 0}]
                                   ds2_abh0
                                     = GHC.Base.fmap
                                         @f_abgQ
                                         (GHC.Base.$p1Applicative @f_abgQ $dApplicative_abgS)
                                         @(GHC.Types.Char, Data.Text.Internal.Text)
                                         @Data.Text.Internal.Text
                                         (\ (p1_abh1
                                               :: (GHC.Types.Char, Data.Text.Internal.Text)) ->
                                            case p1_abh1 of { (x_abh3, ds_abh4) ->
                                            Data.Text.cons x_abh3 ds_abh4
                                            }) } in
                                 \ (ds3_abh6
                                      :: Data.Either.Either
                                           Data.Text.Internal.Text
                                           (f_abgQ (GHC.Types.Char, Data.Text.Internal.Text))) ->
                                   case ds3_abh6 of {
                                     Data.Either.Left x_abh8 -> f2_abgZ x_abh8;
                                     Data.Either.Right y_abha -> ds2_abh0 y_abha
                                   }) } in
                        let {
                          g_abhc
                            :: p_abgP
                                 (GHC.Types.Char, Data.Text.Internal.Text)
                                 (f_abgQ (GHC.Types.Char, Data.Text.Internal.Text))
                               -> p_abgP
                                    (Data.Either.Either
                                       Data.Text.Internal.Text
                                       (GHC.Types.Char, Data.Text.Internal.Text))
                                    (Data.Either.Either
                                       Data.Text.Internal.Text
                                       (f_abgQ (GHC.Types.Char, Data.Text.Internal.Text)))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abhc
                            = Data.Profunctor.Choice.right'
                                @p_abgP
                                $dChoice_abgR
                                @(GHC.Types.Char, Data.Text.Internal.Text)
                                @(f_abgQ (GHC.Types.Char, Data.Text.Internal.Text))
                                @Data.Text.Internal.Text } in
                        \ (x_abhd
                             :: p_abgP
                                  (GHC.Types.Char, Data.Text.Internal.Text)
                                  (f_abgQ (GHC.Types.Char, Data.Text.Internal.Text))) ->
                          f1_abgT (g_abhc x_abhd))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <Data.Text.Internal.Text>_N
                                      <Data.Text.Internal.Text>_N
                                      <GHC.Types.Char>_N
                                      <GHC.Types.Char>_N)
                             :: Control.Lens.Type.Prism
                                  Data.Text.Internal.Text
                                  Data.Text.Internal.Text
                                  (GHC.Types.Char, Data.Text.Internal.Text)
                                  (GHC.Types.Char, Data.Text.Internal.Text)
                                ~R# Control.Lens.Cons.Cons
                                      Data.Text.Internal.Text
                                      Data.Text.Internal.Text
                                      GHC.Types.Char
                                      GHC.Types.Char)
              ValArg (\ (@(p_abgP :: * -> * -> *))
                        (@(f_abgQ :: * -> *))
                        ($dChoice_abgR :: Data.Profunctor.Choice.Choice p_abgP)
                        ($dApplicative_abgS :: GHC.Base.Applicative f_abgQ) ->
                        let {
                          f1_abgT
                            :: p_abgP
                                 (Data.Either.Either
                                    Data.Text.Internal.Text
                                    (GHC.Types.Char, Data.Text.Internal.Text))
                                 (Data.Either.Either
                                    Data.Text.Internal.Text
                                    (f_abgQ (GHC.Types.Char, Data.Text.Internal.Text)))
                               -> p_abgP Data.Text.Internal.Text (f_abgQ Data.Text.Internal.Text)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 340 0}]
                          f1_abgT
                            = Data.Profunctor.Unsafe.dimap
                                @p_abgP
                                (Data.Profunctor.Choice.$p1Choice @p_abgP $dChoice_abgR)
                                @Data.Text.Internal.Text
                                @(Data.Either.Either
                                    Data.Text.Internal.Text
                                    (GHC.Types.Char, Data.Text.Internal.Text))
                                @(Data.Either.Either
                                    Data.Text.Internal.Text
                                    (f_abgQ (GHC.Types.Char, Data.Text.Internal.Text)))
                                @(f_abgQ Data.Text.Internal.Text)
                                (\ (s1_abgU :: Data.Text.Internal.Text) ->
                                   case Data.Text.uncons s1_abgU of {
                                     GHC.Maybe.Nothing ->
                                       Data.Either.Left
                                         @Data.Text.Internal.Text
                                         @(GHC.Types.Char, Data.Text.Internal.Text)
                                         s1_abgU;
                                     GHC.Maybe.Just x_abgX ->
                                       Data.Either.Right
                                         @Data.Text.Internal.Text
                                         @(GHC.Types.Char, Data.Text.Internal.Text)
                                         x_abgX
                                   })
                                (let {
                                   f2_abgZ
                                     :: Data.Text.Internal.Text -> f_abgQ Data.Text.Internal.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abgZ
                                     = GHC.Base.pure
                                         @f_abgQ $dApplicative_abgS @Data.Text.Internal.Text } in
                                 let {
                                   ds2_abh0
                                     :: f_abgQ (GHC.Types.Char, Data.Text.Internal.Text)
                                        -> f_abgQ Data.Text.Internal.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 100 0}]
                                   ds2_abh0
                                     = GHC.Base.fmap
                                         @f_abgQ
                                         (GHC.Base.$p1Applicative @f_abgQ $dApplicative_abgS)
                                         @(GHC.Types.Char, Data.Text.Internal.Text)
                                         @Data.Text.Internal.Text
                                         (\ (p1_abh1
                                               :: (GHC.Types.Char, Data.Text.Internal.Text)) ->
                                            case p1_abh1 of { (x_abh3, ds_abh4) ->
                                            Data.Text.cons x_abh3 ds_abh4
                                            }) } in
                                 \ (ds3_abh6
                                      :: Data.Either.Either
                                           Data.Text.Internal.Text
                                           (f_abgQ (GHC.Types.Char, Data.Text.Internal.Text))) ->
                                   case ds3_abh6 of {
                                     Data.Either.Left x_abh8 -> f2_abgZ x_abh8;
                                     Data.Either.Right y_abha -> ds2_abh0 y_abha
                                   }) } in
                        let {
                          g_abhc
                            :: p_abgP
                                 (GHC.Types.Char, Data.Text.Internal.Text)
                                 (f_abgQ (GHC.Types.Char, Data.Text.Internal.Text))
                               -> p_abgP
                                    (Data.Either.Either
                                       Data.Text.Internal.Text
                                       (GHC.Types.Char, Data.Text.Internal.Text))
                                    (Data.Either.Either
                                       Data.Text.Internal.Text
                                       (f_abgQ (GHC.Types.Char, Data.Text.Internal.Text)))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abhc
                            = Data.Profunctor.Choice.right'
                                @p_abgP
                                $dChoice_abgR
                                @(GHC.Types.Char, Data.Text.Internal.Text)
                                @(f_abgQ (GHC.Types.Char, Data.Text.Internal.Text))
                                @Data.Text.Internal.Text } in
                        \ (x_abhd
                             :: p_abgP
                                  (GHC.Types.Char, Data.Text.Internal.Text)
                                  (f_abgQ (GHC.Types.Char, Data.Text.Internal.Text))) ->
                          f1_abgT (g_abhc x_abhd))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <Data.Text.Internal.Text>_N
                                      <Data.Text.Internal.Text>_N
                                      <GHC.Types.Char>_N
                                      <GHC.Types.Char>_N)
                             :: Control.Lens.Type.Prism
                                  Data.Text.Internal.Text
                                  Data.Text.Internal.Text
                                  (GHC.Types.Char, Data.Text.Internal.Text)
                                  (GHC.Types.Char, Data.Text.Internal.Text)
                                ~R# Control.Lens.Cons.Cons
                                      Data.Text.Internal.Text
                                      Data.Text.Internal.Text
                                      GHC.Types.Char
                                      GHC.Types.Char)
              ValArg (\ (@(p_abhe :: * -> * -> *))
                        (@(f_abhf :: * -> *))
                        ($dChoice_abhg :: Data.Profunctor.Choice.Choice p_abhe)
                        ($dApplicative_abhh :: GHC.Base.Applicative f_abhf) ->
                        let {
                          f1_abhi
                            :: p_abhe
                                 (Data.Either.Either Data.Text.Internal.Text ())
                                 (Data.Either.Either Data.Text.Internal.Text (f_abhf ()))
                               -> p_abhe Data.Text.Internal.Text (f_abhf Data.Text.Internal.Text)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 310 0}]
                          f1_abhi
                            = Data.Profunctor.Unsafe.dimap
                                @p_abhe
                                (Data.Profunctor.Choice.$p1Choice @p_abhe $dChoice_abhg)
                                @Data.Text.Internal.Text
                                @(Data.Either.Either Data.Text.Internal.Text ())
                                @(Data.Either.Either Data.Text.Internal.Text (f_abhf ()))
                                @(f_abhf Data.Text.Internal.Text)
                                (\ (s_abhj :: Data.Text.Internal.Text) ->
                                   case Data.Text.null s_abhj of {
                                     GHC.Types.False ->
                                       Data.Either.Left @Data.Text.Internal.Text @() s_abhj;
                                     GHC.Types.True ->
                                       Data.Either.Right
                                         @Data.Text.Internal.Text @() GHC.Tuple.Prim.()
                                   })
                                (let {
                                   f2_abhm
                                     :: Data.Text.Internal.Text -> f_abhf Data.Text.Internal.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abhm
                                     = GHC.Base.pure
                                         @f_abhf $dApplicative_abhh @Data.Text.Internal.Text } in
                                 let {
                                   ds2_abhn :: f_abhf () -> f_abhf Data.Text.Internal.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 70 0}]
                                   ds2_abhn
                                     = GHC.Base.fmap
                                         @f_abhf
                                         (GHC.Base.$p1Applicative @f_abhf $dApplicative_abhh)
                                         @()
                                         @Data.Text.Internal.Text
                                         (\ (ds3_abho :: ()) ->
                                            case ds3_abho of { () ->
                                            Data.Text.Internal.empty
                                            }) } in
                                 \ (ds3_abhq
                                      :: Data.Either.Either Data.Text.Internal.Text (f_abhf ())) ->
                                   case ds3_abhq of {
                                     Data.Either.Left x_abhs -> f2_abhm x_abhs;
                                     Data.Either.Right y_abhu -> ds2_abhn y_abhu
                                   }) } in
                        let {
                          g_abhw
                            :: p_abhe () (f_abhf ())
                               -> p_abhe
                                    (Data.Either.Either Data.Text.Internal.Text ())
                                    (Data.Either.Either Data.Text.Internal.Text (f_abhf ()))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abhw
                            = Data.Profunctor.Choice.right'
                                @p_abhe
                                $dChoice_abhg
                                @()
                                @(f_abhf ())
                                @Data.Text.Internal.Text } in
                        \ (x_abhx :: p_abhe () (f_abhf ())) -> f1_abhi (g_abhw x_abhx))
                     `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                      <Data.Text.Internal.Text>_N)
                             :: Control.Lens.Type.Prism' Data.Text.Internal.Text ()
                                ~R# Control.Lens.Empty.AsEmpty Data.Text.Internal.Text)
              TyArg Data.Functor.Const.Const Data.Text.Internal.Text
              ValArg Data.Functor.Contravariant.$fContravariantConst
                       @Data.Text.Internal.Text
              ValArg Data.Functor.Const.$fFunctorConst @Data.Text.Internal.Text
    After:  (\ (@s1_aben)
               (@(f_abeo :: * -> *))
               (@a_abep)
               ($dCons_abeq
                  :: Control.Lens.Cons.Cons s1_aben s1_aben a_abep a_abep)
               ($dCons1_aber
                  :: Control.Lens.Cons.Cons s1_aben s1_aben a_abep a_abep)
               ($dAsEmpty_abes :: Control.Lens.Empty.AsEmpty s1_aben)
               ($dContravariant_abet
                  :: Data.Functor.Contravariant.Contravariant f_abeo)
               ($dFunctor_abeu :: GHC.Base.Functor f_abeo) ->
               GHC.Base.id @(s1_aben -> f_abeo s1_aben))
              @Data.Text.Internal.Text
              @(Data.Functor.Const.Const Data.Text.Internal.Text)
              @GHC.Types.Char
              ((\ (@(p_abgP :: * -> * -> *))
                  (@(f_abgQ :: * -> *))
                  ($dChoice_abgR :: Data.Profunctor.Choice.Choice p_abgP)
                  ($dApplicative_abgS :: GHC.Base.Applicative f_abgQ) ->
                  let {
                    f1_abgT
                      :: p_abgP
                           (Data.Either.Either
                              Data.Text.Internal.Text (GHC.Types.Char, Data.Text.Internal.Text))
                           (Data.Either.Either
                              Data.Text.Internal.Text
                              (f_abgQ (GHC.Types.Char, Data.Text.Internal.Text)))
                         -> p_abgP Data.Text.Internal.Text (f_abgQ Data.Text.Internal.Text)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 340 0}]
                    f1_abgT
                      = Data.Profunctor.Unsafe.dimap
                          @p_abgP
                          (Data.Profunctor.Choice.$p1Choice @p_abgP $dChoice_abgR)
                          @Data.Text.Internal.Text
                          @(Data.Either.Either
                              Data.Text.Internal.Text (GHC.Types.Char, Data.Text.Internal.Text))
                          @(Data.Either.Either
                              Data.Text.Internal.Text
                              (f_abgQ (GHC.Types.Char, Data.Text.Internal.Text)))
                          @(f_abgQ Data.Text.Internal.Text)
                          (\ (s1_abgU :: Data.Text.Internal.Text) ->
                             case Data.Text.uncons s1_abgU of {
                               GHC.Maybe.Nothing ->
                                 Data.Either.Left
                                   @Data.Text.Internal.Text
                                   @(GHC.Types.Char, Data.Text.Internal.Text)
                                   s1_abgU;
                               GHC.Maybe.Just x_abgX ->
                                 Data.Either.Right
                                   @Data.Text.Internal.Text
                                   @(GHC.Types.Char, Data.Text.Internal.Text)
                                   x_abgX
                             })
                          (let {
                             f2_abgZ
                               :: Data.Text.Internal.Text -> f_abgQ Data.Text.Internal.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abgZ
                               = GHC.Base.pure
                                   @f_abgQ $dApplicative_abgS @Data.Text.Internal.Text } in
                           let {
                             ds2_abh0
                               :: f_abgQ (GHC.Types.Char, Data.Text.Internal.Text)
                                  -> f_abgQ Data.Text.Internal.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 100 0}]
                             ds2_abh0
                               = GHC.Base.fmap
                                   @f_abgQ
                                   (GHC.Base.$p1Applicative @f_abgQ $dApplicative_abgS)
                                   @(GHC.Types.Char, Data.Text.Internal.Text)
                                   @Data.Text.Internal.Text
                                   (\ (p1_abh1 :: (GHC.Types.Char, Data.Text.Internal.Text)) ->
                                      case p1_abh1 of { (x_abh3, ds_abh4) ->
                                      Data.Text.cons x_abh3 ds_abh4
                                      }) } in
                           \ (ds3_abh6
                                :: Data.Either.Either
                                     Data.Text.Internal.Text
                                     (f_abgQ (GHC.Types.Char, Data.Text.Internal.Text))) ->
                             case ds3_abh6 of {
                               Data.Either.Left x_abh8 -> f2_abgZ x_abh8;
                               Data.Either.Right y_abha -> ds2_abh0 y_abha
                             }) } in
                  let {
                    g_abhc
                      :: p_abgP
                           (GHC.Types.Char, Data.Text.Internal.Text)
                           (f_abgQ (GHC.Types.Char, Data.Text.Internal.Text))
                         -> p_abgP
                              (Data.Either.Either
                                 Data.Text.Internal.Text (GHC.Types.Char, Data.Text.Internal.Text))
                              (Data.Either.Either
                                 Data.Text.Internal.Text
                                 (f_abgQ (GHC.Types.Char, Data.Text.Internal.Text)))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abhc
                      = Data.Profunctor.Choice.right'
                          @p_abgP
                          $dChoice_abgR
                          @(GHC.Types.Char, Data.Text.Internal.Text)
                          @(f_abgQ (GHC.Types.Char, Data.Text.Internal.Text))
                          @Data.Text.Internal.Text } in
                  \ (x_abhd
                       :: p_abgP
                            (GHC.Types.Char, Data.Text.Internal.Text)
                            (f_abgQ (GHC.Types.Char, Data.Text.Internal.Text))) ->
                    f1_abgT (g_abhc x_abhd))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <Data.Text.Internal.Text>_N
                                <Data.Text.Internal.Text>_N
                                <GHC.Types.Char>_N
                                <GHC.Types.Char>_N)
                       :: Control.Lens.Type.Prism
                            Data.Text.Internal.Text
                            Data.Text.Internal.Text
                            (GHC.Types.Char, Data.Text.Internal.Text)
                            (GHC.Types.Char, Data.Text.Internal.Text)
                          ~R# Control.Lens.Cons.Cons
                                Data.Text.Internal.Text
                                Data.Text.Internal.Text
                                GHC.Types.Char
                                GHC.Types.Char))
              ((\ (@(p_abgP :: * -> * -> *))
                  (@(f_abgQ :: * -> *))
                  ($dChoice_abgR :: Data.Profunctor.Choice.Choice p_abgP)
                  ($dApplicative_abgS :: GHC.Base.Applicative f_abgQ) ->
                  let {
                    f1_abgT
                      :: p_abgP
                           (Data.Either.Either
                              Data.Text.Internal.Text (GHC.Types.Char, Data.Text.Internal.Text))
                           (Data.Either.Either
                              Data.Text.Internal.Text
                              (f_abgQ (GHC.Types.Char, Data.Text.Internal.Text)))
                         -> p_abgP Data.Text.Internal.Text (f_abgQ Data.Text.Internal.Text)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 340 0}]
                    f1_abgT
                      = Data.Profunctor.Unsafe.dimap
                          @p_abgP
                          (Data.Profunctor.Choice.$p1Choice @p_abgP $dChoice_abgR)
                          @Data.Text.Internal.Text
                          @(Data.Either.Either
                              Data.Text.Internal.Text (GHC.Types.Char, Data.Text.Internal.Text))
                          @(Data.Either.Either
                              Data.Text.Internal.Text
                              (f_abgQ (GHC.Types.Char, Data.Text.Internal.Text)))
                          @(f_abgQ Data.Text.Internal.Text)
                          (\ (s1_abgU :: Data.Text.Internal.Text) ->
                             case Data.Text.uncons s1_abgU of {
                               GHC.Maybe.Nothing ->
                                 Data.Either.Left
                                   @Data.Text.Internal.Text
                                   @(GHC.Types.Char, Data.Text.Internal.Text)
                                   s1_abgU;
                               GHC.Maybe.Just x_abgX ->
                                 Data.Either.Right
                                   @Data.Text.Internal.Text
                                   @(GHC.Types.Char, Data.Text.Internal.Text)
                                   x_abgX
                             })
                          (let {
                             f2_abgZ
                               :: Data.Text.Internal.Text -> f_abgQ Data.Text.Internal.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abgZ
                               = GHC.Base.pure
                                   @f_abgQ $dApplicative_abgS @Data.Text.Internal.Text } in
                           let {
                             ds2_abh0
                               :: f_abgQ (GHC.Types.Char, Data.Text.Internal.Text)
                                  -> f_abgQ Data.Text.Internal.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 100 0}]
                             ds2_abh0
                               = GHC.Base.fmap
                                   @f_abgQ
                                   (GHC.Base.$p1Applicative @f_abgQ $dApplicative_abgS)
                                   @(GHC.Types.Char, Data.Text.Internal.Text)
                                   @Data.Text.Internal.Text
                                   (\ (p1_abh1 :: (GHC.Types.Char, Data.Text.Internal.Text)) ->
                                      case p1_abh1 of { (x_abh3, ds_abh4) ->
                                      Data.Text.cons x_abh3 ds_abh4
                                      }) } in
                           \ (ds3_abh6
                                :: Data.Either.Either
                                     Data.Text.Internal.Text
                                     (f_abgQ (GHC.Types.Char, Data.Text.Internal.Text))) ->
                             case ds3_abh6 of {
                               Data.Either.Left x_abh8 -> f2_abgZ x_abh8;
                               Data.Either.Right y_abha -> ds2_abh0 y_abha
                             }) } in
                  let {
                    g_abhc
                      :: p_abgP
                           (GHC.Types.Char, Data.Text.Internal.Text)
                           (f_abgQ (GHC.Types.Char, Data.Text.Internal.Text))
                         -> p_abgP
                              (Data.Either.Either
                                 Data.Text.Internal.Text (GHC.Types.Char, Data.Text.Internal.Text))
                              (Data.Either.Either
                                 Data.Text.Internal.Text
                                 (f_abgQ (GHC.Types.Char, Data.Text.Internal.Text)))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abhc
                      = Data.Profunctor.Choice.right'
                          @p_abgP
                          $dChoice_abgR
                          @(GHC.Types.Char, Data.Text.Internal.Text)
                          @(f_abgQ (GHC.Types.Char, Data.Text.Internal.Text))
                          @Data.Text.Internal.Text } in
                  \ (x_abhd
                       :: p_abgP
                            (GHC.Types.Char, Data.Text.Internal.Text)
                            (f_abgQ (GHC.Types.Char, Data.Text.Internal.Text))) ->
                    f1_abgT (g_abhc x_abhd))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <Data.Text.Internal.Text>_N
                                <Data.Text.Internal.Text>_N
                                <GHC.Types.Char>_N
                                <GHC.Types.Char>_N)
                       :: Control.Lens.Type.Prism
                            Data.Text.Internal.Text
                            Data.Text.Internal.Text
                            (GHC.Types.Char, Data.Text.Internal.Text)
                            (GHC.Types.Char, Data.Text.Internal.Text)
                          ~R# Control.Lens.Cons.Cons
                                Data.Text.Internal.Text
                                Data.Text.Internal.Text
                                GHC.Types.Char
                                GHC.Types.Char))
              ((\ (@(p_abhe :: * -> * -> *))
                  (@(f_abhf :: * -> *))
                  ($dChoice_abhg :: Data.Profunctor.Choice.Choice p_abhe)
                  ($dApplicative_abhh :: GHC.Base.Applicative f_abhf) ->
                  let {
                    f1_abhi
                      :: p_abhe
                           (Data.Either.Either Data.Text.Internal.Text ())
                           (Data.Either.Either Data.Text.Internal.Text (f_abhf ()))
                         -> p_abhe Data.Text.Internal.Text (f_abhf Data.Text.Internal.Text)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 310 0}]
                    f1_abhi
                      = Data.Profunctor.Unsafe.dimap
                          @p_abhe
                          (Data.Profunctor.Choice.$p1Choice @p_abhe $dChoice_abhg)
                          @Data.Text.Internal.Text
                          @(Data.Either.Either Data.Text.Internal.Text ())
                          @(Data.Either.Either Data.Text.Internal.Text (f_abhf ()))
                          @(f_abhf Data.Text.Internal.Text)
                          (\ (s_abhj :: Data.Text.Internal.Text) ->
                             case Data.Text.null s_abhj of {
                               GHC.Types.False ->
                                 Data.Either.Left @Data.Text.Internal.Text @() s_abhj;
                               GHC.Types.True ->
                                 Data.Either.Right @Data.Text.Internal.Text @() GHC.Tuple.Prim.()
                             })
                          (let {
                             f2_abhm
                               :: Data.Text.Internal.Text -> f_abhf Data.Text.Internal.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abhm
                               = GHC.Base.pure
                                   @f_abhf $dApplicative_abhh @Data.Text.Internal.Text } in
                           let {
                             ds2_abhn :: f_abhf () -> f_abhf Data.Text.Internal.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 70 0}]
                             ds2_abhn
                               = GHC.Base.fmap
                                   @f_abhf
                                   (GHC.Base.$p1Applicative @f_abhf $dApplicative_abhh)
                                   @()
                                   @Data.Text.Internal.Text
                                   (\ (ds3_abho :: ()) ->
                                      case ds3_abho of { () -> Data.Text.Internal.empty }) } in
                           \ (ds3_abhq
                                :: Data.Either.Either Data.Text.Internal.Text (f_abhf ())) ->
                             case ds3_abhq of {
                               Data.Either.Left x_abhs -> f2_abhm x_abhs;
                               Data.Either.Right y_abhu -> ds2_abhn y_abhu
                             }) } in
                  let {
                    g_abhw
                      :: p_abhe () (f_abhf ())
                         -> p_abhe
                              (Data.Either.Either Data.Text.Internal.Text ())
                              (Data.Either.Either Data.Text.Internal.Text (f_abhf ()))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abhw
                      = Data.Profunctor.Choice.right'
                          @p_abhe
                          $dChoice_abhg
                          @()
                          @(f_abhf ())
                          @Data.Text.Internal.Text } in
                  \ (x_abhx :: p_abhe () (f_abhf ())) -> f1_abhi (g_abhw x_abhx))
               `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                <Data.Text.Internal.Text>_N)
                       :: Control.Lens.Type.Prism' Data.Text.Internal.Text ()
                          ~R# Control.Lens.Empty.AsEmpty Data.Text.Internal.Text))
              (Data.Functor.Contravariant.$fContravariantConst
                 @Data.Text.Internal.Text)
              (Data.Functor.Const.$fFunctorConst @Data.Text.Internal.Text)
    Cont:   ApplyToVal nodup hole Control.Lens.Getter.Getting
                                    Data.Text.Internal.Text
                                    Data.Text.Internal.Text
                                    Data.Text.Internal.Text
              ((\ (ds_abdj [Occ=Once1] :: a_abdg) -> ds_abdj)
               `cast` (<a_abdg>_R
                       %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                          <*>_N <a_abdg>_R <a_abdg>_P)
                       :: (a_abdg -> a_abdg)
                          ~R# (a_abdg -> Data.Functor.Const.Const a_abdg a_abdg)))
            ApplyToVal nodup hole Data.Text.Internal.Text
                                  -> Data.Functor.Const.Const
                                       Data.Text.Internal.Text Data.Text.Internal.Text
              s_a8IV
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N <Data.Text.Internal.Text>_R <Data.Text.Internal.Text>_P
                    :: Data.Functor.Const.Const
                         Data.Text.Internal.Text Data.Text.Internal.Text
                       ~R# Data.Text.Internal.Text)
            Stop[RuleArgCtxt] Data.Text.Internal.Text
Rule fired
    Rule: Class op ==
    Module: (BUILTIN)
    Before: GHC.Classes.==
              TyArg Data.Text.Internal.Text
              ValArg Data.Text.$fEqText
              ValArg s_a8IV
              ValArg s_a8IV
    After:  Data.Text.$fEqText_$c== ValArg s_a8IV ValArg s_a8IV
    Cont:   Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: unpack
    Module: (GHC.Base)
    Before: GHC.CString.unpackCString# ValArg "TL -> TL"#
    After:  (\ (a_ab5Y :: GHC.Prim.Addr#) ->
               GHC.Base.build
                 @GHC.Types.Char
                 (\ (@b_ab5Z) -> GHC.CString.unpackFoldrCString# @b_ab5Z a_ab5Y))
              "TL -> TL"#
    Cont:   Stop[BoringCtxt] Test.Tasty.Core.TestName
Rule fired
    Rule: Class op property
    Module: (BUILTIN)
    Before: Test.QuickCheck.Property.property
              TyArg Data.Text.Internal.Lazy.Text -> GHC.Types.Bool
              ValArg Test.QuickCheck.Property.$fTestableFUN
                       @Data.Text.Internal.Lazy.Text
                       @GHC.Types.Bool
                       Test.QuickCheck.Instances.Text.$fArbitraryText
                       Data.Text.Lazy.$fShowText
                       Test.QuickCheck.Property.$fTestableBool
    After:  Test.QuickCheck.Property.$fTestableFUN_$cproperty
              @Data.Text.Internal.Lazy.Text
              @GHC.Types.Bool
              Test.QuickCheck.Instances.Text.$fArbitraryText
              Data.Text.Lazy.$fShowText
              Test.QuickCheck.Property.$fTestableBool
    Cont:   ApplyToVal nodup hole (Data.Text.Internal.Lazy.Text
                                   -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              prop_ab6b
            CastIt (Sym (Test.Tasty.QuickCheck.N:QC[0])
                    :: Test.QuickCheck.Property.Property ~R# Test.Tasty.QuickCheck.QC)
            Stop[BoringCtxt] Test.Tasty.QuickCheck.QC
Rule fired
    Rule: Class op propertyForAllShrinkShow
    Module: (BUILTIN)
    Before: Test.QuickCheck.Property.propertyForAllShrinkShow
              TyArg GHC.Types.Bool ValArg Test.QuickCheck.Property.$fTestableBool
    After:  Test.QuickCheck.Property.$fTestableBool1
            `cast` (forall (a :: <*>_N).
                    <Test.QuickCheck.Gen.Gen a>_R
                    %<'GHC.Types.Many>_N ->_R <a -> [a]>_R
                    %<'GHC.Types.Many>_N ->_R <a -> [GHC.Base.String]>_R
                    %<'GHC.Types.Many>_N ->_R <a -> GHC.Types.Bool>_R
                    %<'GHC.Types.Many>_N ->_R Sym (Test.QuickCheck.Gen.N:Gen[0]
                                                       (Test.QuickCheck.Property.N:Prop[0]))
                                              ; Sym (Test.QuickCheck.Property.N:Property[0])
                    :: (forall {a}.
                        Test.QuickCheck.Gen.Gen a
                        -> (a -> [a])
                        -> (a -> [GHC.Base.String])
                        -> (a -> GHC.Types.Bool)
                        -> Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int
                        -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result)
                       ~R# (forall {a}.
                            Test.QuickCheck.Gen.Gen a
                            -> (a -> [a])
                            -> (a -> [GHC.Base.String])
                            -> (a -> GHC.Types.Bool)
                            -> Test.QuickCheck.Property.Property))
    Cont:   ApplyToTy Data.Text.Internal.Lazy.Text
            ApplyToVal nodup hole Test.QuickCheck.Gen.Gen
                                    Data.Text.Internal.Lazy.Text
                                  -> (Data.Text.Internal.Lazy.Text
                                      -> [Data.Text.Internal.Lazy.Text])
                                  -> (Data.Text.Internal.Lazy.Text -> [GHC.Base.String])
                                  -> (Data.Text.Internal.Lazy.Text -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (Test.QuickCheck.Arbitrary.arbitrary @a_ab7T $dArbitrary_ab7V)
            ApplyToVal nodup hole (Data.Text.Internal.Lazy.Text
                                   -> [Data.Text.Internal.Lazy.Text])
                                  -> (Data.Text.Internal.Lazy.Text -> [GHC.Base.String])
                                  -> (Data.Text.Internal.Lazy.Text -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (Test.QuickCheck.Arbitrary.shrink @a_ab7T $dArbitrary_ab7V)
            ApplyToVal nodup hole (Data.Text.Internal.Lazy.Text
                                   -> [GHC.Base.String])
                                  -> (Data.Text.Internal.Lazy.Text -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (let {
                 g_ab7Z [Occ=OnceL1!] :: a_ab7T -> GHC.Base.String
                 [LclId]
                 g_ab7Z = GHC.Show.show @a_ab7T $dShow_ab7W } in
               \ (x_ab80 [Occ=Once1] :: a_ab7T) ->
                 GHC.Types.:
                   @GHC.Base.String (g_ab7Z x_ab80) (GHC.Types.[] @GHC.Base.String))
            ApplyToVal nodup hole (Data.Text.Internal.Lazy.Text
                                   -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              f_ab7Y
            CastIt (Sym (Test.Tasty.QuickCheck.N:QC[0])
                    :: Test.QuickCheck.Property.Property ~R# Test.Tasty.QuickCheck.QC)
            Stop[BoringCtxt] Test.Tasty.QuickCheck.QC
Rule fired
    Rule: Class op arbitrary
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.arbitrary
              TyArg Data.Text.Internal.Lazy.Text
              ValArg Test.QuickCheck.Instances.Text.$fArbitraryText
    After:  Test.QuickCheck.Instances.Text.$fArbitraryText2
            `cast` (Sym (Test.QuickCheck.Gen.N:Gen[0]
                             <Data.Text.Internal.Lazy.Text>_R)
                    :: (Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int -> Data.Text.Internal.Lazy.Text)
                       ~R# Test.QuickCheck.Gen.Gen Data.Text.Internal.Lazy.Text)
    Cont:   Stop[BoringCtxt] Test.QuickCheck.Gen.Gen
                               Data.Text.Internal.Lazy.Text
Rule fired
    Rule: Class op shrink
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.shrink
              TyArg Data.Text.Internal.Lazy.Text
              ValArg Test.QuickCheck.Instances.Text.$fArbitraryText
    After:  Test.QuickCheck.Instances.Text.$fArbitraryText_$cshrink
    Cont:   Stop[BoringCtxt] Data.Text.Internal.Lazy.Text
                             -> [Data.Text.Internal.Lazy.Text]
Rule fired
    Rule: Class op show
    Module: (BUILTIN)
    Before: GHC.Show.show
              TyArg Data.Text.Internal.Lazy.Text ValArg Data.Text.Lazy.$fShowText
    After:  Data.Text.Lazy.$fShowText_$cshow
    Cont:   Stop[RhsCtxt(NonRecursive)] Data.Text.Internal.Lazy.Text
                                        -> GHC.Base.String
Rule fired
    Rule: Class op reader
    Module: (BUILTIN)
    Before: Control.Monad.Reader.Class.reader
              TyArg Data.Text.Internal.Lazy.Text
              TyArg (->) Data.Text.Internal.Lazy.Text
              ValArg Control.Monad.Reader.Class.$fMonadReaderrFUN
                       @Data.Text.Internal.Lazy.Text
    After:  \ (@a_abdo) ->
              GHC.Base.id @(Data.Text.Internal.Lazy.Text -> a_abdo)
    Cont:   ApplyToTy Data.Text.Internal.Lazy.Text
            ApplyToVal nodup hole (Data.Text.Internal.Lazy.Text
                                   -> Data.Text.Internal.Lazy.Text)
                                  -> Data.Text.Internal.Lazy.Text -> Data.Text.Internal.Lazy.Text
              ((l_abdi
                  ((\ (ds_abdj [Occ=Once1] :: a_abdg) -> ds_abdj)
                   `cast` (<a_abdg>_R
                           %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                              <*>_N <a_abdg>_R <a_abdg>_P)
                           :: (a_abdg -> a_abdg)
                              ~R# (a_abdg -> Data.Functor.Const.Const a_abdg a_abdg))))
               `cast` (<s_abde>_R
                       %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                     <*>_N <a_abdg>_R <s_abde>_P
                       :: (s_abde -> Data.Functor.Const.Const a_abdg s_abde)
                          ~R# (s_abde -> a_abdg)))
            ApplyToVal nodup hole Data.Text.Internal.Lazy.Text
                                  -> Data.Text.Internal.Lazy.Text
              s_a8IW
            Stop[RuleArgCtxt] Data.Text.Internal.Lazy.Text
Rule fired
    Rule: recons/id
    Module: (Control.Lens.Cons.Extras)
    Before: Control.Lens.Cons.Extras.recons
              TyArg Data.Text.Internal.Lazy.Text
              TyArg GHC.Types.Char
              TyArg Data.Text.Internal.Lazy.Text
              ValArg (\ (@(p_abhE :: * -> * -> *))
                        (@(f_abhF :: * -> *))
                        ($dChoice_abhG :: Data.Profunctor.Choice.Choice p_abhE)
                        ($dApplicative_abhH :: GHC.Base.Applicative f_abhF) ->
                        let {
                          f1_abhI
                            :: p_abhE
                                 (Data.Either.Either
                                    Data.Text.Internal.Lazy.Text
                                    (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                                 (Data.Either.Either
                                    Data.Text.Internal.Lazy.Text
                                    (f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                               -> p_abhE
                                    Data.Text.Internal.Lazy.Text
                                    (f_abhF Data.Text.Internal.Lazy.Text)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 639 0}]
                          f1_abhI
                            = Data.Profunctor.Unsafe.dimap
                                @p_abhE
                                (Data.Profunctor.Choice.$p1Choice @p_abhE $dChoice_abhG)
                                @Data.Text.Internal.Lazy.Text
                                @(Data.Either.Either
                                    Data.Text.Internal.Lazy.Text
                                    (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                                @(Data.Either.Either
                                    Data.Text.Internal.Lazy.Text
                                    (f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                                @(f_abhF Data.Text.Internal.Lazy.Text)
                                (\ (s1_abhJ :: Data.Text.Internal.Lazy.Text) ->
                                   case s1_abhJ of {
                                     Data.Text.Internal.Lazy.Empty ->
                                       Data.Either.Left
                                         @Data.Text.Internal.Lazy.Text
                                         @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                         Data.Text.Internal.Lazy.Empty;
                                     Data.Text.Internal.Lazy.Chunk bx_abhQ bx1_abhR bx2_abhS
                                                                   ts_abhT ->
                                       Data.Either.Right
                                         @Data.Text.Internal.Lazy.Text
                                         @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                         (case GHC.Prim.indexWord8Array# bx_abhQ bx1_abhR of r#_abhV
                                          { __DEFAULT ->
                                          let {
                                            c#_abhW :: GHC.Prim.Int#
                                            [LclId,
                                             Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                     Value=False, ConLike=False, WorkFree=False,
                                                     Expandable=False,
                                                     Guidance=IF_ARGS [] 4 0}]
                                            c#_abhW
                                              = GHC.Prim.word2Int#
                                                  (GHC.Prim.clz8#
                                                     (GHC.Prim.and#
                                                        (GHC.Prim.not#
                                                           (GHC.Prim.word8ToWord# r#_abhV))
                                                        255##)) } in
                                          case GHC.Prim.xorI# c#_abhW (GHC.Prim.<=# c#_abhW 0#) of {
                                            __DEFAULT ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abhQ (GHC.Prim.+# bx1_abhR 1#)
                                              of r#1_abhY
                                              { __DEFAULT ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abhQ (GHC.Prim.+# bx1_abhR 2#)
                                              of r#2_abhZ
                                              { __DEFAULT ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abhQ (GHC.Prim.+# bx1_abhR 3#)
                                              of r#3_abi0
                                              { __DEFAULT ->
                                              GHC.Types.C#
                                                (GHC.Prim.chr#
                                                   (GHC.Prim.-#
                                                      (GHC.Prim.+#
                                                         (GHC.Prim.+#
                                                            (GHC.Prim.+#
                                                               (GHC.Prim.uncheckedIShiftL#
                                                                  (GHC.Prim.-#
                                                                     (GHC.Prim.word2Int#
                                                                        (GHC.Prim.word8ToWord#
                                                                           r#_abhV))
                                                                     240#)
                                                                  18#)
                                                               (GHC.Prim.uncheckedIShiftL#
                                                                  (GHC.Prim.-#
                                                                     (GHC.Prim.word2Int#
                                                                        (GHC.Prim.word8ToWord#
                                                                           r#1_abhY))
                                                                     128#)
                                                                  12#))
                                                            (GHC.Prim.uncheckedIShiftL#
                                                               (GHC.Prim.-#
                                                                  (GHC.Prim.word2Int#
                                                                     (GHC.Prim.word8ToWord#
                                                                        r#2_abhZ))
                                                                  128#)
                                                               6#))
                                                         (GHC.Prim.word2Int#
                                                            (GHC.Prim.word8ToWord# r#3_abi0)))
                                                      128#))
                                              }
                                              }
                                              };
                                            1# ->
                                              GHC.Types.C#
                                                (GHC.Prim.chr#
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.word8ToWord# r#_abhV)));
                                            2# ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abhQ (GHC.Prim.+# bx1_abhR 1#)
                                              of r#1_abi1
                                              { __DEFAULT ->
                                              GHC.Types.C#
                                                (GHC.Prim.chr#
                                                   (GHC.Prim.-#
                                                      (GHC.Prim.+#
                                                         (GHC.Prim.uncheckedIShiftL#
                                                            (GHC.Prim.-#
                                                               (GHC.Prim.word2Int#
                                                                  (GHC.Prim.word8ToWord# r#_abhV))
                                                               192#)
                                                            6#)
                                                         (GHC.Prim.word2Int#
                                                            (GHC.Prim.word8ToWord# r#1_abi1)))
                                                      128#))
                                              };
                                            3# ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abhQ (GHC.Prim.+# bx1_abhR 1#)
                                              of r#1_abi2
                                              { __DEFAULT ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abhQ (GHC.Prim.+# bx1_abhR 2#)
                                              of r#2_abi3
                                              { __DEFAULT ->
                                              GHC.Types.C#
                                                (GHC.Prim.chr#
                                                   (GHC.Prim.-#
                                                      (GHC.Prim.+#
                                                         (GHC.Prim.+#
                                                            (GHC.Prim.uncheckedIShiftL#
                                                               (GHC.Prim.-#
                                                                  (GHC.Prim.word2Int#
                                                                     (GHC.Prim.word8ToWord#
                                                                        r#_abhV))
                                                                  224#)
                                                               12#)
                                                            (GHC.Prim.uncheckedIShiftL#
                                                               (GHC.Prim.-#
                                                                  (GHC.Prim.word2Int#
                                                                     (GHC.Prim.word8ToWord#
                                                                        r#1_abi2))
                                                                  128#)
                                                               6#))
                                                         (GHC.Prim.word2Int#
                                                            (GHC.Prim.word8ToWord# r#2_abi3)))
                                                      128#))
                                              }
                                              }
                                          }
                                          },
                                          case Data.Text.compareLength
                                                 (Data.Text.Internal.Text bx_abhQ bx1_abhR bx2_abhS)
                                                 (GHC.Types.I# 1#)
                                          of {
                                            __DEFAULT ->
                                              case GHC.Prim.indexWord8Array# bx_abhQ bx1_abhR
                                              of r#_abi5
                                              { __DEFAULT ->
                                              let {
                                                c#_abi6 :: GHC.Prim.Int#
                                                [LclId,
                                                 Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                         Value=False, ConLike=False, WorkFree=False,
                                                         Expandable=False,
                                                         Guidance=IF_ARGS [] 4 0}]
                                                c#_abi6
                                                  = GHC.Prim.word2Int#
                                                      (GHC.Prim.clz8#
                                                         (GHC.Prim.and#
                                                            (GHC.Prim.not#
                                                               (GHC.Prim.word8ToWord# r#_abi5))
                                                            255##)) } in
                                              let {
                                                y_abi7 :: GHC.Prim.Int#
                                                [LclId,
                                                 Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                         Value=False, ConLike=False, WorkFree=False,
                                                         Expandable=False,
                                                         Guidance=IF_ARGS [] 2 0}]
                                                y_abi7
                                                  = GHC.Prim.xorI#
                                                      c#_abi6 (GHC.Prim.<=# c#_abi6 0#) } in
                                              Data.Text.Internal.Lazy.$WChunk
                                                (Data.Text.Internal.$WText
                                                   (Data.Text.Array.ByteArray bx_abhQ)
                                                   (GHC.Types.I# (GHC.Prim.+# bx1_abhR y_abi7))
                                                   (GHC.Types.I# (GHC.Prim.-# bx2_abhS y_abi7)))
                                                ts_abhT
                                              };
                                            GHC.Types.EQ -> ts_abhT
                                          })
                                   })
                                (let {
                                   f2_abi9
                                     :: Data.Text.Internal.Lazy.Text
                                        -> f_abhF Data.Text.Internal.Lazy.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abi9
                                     = GHC.Base.pure
                                         @f_abhF
                                         $dApplicative_abhH
                                         @Data.Text.Internal.Lazy.Text } in
                                 let {
                                   ds2_abia
                                     :: f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                        -> f_abhF Data.Text.Internal.Lazy.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 100 0}]
                                   ds2_abia
                                     = GHC.Base.fmap
                                         @f_abhF
                                         (GHC.Base.$p1Applicative @f_abhF $dApplicative_abhH)
                                         @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                         @Data.Text.Internal.Lazy.Text
                                         (\ (p1_abib
                                               :: (GHC.Types.Char, Data.Text.Internal.Lazy.Text)) ->
                                            case p1_abib of { (x_abid, ds_abie) ->
                                            Data.Text.Lazy.cons x_abid ds_abie
                                            }) } in
                                 \ (ds3_abig
                                      :: Data.Either.Either
                                           Data.Text.Internal.Lazy.Text
                                           (f_abhF
                                              (GHC.Types.Char, Data.Text.Internal.Lazy.Text))) ->
                                   case ds3_abig of {
                                     Data.Either.Left x_abii -> f2_abi9 x_abii;
                                     Data.Either.Right y_abik -> ds2_abia y_abik
                                   }) } in
                        let {
                          g_abim
                            :: p_abhE
                                 (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                 (f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                               -> p_abhE
                                    (Data.Either.Either
                                       Data.Text.Internal.Lazy.Text
                                       (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                                    (Data.Either.Either
                                       Data.Text.Internal.Lazy.Text
                                       (f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abim
                            = Data.Profunctor.Choice.right'
                                @p_abhE
                                $dChoice_abhG
                                @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                @(f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                                @Data.Text.Internal.Lazy.Text } in
                        \ (x_abin
                             :: p_abhE
                                  (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                  (f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text))) ->
                          f1_abhI (g_abim x_abin))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <Data.Text.Internal.Lazy.Text>_N
                                      <Data.Text.Internal.Lazy.Text>_N
                                      <GHC.Types.Char>_N
                                      <GHC.Types.Char>_N)
                             :: Control.Lens.Type.Prism
                                  Data.Text.Internal.Lazy.Text
                                  Data.Text.Internal.Lazy.Text
                                  (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                  (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                ~R# Control.Lens.Cons.Cons
                                      Data.Text.Internal.Lazy.Text
                                      Data.Text.Internal.Lazy.Text
                                      GHC.Types.Char
                                      GHC.Types.Char)
              ValArg (\ (@(p_abhE :: * -> * -> *))
                        (@(f_abhF :: * -> *))
                        ($dChoice_abhG :: Data.Profunctor.Choice.Choice p_abhE)
                        ($dApplicative_abhH :: GHC.Base.Applicative f_abhF) ->
                        let {
                          f1_abhI
                            :: p_abhE
                                 (Data.Either.Either
                                    Data.Text.Internal.Lazy.Text
                                    (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                                 (Data.Either.Either
                                    Data.Text.Internal.Lazy.Text
                                    (f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                               -> p_abhE
                                    Data.Text.Internal.Lazy.Text
                                    (f_abhF Data.Text.Internal.Lazy.Text)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 639 0}]
                          f1_abhI
                            = Data.Profunctor.Unsafe.dimap
                                @p_abhE
                                (Data.Profunctor.Choice.$p1Choice @p_abhE $dChoice_abhG)
                                @Data.Text.Internal.Lazy.Text
                                @(Data.Either.Either
                                    Data.Text.Internal.Lazy.Text
                                    (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                                @(Data.Either.Either
                                    Data.Text.Internal.Lazy.Text
                                    (f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                                @(f_abhF Data.Text.Internal.Lazy.Text)
                                (\ (s1_abhJ :: Data.Text.Internal.Lazy.Text) ->
                                   case s1_abhJ of {
                                     Data.Text.Internal.Lazy.Empty ->
                                       Data.Either.Left
                                         @Data.Text.Internal.Lazy.Text
                                         @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                         Data.Text.Internal.Lazy.Empty;
                                     Data.Text.Internal.Lazy.Chunk bx_abhQ bx1_abhR bx2_abhS
                                                                   ts_abhT ->
                                       Data.Either.Right
                                         @Data.Text.Internal.Lazy.Text
                                         @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                         (case GHC.Prim.indexWord8Array# bx_abhQ bx1_abhR of r#_abhV
                                          { __DEFAULT ->
                                          let {
                                            c#_abhW :: GHC.Prim.Int#
                                            [LclId,
                                             Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                     Value=False, ConLike=False, WorkFree=False,
                                                     Expandable=False,
                                                     Guidance=IF_ARGS [] 4 0}]
                                            c#_abhW
                                              = GHC.Prim.word2Int#
                                                  (GHC.Prim.clz8#
                                                     (GHC.Prim.and#
                                                        (GHC.Prim.not#
                                                           (GHC.Prim.word8ToWord# r#_abhV))
                                                        255##)) } in
                                          case GHC.Prim.xorI# c#_abhW (GHC.Prim.<=# c#_abhW 0#) of {
                                            __DEFAULT ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abhQ (GHC.Prim.+# bx1_abhR 1#)
                                              of r#1_abhY
                                              { __DEFAULT ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abhQ (GHC.Prim.+# bx1_abhR 2#)
                                              of r#2_abhZ
                                              { __DEFAULT ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abhQ (GHC.Prim.+# bx1_abhR 3#)
                                              of r#3_abi0
                                              { __DEFAULT ->
                                              GHC.Types.C#
                                                (GHC.Prim.chr#
                                                   (GHC.Prim.-#
                                                      (GHC.Prim.+#
                                                         (GHC.Prim.+#
                                                            (GHC.Prim.+#
                                                               (GHC.Prim.uncheckedIShiftL#
                                                                  (GHC.Prim.-#
                                                                     (GHC.Prim.word2Int#
                                                                        (GHC.Prim.word8ToWord#
                                                                           r#_abhV))
                                                                     240#)
                                                                  18#)
                                                               (GHC.Prim.uncheckedIShiftL#
                                                                  (GHC.Prim.-#
                                                                     (GHC.Prim.word2Int#
                                                                        (GHC.Prim.word8ToWord#
                                                                           r#1_abhY))
                                                                     128#)
                                                                  12#))
                                                            (GHC.Prim.uncheckedIShiftL#
                                                               (GHC.Prim.-#
                                                                  (GHC.Prim.word2Int#
                                                                     (GHC.Prim.word8ToWord#
                                                                        r#2_abhZ))
                                                                  128#)
                                                               6#))
                                                         (GHC.Prim.word2Int#
                                                            (GHC.Prim.word8ToWord# r#3_abi0)))
                                                      128#))
                                              }
                                              }
                                              };
                                            1# ->
                                              GHC.Types.C#
                                                (GHC.Prim.chr#
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.word8ToWord# r#_abhV)));
                                            2# ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abhQ (GHC.Prim.+# bx1_abhR 1#)
                                              of r#1_abi1
                                              { __DEFAULT ->
                                              GHC.Types.C#
                                                (GHC.Prim.chr#
                                                   (GHC.Prim.-#
                                                      (GHC.Prim.+#
                                                         (GHC.Prim.uncheckedIShiftL#
                                                            (GHC.Prim.-#
                                                               (GHC.Prim.word2Int#
                                                                  (GHC.Prim.word8ToWord# r#_abhV))
                                                               192#)
                                                            6#)
                                                         (GHC.Prim.word2Int#
                                                            (GHC.Prim.word8ToWord# r#1_abi1)))
                                                      128#))
                                              };
                                            3# ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abhQ (GHC.Prim.+# bx1_abhR 1#)
                                              of r#1_abi2
                                              { __DEFAULT ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abhQ (GHC.Prim.+# bx1_abhR 2#)
                                              of r#2_abi3
                                              { __DEFAULT ->
                                              GHC.Types.C#
                                                (GHC.Prim.chr#
                                                   (GHC.Prim.-#
                                                      (GHC.Prim.+#
                                                         (GHC.Prim.+#
                                                            (GHC.Prim.uncheckedIShiftL#
                                                               (GHC.Prim.-#
                                                                  (GHC.Prim.word2Int#
                                                                     (GHC.Prim.word8ToWord#
                                                                        r#_abhV))
                                                                  224#)
                                                               12#)
                                                            (GHC.Prim.uncheckedIShiftL#
                                                               (GHC.Prim.-#
                                                                  (GHC.Prim.word2Int#
                                                                     (GHC.Prim.word8ToWord#
                                                                        r#1_abi2))
                                                                  128#)
                                                               6#))
                                                         (GHC.Prim.word2Int#
                                                            (GHC.Prim.word8ToWord# r#2_abi3)))
                                                      128#))
                                              }
                                              }
                                          }
                                          },
                                          case Data.Text.compareLength
                                                 (Data.Text.Internal.Text bx_abhQ bx1_abhR bx2_abhS)
                                                 (GHC.Types.I# 1#)
                                          of {
                                            __DEFAULT ->
                                              case GHC.Prim.indexWord8Array# bx_abhQ bx1_abhR
                                              of r#_abi5
                                              { __DEFAULT ->
                                              let {
                                                c#_abi6 :: GHC.Prim.Int#
                                                [LclId,
                                                 Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                         Value=False, ConLike=False, WorkFree=False,
                                                         Expandable=False,
                                                         Guidance=IF_ARGS [] 4 0}]
                                                c#_abi6
                                                  = GHC.Prim.word2Int#
                                                      (GHC.Prim.clz8#
                                                         (GHC.Prim.and#
                                                            (GHC.Prim.not#
                                                               (GHC.Prim.word8ToWord# r#_abi5))
                                                            255##)) } in
                                              let {
                                                y_abi7 :: GHC.Prim.Int#
                                                [LclId,
                                                 Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                         Value=False, ConLike=False, WorkFree=False,
                                                         Expandable=False,
                                                         Guidance=IF_ARGS [] 2 0}]
                                                y_abi7
                                                  = GHC.Prim.xorI#
                                                      c#_abi6 (GHC.Prim.<=# c#_abi6 0#) } in
                                              Data.Text.Internal.Lazy.$WChunk
                                                (Data.Text.Internal.$WText
                                                   (Data.Text.Array.ByteArray bx_abhQ)
                                                   (GHC.Types.I# (GHC.Prim.+# bx1_abhR y_abi7))
                                                   (GHC.Types.I# (GHC.Prim.-# bx2_abhS y_abi7)))
                                                ts_abhT
                                              };
                                            GHC.Types.EQ -> ts_abhT
                                          })
                                   })
                                (let {
                                   f2_abi9
                                     :: Data.Text.Internal.Lazy.Text
                                        -> f_abhF Data.Text.Internal.Lazy.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abi9
                                     = GHC.Base.pure
                                         @f_abhF
                                         $dApplicative_abhH
                                         @Data.Text.Internal.Lazy.Text } in
                                 let {
                                   ds2_abia
                                     :: f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                        -> f_abhF Data.Text.Internal.Lazy.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 100 0}]
                                   ds2_abia
                                     = GHC.Base.fmap
                                         @f_abhF
                                         (GHC.Base.$p1Applicative @f_abhF $dApplicative_abhH)
                                         @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                         @Data.Text.Internal.Lazy.Text
                                         (\ (p1_abib
                                               :: (GHC.Types.Char, Data.Text.Internal.Lazy.Text)) ->
                                            case p1_abib of { (x_abid, ds_abie) ->
                                            Data.Text.Lazy.cons x_abid ds_abie
                                            }) } in
                                 \ (ds3_abig
                                      :: Data.Either.Either
                                           Data.Text.Internal.Lazy.Text
                                           (f_abhF
                                              (GHC.Types.Char, Data.Text.Internal.Lazy.Text))) ->
                                   case ds3_abig of {
                                     Data.Either.Left x_abii -> f2_abi9 x_abii;
                                     Data.Either.Right y_abik -> ds2_abia y_abik
                                   }) } in
                        let {
                          g_abim
                            :: p_abhE
                                 (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                 (f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                               -> p_abhE
                                    (Data.Either.Either
                                       Data.Text.Internal.Lazy.Text
                                       (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                                    (Data.Either.Either
                                       Data.Text.Internal.Lazy.Text
                                       (f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abim
                            = Data.Profunctor.Choice.right'
                                @p_abhE
                                $dChoice_abhG
                                @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                @(f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                                @Data.Text.Internal.Lazy.Text } in
                        \ (x_abin
                             :: p_abhE
                                  (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                  (f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text))) ->
                          f1_abhI (g_abim x_abin))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <Data.Text.Internal.Lazy.Text>_N
                                      <Data.Text.Internal.Lazy.Text>_N
                                      <GHC.Types.Char>_N
                                      <GHC.Types.Char>_N)
                             :: Control.Lens.Type.Prism
                                  Data.Text.Internal.Lazy.Text
                                  Data.Text.Internal.Lazy.Text
                                  (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                  (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                ~R# Control.Lens.Cons.Cons
                                      Data.Text.Internal.Lazy.Text
                                      Data.Text.Internal.Lazy.Text
                                      GHC.Types.Char
                                      GHC.Types.Char)
              ValArg (\ (@(p_abiq :: * -> * -> *))
                        (@(f_abir :: * -> *))
                        ($dChoice_abis :: Data.Profunctor.Choice.Choice p_abiq)
                        ($dApplicative_abit :: GHC.Base.Applicative f_abir) ->
                        let {
                          f1_abiu
                            :: p_abiq
                                 (Data.Either.Either Data.Text.Internal.Lazy.Text ())
                                 (Data.Either.Either Data.Text.Internal.Lazy.Text (f_abir ()))
                               -> p_abiq
                                    Data.Text.Internal.Lazy.Text
                                    (f_abir Data.Text.Internal.Lazy.Text)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 310 0}]
                          f1_abiu
                            = Data.Profunctor.Unsafe.dimap
                                @p_abiq
                                (Data.Profunctor.Choice.$p1Choice @p_abiq $dChoice_abis)
                                @Data.Text.Internal.Lazy.Text
                                @(Data.Either.Either Data.Text.Internal.Lazy.Text ())
                                @(Data.Either.Either Data.Text.Internal.Lazy.Text (f_abir ()))
                                @(f_abir Data.Text.Internal.Lazy.Text)
                                (\ (s_abiv :: Data.Text.Internal.Lazy.Text) ->
                                   case Data.Text.Lazy.null s_abiv of {
                                     GHC.Types.False ->
                                       Data.Either.Left @Data.Text.Internal.Lazy.Text @() s_abiv;
                                     GHC.Types.True ->
                                       Data.Either.Right
                                         @Data.Text.Internal.Lazy.Text @() GHC.Tuple.Prim.()
                                   })
                                (let {
                                   f2_abiy
                                     :: Data.Text.Internal.Lazy.Text
                                        -> f_abir Data.Text.Internal.Lazy.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abiy
                                     = GHC.Base.pure
                                         @f_abir
                                         $dApplicative_abit
                                         @Data.Text.Internal.Lazy.Text } in
                                 let {
                                   ds2_abiz :: f_abir () -> f_abir Data.Text.Internal.Lazy.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 70 0}]
                                   ds2_abiz
                                     = GHC.Base.fmap
                                         @f_abir
                                         (GHC.Base.$p1Applicative @f_abir $dApplicative_abit)
                                         @()
                                         @Data.Text.Internal.Lazy.Text
                                         (\ (ds3_abiA :: ()) ->
                                            case ds3_abiA of { () ->
                                            Data.Text.Internal.Lazy.empty
                                            }) } in
                                 \ (ds3_abiC
                                      :: Data.Either.Either
                                           Data.Text.Internal.Lazy.Text (f_abir ())) ->
                                   case ds3_abiC of {
                                     Data.Either.Left x_abiE -> f2_abiy x_abiE;
                                     Data.Either.Right y_abiG -> ds2_abiz y_abiG
                                   }) } in
                        let {
                          g_abiI
                            :: p_abiq () (f_abir ())
                               -> p_abiq
                                    (Data.Either.Either Data.Text.Internal.Lazy.Text ())
                                    (Data.Either.Either Data.Text.Internal.Lazy.Text (f_abir ()))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abiI
                            = Data.Profunctor.Choice.right'
                                @p_abiq
                                $dChoice_abis
                                @()
                                @(f_abir ())
                                @Data.Text.Internal.Lazy.Text } in
                        \ (x_abiJ :: p_abiq () (f_abir ())) -> f1_abiu (g_abiI x_abiJ))
                     `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                      <Data.Text.Internal.Lazy.Text>_N)
                             :: Control.Lens.Type.Prism' Data.Text.Internal.Lazy.Text ()
                                ~R# Control.Lens.Empty.AsEmpty Data.Text.Internal.Lazy.Text)
              TyArg Data.Functor.Const.Const Data.Text.Internal.Lazy.Text
              ValArg Data.Functor.Contravariant.$fContravariantConst
                       @Data.Text.Internal.Lazy.Text
              ValArg Data.Functor.Const.$fFunctorConst
                       @Data.Text.Internal.Lazy.Text
    After:  (\ (@s1_aben)
               (@(f_abeo :: * -> *))
               (@a_abep)
               ($dCons_abeq
                  :: Control.Lens.Cons.Cons s1_aben s1_aben a_abep a_abep)
               ($dCons1_aber
                  :: Control.Lens.Cons.Cons s1_aben s1_aben a_abep a_abep)
               ($dAsEmpty_abes :: Control.Lens.Empty.AsEmpty s1_aben)
               ($dContravariant_abet
                  :: Data.Functor.Contravariant.Contravariant f_abeo)
               ($dFunctor_abeu :: GHC.Base.Functor f_abeo) ->
               GHC.Base.id @(s1_aben -> f_abeo s1_aben))
              @Data.Text.Internal.Lazy.Text
              @(Data.Functor.Const.Const Data.Text.Internal.Lazy.Text)
              @GHC.Types.Char
              ((\ (@(p_abhE :: * -> * -> *))
                  (@(f_abhF :: * -> *))
                  ($dChoice_abhG :: Data.Profunctor.Choice.Choice p_abhE)
                  ($dApplicative_abhH :: GHC.Base.Applicative f_abhF) ->
                  let {
                    f1_abhI
                      :: p_abhE
                           (Data.Either.Either
                              Data.Text.Internal.Lazy.Text
                              (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                           (Data.Either.Either
                              Data.Text.Internal.Lazy.Text
                              (f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                         -> p_abhE
                              Data.Text.Internal.Lazy.Text (f_abhF Data.Text.Internal.Lazy.Text)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 639 0}]
                    f1_abhI
                      = Data.Profunctor.Unsafe.dimap
                          @p_abhE
                          (Data.Profunctor.Choice.$p1Choice @p_abhE $dChoice_abhG)
                          @Data.Text.Internal.Lazy.Text
                          @(Data.Either.Either
                              Data.Text.Internal.Lazy.Text
                              (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                          @(Data.Either.Either
                              Data.Text.Internal.Lazy.Text
                              (f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                          @(f_abhF Data.Text.Internal.Lazy.Text)
                          (\ (s1_abhJ :: Data.Text.Internal.Lazy.Text) ->
                             case s1_abhJ of {
                               Data.Text.Internal.Lazy.Empty ->
                                 Data.Either.Left
                                   @Data.Text.Internal.Lazy.Text
                                   @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                   Data.Text.Internal.Lazy.Empty;
                               Data.Text.Internal.Lazy.Chunk bx_abhQ bx1_abhR bx2_abhS ts_abhT ->
                                 Data.Either.Right
                                   @Data.Text.Internal.Lazy.Text
                                   @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                   (case GHC.Prim.indexWord8Array# bx_abhQ bx1_abhR of r#_abhV
                                    { __DEFAULT ->
                                    let {
                                      c#_abhW :: GHC.Prim.Int#
                                      [LclId,
                                       Unf=Unf{Src=<vanilla>, TopLvl=False,
                                               Value=False, ConLike=False, WorkFree=False,
                                               Expandable=False,
                                               Guidance=IF_ARGS [] 4 0}]
                                      c#_abhW
                                        = GHC.Prim.word2Int#
                                            (GHC.Prim.clz8#
                                               (GHC.Prim.and#
                                                  (GHC.Prim.not# (GHC.Prim.word8ToWord# r#_abhV))
                                                  255##)) } in
                                    case GHC.Prim.xorI# c#_abhW (GHC.Prim.<=# c#_abhW 0#) of {
                                      __DEFAULT ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abhQ (GHC.Prim.+# bx1_abhR 1#)
                                        of r#1_abhY
                                        { __DEFAULT ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abhQ (GHC.Prim.+# bx1_abhR 2#)
                                        of r#2_abhZ
                                        { __DEFAULT ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abhQ (GHC.Prim.+# bx1_abhR 3#)
                                        of r#3_abi0
                                        { __DEFAULT ->
                                        GHC.Types.C#
                                          (GHC.Prim.chr#
                                             (GHC.Prim.-#
                                                (GHC.Prim.+#
                                                   (GHC.Prim.+#
                                                      (GHC.Prim.+#
                                                         (GHC.Prim.uncheckedIShiftL#
                                                            (GHC.Prim.-#
                                                               (GHC.Prim.word2Int#
                                                                  (GHC.Prim.word8ToWord# r#_abhV))
                                                               240#)
                                                            18#)
                                                         (GHC.Prim.uncheckedIShiftL#
                                                            (GHC.Prim.-#
                                                               (GHC.Prim.word2Int#
                                                                  (GHC.Prim.word8ToWord# r#1_abhY))
                                                               128#)
                                                            12#))
                                                      (GHC.Prim.uncheckedIShiftL#
                                                         (GHC.Prim.-#
                                                            (GHC.Prim.word2Int#
                                                               (GHC.Prim.word8ToWord# r#2_abhZ))
                                                            128#)
                                                         6#))
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.word8ToWord# r#3_abi0)))
                                                128#))
                                        }
                                        }
                                        };
                                      1# ->
                                        GHC.Types.C#
                                          (GHC.Prim.chr#
                                             (GHC.Prim.word2Int# (GHC.Prim.word8ToWord# r#_abhV)));
                                      2# ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abhQ (GHC.Prim.+# bx1_abhR 1#)
                                        of r#1_abi1
                                        { __DEFAULT ->
                                        GHC.Types.C#
                                          (GHC.Prim.chr#
                                             (GHC.Prim.-#
                                                (GHC.Prim.+#
                                                   (GHC.Prim.uncheckedIShiftL#
                                                      (GHC.Prim.-#
                                                         (GHC.Prim.word2Int#
                                                            (GHC.Prim.word8ToWord# r#_abhV))
                                                         192#)
                                                      6#)
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.word8ToWord# r#1_abi1)))
                                                128#))
                                        };
                                      3# ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abhQ (GHC.Prim.+# bx1_abhR 1#)
                                        of r#1_abi2
                                        { __DEFAULT ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abhQ (GHC.Prim.+# bx1_abhR 2#)
                                        of r#2_abi3
                                        { __DEFAULT ->
                                        GHC.Types.C#
                                          (GHC.Prim.chr#
                                             (GHC.Prim.-#
                                                (GHC.Prim.+#
                                                   (GHC.Prim.+#
                                                      (GHC.Prim.uncheckedIShiftL#
                                                         (GHC.Prim.-#
                                                            (GHC.Prim.word2Int#
                                                               (GHC.Prim.word8ToWord# r#_abhV))
                                                            224#)
                                                         12#)
                                                      (GHC.Prim.uncheckedIShiftL#
                                                         (GHC.Prim.-#
                                                            (GHC.Prim.word2Int#
                                                               (GHC.Prim.word8ToWord# r#1_abi2))
                                                            128#)
                                                         6#))
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.word8ToWord# r#2_abi3)))
                                                128#))
                                        }
                                        }
                                    }
                                    },
                                    case Data.Text.compareLength
                                           (Data.Text.Internal.Text bx_abhQ bx1_abhR bx2_abhS)
                                           (GHC.Types.I# 1#)
                                    of {
                                      __DEFAULT ->
                                        case GHC.Prim.indexWord8Array# bx_abhQ bx1_abhR of r#_abi5
                                        { __DEFAULT ->
                                        let {
                                          c#_abi6 :: GHC.Prim.Int#
                                          [LclId,
                                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                   Value=False, ConLike=False, WorkFree=False,
                                                   Expandable=False,
                                                   Guidance=IF_ARGS [] 4 0}]
                                          c#_abi6
                                            = GHC.Prim.word2Int#
                                                (GHC.Prim.clz8#
                                                   (GHC.Prim.and#
                                                      (GHC.Prim.not#
                                                         (GHC.Prim.word8ToWord# r#_abi5))
                                                      255##)) } in
                                        let {
                                          y_abi7 :: GHC.Prim.Int#
                                          [LclId,
                                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                   Value=False, ConLike=False, WorkFree=False,
                                                   Expandable=False,
                                                   Guidance=IF_ARGS [] 2 0}]
                                          y_abi7
                                            = GHC.Prim.xorI# c#_abi6 (GHC.Prim.<=# c#_abi6 0#) } in
                                        Data.Text.Internal.Lazy.$WChunk
                                          (Data.Text.Internal.$WText
                                             (Data.Text.Array.ByteArray bx_abhQ)
                                             (GHC.Types.I# (GHC.Prim.+# bx1_abhR y_abi7))
                                             (GHC.Types.I# (GHC.Prim.-# bx2_abhS y_abi7)))
                                          ts_abhT
                                        };
                                      GHC.Types.EQ -> ts_abhT
                                    })
                             })
                          (let {
                             f2_abi9
                               :: Data.Text.Internal.Lazy.Text
                                  -> f_abhF Data.Text.Internal.Lazy.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abi9
                               = GHC.Base.pure
                                   @f_abhF $dApplicative_abhH @Data.Text.Internal.Lazy.Text } in
                           let {
                             ds2_abia
                               :: f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                  -> f_abhF Data.Text.Internal.Lazy.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 100 0}]
                             ds2_abia
                               = GHC.Base.fmap
                                   @f_abhF
                                   (GHC.Base.$p1Applicative @f_abhF $dApplicative_abhH)
                                   @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                   @Data.Text.Internal.Lazy.Text
                                   (\ (p1_abib :: (GHC.Types.Char, Data.Text.Internal.Lazy.Text)) ->
                                      case p1_abib of { (x_abid, ds_abie) ->
                                      Data.Text.Lazy.cons x_abid ds_abie
                                      }) } in
                           \ (ds3_abig
                                :: Data.Either.Either
                                     Data.Text.Internal.Lazy.Text
                                     (f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text))) ->
                             case ds3_abig of {
                               Data.Either.Left x_abii -> f2_abi9 x_abii;
                               Data.Either.Right y_abik -> ds2_abia y_abik
                             }) } in
                  let {
                    g_abim
                      :: p_abhE
                           (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                           (f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                         -> p_abhE
                              (Data.Either.Either
                                 Data.Text.Internal.Lazy.Text
                                 (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                              (Data.Either.Either
                                 Data.Text.Internal.Lazy.Text
                                 (f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abim
                      = Data.Profunctor.Choice.right'
                          @p_abhE
                          $dChoice_abhG
                          @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                          @(f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                          @Data.Text.Internal.Lazy.Text } in
                  \ (x_abin
                       :: p_abhE
                            (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                            (f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text))) ->
                    f1_abhI (g_abim x_abin))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <Data.Text.Internal.Lazy.Text>_N
                                <Data.Text.Internal.Lazy.Text>_N
                                <GHC.Types.Char>_N
                                <GHC.Types.Char>_N)
                       :: Control.Lens.Type.Prism
                            Data.Text.Internal.Lazy.Text
                            Data.Text.Internal.Lazy.Text
                            (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                            (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                          ~R# Control.Lens.Cons.Cons
                                Data.Text.Internal.Lazy.Text
                                Data.Text.Internal.Lazy.Text
                                GHC.Types.Char
                                GHC.Types.Char))
              ((\ (@(p_abhE :: * -> * -> *))
                  (@(f_abhF :: * -> *))
                  ($dChoice_abhG :: Data.Profunctor.Choice.Choice p_abhE)
                  ($dApplicative_abhH :: GHC.Base.Applicative f_abhF) ->
                  let {
                    f1_abhI
                      :: p_abhE
                           (Data.Either.Either
                              Data.Text.Internal.Lazy.Text
                              (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                           (Data.Either.Either
                              Data.Text.Internal.Lazy.Text
                              (f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                         -> p_abhE
                              Data.Text.Internal.Lazy.Text (f_abhF Data.Text.Internal.Lazy.Text)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 639 0}]
                    f1_abhI
                      = Data.Profunctor.Unsafe.dimap
                          @p_abhE
                          (Data.Profunctor.Choice.$p1Choice @p_abhE $dChoice_abhG)
                          @Data.Text.Internal.Lazy.Text
                          @(Data.Either.Either
                              Data.Text.Internal.Lazy.Text
                              (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                          @(Data.Either.Either
                              Data.Text.Internal.Lazy.Text
                              (f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                          @(f_abhF Data.Text.Internal.Lazy.Text)
                          (\ (s1_abhJ :: Data.Text.Internal.Lazy.Text) ->
                             case s1_abhJ of {
                               Data.Text.Internal.Lazy.Empty ->
                                 Data.Either.Left
                                   @Data.Text.Internal.Lazy.Text
                                   @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                   Data.Text.Internal.Lazy.Empty;
                               Data.Text.Internal.Lazy.Chunk bx_abhQ bx1_abhR bx2_abhS ts_abhT ->
                                 Data.Either.Right
                                   @Data.Text.Internal.Lazy.Text
                                   @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                   (case GHC.Prim.indexWord8Array# bx_abhQ bx1_abhR of r#_abhV
                                    { __DEFAULT ->
                                    let {
                                      c#_abhW :: GHC.Prim.Int#
                                      [LclId,
                                       Unf=Unf{Src=<vanilla>, TopLvl=False,
                                               Value=False, ConLike=False, WorkFree=False,
                                               Expandable=False,
                                               Guidance=IF_ARGS [] 4 0}]
                                      c#_abhW
                                        = GHC.Prim.word2Int#
                                            (GHC.Prim.clz8#
                                               (GHC.Prim.and#
                                                  (GHC.Prim.not# (GHC.Prim.word8ToWord# r#_abhV))
                                                  255##)) } in
                                    case GHC.Prim.xorI# c#_abhW (GHC.Prim.<=# c#_abhW 0#) of {
                                      __DEFAULT ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abhQ (GHC.Prim.+# bx1_abhR 1#)
                                        of r#1_abhY
                                        { __DEFAULT ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abhQ (GHC.Prim.+# bx1_abhR 2#)
                                        of r#2_abhZ
                                        { __DEFAULT ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abhQ (GHC.Prim.+# bx1_abhR 3#)
                                        of r#3_abi0
                                        { __DEFAULT ->
                                        GHC.Types.C#
                                          (GHC.Prim.chr#
                                             (GHC.Prim.-#
                                                (GHC.Prim.+#
                                                   (GHC.Prim.+#
                                                      (GHC.Prim.+#
                                                         (GHC.Prim.uncheckedIShiftL#
                                                            (GHC.Prim.-#
                                                               (GHC.Prim.word2Int#
                                                                  (GHC.Prim.word8ToWord# r#_abhV))
                                                               240#)
                                                            18#)
                                                         (GHC.Prim.uncheckedIShiftL#
                                                            (GHC.Prim.-#
                                                               (GHC.Prim.word2Int#
                                                                  (GHC.Prim.word8ToWord# r#1_abhY))
                                                               128#)
                                                            12#))
                                                      (GHC.Prim.uncheckedIShiftL#
                                                         (GHC.Prim.-#
                                                            (GHC.Prim.word2Int#
                                                               (GHC.Prim.word8ToWord# r#2_abhZ))
                                                            128#)
                                                         6#))
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.word8ToWord# r#3_abi0)))
                                                128#))
                                        }
                                        }
                                        };
                                      1# ->
                                        GHC.Types.C#
                                          (GHC.Prim.chr#
                                             (GHC.Prim.word2Int# (GHC.Prim.word8ToWord# r#_abhV)));
                                      2# ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abhQ (GHC.Prim.+# bx1_abhR 1#)
                                        of r#1_abi1
                                        { __DEFAULT ->
                                        GHC.Types.C#
                                          (GHC.Prim.chr#
                                             (GHC.Prim.-#
                                                (GHC.Prim.+#
                                                   (GHC.Prim.uncheckedIShiftL#
                                                      (GHC.Prim.-#
                                                         (GHC.Prim.word2Int#
                                                            (GHC.Prim.word8ToWord# r#_abhV))
                                                         192#)
                                                      6#)
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.word8ToWord# r#1_abi1)))
                                                128#))
                                        };
                                      3# ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abhQ (GHC.Prim.+# bx1_abhR 1#)
                                        of r#1_abi2
                                        { __DEFAULT ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abhQ (GHC.Prim.+# bx1_abhR 2#)
                                        of r#2_abi3
                                        { __DEFAULT ->
                                        GHC.Types.C#
                                          (GHC.Prim.chr#
                                             (GHC.Prim.-#
                                                (GHC.Prim.+#
                                                   (GHC.Prim.+#
                                                      (GHC.Prim.uncheckedIShiftL#
                                                         (GHC.Prim.-#
                                                            (GHC.Prim.word2Int#
                                                               (GHC.Prim.word8ToWord# r#_abhV))
                                                            224#)
                                                         12#)
                                                      (GHC.Prim.uncheckedIShiftL#
                                                         (GHC.Prim.-#
                                                            (GHC.Prim.word2Int#
                                                               (GHC.Prim.word8ToWord# r#1_abi2))
                                                            128#)
                                                         6#))
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.word8ToWord# r#2_abi3)))
                                                128#))
                                        }
                                        }
                                    }
                                    },
                                    case Data.Text.compareLength
                                           (Data.Text.Internal.Text bx_abhQ bx1_abhR bx2_abhS)
                                           (GHC.Types.I# 1#)
                                    of {
                                      __DEFAULT ->
                                        case GHC.Prim.indexWord8Array# bx_abhQ bx1_abhR of r#_abi5
                                        { __DEFAULT ->
                                        let {
                                          c#_abi6 :: GHC.Prim.Int#
                                          [LclId,
                                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                   Value=False, ConLike=False, WorkFree=False,
                                                   Expandable=False,
                                                   Guidance=IF_ARGS [] 4 0}]
                                          c#_abi6
                                            = GHC.Prim.word2Int#
                                                (GHC.Prim.clz8#
                                                   (GHC.Prim.and#
                                                      (GHC.Prim.not#
                                                         (GHC.Prim.word8ToWord# r#_abi5))
                                                      255##)) } in
                                        let {
                                          y_abi7 :: GHC.Prim.Int#
                                          [LclId,
                                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                   Value=False, ConLike=False, WorkFree=False,
                                                   Expandable=False,
                                                   Guidance=IF_ARGS [] 2 0}]
                                          y_abi7
                                            = GHC.Prim.xorI# c#_abi6 (GHC.Prim.<=# c#_abi6 0#) } in
                                        Data.Text.Internal.Lazy.$WChunk
                                          (Data.Text.Internal.$WText
                                             (Data.Text.Array.ByteArray bx_abhQ)
                                             (GHC.Types.I# (GHC.Prim.+# bx1_abhR y_abi7))
                                             (GHC.Types.I# (GHC.Prim.-# bx2_abhS y_abi7)))
                                          ts_abhT
                                        };
                                      GHC.Types.EQ -> ts_abhT
                                    })
                             })
                          (let {
                             f2_abi9
                               :: Data.Text.Internal.Lazy.Text
                                  -> f_abhF Data.Text.Internal.Lazy.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abi9
                               = GHC.Base.pure
                                   @f_abhF $dApplicative_abhH @Data.Text.Internal.Lazy.Text } in
                           let {
                             ds2_abia
                               :: f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                  -> f_abhF Data.Text.Internal.Lazy.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 100 0}]
                             ds2_abia
                               = GHC.Base.fmap
                                   @f_abhF
                                   (GHC.Base.$p1Applicative @f_abhF $dApplicative_abhH)
                                   @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                   @Data.Text.Internal.Lazy.Text
                                   (\ (p1_abib :: (GHC.Types.Char, Data.Text.Internal.Lazy.Text)) ->
                                      case p1_abib of { (x_abid, ds_abie) ->
                                      Data.Text.Lazy.cons x_abid ds_abie
                                      }) } in
                           \ (ds3_abig
                                :: Data.Either.Either
                                     Data.Text.Internal.Lazy.Text
                                     (f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text))) ->
                             case ds3_abig of {
                               Data.Either.Left x_abii -> f2_abi9 x_abii;
                               Data.Either.Right y_abik -> ds2_abia y_abik
                             }) } in
                  let {
                    g_abim
                      :: p_abhE
                           (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                           (f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                         -> p_abhE
                              (Data.Either.Either
                                 Data.Text.Internal.Lazy.Text
                                 (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                              (Data.Either.Either
                                 Data.Text.Internal.Lazy.Text
                                 (f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abim
                      = Data.Profunctor.Choice.right'
                          @p_abhE
                          $dChoice_abhG
                          @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                          @(f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                          @Data.Text.Internal.Lazy.Text } in
                  \ (x_abin
                       :: p_abhE
                            (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                            (f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text))) ->
                    f1_abhI (g_abim x_abin))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <Data.Text.Internal.Lazy.Text>_N
                                <Data.Text.Internal.Lazy.Text>_N
                                <GHC.Types.Char>_N
                                <GHC.Types.Char>_N)
                       :: Control.Lens.Type.Prism
                            Data.Text.Internal.Lazy.Text
                            Data.Text.Internal.Lazy.Text
                            (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                            (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                          ~R# Control.Lens.Cons.Cons
                                Data.Text.Internal.Lazy.Text
                                Data.Text.Internal.Lazy.Text
                                GHC.Types.Char
                                GHC.Types.Char))
              ((\ (@(p_abiq :: * -> * -> *))
                  (@(f_abir :: * -> *))
                  ($dChoice_abis :: Data.Profunctor.Choice.Choice p_abiq)
                  ($dApplicative_abit :: GHC.Base.Applicative f_abir) ->
                  let {
                    f1_abiu
                      :: p_abiq
                           (Data.Either.Either Data.Text.Internal.Lazy.Text ())
                           (Data.Either.Either Data.Text.Internal.Lazy.Text (f_abir ()))
                         -> p_abiq
                              Data.Text.Internal.Lazy.Text (f_abir Data.Text.Internal.Lazy.Text)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 310 0}]
                    f1_abiu
                      = Data.Profunctor.Unsafe.dimap
                          @p_abiq
                          (Data.Profunctor.Choice.$p1Choice @p_abiq $dChoice_abis)
                          @Data.Text.Internal.Lazy.Text
                          @(Data.Either.Either Data.Text.Internal.Lazy.Text ())
                          @(Data.Either.Either Data.Text.Internal.Lazy.Text (f_abir ()))
                          @(f_abir Data.Text.Internal.Lazy.Text)
                          (\ (s_abiv :: Data.Text.Internal.Lazy.Text) ->
                             case Data.Text.Lazy.null s_abiv of {
                               GHC.Types.False ->
                                 Data.Either.Left @Data.Text.Internal.Lazy.Text @() s_abiv;
                               GHC.Types.True ->
                                 Data.Either.Right
                                   @Data.Text.Internal.Lazy.Text @() GHC.Tuple.Prim.()
                             })
                          (let {
                             f2_abiy
                               :: Data.Text.Internal.Lazy.Text
                                  -> f_abir Data.Text.Internal.Lazy.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abiy
                               = GHC.Base.pure
                                   @f_abir $dApplicative_abit @Data.Text.Internal.Lazy.Text } in
                           let {
                             ds2_abiz :: f_abir () -> f_abir Data.Text.Internal.Lazy.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 70 0}]
                             ds2_abiz
                               = GHC.Base.fmap
                                   @f_abir
                                   (GHC.Base.$p1Applicative @f_abir $dApplicative_abit)
                                   @()
                                   @Data.Text.Internal.Lazy.Text
                                   (\ (ds3_abiA :: ()) ->
                                      case ds3_abiA of { () -> Data.Text.Internal.Lazy.empty }) } in
                           \ (ds3_abiC
                                :: Data.Either.Either Data.Text.Internal.Lazy.Text (f_abir ())) ->
                             case ds3_abiC of {
                               Data.Either.Left x_abiE -> f2_abiy x_abiE;
                               Data.Either.Right y_abiG -> ds2_abiz y_abiG
                             }) } in
                  let {
                    g_abiI
                      :: p_abiq () (f_abir ())
                         -> p_abiq
                              (Data.Either.Either Data.Text.Internal.Lazy.Text ())
                              (Data.Either.Either Data.Text.Internal.Lazy.Text (f_abir ()))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abiI
                      = Data.Profunctor.Choice.right'
                          @p_abiq
                          $dChoice_abis
                          @()
                          @(f_abir ())
                          @Data.Text.Internal.Lazy.Text } in
                  \ (x_abiJ :: p_abiq () (f_abir ())) -> f1_abiu (g_abiI x_abiJ))
               `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                <Data.Text.Internal.Lazy.Text>_N)
                       :: Control.Lens.Type.Prism' Data.Text.Internal.Lazy.Text ()
                          ~R# Control.Lens.Empty.AsEmpty Data.Text.Internal.Lazy.Text))
              (Data.Functor.Contravariant.$fContravariantConst
                 @Data.Text.Internal.Lazy.Text)
              (Data.Functor.Const.$fFunctorConst @Data.Text.Internal.Lazy.Text)
    Cont:   ApplyToVal nodup hole Control.Lens.Getter.Getting
                                    Data.Text.Internal.Lazy.Text
                                    Data.Text.Internal.Lazy.Text
                                    Data.Text.Internal.Lazy.Text
              ((\ (ds_abdj [Occ=Once1] :: a_abdg) -> ds_abdj)
               `cast` (<a_abdg>_R
                       %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                          <*>_N <a_abdg>_R <a_abdg>_P)
                       :: (a_abdg -> a_abdg)
                          ~R# (a_abdg -> Data.Functor.Const.Const a_abdg a_abdg)))
            ApplyToVal nodup hole Data.Text.Internal.Lazy.Text
                                  -> Data.Functor.Const.Const
                                       Data.Text.Internal.Lazy.Text Data.Text.Internal.Lazy.Text
              s_a8IW
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N
                        <Data.Text.Internal.Lazy.Text>_R
                        <Data.Text.Internal.Lazy.Text>_P
                    :: Data.Functor.Const.Const
                         Data.Text.Internal.Lazy.Text Data.Text.Internal.Lazy.Text
                       ~R# Data.Text.Internal.Lazy.Text)
            Stop[RuleArgCtxt] Data.Text.Internal.Lazy.Text
Rule fired
    Rule: Class op ==
    Module: (BUILTIN)
    Before: GHC.Classes.==
              TyArg Data.Text.Internal.Lazy.Text
              ValArg Data.Text.Lazy.$fEqText
              ValArg s_a8IW
              ValArg s_a8IW
    After:  Data.Text.Internal.Lazy.equal ValArg s_a8IW ValArg s_a8IW
    Cont:   Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: unpack
    Module: (GHC.Base)
    Before: GHC.CString.unpackCString# ValArg "B -> B"#
    After:  (\ (a_ab5Y :: GHC.Prim.Addr#) ->
               GHC.Base.build
                 @GHC.Types.Char
                 (\ (@b_ab5Z) -> GHC.CString.unpackFoldrCString# @b_ab5Z a_ab5Y))
              "B -> B"#
    Cont:   Stop[BoringCtxt] Test.Tasty.Core.TestName
Rule fired
    Rule: Class op property
    Module: (BUILTIN)
    Before: Test.QuickCheck.Property.property
              TyArg Data.ByteString.Internal.Type.ByteString -> GHC.Types.Bool
              ValArg $dTestable_a98I
    After:  Test.QuickCheck.Property.$fTestableFUN_$cproperty
              @Data.ByteString.Internal.Type.ByteString
              @GHC.Types.Bool
              Test.QuickCheck.Instances.ByteString.$fArbitraryByteString0
              Data.ByteString.Internal.Type.$fShowByteString
              Test.QuickCheck.Property.$fTestableBool
    Cont:   ApplyToVal nodup hole (Data.ByteString.Internal.Type.ByteString
                                   -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              prop_ab6b
            CastIt (Sym (Test.Tasty.QuickCheck.N:QC[0])
                    :: Test.QuickCheck.Property.Property ~R# Test.Tasty.QuickCheck.QC)
            Stop[BoringCtxt] Test.Tasty.QuickCheck.QC
Rule fired
    Rule: Class op propertyForAllShrinkShow
    Module: (BUILTIN)
    Before: Test.QuickCheck.Property.propertyForAllShrinkShow
              TyArg GHC.Types.Bool ValArg Test.QuickCheck.Property.$fTestableBool
    After:  Test.QuickCheck.Property.$fTestableBool1
            `cast` (forall (a :: <*>_N).
                    <Test.QuickCheck.Gen.Gen a>_R
                    %<'GHC.Types.Many>_N ->_R <a -> [a]>_R
                    %<'GHC.Types.Many>_N ->_R <a -> [GHC.Base.String]>_R
                    %<'GHC.Types.Many>_N ->_R <a -> GHC.Types.Bool>_R
                    %<'GHC.Types.Many>_N ->_R Sym (Test.QuickCheck.Gen.N:Gen[0]
                                                       (Test.QuickCheck.Property.N:Prop[0]))
                                              ; Sym (Test.QuickCheck.Property.N:Property[0])
                    :: (forall {a}.
                        Test.QuickCheck.Gen.Gen a
                        -> (a -> [a])
                        -> (a -> [GHC.Base.String])
                        -> (a -> GHC.Types.Bool)
                        -> Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int
                        -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result)
                       ~R# (forall {a}.
                            Test.QuickCheck.Gen.Gen a
                            -> (a -> [a])
                            -> (a -> [GHC.Base.String])
                            -> (a -> GHC.Types.Bool)
                            -> Test.QuickCheck.Property.Property))
    Cont:   ApplyToTy Data.ByteString.Internal.Type.ByteString
            ApplyToVal nodup hole Test.QuickCheck.Gen.Gen
                                    Data.ByteString.Internal.Type.ByteString
                                  -> (Data.ByteString.Internal.Type.ByteString
                                      -> [Data.ByteString.Internal.Type.ByteString])
                                  -> (Data.ByteString.Internal.Type.ByteString -> [GHC.Base.String])
                                  -> (Data.ByteString.Internal.Type.ByteString -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (Test.QuickCheck.Arbitrary.arbitrary @a_ab7T $dArbitrary_ab7V)
            ApplyToVal nodup hole (Data.ByteString.Internal.Type.ByteString
                                   -> [Data.ByteString.Internal.Type.ByteString])
                                  -> (Data.ByteString.Internal.Type.ByteString -> [GHC.Base.String])
                                  -> (Data.ByteString.Internal.Type.ByteString -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (Test.QuickCheck.Arbitrary.shrink @a_ab7T $dArbitrary_ab7V)
            ApplyToVal nodup hole (Data.ByteString.Internal.Type.ByteString
                                   -> [GHC.Base.String])
                                  -> (Data.ByteString.Internal.Type.ByteString -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (let {
                 g_ab7Z [Occ=OnceL1!] :: a_ab7T -> GHC.Base.String
                 [LclId]
                 g_ab7Z = GHC.Show.show @a_ab7T $dShow_ab7W } in
               \ (x_ab80 [Occ=Once1] :: a_ab7T) ->
                 GHC.Types.:
                   @GHC.Base.String (g_ab7Z x_ab80) (GHC.Types.[] @GHC.Base.String))
            ApplyToVal nodup hole (Data.ByteString.Internal.Type.ByteString
                                   -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              f_ab7Y
            CastIt (Sym (Test.Tasty.QuickCheck.N:QC[0])
                    :: Test.QuickCheck.Property.Property ~R# Test.Tasty.QuickCheck.QC)
            Stop[BoringCtxt] Test.Tasty.QuickCheck.QC
Rule fired
    Rule: Class op arbitrary
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.arbitrary
              TyArg Data.ByteString.Internal.Type.ByteString
              ValArg Test.QuickCheck.Instances.ByteString.$fArbitraryByteString0
    After:  Test.QuickCheck.Instances.ByteString.$fArbitraryByteString3
            `cast` (Sym (Test.QuickCheck.Gen.N:Gen[0]
                             <Data.ByteString.Internal.Type.ByteString>_R)
                    :: (Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int -> Data.ByteString.Internal.Type.ByteString)
                       ~R# Test.QuickCheck.Gen.Gen
                             Data.ByteString.Internal.Type.ByteString)
    Cont:   Stop[BoringCtxt] Test.QuickCheck.Gen.Gen
                               Data.ByteString.Internal.Type.ByteString
Rule fired
    Rule: Class op shrink
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.shrink
              TyArg Data.ByteString.Internal.Type.ByteString
              ValArg Test.QuickCheck.Instances.ByteString.$fArbitraryByteString0
    After:  Test.QuickCheck.Instances.ByteString.$fArbitraryByteString0_$cshrink
    Cont:   Stop[BoringCtxt] Data.ByteString.Internal.Type.ByteString
                             -> [Data.ByteString.Internal.Type.ByteString]
Rule fired
    Rule: Class op show
    Module: (BUILTIN)
    Before: GHC.Show.show
              TyArg Data.ByteString.Internal.Type.ByteString
              ValArg Data.ByteString.Internal.Type.$fShowByteString
    After:  Data.ByteString.Internal.Type.$fShowByteString_$cshow
    Cont:   Stop[RhsCtxt(NonRecursive)] Data.ByteString.Internal.Type.ByteString
                                        -> GHC.Base.String
Rule fired
    Rule: Class op reader
    Module: (BUILTIN)
    Before: Control.Monad.Reader.Class.reader
              TyArg Data.ByteString.Internal.Type.ByteString
              TyArg (->) Data.ByteString.Internal.Type.ByteString
              ValArg Control.Monad.Reader.Class.$fMonadReaderrFUN
                       @Data.ByteString.Internal.Type.ByteString
    After:  \ (@a_abdo) ->
              GHC.Base.id @(Data.ByteString.Internal.Type.ByteString -> a_abdo)
    Cont:   ApplyToTy Data.ByteString.Internal.Type.ByteString
            ApplyToVal nodup hole (Data.ByteString.Internal.Type.ByteString
                                   -> Data.ByteString.Internal.Type.ByteString)
                                  -> Data.ByteString.Internal.Type.ByteString
                                  -> Data.ByteString.Internal.Type.ByteString
              ((l_abdi
                  ((\ (ds_abdj [Occ=Once1] :: a_abdg) -> ds_abdj)
                   `cast` (<a_abdg>_R
                           %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                              <*>_N <a_abdg>_R <a_abdg>_P)
                           :: (a_abdg -> a_abdg)
                              ~R# (a_abdg -> Data.Functor.Const.Const a_abdg a_abdg))))
               `cast` (<s_abde>_R
                       %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                     <*>_N <a_abdg>_R <s_abde>_P
                       :: (s_abde -> Data.Functor.Const.Const a_abdg s_abde)
                          ~R# (s_abde -> a_abdg)))
            ApplyToVal nodup hole Data.ByteString.Internal.Type.ByteString
                                  -> Data.ByteString.Internal.Type.ByteString
              s_a8Ju
            Stop[RuleArgCtxt] Data.ByteString.Internal.Type.ByteString
Rule fired
    Rule: recons/id
    Module: (Control.Lens.Cons.Extras)
    Before: Control.Lens.Cons.Extras.recons
              TyArg Data.ByteString.Internal.Type.ByteString
              TyArg GHC.Word.Word8
              TyArg Data.ByteString.Internal.Type.ByteString
              ValArg (\ (@(p_abj8 :: * -> * -> *))
                        (@(f_abj9 :: * -> *))
                        ($dChoice_abja :: Data.Profunctor.Choice.Choice p_abj8)
                        ($dApplicative_abjb :: GHC.Base.Applicative f_abj9) ->
                        let {
                          f1_abjc
                            :: p_abj8
                                 (Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                                 (Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString
                                    (f_abj9
                                       (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                               -> p_abj8
                                    Data.ByteString.Internal.Type.ByteString
                                    (f_abj9 Data.ByteString.Internal.Type.ByteString)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 612 0}]
                          f1_abjc
                            = Data.Profunctor.Unsafe.dimap
                                @p_abj8
                                (Data.Profunctor.Choice.$p1Choice @p_abj8 $dChoice_abja)
                                @Data.ByteString.Internal.Type.ByteString
                                @(Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                                @(Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString
                                    (f_abj9
                                       (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                                @(f_abj9 Data.ByteString.Internal.Type.ByteString)
                                (\ (s1_abjd :: Data.ByteString.Internal.Type.ByteString) ->
                                   case s1_abjd of wild_abje
                                   { Data.ByteString.Internal.Type.BS bx_abjf bx1_abjg bx2_abjh ->
                                   case GHC.Classes.leInt (GHC.Types.I# bx2_abjh) (GHC.Types.I# 0#)
                                   of {
                                     GHC.Types.False ->
                                       Data.Either.Right
                                         @Data.ByteString.Internal.Type.ByteString
                                         @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                         (case GHC.Prim.readWord8OffAddr#
                                                 @GHC.Prim.RealWorld bx_abjf 0# GHC.Prim.realWorld#
                                          of
                                          { (# ipv_abjm, ipv1_abjn #) ->
                                          case GHC.Prim.touch#
                                                 @'GHC.Types.Lifted
                                                 @GHC.ForeignPtr.ForeignPtrContents
                                                 bx1_abjg
                                                 ipv_abjm
                                          of
                                          { __DEFAULT ->
                                          GHC.Word.W8# ipv1_abjn
                                          }
                                          },
                                          Data.ByteString.Internal.Type.$WBS
                                            (GHC.ForeignPtr.ForeignPtr
                                               @GHC.Word.Word8
                                               (GHC.Prim.plusAddr# bx_abjf 1#)
                                               bx1_abjg)
                                            (GHC.Types.I# (GHC.Prim.-# bx2_abjh 1#)));
                                     GHC.Types.True ->
                                       Data.Either.Left
                                         @Data.ByteString.Internal.Type.ByteString
                                         @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                         wild_abje
                                   }
                                   })
                                (let {
                                   f2_abjr
                                     :: Data.ByteString.Internal.Type.ByteString
                                        -> f_abj9 Data.ByteString.Internal.Type.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abjr
                                     = GHC.Base.pure
                                         @f_abj9
                                         $dApplicative_abjb
                                         @Data.ByteString.Internal.Type.ByteString } in
                                 let {
                                   ds2_abjs
                                     :: f_abj9
                                          (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                        -> f_abj9 Data.ByteString.Internal.Type.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 259 0}]
                                   ds2_abjs
                                     = GHC.Base.fmap
                                         @f_abj9
                                         (GHC.Base.$p1Applicative @f_abj9 $dApplicative_abjb)
                                         @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                         @Data.ByteString.Internal.Type.ByteString
                                         (\ (p1_abjt
                                               :: (GHC.Word.Word8,
                                                   Data.ByteString.Internal.Type.ByteString)) ->
                                            case p1_abjt of { (ds_abjv, y_abjw) ->
                                            case y_abjw of
                                            { Data.ByteString.Internal.Type.BS bx_abjI bx1_abjJ
                                                                               bx2_abjK ->
                                            GHC.Magic.runRW#
                                              @GHC.Types.LiftedRep
                                              @Data.ByteString.Internal.Type.ByteString
                                              (\ (s_abjG [OS=OneShot]
                                                    :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                                                 let {
                                                   x_abjH :: GHC.Prim.Int#
                                                   [LclId,
                                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                            Value=False, ConLike=False,
                                                            WorkFree=False, Expandable=False,
                                                            Guidance=IF_ARGS [] 1 0}]
                                                   x_abjH = GHC.Prim.+# bx2_abjK 1# } in
                                                 case GHC.Prim.<# x_abjH 0# of {
                                                   __DEFAULT ->
                                                     case GHC.Prim.newPinnedByteArray#
                                                            @GHC.Prim.RealWorld x_abjH s_abjG
                                                     of
                                                     { (# ipv_abjP, ipv1_abjQ #) ->
                                                     let {
                                                       ipv2_abjO :: GHC.Prim.Addr#
                                                       [LclId,
                                                        Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                                Value=False, ConLike=False,
                                                                WorkFree=False, Expandable=False,
                                                                Guidance=IF_ARGS [] 1 0}]
                                                       ipv2_abjO
                                                         = GHC.Prim.mutableByteArrayContents#
                                                             @GHC.Prim.RealWorld ipv1_abjQ } in
                                                     let {
                                                       ipv3_abjS
                                                         :: GHC.ForeignPtr.ForeignPtrContents
                                                       [LclId,
                                                        Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                                Value=True, ConLike=True,
                                                                WorkFree=True, Expandable=True,
                                                                Guidance=IF_ARGS [] 10 10}]
                                                       ipv3_abjS
                                                         = GHC.ForeignPtr.PlainPtr ipv1_abjQ } in
                                                     case ds_abjv of { GHC.Word.W8# x1_abla ->
                                                     case GHC.Prim.writeWord8OffAddr#
                                                            @GHC.Prim.RealWorld
                                                            ipv2_abjO
                                                            0#
                                                            x1_abla
                                                            ipv_abjP
                                                     of s2_ablc
                                                     { __DEFAULT ->
                                                     case GHC.Prim.touch#
                                                            @'GHC.Types.Lifted
                                                            @GHC.ForeignPtr.ForeignPtrContents
                                                            ipv3_abjS
                                                            s2_ablc
                                                     of s'_abld
                                                     { __DEFAULT ->
                                                     case {__ffi_static_ccall_unsafe base:memcpy :: Addr#
                                          -> Addr#
                                          -> Word64#
                                          -> State# RealWorld
                                          -> (# State# RealWorld, Addr# #)}_able
                                                            (GHC.Prim.plusAddr# ipv2_abjO 1#)
                                                            bx_abjI
                                                            (GHC.Prim.int64ToWord64#
                                                               (GHC.Prim.intToInt64# bx2_abjK))
                                                            s'_abld
                                                     of
                                                     { (# ds4_ablg, ds5_ablh #) ->
                                                     case GHC.Prim.touch#
                                                            @'GHC.Types.Lifted
                                                            @GHC.ForeignPtr.ForeignPtrContents
                                                            bx1_abjJ
                                                            ds4_ablg
                                                     of s'1_ablj
                                                     { __DEFAULT ->
                                                     case GHC.Prim.touch#
                                                            @'GHC.Types.Lifted
                                                            @GHC.ForeignPtr.ForeignPtrContents
                                                            ipv3_abjS
                                                            s'1_ablj
                                                     of s'2_ablk
                                                     { __DEFAULT ->
                                                     case GHC.Magic.lazy
                                                            @((GHC.Prim.State# GHC.Prim.RealWorld
                                                               -> (# GHC.Prim.State#
                                                                       GHC.Prim.RealWorld,
                                                                     GHC.Prim.Addr# #))
                                                              -> (# GHC.Prim.State#
                                                                      GHC.Prim.RealWorld,
                                                                    GHC.Prim.Addr# #))
                                                            (GHC.Magic.runRW#
                                                               @('GHC.Types.TupleRep
                                                                   '[GHC.Types.ZeroBitRep,
                                                                     'GHC.Types.AddrRep])
                                                               @(# GHC.Prim.State#
                                                                     GHC.Prim.RealWorld,
                                                                   GHC.Prim.Addr# #))
                                                            (\ _ [Occ=Dead] ->
                                                               (# s'2_ablk, ipv2_abjO #))
                                                     of
                                                     { (# ipv6_abln, ipv7_ablo #) ->
                                                     Data.ByteString.Internal.Type.BS
                                                       ipv7_ablo ipv3_abjS x_abjH
                                                     }
                                                     }
                                                     }
                                                     }
                                                     }
                                                     }
                                                     }
                                                     };
                                                   1# ->
                                                     case GHC.ForeignPtr.mallocPlainForeignPtrBytes2
                                                     of wild_00 {
                                                     }
                                                 })
                                            }
                                            }) } in
                                 \ (ds3_ablr
                                      :: Data.Either.Either
                                           Data.ByteString.Internal.Type.ByteString
                                           (f_abj9
                                              (GHC.Word.Word8,
                                               Data.ByteString.Internal.Type.ByteString))) ->
                                   case ds3_ablr of {
                                     Data.Either.Left x_ablt -> f2_abjr x_ablt;
                                     Data.Either.Right y_ablv -> ds2_abjs y_ablv
                                   }) } in
                        let {
                          g_ablx
                            :: p_abj8
                                 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                 (f_abj9 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                               -> p_abj8
                                    (Data.Either.Either
                                       Data.ByteString.Internal.Type.ByteString
                                       (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                                    (Data.Either.Either
                                       Data.ByteString.Internal.Type.ByteString
                                       (f_abj9
                                          (GHC.Word.Word8,
                                           Data.ByteString.Internal.Type.ByteString)))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_ablx
                            = Data.Profunctor.Choice.right'
                                @p_abj8
                                $dChoice_abja
                                @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                @(f_abj9
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                                @Data.ByteString.Internal.Type.ByteString } in
                        \ (x_ably
                             :: p_abj8
                                  (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                  (f_abj9
                                     (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))) ->
                          f1_abjc (g_ablx x_ably))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <Data.ByteString.Internal.Type.ByteString>_N
                                      <Data.ByteString.Internal.Type.ByteString>_N
                                      <GHC.Word.Word8>_N
                                      <GHC.Word.Word8>_N)
                             :: Control.Lens.Type.Prism
                                  Data.ByteString.Internal.Type.ByteString
                                  Data.ByteString.Internal.Type.ByteString
                                  (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                  (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                ~R# Control.Lens.Cons.Cons
                                      Data.ByteString.Internal.Type.ByteString
                                      Data.ByteString.Internal.Type.ByteString
                                      GHC.Word.Word8
                                      GHC.Word.Word8)
              ValArg (\ (@(p_abj8 :: * -> * -> *))
                        (@(f_abj9 :: * -> *))
                        ($dChoice_abja :: Data.Profunctor.Choice.Choice p_abj8)
                        ($dApplicative_abjb :: GHC.Base.Applicative f_abj9) ->
                        let {
                          f1_abjc
                            :: p_abj8
                                 (Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                                 (Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString
                                    (f_abj9
                                       (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                               -> p_abj8
                                    Data.ByteString.Internal.Type.ByteString
                                    (f_abj9 Data.ByteString.Internal.Type.ByteString)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 612 0}]
                          f1_abjc
                            = Data.Profunctor.Unsafe.dimap
                                @p_abj8
                                (Data.Profunctor.Choice.$p1Choice @p_abj8 $dChoice_abja)
                                @Data.ByteString.Internal.Type.ByteString
                                @(Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                                @(Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString
                                    (f_abj9
                                       (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                                @(f_abj9 Data.ByteString.Internal.Type.ByteString)
                                (\ (s1_abjd :: Data.ByteString.Internal.Type.ByteString) ->
                                   case s1_abjd of wild_abje
                                   { Data.ByteString.Internal.Type.BS bx_abjf bx1_abjg bx2_abjh ->
                                   case GHC.Classes.leInt (GHC.Types.I# bx2_abjh) (GHC.Types.I# 0#)
                                   of {
                                     GHC.Types.False ->
                                       Data.Either.Right
                                         @Data.ByteString.Internal.Type.ByteString
                                         @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                         (case GHC.Prim.readWord8OffAddr#
                                                 @GHC.Prim.RealWorld bx_abjf 0# GHC.Prim.realWorld#
                                          of
                                          { (# ipv_abjm, ipv1_abjn #) ->
                                          case GHC.Prim.touch#
                                                 @'GHC.Types.Lifted
                                                 @GHC.ForeignPtr.ForeignPtrContents
                                                 bx1_abjg
                                                 ipv_abjm
                                          of
                                          { __DEFAULT ->
                                          GHC.Word.W8# ipv1_abjn
                                          }
                                          },
                                          Data.ByteString.Internal.Type.$WBS
                                            (GHC.ForeignPtr.ForeignPtr
                                               @GHC.Word.Word8
                                               (GHC.Prim.plusAddr# bx_abjf 1#)
                                               bx1_abjg)
                                            (GHC.Types.I# (GHC.Prim.-# bx2_abjh 1#)));
                                     GHC.Types.True ->
                                       Data.Either.Left
                                         @Data.ByteString.Internal.Type.ByteString
                                         @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                         wild_abje
                                   }
                                   })
                                (let {
                                   f2_abjr
                                     :: Data.ByteString.Internal.Type.ByteString
                                        -> f_abj9 Data.ByteString.Internal.Type.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abjr
                                     = GHC.Base.pure
                                         @f_abj9
                                         $dApplicative_abjb
                                         @Data.ByteString.Internal.Type.ByteString } in
                                 let {
                                   ds2_abjs
                                     :: f_abj9
                                          (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                        -> f_abj9 Data.ByteString.Internal.Type.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 259 0}]
                                   ds2_abjs
                                     = GHC.Base.fmap
                                         @f_abj9
                                         (GHC.Base.$p1Applicative @f_abj9 $dApplicative_abjb)
                                         @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                         @Data.ByteString.Internal.Type.ByteString
                                         (\ (p1_abjt
                                               :: (GHC.Word.Word8,
                                                   Data.ByteString.Internal.Type.ByteString)) ->
                                            case p1_abjt of { (ds_abjv, y_abjw) ->
                                            case y_abjw of
                                            { Data.ByteString.Internal.Type.BS bx_abjI bx1_abjJ
                                                                               bx2_abjK ->
                                            GHC.Magic.runRW#
                                              @GHC.Types.LiftedRep
                                              @Data.ByteString.Internal.Type.ByteString
                                              (\ (s_abjG [OS=OneShot]
                                                    :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                                                 let {
                                                   x_abjH :: GHC.Prim.Int#
                                                   [LclId,
                                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                            Value=False, ConLike=False,
                                                            WorkFree=False, Expandable=False,
                                                            Guidance=IF_ARGS [] 1 0}]
                                                   x_abjH = GHC.Prim.+# bx2_abjK 1# } in
                                                 case GHC.Prim.<# x_abjH 0# of {
                                                   __DEFAULT ->
                                                     case GHC.Prim.newPinnedByteArray#
                                                            @GHC.Prim.RealWorld x_abjH s_abjG
                                                     of
                                                     { (# ipv_abjP, ipv1_abjQ #) ->
                                                     let {
                                                       ipv2_abjO :: GHC.Prim.Addr#
                                                       [LclId,
                                                        Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                                Value=False, ConLike=False,
                                                                WorkFree=False, Expandable=False,
                                                                Guidance=IF_ARGS [] 1 0}]
                                                       ipv2_abjO
                                                         = GHC.Prim.mutableByteArrayContents#
                                                             @GHC.Prim.RealWorld ipv1_abjQ } in
                                                     let {
                                                       ipv3_abjS
                                                         :: GHC.ForeignPtr.ForeignPtrContents
                                                       [LclId,
                                                        Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                                Value=True, ConLike=True,
                                                                WorkFree=True, Expandable=True,
                                                                Guidance=IF_ARGS [] 10 10}]
                                                       ipv3_abjS
                                                         = GHC.ForeignPtr.PlainPtr ipv1_abjQ } in
                                                     case ds_abjv of { GHC.Word.W8# x1_abla ->
                                                     case GHC.Prim.writeWord8OffAddr#
                                                            @GHC.Prim.RealWorld
                                                            ipv2_abjO
                                                            0#
                                                            x1_abla
                                                            ipv_abjP
                                                     of s2_ablc
                                                     { __DEFAULT ->
                                                     case GHC.Prim.touch#
                                                            @'GHC.Types.Lifted
                                                            @GHC.ForeignPtr.ForeignPtrContents
                                                            ipv3_abjS
                                                            s2_ablc
                                                     of s'_abld
                                                     { __DEFAULT ->
                                                     case {__ffi_static_ccall_unsafe base:memcpy :: Addr#
                                          -> Addr#
                                          -> Word64#
                                          -> State# RealWorld
                                          -> (# State# RealWorld, Addr# #)}_able
                                                            (GHC.Prim.plusAddr# ipv2_abjO 1#)
                                                            bx_abjI
                                                            (GHC.Prim.int64ToWord64#
                                                               (GHC.Prim.intToInt64# bx2_abjK))
                                                            s'_abld
                                                     of
                                                     { (# ds4_ablg, ds5_ablh #) ->
                                                     case GHC.Prim.touch#
                                                            @'GHC.Types.Lifted
                                                            @GHC.ForeignPtr.ForeignPtrContents
                                                            bx1_abjJ
                                                            ds4_ablg
                                                     of s'1_ablj
                                                     { __DEFAULT ->
                                                     case GHC.Prim.touch#
                                                            @'GHC.Types.Lifted
                                                            @GHC.ForeignPtr.ForeignPtrContents
                                                            ipv3_abjS
                                                            s'1_ablj
                                                     of s'2_ablk
                                                     { __DEFAULT ->
                                                     case GHC.Magic.lazy
                                                            @((GHC.Prim.State# GHC.Prim.RealWorld
                                                               -> (# GHC.Prim.State#
                                                                       GHC.Prim.RealWorld,
                                                                     GHC.Prim.Addr# #))
                                                              -> (# GHC.Prim.State#
                                                                      GHC.Prim.RealWorld,
                                                                    GHC.Prim.Addr# #))
                                                            (GHC.Magic.runRW#
                                                               @('GHC.Types.TupleRep
                                                                   '[GHC.Types.ZeroBitRep,
                                                                     'GHC.Types.AddrRep])
                                                               @(# GHC.Prim.State#
                                                                     GHC.Prim.RealWorld,
                                                                   GHC.Prim.Addr# #))
                                                            (\ _ [Occ=Dead] ->
                                                               (# s'2_ablk, ipv2_abjO #))
                                                     of
                                                     { (# ipv6_abln, ipv7_ablo #) ->
                                                     Data.ByteString.Internal.Type.BS
                                                       ipv7_ablo ipv3_abjS x_abjH
                                                     }
                                                     }
                                                     }
                                                     }
                                                     }
                                                     }
                                                     }
                                                     };
                                                   1# ->
                                                     case GHC.ForeignPtr.mallocPlainForeignPtrBytes2
                                                     of wild_00 {
                                                     }
                                                 })
                                            }
                                            }) } in
                                 \ (ds3_ablr
                                      :: Data.Either.Either
                                           Data.ByteString.Internal.Type.ByteString
                                           (f_abj9
                                              (GHC.Word.Word8,
                                               Data.ByteString.Internal.Type.ByteString))) ->
                                   case ds3_ablr of {
                                     Data.Either.Left x_ablt -> f2_abjr x_ablt;
                                     Data.Either.Right y_ablv -> ds2_abjs y_ablv
                                   }) } in
                        let {
                          g_ablx
                            :: p_abj8
                                 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                 (f_abj9 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                               -> p_abj8
                                    (Data.Either.Either
                                       Data.ByteString.Internal.Type.ByteString
                                       (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                                    (Data.Either.Either
                                       Data.ByteString.Internal.Type.ByteString
                                       (f_abj9
                                          (GHC.Word.Word8,
                                           Data.ByteString.Internal.Type.ByteString)))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_ablx
                            = Data.Profunctor.Choice.right'
                                @p_abj8
                                $dChoice_abja
                                @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                @(f_abj9
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                                @Data.ByteString.Internal.Type.ByteString } in
                        \ (x_ably
                             :: p_abj8
                                  (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                  (f_abj9
                                     (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))) ->
                          f1_abjc (g_ablx x_ably))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <Data.ByteString.Internal.Type.ByteString>_N
                                      <Data.ByteString.Internal.Type.ByteString>_N
                                      <GHC.Word.Word8>_N
                                      <GHC.Word.Word8>_N)
                             :: Control.Lens.Type.Prism
                                  Data.ByteString.Internal.Type.ByteString
                                  Data.ByteString.Internal.Type.ByteString
                                  (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                  (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                ~R# Control.Lens.Cons.Cons
                                      Data.ByteString.Internal.Type.ByteString
                                      Data.ByteString.Internal.Type.ByteString
                                      GHC.Word.Word8
                                      GHC.Word.Word8)
              ValArg (\ (@(p_ablF :: * -> * -> *))
                        (@(f_ablG :: * -> *))
                        ($dChoice_ablH :: Data.Profunctor.Choice.Choice p_ablF)
                        ($dApplicative_ablI :: GHC.Base.Applicative f_ablG) ->
                        let {
                          f1_ablJ
                            :: p_ablF
                                 (Data.Either.Either Data.ByteString.Internal.Type.ByteString ())
                                 (Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString (f_ablG ()))
                               -> p_ablF
                                    Data.ByteString.Internal.Type.ByteString
                                    (f_ablG Data.ByteString.Internal.Type.ByteString)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 350 0}]
                          f1_ablJ
                            = Data.Profunctor.Unsafe.dimap
                                @p_ablF
                                (Data.Profunctor.Choice.$p1Choice @p_ablF $dChoice_ablH)
                                @Data.ByteString.Internal.Type.ByteString
                                @(Data.Either.Either Data.ByteString.Internal.Type.ByteString ())
                                @(Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString (f_ablG ()))
                                @(f_ablG Data.ByteString.Internal.Type.ByteString)
                                (\ (s_ablK :: Data.ByteString.Internal.Type.ByteString) ->
                                   case s_ablK of wild_ablL
                                   { Data.ByteString.Internal.Type.BS bx_ablM bx1_ablN bx2_ablO ->
                                   case GHC.Classes.leInt (GHC.Types.I# bx2_ablO) (GHC.Types.I# 0#)
                                   of {
                                     GHC.Types.False ->
                                       Data.Either.Left
                                         @Data.ByteString.Internal.Type.ByteString @() wild_ablL;
                                     GHC.Types.True ->
                                       Data.Either.Right
                                         @Data.ByteString.Internal.Type.ByteString
                                         @()
                                         GHC.Tuple.Prim.()
                                   }
                                   })
                                (let {
                                   f2_ablS
                                     :: Data.ByteString.Internal.Type.ByteString
                                        -> f_ablG Data.ByteString.Internal.Type.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_ablS
                                     = GHC.Base.pure
                                         @f_ablG
                                         $dApplicative_ablI
                                         @Data.ByteString.Internal.Type.ByteString } in
                                 let {
                                   ds2_ablT
                                     :: f_ablG () -> f_ablG Data.ByteString.Internal.Type.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 70 0}]
                                   ds2_ablT
                                     = GHC.Base.fmap
                                         @f_ablG
                                         (GHC.Base.$p1Applicative @f_ablG $dApplicative_ablI)
                                         @()
                                         @Data.ByteString.Internal.Type.ByteString
                                         (\ (ds3_ablU :: ()) ->
                                            case ds3_ablU of { () ->
                                            Data.ByteString.Internal.Type.empty
                                            }) } in
                                 \ (ds3_ablW
                                      :: Data.Either.Either
                                           Data.ByteString.Internal.Type.ByteString (f_ablG ())) ->
                                   case ds3_ablW of {
                                     Data.Either.Left x_ablY -> f2_ablS x_ablY;
                                     Data.Either.Right y_abm0 -> ds2_ablT y_abm0
                                   }) } in
                        let {
                          g_abm2
                            :: p_ablF () (f_ablG ())
                               -> p_ablF
                                    (Data.Either.Either Data.ByteString.Internal.Type.ByteString ())
                                    (Data.Either.Either
                                       Data.ByteString.Internal.Type.ByteString (f_ablG ()))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abm2
                            = Data.Profunctor.Choice.right'
                                @p_ablF
                                $dChoice_ablH
                                @()
                                @(f_ablG ())
                                @Data.ByteString.Internal.Type.ByteString } in
                        \ (x_abm3 :: p_ablF () (f_ablG ())) -> f1_ablJ (g_abm2 x_abm3))
                     `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                      <Data.ByteString.Internal.Type.ByteString>_N)
                             :: Control.Lens.Type.Prism'
                                  Data.ByteString.Internal.Type.ByteString ()
                                ~R# Control.Lens.Empty.AsEmpty
                                      Data.ByteString.Internal.Type.ByteString)
              TyArg Data.Functor.Const.Const
                      Data.ByteString.Internal.Type.ByteString
              ValArg Data.Functor.Contravariant.$fContravariantConst
                       @Data.ByteString.Internal.Type.ByteString
              ValArg Data.Functor.Const.$fFunctorConst
                       @Data.ByteString.Internal.Type.ByteString
    After:  (\ (@s1_aben)
               (@(f_abeo :: * -> *))
               (@a_abep)
               ($dCons_abeq
                  :: Control.Lens.Cons.Cons s1_aben s1_aben a_abep a_abep)
               ($dCons1_aber
                  :: Control.Lens.Cons.Cons s1_aben s1_aben a_abep a_abep)
               ($dAsEmpty_abes :: Control.Lens.Empty.AsEmpty s1_aben)
               ($dContravariant_abet
                  :: Data.Functor.Contravariant.Contravariant f_abeo)
               ($dFunctor_abeu :: GHC.Base.Functor f_abeo) ->
               GHC.Base.id @(s1_aben -> f_abeo s1_aben))
              @Data.ByteString.Internal.Type.ByteString
              @(Data.Functor.Const.Const
                  Data.ByteString.Internal.Type.ByteString)
              @GHC.Word.Word8
              ((\ (@(p_abj8 :: * -> * -> *))
                  (@(f_abj9 :: * -> *))
                  ($dChoice_abja :: Data.Profunctor.Choice.Choice p_abj8)
                  ($dApplicative_abjb :: GHC.Base.Applicative f_abj9) ->
                  let {
                    f1_abjc
                      :: p_abj8
                           (Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString
                              (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                           (Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString
                              (f_abj9
                                 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                         -> p_abj8
                              Data.ByteString.Internal.Type.ByteString
                              (f_abj9 Data.ByteString.Internal.Type.ByteString)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 612 0}]
                    f1_abjc
                      = Data.Profunctor.Unsafe.dimap
                          @p_abj8
                          (Data.Profunctor.Choice.$p1Choice @p_abj8 $dChoice_abja)
                          @Data.ByteString.Internal.Type.ByteString
                          @(Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString
                              (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                          @(Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString
                              (f_abj9
                                 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                          @(f_abj9 Data.ByteString.Internal.Type.ByteString)
                          (\ (s1_abjd :: Data.ByteString.Internal.Type.ByteString) ->
                             case s1_abjd of wild_abje
                             { Data.ByteString.Internal.Type.BS bx_abjf bx1_abjg bx2_abjh ->
                             case GHC.Classes.leInt (GHC.Types.I# bx2_abjh) (GHC.Types.I# 0#)
                             of {
                               GHC.Types.False ->
                                 Data.Either.Right
                                   @Data.ByteString.Internal.Type.ByteString
                                   @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                   (case GHC.Prim.readWord8OffAddr#
                                           @GHC.Prim.RealWorld bx_abjf 0# GHC.Prim.realWorld#
                                    of
                                    { (# ipv_abjm, ipv1_abjn #) ->
                                    case GHC.Prim.touch#
                                           @'GHC.Types.Lifted
                                           @GHC.ForeignPtr.ForeignPtrContents
                                           bx1_abjg
                                           ipv_abjm
                                    of
                                    { __DEFAULT ->
                                    GHC.Word.W8# ipv1_abjn
                                    }
                                    },
                                    Data.ByteString.Internal.Type.$WBS
                                      (GHC.ForeignPtr.ForeignPtr
                                         @GHC.Word.Word8 (GHC.Prim.plusAddr# bx_abjf 1#) bx1_abjg)
                                      (GHC.Types.I# (GHC.Prim.-# bx2_abjh 1#)));
                               GHC.Types.True ->
                                 Data.Either.Left
                                   @Data.ByteString.Internal.Type.ByteString
                                   @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                   wild_abje
                             }
                             })
                          (let {
                             f2_abjr
                               :: Data.ByteString.Internal.Type.ByteString
                                  -> f_abj9 Data.ByteString.Internal.Type.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abjr
                               = GHC.Base.pure
                                   @f_abj9
                                   $dApplicative_abjb
                                   @Data.ByteString.Internal.Type.ByteString } in
                           let {
                             ds2_abjs
                               :: f_abj9
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                  -> f_abj9 Data.ByteString.Internal.Type.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 259 0}]
                             ds2_abjs
                               = GHC.Base.fmap
                                   @f_abj9
                                   (GHC.Base.$p1Applicative @f_abj9 $dApplicative_abjb)
                                   @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                   @Data.ByteString.Internal.Type.ByteString
                                   (\ (p1_abjt
                                         :: (GHC.Word.Word8,
                                             Data.ByteString.Internal.Type.ByteString)) ->
                                      case p1_abjt of { (ds_abjv, y_abjw) ->
                                      case y_abjw of
                                      { Data.ByteString.Internal.Type.BS bx_abjI bx1_abjJ
                                                                         bx2_abjK ->
                                      GHC.Magic.runRW#
                                        @GHC.Types.LiftedRep
                                        @Data.ByteString.Internal.Type.ByteString
                                        (\ (s_abjG [OS=OneShot]
                                              :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                                           let {
                                             x_abjH :: GHC.Prim.Int#
                                             [LclId,
                                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                      Value=False, ConLike=False, WorkFree=False,
                                                      Expandable=False,
                                                      Guidance=IF_ARGS [] 1 0}]
                                             x_abjH = GHC.Prim.+# bx2_abjK 1# } in
                                           case GHC.Prim.<# x_abjH 0# of {
                                             __DEFAULT ->
                                               case GHC.Prim.newPinnedByteArray#
                                                      @GHC.Prim.RealWorld x_abjH s_abjG
                                               of
                                               { (# ipv_abjP, ipv1_abjQ #) ->
                                               let {
                                                 ipv2_abjO :: GHC.Prim.Addr#
                                                 [LclId,
                                                  Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                          Value=False, ConLike=False,
                                                          WorkFree=False, Expandable=False,
                                                          Guidance=IF_ARGS [] 1 0}]
                                                 ipv2_abjO
                                                   = GHC.Prim.mutableByteArrayContents#
                                                       @GHC.Prim.RealWorld ipv1_abjQ } in
                                               let {
                                                 ipv3_abjS :: GHC.ForeignPtr.ForeignPtrContents
                                                 [LclId,
                                                  Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                          Value=True, ConLike=True, WorkFree=True,
                                                          Expandable=True,
                                                          Guidance=IF_ARGS [] 10 10}]
                                                 ipv3_abjS = GHC.ForeignPtr.PlainPtr ipv1_abjQ } in
                                               case ds_abjv of { GHC.Word.W8# x1_abla ->
                                               case GHC.Prim.writeWord8OffAddr#
                                                      @GHC.Prim.RealWorld
                                                      ipv2_abjO
                                                      0#
                                                      x1_abla
                                                      ipv_abjP
                                               of s2_ablc
                                               { __DEFAULT ->
                                               case GHC.Prim.touch#
                                                      @'GHC.Types.Lifted
                                                      @GHC.ForeignPtr.ForeignPtrContents
                                                      ipv3_abjS
                                                      s2_ablc
                                               of s'_abld
                                               { __DEFAULT ->
                                               case {__ffi_static_ccall_unsafe base:memcpy :: Addr#
                                          -> Addr#
                                          -> Word64#
                                          -> State# RealWorld
                                          -> (# State# RealWorld, Addr# #)}_able
                                                      (GHC.Prim.plusAddr# ipv2_abjO 1#)
                                                      bx_abjI
                                                      (GHC.Prim.int64ToWord64#
                                                         (GHC.Prim.intToInt64# bx2_abjK))
                                                      s'_abld
                                               of
                                               { (# ds4_ablg, ds5_ablh #) ->
                                               case GHC.Prim.touch#
                                                      @'GHC.Types.Lifted
                                                      @GHC.ForeignPtr.ForeignPtrContents
                                                      bx1_abjJ
                                                      ds4_ablg
                                               of s'1_ablj
                                               { __DEFAULT ->
                                               case GHC.Prim.touch#
                                                      @'GHC.Types.Lifted
                                                      @GHC.ForeignPtr.ForeignPtrContents
                                                      ipv3_abjS
                                                      s'1_ablj
                                               of s'2_ablk
                                               { __DEFAULT ->
                                               case GHC.Magic.lazy
                                                      @((GHC.Prim.State# GHC.Prim.RealWorld
                                                         -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                               GHC.Prim.Addr# #))
                                                        -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                              GHC.Prim.Addr# #))
                                                      (GHC.Magic.runRW#
                                                         @('GHC.Types.TupleRep
                                                             '[GHC.Types.ZeroBitRep,
                                                               'GHC.Types.AddrRep])
                                                         @(# GHC.Prim.State# GHC.Prim.RealWorld,
                                                             GHC.Prim.Addr# #))
                                                      (\ _ [Occ=Dead] -> (# s'2_ablk, ipv2_abjO #))
                                               of
                                               { (# ipv6_abln, ipv7_ablo #) ->
                                               Data.ByteString.Internal.Type.BS
                                                 ipv7_ablo ipv3_abjS x_abjH
                                               }
                                               }
                                               }
                                               }
                                               }
                                               }
                                               }
                                               };
                                             1# ->
                                               case GHC.ForeignPtr.mallocPlainForeignPtrBytes2
                                               of wild_00 {
                                               }
                                           })
                                      }
                                      }) } in
                           \ (ds3_ablr
                                :: Data.Either.Either
                                     Data.ByteString.Internal.Type.ByteString
                                     (f_abj9
                                        (GHC.Word.Word8,
                                         Data.ByteString.Internal.Type.ByteString))) ->
                             case ds3_ablr of {
                               Data.Either.Left x_ablt -> f2_abjr x_ablt;
                               Data.Either.Right y_ablv -> ds2_abjs y_ablv
                             }) } in
                  let {
                    g_ablx
                      :: p_abj8
                           (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                           (f_abj9 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                         -> p_abj8
                              (Data.Either.Either
                                 Data.ByteString.Internal.Type.ByteString
                                 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                              (Data.Either.Either
                                 Data.ByteString.Internal.Type.ByteString
                                 (f_abj9
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_ablx
                      = Data.Profunctor.Choice.right'
                          @p_abj8
                          $dChoice_abja
                          @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                          @(f_abj9
                              (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                          @Data.ByteString.Internal.Type.ByteString } in
                  \ (x_ably
                       :: p_abj8
                            (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                            (f_abj9
                               (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))) ->
                    f1_abjc (g_ablx x_ably))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <Data.ByteString.Internal.Type.ByteString>_N
                                <Data.ByteString.Internal.Type.ByteString>_N
                                <GHC.Word.Word8>_N
                                <GHC.Word.Word8>_N)
                       :: Control.Lens.Type.Prism
                            Data.ByteString.Internal.Type.ByteString
                            Data.ByteString.Internal.Type.ByteString
                            (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                            (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                          ~R# Control.Lens.Cons.Cons
                                Data.ByteString.Internal.Type.ByteString
                                Data.ByteString.Internal.Type.ByteString
                                GHC.Word.Word8
                                GHC.Word.Word8))
              ((\ (@(p_abj8 :: * -> * -> *))
                  (@(f_abj9 :: * -> *))
                  ($dChoice_abja :: Data.Profunctor.Choice.Choice p_abj8)
                  ($dApplicative_abjb :: GHC.Base.Applicative f_abj9) ->
                  let {
                    f1_abjc
                      :: p_abj8
                           (Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString
                              (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                           (Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString
                              (f_abj9
                                 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                         -> p_abj8
                              Data.ByteString.Internal.Type.ByteString
                              (f_abj9 Data.ByteString.Internal.Type.ByteString)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 612 0}]
                    f1_abjc
                      = Data.Profunctor.Unsafe.dimap
                          @p_abj8
                          (Data.Profunctor.Choice.$p1Choice @p_abj8 $dChoice_abja)
                          @Data.ByteString.Internal.Type.ByteString
                          @(Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString
                              (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                          @(Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString
                              (f_abj9
                                 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                          @(f_abj9 Data.ByteString.Internal.Type.ByteString)
                          (\ (s1_abjd :: Data.ByteString.Internal.Type.ByteString) ->
                             case s1_abjd of wild_abje
                             { Data.ByteString.Internal.Type.BS bx_abjf bx1_abjg bx2_abjh ->
                             case GHC.Classes.leInt (GHC.Types.I# bx2_abjh) (GHC.Types.I# 0#)
                             of {
                               GHC.Types.False ->
                                 Data.Either.Right
                                   @Data.ByteString.Internal.Type.ByteString
                                   @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                   (case GHC.Prim.readWord8OffAddr#
                                           @GHC.Prim.RealWorld bx_abjf 0# GHC.Prim.realWorld#
                                    of
                                    { (# ipv_abjm, ipv1_abjn #) ->
                                    case GHC.Prim.touch#
                                           @'GHC.Types.Lifted
                                           @GHC.ForeignPtr.ForeignPtrContents
                                           bx1_abjg
                                           ipv_abjm
                                    of
                                    { __DEFAULT ->
                                    GHC.Word.W8# ipv1_abjn
                                    }
                                    },
                                    Data.ByteString.Internal.Type.$WBS
                                      (GHC.ForeignPtr.ForeignPtr
                                         @GHC.Word.Word8 (GHC.Prim.plusAddr# bx_abjf 1#) bx1_abjg)
                                      (GHC.Types.I# (GHC.Prim.-# bx2_abjh 1#)));
                               GHC.Types.True ->
                                 Data.Either.Left
                                   @Data.ByteString.Internal.Type.ByteString
                                   @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                   wild_abje
                             }
                             })
                          (let {
                             f2_abjr
                               :: Data.ByteString.Internal.Type.ByteString
                                  -> f_abj9 Data.ByteString.Internal.Type.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abjr
                               = GHC.Base.pure
                                   @f_abj9
                                   $dApplicative_abjb
                                   @Data.ByteString.Internal.Type.ByteString } in
                           let {
                             ds2_abjs
                               :: f_abj9
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                  -> f_abj9 Data.ByteString.Internal.Type.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 259 0}]
                             ds2_abjs
                               = GHC.Base.fmap
                                   @f_abj9
                                   (GHC.Base.$p1Applicative @f_abj9 $dApplicative_abjb)
                                   @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                   @Data.ByteString.Internal.Type.ByteString
                                   (\ (p1_abjt
                                         :: (GHC.Word.Word8,
                                             Data.ByteString.Internal.Type.ByteString)) ->
                                      case p1_abjt of { (ds_abjv, y_abjw) ->
                                      case y_abjw of
                                      { Data.ByteString.Internal.Type.BS bx_abjI bx1_abjJ
                                                                         bx2_abjK ->
                                      GHC.Magic.runRW#
                                        @GHC.Types.LiftedRep
                                        @Data.ByteString.Internal.Type.ByteString
                                        (\ (s_abjG [OS=OneShot]
                                              :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                                           let {
                                             x_abjH :: GHC.Prim.Int#
                                             [LclId,
                                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                      Value=False, ConLike=False, WorkFree=False,
                                                      Expandable=False,
                                                      Guidance=IF_ARGS [] 1 0}]
                                             x_abjH = GHC.Prim.+# bx2_abjK 1# } in
                                           case GHC.Prim.<# x_abjH 0# of {
                                             __DEFAULT ->
                                               case GHC.Prim.newPinnedByteArray#
                                                      @GHC.Prim.RealWorld x_abjH s_abjG
                                               of
                                               { (# ipv_abjP, ipv1_abjQ #) ->
                                               let {
                                                 ipv2_abjO :: GHC.Prim.Addr#
                                                 [LclId,
                                                  Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                          Value=False, ConLike=False,
                                                          WorkFree=False, Expandable=False,
                                                          Guidance=IF_ARGS [] 1 0}]
                                                 ipv2_abjO
                                                   = GHC.Prim.mutableByteArrayContents#
                                                       @GHC.Prim.RealWorld ipv1_abjQ } in
                                               let {
                                                 ipv3_abjS :: GHC.ForeignPtr.ForeignPtrContents
                                                 [LclId,
                                                  Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                          Value=True, ConLike=True, WorkFree=True,
                                                          Expandable=True,
                                                          Guidance=IF_ARGS [] 10 10}]
                                                 ipv3_abjS = GHC.ForeignPtr.PlainPtr ipv1_abjQ } in
                                               case ds_abjv of { GHC.Word.W8# x1_abla ->
                                               case GHC.Prim.writeWord8OffAddr#
                                                      @GHC.Prim.RealWorld
                                                      ipv2_abjO
                                                      0#
                                                      x1_abla
                                                      ipv_abjP
                                               of s2_ablc
                                               { __DEFAULT ->
                                               case GHC.Prim.touch#
                                                      @'GHC.Types.Lifted
                                                      @GHC.ForeignPtr.ForeignPtrContents
                                                      ipv3_abjS
                                                      s2_ablc
                                               of s'_abld
                                               { __DEFAULT ->
                                               case {__ffi_static_ccall_unsafe base:memcpy :: Addr#
                                          -> Addr#
                                          -> Word64#
                                          -> State# RealWorld
                                          -> (# State# RealWorld, Addr# #)}_able
                                                      (GHC.Prim.plusAddr# ipv2_abjO 1#)
                                                      bx_abjI
                                                      (GHC.Prim.int64ToWord64#
                                                         (GHC.Prim.intToInt64# bx2_abjK))
                                                      s'_abld
                                               of
                                               { (# ds4_ablg, ds5_ablh #) ->
                                               case GHC.Prim.touch#
                                                      @'GHC.Types.Lifted
                                                      @GHC.ForeignPtr.ForeignPtrContents
                                                      bx1_abjJ
                                                      ds4_ablg
                                               of s'1_ablj
                                               { __DEFAULT ->
                                               case GHC.Prim.touch#
                                                      @'GHC.Types.Lifted
                                                      @GHC.ForeignPtr.ForeignPtrContents
                                                      ipv3_abjS
                                                      s'1_ablj
                                               of s'2_ablk
                                               { __DEFAULT ->
                                               case GHC.Magic.lazy
                                                      @((GHC.Prim.State# GHC.Prim.RealWorld
                                                         -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                               GHC.Prim.Addr# #))
                                                        -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                              GHC.Prim.Addr# #))
                                                      (GHC.Magic.runRW#
                                                         @('GHC.Types.TupleRep
                                                             '[GHC.Types.ZeroBitRep,
                                                               'GHC.Types.AddrRep])
                                                         @(# GHC.Prim.State# GHC.Prim.RealWorld,
                                                             GHC.Prim.Addr# #))
                                                      (\ _ [Occ=Dead] -> (# s'2_ablk, ipv2_abjO #))
                                               of
                                               { (# ipv6_abln, ipv7_ablo #) ->
                                               Data.ByteString.Internal.Type.BS
                                                 ipv7_ablo ipv3_abjS x_abjH
                                               }
                                               }
                                               }
                                               }
                                               }
                                               }
                                               }
                                               };
                                             1# ->
                                               case GHC.ForeignPtr.mallocPlainForeignPtrBytes2
                                               of wild_00 {
                                               }
                                           })
                                      }
                                      }) } in
                           \ (ds3_ablr
                                :: Data.Either.Either
                                     Data.ByteString.Internal.Type.ByteString
                                     (f_abj9
                                        (GHC.Word.Word8,
                                         Data.ByteString.Internal.Type.ByteString))) ->
                             case ds3_ablr of {
                               Data.Either.Left x_ablt -> f2_abjr x_ablt;
                               Data.Either.Right y_ablv -> ds2_abjs y_ablv
                             }) } in
                  let {
                    g_ablx
                      :: p_abj8
                           (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                           (f_abj9 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                         -> p_abj8
                              (Data.Either.Either
                                 Data.ByteString.Internal.Type.ByteString
                                 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                              (Data.Either.Either
                                 Data.ByteString.Internal.Type.ByteString
                                 (f_abj9
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_ablx
                      = Data.Profunctor.Choice.right'
                          @p_abj8
                          $dChoice_abja
                          @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                          @(f_abj9
                              (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                          @Data.ByteString.Internal.Type.ByteString } in
                  \ (x_ably
                       :: p_abj8
                            (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                            (f_abj9
                               (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))) ->
                    f1_abjc (g_ablx x_ably))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <Data.ByteString.Internal.Type.ByteString>_N
                                <Data.ByteString.Internal.Type.ByteString>_N
                                <GHC.Word.Word8>_N
                                <GHC.Word.Word8>_N)
                       :: Control.Lens.Type.Prism
                            Data.ByteString.Internal.Type.ByteString
                            Data.ByteString.Internal.Type.ByteString
                            (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                            (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                          ~R# Control.Lens.Cons.Cons
                                Data.ByteString.Internal.Type.ByteString
                                Data.ByteString.Internal.Type.ByteString
                                GHC.Word.Word8
                                GHC.Word.Word8))
              ((\ (@(p_ablF :: * -> * -> *))
                  (@(f_ablG :: * -> *))
                  ($dChoice_ablH :: Data.Profunctor.Choice.Choice p_ablF)
                  ($dApplicative_ablI :: GHC.Base.Applicative f_ablG) ->
                  let {
                    f1_ablJ
                      :: p_ablF
                           (Data.Either.Either Data.ByteString.Internal.Type.ByteString ())
                           (Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString (f_ablG ()))
                         -> p_ablF
                              Data.ByteString.Internal.Type.ByteString
                              (f_ablG Data.ByteString.Internal.Type.ByteString)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 350 0}]
                    f1_ablJ
                      = Data.Profunctor.Unsafe.dimap
                          @p_ablF
                          (Data.Profunctor.Choice.$p1Choice @p_ablF $dChoice_ablH)
                          @Data.ByteString.Internal.Type.ByteString
                          @(Data.Either.Either Data.ByteString.Internal.Type.ByteString ())
                          @(Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString (f_ablG ()))
                          @(f_ablG Data.ByteString.Internal.Type.ByteString)
                          (\ (s_ablK :: Data.ByteString.Internal.Type.ByteString) ->
                             case s_ablK of wild_ablL
                             { Data.ByteString.Internal.Type.BS bx_ablM bx1_ablN bx2_ablO ->
                             case GHC.Classes.leInt (GHC.Types.I# bx2_ablO) (GHC.Types.I# 0#)
                             of {
                               GHC.Types.False ->
                                 Data.Either.Left
                                   @Data.ByteString.Internal.Type.ByteString @() wild_ablL;
                               GHC.Types.True ->
                                 Data.Either.Right
                                   @Data.ByteString.Internal.Type.ByteString @() GHC.Tuple.Prim.()
                             }
                             })
                          (let {
                             f2_ablS
                               :: Data.ByteString.Internal.Type.ByteString
                                  -> f_ablG Data.ByteString.Internal.Type.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_ablS
                               = GHC.Base.pure
                                   @f_ablG
                                   $dApplicative_ablI
                                   @Data.ByteString.Internal.Type.ByteString } in
                           let {
                             ds2_ablT
                               :: f_ablG () -> f_ablG Data.ByteString.Internal.Type.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 70 0}]
                             ds2_ablT
                               = GHC.Base.fmap
                                   @f_ablG
                                   (GHC.Base.$p1Applicative @f_ablG $dApplicative_ablI)
                                   @()
                                   @Data.ByteString.Internal.Type.ByteString
                                   (\ (ds3_ablU :: ()) ->
                                      case ds3_ablU of { () ->
                                      Data.ByteString.Internal.Type.empty
                                      }) } in
                           \ (ds3_ablW
                                :: Data.Either.Either
                                     Data.ByteString.Internal.Type.ByteString (f_ablG ())) ->
                             case ds3_ablW of {
                               Data.Either.Left x_ablY -> f2_ablS x_ablY;
                               Data.Either.Right y_abm0 -> ds2_ablT y_abm0
                             }) } in
                  let {
                    g_abm2
                      :: p_ablF () (f_ablG ())
                         -> p_ablF
                              (Data.Either.Either Data.ByteString.Internal.Type.ByteString ())
                              (Data.Either.Either
                                 Data.ByteString.Internal.Type.ByteString (f_ablG ()))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abm2
                      = Data.Profunctor.Choice.right'
                          @p_ablF
                          $dChoice_ablH
                          @()
                          @(f_ablG ())
                          @Data.ByteString.Internal.Type.ByteString } in
                  \ (x_abm3 :: p_ablF () (f_ablG ())) -> f1_ablJ (g_abm2 x_abm3))
               `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                <Data.ByteString.Internal.Type.ByteString>_N)
                       :: Control.Lens.Type.Prism'
                            Data.ByteString.Internal.Type.ByteString ()
                          ~R# Control.Lens.Empty.AsEmpty
                                Data.ByteString.Internal.Type.ByteString))
              (Data.Functor.Contravariant.$fContravariantConst
                 @Data.ByteString.Internal.Type.ByteString)
              (Data.Functor.Const.$fFunctorConst
                 @Data.ByteString.Internal.Type.ByteString)
    Cont:   ApplyToVal nodup hole Control.Lens.Getter.Getting
                                    Data.ByteString.Internal.Type.ByteString
                                    Data.ByteString.Internal.Type.ByteString
                                    Data.ByteString.Internal.Type.ByteString
              ((\ (ds_abdj [Occ=Once1] :: a_abdg) -> ds_abdj)
               `cast` (<a_abdg>_R
                       %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                          <*>_N <a_abdg>_R <a_abdg>_P)
                       :: (a_abdg -> a_abdg)
                          ~R# (a_abdg -> Data.Functor.Const.Const a_abdg a_abdg)))
            ApplyToVal nodup hole Data.ByteString.Internal.Type.ByteString
                                  -> Data.Functor.Const.Const
                                       Data.ByteString.Internal.Type.ByteString
                                       Data.ByteString.Internal.Type.ByteString
              s_a8Ju
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N
                        <Data.ByteString.Internal.Type.ByteString>_R
                        <Data.ByteString.Internal.Type.ByteString>_P
                    :: Data.Functor.Const.Const
                         Data.ByteString.Internal.Type.ByteString
                         Data.ByteString.Internal.Type.ByteString
                       ~R# Data.ByteString.Internal.Type.ByteString)
            Stop[RuleArgCtxt] Data.ByteString.Internal.Type.ByteString
Rule fired
    Rule: Class op ==
    Module: (BUILTIN)
    Before: GHC.Classes.==
              TyArg Data.ByteString.Internal.Type.ByteString
              ValArg Data.ByteString.Internal.Type.$fEqByteString
              ValArg s_a8Ju
              ValArg s_a8Ju
    After:  Data.ByteString.Internal.Type.eq
              ValArg s_a8Ju ValArg s_a8Ju
    Cont:   Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: unpack
    Module: (GHC.Base)
    Before: GHC.CString.unpackCString# ValArg "L -> L"#
    After:  (\ (a_ab5Y :: GHC.Prim.Addr#) ->
               GHC.Base.build
                 @GHC.Types.Char
                 (\ (@b_ab5Z) -> GHC.CString.unpackFoldrCString# @b_ab5Z a_ab5Y))
              "L -> L"#
    Cont:   Stop[BoringCtxt] Test.Tasty.Core.TestName
Rule fired
    Rule: Class op property
    Module: (BUILTIN)
    Before: Test.QuickCheck.Property.property
              TyArg Data.ByteString.Lazy.Internal.ByteString -> GHC.Types.Bool
              ValArg Test.QuickCheck.Property.$fTestableFUN
                       @Data.ByteString.Lazy.Internal.ByteString
                       @GHC.Types.Bool
                       Test.QuickCheck.Instances.ByteString.$fArbitraryByteString
                       Data.ByteString.Lazy.Internal.$fShowByteString
                       Test.QuickCheck.Property.$fTestableBool
    After:  Test.QuickCheck.Property.$fTestableFUN_$cproperty
              @Data.ByteString.Lazy.Internal.ByteString
              @GHC.Types.Bool
              Test.QuickCheck.Instances.ByteString.$fArbitraryByteString
              Data.ByteString.Lazy.Internal.$fShowByteString
              Test.QuickCheck.Property.$fTestableBool
    Cont:   ApplyToVal nodup hole (Data.ByteString.Lazy.Internal.ByteString
                                   -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              prop_ab6b
            CastIt (Sym (Test.Tasty.QuickCheck.N:QC[0])
                    :: Test.QuickCheck.Property.Property ~R# Test.Tasty.QuickCheck.QC)
            Stop[BoringCtxt] Test.Tasty.QuickCheck.QC
Rule fired
    Rule: Class op propertyForAllShrinkShow
    Module: (BUILTIN)
    Before: Test.QuickCheck.Property.propertyForAllShrinkShow
              TyArg GHC.Types.Bool ValArg Test.QuickCheck.Property.$fTestableBool
    After:  Test.QuickCheck.Property.$fTestableBool1
            `cast` (forall (a :: <*>_N).
                    <Test.QuickCheck.Gen.Gen a>_R
                    %<'GHC.Types.Many>_N ->_R <a -> [a]>_R
                    %<'GHC.Types.Many>_N ->_R <a -> [GHC.Base.String]>_R
                    %<'GHC.Types.Many>_N ->_R <a -> GHC.Types.Bool>_R
                    %<'GHC.Types.Many>_N ->_R Sym (Test.QuickCheck.Gen.N:Gen[0]
                                                       (Test.QuickCheck.Property.N:Prop[0]))
                                              ; Sym (Test.QuickCheck.Property.N:Property[0])
                    :: (forall {a}.
                        Test.QuickCheck.Gen.Gen a
                        -> (a -> [a])
                        -> (a -> [GHC.Base.String])
                        -> (a -> GHC.Types.Bool)
                        -> Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int
                        -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result)
                       ~R# (forall {a}.
                            Test.QuickCheck.Gen.Gen a
                            -> (a -> [a])
                            -> (a -> [GHC.Base.String])
                            -> (a -> GHC.Types.Bool)
                            -> Test.QuickCheck.Property.Property))
    Cont:   ApplyToTy Data.ByteString.Lazy.Internal.ByteString
            ApplyToVal nodup hole Test.QuickCheck.Gen.Gen
                                    Data.ByteString.Lazy.Internal.ByteString
                                  -> (Data.ByteString.Lazy.Internal.ByteString
                                      -> [Data.ByteString.Lazy.Internal.ByteString])
                                  -> (Data.ByteString.Lazy.Internal.ByteString -> [GHC.Base.String])
                                  -> (Data.ByteString.Lazy.Internal.ByteString -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (Test.QuickCheck.Arbitrary.arbitrary @a_ab7T $dArbitrary_ab7V)
            ApplyToVal nodup hole (Data.ByteString.Lazy.Internal.ByteString
                                   -> [Data.ByteString.Lazy.Internal.ByteString])
                                  -> (Data.ByteString.Lazy.Internal.ByteString -> [GHC.Base.String])
                                  -> (Data.ByteString.Lazy.Internal.ByteString -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (Test.QuickCheck.Arbitrary.shrink @a_ab7T $dArbitrary_ab7V)
            ApplyToVal nodup hole (Data.ByteString.Lazy.Internal.ByteString
                                   -> [GHC.Base.String])
                                  -> (Data.ByteString.Lazy.Internal.ByteString -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (let {
                 g_ab7Z [Occ=OnceL1!] :: a_ab7T -> GHC.Base.String
                 [LclId]
                 g_ab7Z = GHC.Show.show @a_ab7T $dShow_ab7W } in
               \ (x_ab80 [Occ=Once1] :: a_ab7T) ->
                 GHC.Types.:
                   @GHC.Base.String (g_ab7Z x_ab80) (GHC.Types.[] @GHC.Base.String))
            ApplyToVal nodup hole (Data.ByteString.Lazy.Internal.ByteString
                                   -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              f_ab7Y
            CastIt (Sym (Test.Tasty.QuickCheck.N:QC[0])
                    :: Test.QuickCheck.Property.Property ~R# Test.Tasty.QuickCheck.QC)
            Stop[BoringCtxt] Test.Tasty.QuickCheck.QC
Rule fired
    Rule: Class op arbitrary
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.arbitrary
              TyArg Data.ByteString.Lazy.Internal.ByteString
              ValArg Test.QuickCheck.Instances.ByteString.$fArbitraryByteString
    After:  Test.QuickCheck.Instances.ByteString.$fArbitraryByteString1
            `cast` (Sym (Test.QuickCheck.Gen.N:Gen[0]
                             <Data.ByteString.Lazy.Internal.ByteString>_R)
                    :: (Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int -> Data.ByteString.Lazy.Internal.ByteString)
                       ~R# Test.QuickCheck.Gen.Gen
                             Data.ByteString.Lazy.Internal.ByteString)
    Cont:   Stop[BoringCtxt] Test.QuickCheck.Gen.Gen
                               Data.ByteString.Lazy.Internal.ByteString
Rule fired
    Rule: Class op shrink
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.shrink
              TyArg Data.ByteString.Lazy.Internal.ByteString
              ValArg Test.QuickCheck.Instances.ByteString.$fArbitraryByteString
    After:  Test.QuickCheck.Instances.ByteString.$fArbitraryByteString_$cshrink
    Cont:   Stop[BoringCtxt] Data.ByteString.Lazy.Internal.ByteString
                             -> [Data.ByteString.Lazy.Internal.ByteString]
Rule fired
    Rule: Class op show
    Module: (BUILTIN)
    Before: GHC.Show.show
              TyArg Data.ByteString.Lazy.Internal.ByteString
              ValArg Data.ByteString.Lazy.Internal.$fShowByteString
    After:  Data.ByteString.Lazy.Internal.$fShowByteString_$cshow
    Cont:   Stop[RhsCtxt(NonRecursive)] Data.ByteString.Lazy.Internal.ByteString
                                        -> GHC.Base.String
Rule fired
    Rule: Class op reader
    Module: (BUILTIN)
    Before: Control.Monad.Reader.Class.reader
              TyArg Data.ByteString.Lazy.Internal.ByteString
              TyArg (->) Data.ByteString.Lazy.Internal.ByteString
              ValArg Control.Monad.Reader.Class.$fMonadReaderrFUN
                       @Data.ByteString.Lazy.Internal.ByteString
    After:  \ (@a_abdo) ->
              GHC.Base.id @(Data.ByteString.Lazy.Internal.ByteString -> a_abdo)
    Cont:   ApplyToTy Data.ByteString.Lazy.Internal.ByteString
            ApplyToVal nodup hole (Data.ByteString.Lazy.Internal.ByteString
                                   -> Data.ByteString.Lazy.Internal.ByteString)
                                  -> Data.ByteString.Lazy.Internal.ByteString
                                  -> Data.ByteString.Lazy.Internal.ByteString
              ((l_abdi
                  ((\ (ds_abdj [Occ=Once1] :: a_abdg) -> ds_abdj)
                   `cast` (<a_abdg>_R
                           %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                              <*>_N <a_abdg>_R <a_abdg>_P)
                           :: (a_abdg -> a_abdg)
                              ~R# (a_abdg -> Data.Functor.Const.Const a_abdg a_abdg))))
               `cast` (<s_abde>_R
                       %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                     <*>_N <a_abdg>_R <s_abde>_P
                       :: (s_abde -> Data.Functor.Const.Const a_abdg s_abde)
                          ~R# (s_abde -> a_abdg)))
            ApplyToVal nodup hole Data.ByteString.Lazy.Internal.ByteString
                                  -> Data.ByteString.Lazy.Internal.ByteString
              s_a8My
            Stop[RuleArgCtxt] Data.ByteString.Lazy.Internal.ByteString
Rule fired
    Rule: recons/id
    Module: (Control.Lens.Cons.Extras)
    Before: Control.Lens.Cons.Extras.recons
              TyArg Data.ByteString.Lazy.Internal.ByteString
              TyArg GHC.Word.Word8
              TyArg Data.ByteString.Lazy.Internal.ByteString
              ValArg (\ (@(p_abm8 :: * -> * -> *))
                        (@(f_abm9 :: * -> *))
                        ($dChoice_abma :: Data.Profunctor.Choice.Choice p_abm8)
                        ($dApplicative_abmb :: GHC.Base.Applicative f_abm9) ->
                        let {
                          f1_abmc
                            :: p_abm8
                                 (Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                                 (Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (f_abm9
                                       (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                               -> p_abm8
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (f_abm9 Data.ByteString.Lazy.Internal.ByteString)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 536 0}]
                          f1_abmc
                            = Data.Profunctor.Unsafe.dimap
                                @p_abm8
                                (Data.Profunctor.Choice.$p1Choice @p_abm8 $dChoice_abma)
                                @Data.ByteString.Lazy.Internal.ByteString
                                @(Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                                @(Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (f_abm9
                                       (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                                @(f_abm9 Data.ByteString.Lazy.Internal.ByteString)
                                (\ (s1_abmd :: Data.ByteString.Lazy.Internal.ByteString) ->
                                   case s1_abmd of {
                                     Data.ByteString.Lazy.Internal.Empty ->
                                       Data.Either.Left
                                         @Data.ByteString.Lazy.Internal.ByteString
                                         @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                         Data.ByteString.Lazy.Internal.Empty;
                                     Data.ByteString.Lazy.Internal.Chunk bx_abmk bx1_abml bx2_abmm
                                                                         cs_abmn ->
                                       case bx2_abmm of ds1_abmp {
                                         __DEFAULT ->
                                           Data.Either.Right
                                             @Data.ByteString.Lazy.Internal.ByteString
                                             @(GHC.Word.Word8,
                                               Data.ByteString.Lazy.Internal.ByteString)
                                             (case GHC.Prim.readWord8OffAddr#
                                                     @GHC.Prim.RealWorld
                                                     bx_abmk
                                                     0#
                                                     GHC.Prim.realWorld#
                                              of
                                              { (# ipv_abmr, ipv1_abms #) ->
                                              case GHC.Prim.touch#
                                                     @'GHC.Types.Lifted
                                                     @GHC.ForeignPtr.ForeignPtrContents
                                                     bx1_abml
                                                     ipv_abmr
                                              of
                                              { __DEFAULT ->
                                              GHC.Word.W8# ipv1_abms
                                              }
                                              },
                                              Data.ByteString.Lazy.Internal.$WChunk
                                                (Data.ByteString.Internal.Type.$WBS
                                                   (GHC.ForeignPtr.ForeignPtr
                                                      @GHC.Word.Word8
                                                      (GHC.Prim.plusAddr# bx_abmk 1#)
                                                      bx1_abml)
                                                   (GHC.Types.I# (GHC.Prim.-# ds1_abmp 1#)))
                                                cs_abmn);
                                         1# ->
                                           Data.Either.Right
                                             @Data.ByteString.Lazy.Internal.ByteString
                                             @(GHC.Word.Word8,
                                               Data.ByteString.Lazy.Internal.ByteString)
                                             (case GHC.Prim.readWord8OffAddr#
                                                     @GHC.Prim.RealWorld
                                                     bx_abmk
                                                     0#
                                                     GHC.Prim.realWorld#
                                              of
                                              { (# ipv_abmw, ipv1_abmx #) ->
                                              case GHC.Prim.touch#
                                                     @'GHC.Types.Lifted
                                                     @GHC.ForeignPtr.ForeignPtrContents
                                                     bx1_abml
                                                     ipv_abmw
                                              of
                                              { __DEFAULT ->
                                              GHC.Word.W8# ipv1_abmx
                                              }
                                              },
                                              cs_abmn)
                                       }
                                   })
                                (let {
                                   f2_abmA
                                     :: Data.ByteString.Lazy.Internal.ByteString
                                        -> f_abm9 Data.ByteString.Lazy.Internal.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abmA
                                     = GHC.Base.pure
                                         @f_abm9
                                         $dApplicative_abmb
                                         @Data.ByteString.Lazy.Internal.ByteString } in
                                 let {
                                   ds2_abmB
                                     :: f_abm9
                                          (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                        -> f_abm9 Data.ByteString.Lazy.Internal.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 162 0}]
                                   ds2_abmB
                                     = GHC.Base.fmap
                                         @f_abm9
                                         (GHC.Base.$p1Applicative @f_abm9 $dApplicative_abmb)
                                         @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                         @Data.ByteString.Lazy.Internal.ByteString
                                         (\ (p1_abmC
                                               :: (GHC.Word.Word8,
                                                   Data.ByteString.Lazy.Internal.ByteString)) ->
                                            case p1_abmC of { (x_abmE, ds_abmF) ->
                                            case x_abmE of { GHC.Word.W8# x#_abmI ->
                                            Data.ByteString.Lazy.Internal.$WChunk
                                              (Data.ByteString.Internal.Type.$WBS
                                                 (GHC.ForeignPtr.ForeignPtr
                                                    @GHC.Word.Word8
                                                    (GHC.Prim.plusAddr#
                                                       Data.ByteString.singleton1
                                                       (GHC.Prim.word2Int#
                                                          (GHC.Prim.word8ToWord# x#_abmI)))
                                                    GHC.ForeignPtr.FinalPtr)
                                                 (GHC.Types.I# 1#))
                                              ds_abmF
                                            }
                                            }) } in
                                 \ (ds3_abmK
                                      :: Data.Either.Either
                                           Data.ByteString.Lazy.Internal.ByteString
                                           (f_abm9
                                              (GHC.Word.Word8,
                                               Data.ByteString.Lazy.Internal.ByteString))) ->
                                   case ds3_abmK of {
                                     Data.Either.Left x_abmM -> f2_abmA x_abmM;
                                     Data.Either.Right y_abmO -> ds2_abmB y_abmO
                                   }) } in
                        let {
                          g_abmQ
                            :: p_abm8
                                 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                 (f_abm9 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                               -> p_abm8
                                    (Data.Either.Either
                                       Data.ByteString.Lazy.Internal.ByteString
                                       (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                                    (Data.Either.Either
                                       Data.ByteString.Lazy.Internal.ByteString
                                       (f_abm9
                                          (GHC.Word.Word8,
                                           Data.ByteString.Lazy.Internal.ByteString)))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abmQ
                            = Data.Profunctor.Choice.right'
                                @p_abm8
                                $dChoice_abma
                                @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                @(f_abm9
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                                @Data.ByteString.Lazy.Internal.ByteString } in
                        \ (x_abmR
                             :: p_abm8
                                  (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                  (f_abm9
                                     (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))) ->
                          f1_abmc (g_abmQ x_abmR))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <Data.ByteString.Lazy.Internal.ByteString>_N
                                      <Data.ByteString.Lazy.Internal.ByteString>_N
                                      <GHC.Word.Word8>_N
                                      <GHC.Word.Word8>_N)
                             :: Control.Lens.Type.Prism
                                  Data.ByteString.Lazy.Internal.ByteString
                                  Data.ByteString.Lazy.Internal.ByteString
                                  (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                  (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                ~R# Control.Lens.Cons.Cons
                                      Data.ByteString.Lazy.Internal.ByteString
                                      Data.ByteString.Lazy.Internal.ByteString
                                      GHC.Word.Word8
                                      GHC.Word.Word8)
              ValArg (\ (@(p_abm8 :: * -> * -> *))
                        (@(f_abm9 :: * -> *))
                        ($dChoice_abma :: Data.Profunctor.Choice.Choice p_abm8)
                        ($dApplicative_abmb :: GHC.Base.Applicative f_abm9) ->
                        let {
                          f1_abmc
                            :: p_abm8
                                 (Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                                 (Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (f_abm9
                                       (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                               -> p_abm8
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (f_abm9 Data.ByteString.Lazy.Internal.ByteString)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 536 0}]
                          f1_abmc
                            = Data.Profunctor.Unsafe.dimap
                                @p_abm8
                                (Data.Profunctor.Choice.$p1Choice @p_abm8 $dChoice_abma)
                                @Data.ByteString.Lazy.Internal.ByteString
                                @(Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                                @(Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (f_abm9
                                       (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                                @(f_abm9 Data.ByteString.Lazy.Internal.ByteString)
                                (\ (s1_abmd :: Data.ByteString.Lazy.Internal.ByteString) ->
                                   case s1_abmd of {
                                     Data.ByteString.Lazy.Internal.Empty ->
                                       Data.Either.Left
                                         @Data.ByteString.Lazy.Internal.ByteString
                                         @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                         Data.ByteString.Lazy.Internal.Empty;
                                     Data.ByteString.Lazy.Internal.Chunk bx_abmk bx1_abml bx2_abmm
                                                                         cs_abmn ->
                                       case bx2_abmm of ds1_abmp {
                                         __DEFAULT ->
                                           Data.Either.Right
                                             @Data.ByteString.Lazy.Internal.ByteString
                                             @(GHC.Word.Word8,
                                               Data.ByteString.Lazy.Internal.ByteString)
                                             (case GHC.Prim.readWord8OffAddr#
                                                     @GHC.Prim.RealWorld
                                                     bx_abmk
                                                     0#
                                                     GHC.Prim.realWorld#
                                              of
                                              { (# ipv_abmr, ipv1_abms #) ->
                                              case GHC.Prim.touch#
                                                     @'GHC.Types.Lifted
                                                     @GHC.ForeignPtr.ForeignPtrContents
                                                     bx1_abml
                                                     ipv_abmr
                                              of
                                              { __DEFAULT ->
                                              GHC.Word.W8# ipv1_abms
                                              }
                                              },
                                              Data.ByteString.Lazy.Internal.$WChunk
                                                (Data.ByteString.Internal.Type.$WBS
                                                   (GHC.ForeignPtr.ForeignPtr
                                                      @GHC.Word.Word8
                                                      (GHC.Prim.plusAddr# bx_abmk 1#)
                                                      bx1_abml)
                                                   (GHC.Types.I# (GHC.Prim.-# ds1_abmp 1#)))
                                                cs_abmn);
                                         1# ->
                                           Data.Either.Right
                                             @Data.ByteString.Lazy.Internal.ByteString
                                             @(GHC.Word.Word8,
                                               Data.ByteString.Lazy.Internal.ByteString)
                                             (case GHC.Prim.readWord8OffAddr#
                                                     @GHC.Prim.RealWorld
                                                     bx_abmk
                                                     0#
                                                     GHC.Prim.realWorld#
                                              of
                                              { (# ipv_abmw, ipv1_abmx #) ->
                                              case GHC.Prim.touch#
                                                     @'GHC.Types.Lifted
                                                     @GHC.ForeignPtr.ForeignPtrContents
                                                     bx1_abml
                                                     ipv_abmw
                                              of
                                              { __DEFAULT ->
                                              GHC.Word.W8# ipv1_abmx
                                              }
                                              },
                                              cs_abmn)
                                       }
                                   })
                                (let {
                                   f2_abmA
                                     :: Data.ByteString.Lazy.Internal.ByteString
                                        -> f_abm9 Data.ByteString.Lazy.Internal.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abmA
                                     = GHC.Base.pure
                                         @f_abm9
                                         $dApplicative_abmb
                                         @Data.ByteString.Lazy.Internal.ByteString } in
                                 let {
                                   ds2_abmB
                                     :: f_abm9
                                          (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                        -> f_abm9 Data.ByteString.Lazy.Internal.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 162 0}]
                                   ds2_abmB
                                     = GHC.Base.fmap
                                         @f_abm9
                                         (GHC.Base.$p1Applicative @f_abm9 $dApplicative_abmb)
                                         @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                         @Data.ByteString.Lazy.Internal.ByteString
                                         (\ (p1_abmC
                                               :: (GHC.Word.Word8,
                                                   Data.ByteString.Lazy.Internal.ByteString)) ->
                                            case p1_abmC of { (x_abmE, ds_abmF) ->
                                            case x_abmE of { GHC.Word.W8# x#_abmI ->
                                            Data.ByteString.Lazy.Internal.$WChunk
                                              (Data.ByteString.Internal.Type.$WBS
                                                 (GHC.ForeignPtr.ForeignPtr
                                                    @GHC.Word.Word8
                                                    (GHC.Prim.plusAddr#
                                                       Data.ByteString.singleton1
                                                       (GHC.Prim.word2Int#
                                                          (GHC.Prim.word8ToWord# x#_abmI)))
                                                    GHC.ForeignPtr.FinalPtr)
                                                 (GHC.Types.I# 1#))
                                              ds_abmF
                                            }
                                            }) } in
                                 \ (ds3_abmK
                                      :: Data.Either.Either
                                           Data.ByteString.Lazy.Internal.ByteString
                                           (f_abm9
                                              (GHC.Word.Word8,
                                               Data.ByteString.Lazy.Internal.ByteString))) ->
                                   case ds3_abmK of {
                                     Data.Either.Left x_abmM -> f2_abmA x_abmM;
                                     Data.Either.Right y_abmO -> ds2_abmB y_abmO
                                   }) } in
                        let {
                          g_abmQ
                            :: p_abm8
                                 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                 (f_abm9 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                               -> p_abm8
                                    (Data.Either.Either
                                       Data.ByteString.Lazy.Internal.ByteString
                                       (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                                    (Data.Either.Either
                                       Data.ByteString.Lazy.Internal.ByteString
                                       (f_abm9
                                          (GHC.Word.Word8,
                                           Data.ByteString.Lazy.Internal.ByteString)))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abmQ
                            = Data.Profunctor.Choice.right'
                                @p_abm8
                                $dChoice_abma
                                @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                @(f_abm9
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                                @Data.ByteString.Lazy.Internal.ByteString } in
                        \ (x_abmR
                             :: p_abm8
                                  (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                  (f_abm9
                                     (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))) ->
                          f1_abmc (g_abmQ x_abmR))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <Data.ByteString.Lazy.Internal.ByteString>_N
                                      <Data.ByteString.Lazy.Internal.ByteString>_N
                                      <GHC.Word.Word8>_N
                                      <GHC.Word.Word8>_N)
                             :: Control.Lens.Type.Prism
                                  Data.ByteString.Lazy.Internal.ByteString
                                  Data.ByteString.Lazy.Internal.ByteString
                                  (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                  (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                ~R# Control.Lens.Cons.Cons
                                      Data.ByteString.Lazy.Internal.ByteString
                                      Data.ByteString.Lazy.Internal.ByteString
                                      GHC.Word.Word8
                                      GHC.Word.Word8)
              ValArg (\ (@(p_abmT :: * -> * -> *))
                        (@(f_abmU :: * -> *))
                        ($dChoice_abmV :: Data.Profunctor.Choice.Choice p_abmT)
                        ($dApplicative_abmW :: GHC.Base.Applicative f_abmU) ->
                        let {
                          f1_abmX
                            :: p_abmT
                                 (Data.Either.Either Data.ByteString.Lazy.Internal.ByteString ())
                                 (Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString (f_abmU ()))
                               -> p_abmT
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (f_abmU Data.ByteString.Lazy.Internal.ByteString)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 290 0}]
                          f1_abmX
                            = Data.Profunctor.Unsafe.dimap
                                @p_abmT
                                (Data.Profunctor.Choice.$p1Choice @p_abmT $dChoice_abmV)
                                @Data.ByteString.Lazy.Internal.ByteString
                                @(Data.Either.Either Data.ByteString.Lazy.Internal.ByteString ())
                                @(Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString (f_abmU ()))
                                @(f_abmU Data.ByteString.Lazy.Internal.ByteString)
                                (\ (s_abmY :: Data.ByteString.Lazy.Internal.ByteString) ->
                                   case s_abmY of wild_abmZ {
                                     Data.ByteString.Lazy.Internal.Empty ->
                                       Data.Either.Right
                                         @Data.ByteString.Lazy.Internal.ByteString
                                         @()
                                         GHC.Tuple.Prim.();
                                     Data.ByteString.Lazy.Internal.Chunk ipv_abn0 ipv1_abn1
                                                                         ipv2_abn2 ipv3_abn3 ->
                                       Data.Either.Left
                                         @Data.ByteString.Lazy.Internal.ByteString @() wild_abmZ
                                   })
                                (let {
                                   f2_abn5
                                     :: Data.ByteString.Lazy.Internal.ByteString
                                        -> f_abmU Data.ByteString.Lazy.Internal.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abn5
                                     = GHC.Base.pure
                                         @f_abmU
                                         $dApplicative_abmW
                                         @Data.ByteString.Lazy.Internal.ByteString } in
                                 let {
                                   ds2_abn6
                                     :: f_abmU () -> f_abmU Data.ByteString.Lazy.Internal.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 70 0}]
                                   ds2_abn6
                                     = GHC.Base.fmap
                                         @f_abmU
                                         (GHC.Base.$p1Applicative @f_abmU $dApplicative_abmW)
                                         @()
                                         @Data.ByteString.Lazy.Internal.ByteString
                                         (\ (ds3_abn7 :: ()) ->
                                            case ds3_abn7 of { () ->
                                            Data.ByteString.Lazy.Internal.Empty
                                            }) } in
                                 \ (ds3_abn9
                                      :: Data.Either.Either
                                           Data.ByteString.Lazy.Internal.ByteString (f_abmU ())) ->
                                   case ds3_abn9 of {
                                     Data.Either.Left x_abnb -> f2_abn5 x_abnb;
                                     Data.Either.Right y_abnd -> ds2_abn6 y_abnd
                                   }) } in
                        let {
                          g_abnf
                            :: p_abmT () (f_abmU ())
                               -> p_abmT
                                    (Data.Either.Either Data.ByteString.Lazy.Internal.ByteString ())
                                    (Data.Either.Either
                                       Data.ByteString.Lazy.Internal.ByteString (f_abmU ()))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abnf
                            = Data.Profunctor.Choice.right'
                                @p_abmT
                                $dChoice_abmV
                                @()
                                @(f_abmU ())
                                @Data.ByteString.Lazy.Internal.ByteString } in
                        \ (x_abng :: p_abmT () (f_abmU ())) -> f1_abmX (g_abnf x_abng))
                     `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                      <Data.ByteString.Lazy.Internal.ByteString>_N)
                             :: Control.Lens.Type.Prism'
                                  Data.ByteString.Lazy.Internal.ByteString ()
                                ~R# Control.Lens.Empty.AsEmpty
                                      Data.ByteString.Lazy.Internal.ByteString)
              TyArg Data.Functor.Const.Const
                      Data.ByteString.Lazy.Internal.ByteString
              ValArg Data.Functor.Contravariant.$fContravariantConst
                       @Data.ByteString.Lazy.Internal.ByteString
              ValArg Data.Functor.Const.$fFunctorConst
                       @Data.ByteString.Lazy.Internal.ByteString
    After:  (\ (@s1_aben)
               (@(f_abeo :: * -> *))
               (@a_abep)
               ($dCons_abeq
                  :: Control.Lens.Cons.Cons s1_aben s1_aben a_abep a_abep)
               ($dCons1_aber
                  :: Control.Lens.Cons.Cons s1_aben s1_aben a_abep a_abep)
               ($dAsEmpty_abes :: Control.Lens.Empty.AsEmpty s1_aben)
               ($dContravariant_abet
                  :: Data.Functor.Contravariant.Contravariant f_abeo)
               ($dFunctor_abeu :: GHC.Base.Functor f_abeo) ->
               GHC.Base.id @(s1_aben -> f_abeo s1_aben))
              @Data.ByteString.Lazy.Internal.ByteString
              @(Data.Functor.Const.Const
                  Data.ByteString.Lazy.Internal.ByteString)
              @GHC.Word.Word8
              ((\ (@(p_abm8 :: * -> * -> *))
                  (@(f_abm9 :: * -> *))
                  ($dChoice_abma :: Data.Profunctor.Choice.Choice p_abm8)
                  ($dApplicative_abmb :: GHC.Base.Applicative f_abm9) ->
                  let {
                    f1_abmc
                      :: p_abm8
                           (Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString
                              (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                           (Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString
                              (f_abm9
                                 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                         -> p_abm8
                              Data.ByteString.Lazy.Internal.ByteString
                              (f_abm9 Data.ByteString.Lazy.Internal.ByteString)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 536 0}]
                    f1_abmc
                      = Data.Profunctor.Unsafe.dimap
                          @p_abm8
                          (Data.Profunctor.Choice.$p1Choice @p_abm8 $dChoice_abma)
                          @Data.ByteString.Lazy.Internal.ByteString
                          @(Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString
                              (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                          @(Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString
                              (f_abm9
                                 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                          @(f_abm9 Data.ByteString.Lazy.Internal.ByteString)
                          (\ (s1_abmd :: Data.ByteString.Lazy.Internal.ByteString) ->
                             case s1_abmd of {
                               Data.ByteString.Lazy.Internal.Empty ->
                                 Data.Either.Left
                                   @Data.ByteString.Lazy.Internal.ByteString
                                   @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                   Data.ByteString.Lazy.Internal.Empty;
                               Data.ByteString.Lazy.Internal.Chunk bx_abmk bx1_abml bx2_abmm
                                                                   cs_abmn ->
                                 case bx2_abmm of ds1_abmp {
                                   __DEFAULT ->
                                     Data.Either.Right
                                       @Data.ByteString.Lazy.Internal.ByteString
                                       @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                       (case GHC.Prim.readWord8OffAddr#
                                               @GHC.Prim.RealWorld bx_abmk 0# GHC.Prim.realWorld#
                                        of
                                        { (# ipv_abmr, ipv1_abms #) ->
                                        case GHC.Prim.touch#
                                               @'GHC.Types.Lifted
                                               @GHC.ForeignPtr.ForeignPtrContents
                                               bx1_abml
                                               ipv_abmr
                                        of
                                        { __DEFAULT ->
                                        GHC.Word.W8# ipv1_abms
                                        }
                                        },
                                        Data.ByteString.Lazy.Internal.$WChunk
                                          (Data.ByteString.Internal.Type.$WBS
                                             (GHC.ForeignPtr.ForeignPtr
                                                @GHC.Word.Word8
                                                (GHC.Prim.plusAddr# bx_abmk 1#)
                                                bx1_abml)
                                             (GHC.Types.I# (GHC.Prim.-# ds1_abmp 1#)))
                                          cs_abmn);
                                   1# ->
                                     Data.Either.Right
                                       @Data.ByteString.Lazy.Internal.ByteString
                                       @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                       (case GHC.Prim.readWord8OffAddr#
                                               @GHC.Prim.RealWorld bx_abmk 0# GHC.Prim.realWorld#
                                        of
                                        { (# ipv_abmw, ipv1_abmx #) ->
                                        case GHC.Prim.touch#
                                               @'GHC.Types.Lifted
                                               @GHC.ForeignPtr.ForeignPtrContents
                                               bx1_abml
                                               ipv_abmw
                                        of
                                        { __DEFAULT ->
                                        GHC.Word.W8# ipv1_abmx
                                        }
                                        },
                                        cs_abmn)
                                 }
                             })
                          (let {
                             f2_abmA
                               :: Data.ByteString.Lazy.Internal.ByteString
                                  -> f_abm9 Data.ByteString.Lazy.Internal.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abmA
                               = GHC.Base.pure
                                   @f_abm9
                                   $dApplicative_abmb
                                   @Data.ByteString.Lazy.Internal.ByteString } in
                           let {
                             ds2_abmB
                               :: f_abm9
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                  -> f_abm9 Data.ByteString.Lazy.Internal.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 162 0}]
                             ds2_abmB
                               = GHC.Base.fmap
                                   @f_abm9
                                   (GHC.Base.$p1Applicative @f_abm9 $dApplicative_abmb)
                                   @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                   @Data.ByteString.Lazy.Internal.ByteString
                                   (\ (p1_abmC
                                         :: (GHC.Word.Word8,
                                             Data.ByteString.Lazy.Internal.ByteString)) ->
                                      case p1_abmC of { (x_abmE, ds_abmF) ->
                                      case x_abmE of { GHC.Word.W8# x#_abmI ->
                                      Data.ByteString.Lazy.Internal.$WChunk
                                        (Data.ByteString.Internal.Type.$WBS
                                           (GHC.ForeignPtr.ForeignPtr
                                              @GHC.Word.Word8
                                              (GHC.Prim.plusAddr#
                                                 Data.ByteString.singleton1
                                                 (GHC.Prim.word2Int#
                                                    (GHC.Prim.word8ToWord# x#_abmI)))
                                              GHC.ForeignPtr.FinalPtr)
                                           (GHC.Types.I# 1#))
                                        ds_abmF
                                      }
                                      }) } in
                           \ (ds3_abmK
                                :: Data.Either.Either
                                     Data.ByteString.Lazy.Internal.ByteString
                                     (f_abm9
                                        (GHC.Word.Word8,
                                         Data.ByteString.Lazy.Internal.ByteString))) ->
                             case ds3_abmK of {
                               Data.Either.Left x_abmM -> f2_abmA x_abmM;
                               Data.Either.Right y_abmO -> ds2_abmB y_abmO
                             }) } in
                  let {
                    g_abmQ
                      :: p_abm8
                           (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                           (f_abm9 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                         -> p_abm8
                              (Data.Either.Either
                                 Data.ByteString.Lazy.Internal.ByteString
                                 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                              (Data.Either.Either
                                 Data.ByteString.Lazy.Internal.ByteString
                                 (f_abm9
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abmQ
                      = Data.Profunctor.Choice.right'
                          @p_abm8
                          $dChoice_abma
                          @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                          @(f_abm9
                              (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                          @Data.ByteString.Lazy.Internal.ByteString } in
                  \ (x_abmR
                       :: p_abm8
                            (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                            (f_abm9
                               (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))) ->
                    f1_abmc (g_abmQ x_abmR))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <Data.ByteString.Lazy.Internal.ByteString>_N
                                <Data.ByteString.Lazy.Internal.ByteString>_N
                                <GHC.Word.Word8>_N
                                <GHC.Word.Word8>_N)
                       :: Control.Lens.Type.Prism
                            Data.ByteString.Lazy.Internal.ByteString
                            Data.ByteString.Lazy.Internal.ByteString
                            (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                            (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                          ~R# Control.Lens.Cons.Cons
                                Data.ByteString.Lazy.Internal.ByteString
                                Data.ByteString.Lazy.Internal.ByteString
                                GHC.Word.Word8
                                GHC.Word.Word8))
              ((\ (@(p_abm8 :: * -> * -> *))
                  (@(f_abm9 :: * -> *))
                  ($dChoice_abma :: Data.Profunctor.Choice.Choice p_abm8)
                  ($dApplicative_abmb :: GHC.Base.Applicative f_abm9) ->
                  let {
                    f1_abmc
                      :: p_abm8
                           (Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString
                              (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                           (Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString
                              (f_abm9
                                 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                         -> p_abm8
                              Data.ByteString.Lazy.Internal.ByteString
                              (f_abm9 Data.ByteString.Lazy.Internal.ByteString)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 536 0}]
                    f1_abmc
                      = Data.Profunctor.Unsafe.dimap
                          @p_abm8
                          (Data.Profunctor.Choice.$p1Choice @p_abm8 $dChoice_abma)
                          @Data.ByteString.Lazy.Internal.ByteString
                          @(Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString
                              (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                          @(Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString
                              (f_abm9
                                 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                          @(f_abm9 Data.ByteString.Lazy.Internal.ByteString)
                          (\ (s1_abmd :: Data.ByteString.Lazy.Internal.ByteString) ->
                             case s1_abmd of {
                               Data.ByteString.Lazy.Internal.Empty ->
                                 Data.Either.Left
                                   @Data.ByteString.Lazy.Internal.ByteString
                                   @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                   Data.ByteString.Lazy.Internal.Empty;
                               Data.ByteString.Lazy.Internal.Chunk bx_abmk bx1_abml bx2_abmm
                                                                   cs_abmn ->
                                 case bx2_abmm of ds1_abmp {
                                   __DEFAULT ->
                                     Data.Either.Right
                                       @Data.ByteString.Lazy.Internal.ByteString
                                       @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                       (case GHC.Prim.readWord8OffAddr#
                                               @GHC.Prim.RealWorld bx_abmk 0# GHC.Prim.realWorld#
                                        of
                                        { (# ipv_abmr, ipv1_abms #) ->
                                        case GHC.Prim.touch#
                                               @'GHC.Types.Lifted
                                               @GHC.ForeignPtr.ForeignPtrContents
                                               bx1_abml
                                               ipv_abmr
                                        of
                                        { __DEFAULT ->
                                        GHC.Word.W8# ipv1_abms
                                        }
                                        },
                                        Data.ByteString.Lazy.Internal.$WChunk
                                          (Data.ByteString.Internal.Type.$WBS
                                             (GHC.ForeignPtr.ForeignPtr
                                                @GHC.Word.Word8
                                                (GHC.Prim.plusAddr# bx_abmk 1#)
                                                bx1_abml)
                                             (GHC.Types.I# (GHC.Prim.-# ds1_abmp 1#)))
                                          cs_abmn);
                                   1# ->
                                     Data.Either.Right
                                       @Data.ByteString.Lazy.Internal.ByteString
                                       @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                       (case GHC.Prim.readWord8OffAddr#
                                               @GHC.Prim.RealWorld bx_abmk 0# GHC.Prim.realWorld#
                                        of
                                        { (# ipv_abmw, ipv1_abmx #) ->
                                        case GHC.Prim.touch#
                                               @'GHC.Types.Lifted
                                               @GHC.ForeignPtr.ForeignPtrContents
                                               bx1_abml
                                               ipv_abmw
                                        of
                                        { __DEFAULT ->
                                        GHC.Word.W8# ipv1_abmx
                                        }
                                        },
                                        cs_abmn)
                                 }
                             })
                          (let {
                             f2_abmA
                               :: Data.ByteString.Lazy.Internal.ByteString
                                  -> f_abm9 Data.ByteString.Lazy.Internal.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abmA
                               = GHC.Base.pure
                                   @f_abm9
                                   $dApplicative_abmb
                                   @Data.ByteString.Lazy.Internal.ByteString } in
                           let {
                             ds2_abmB
                               :: f_abm9
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                  -> f_abm9 Data.ByteString.Lazy.Internal.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 162 0}]
                             ds2_abmB
                               = GHC.Base.fmap
                                   @f_abm9
                                   (GHC.Base.$p1Applicative @f_abm9 $dApplicative_abmb)
                                   @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                   @Data.ByteString.Lazy.Internal.ByteString
                                   (\ (p1_abmC
                                         :: (GHC.Word.Word8,
                                             Data.ByteString.Lazy.Internal.ByteString)) ->
                                      case p1_abmC of { (x_abmE, ds_abmF) ->
                                      case x_abmE of { GHC.Word.W8# x#_abmI ->
                                      Data.ByteString.Lazy.Internal.$WChunk
                                        (Data.ByteString.Internal.Type.$WBS
                                           (GHC.ForeignPtr.ForeignPtr
                                              @GHC.Word.Word8
                                              (GHC.Prim.plusAddr#
                                                 Data.ByteString.singleton1
                                                 (GHC.Prim.word2Int#
                                                    (GHC.Prim.word8ToWord# x#_abmI)))
                                              GHC.ForeignPtr.FinalPtr)
                                           (GHC.Types.I# 1#))
                                        ds_abmF
                                      }
                                      }) } in
                           \ (ds3_abmK
                                :: Data.Either.Either
                                     Data.ByteString.Lazy.Internal.ByteString
                                     (f_abm9
                                        (GHC.Word.Word8,
                                         Data.ByteString.Lazy.Internal.ByteString))) ->
                             case ds3_abmK of {
                               Data.Either.Left x_abmM -> f2_abmA x_abmM;
                               Data.Either.Right y_abmO -> ds2_abmB y_abmO
                             }) } in
                  let {
                    g_abmQ
                      :: p_abm8
                           (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                           (f_abm9 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                         -> p_abm8
                              (Data.Either.Either
                                 Data.ByteString.Lazy.Internal.ByteString
                                 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                              (Data.Either.Either
                                 Data.ByteString.Lazy.Internal.ByteString
                                 (f_abm9
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abmQ
                      = Data.Profunctor.Choice.right'
                          @p_abm8
                          $dChoice_abma
                          @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                          @(f_abm9
                              (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                          @Data.ByteString.Lazy.Internal.ByteString } in
                  \ (x_abmR
                       :: p_abm8
                            (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                            (f_abm9
                               (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))) ->
                    f1_abmc (g_abmQ x_abmR))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <Data.ByteString.Lazy.Internal.ByteString>_N
                                <Data.ByteString.Lazy.Internal.ByteString>_N
                                <GHC.Word.Word8>_N
                                <GHC.Word.Word8>_N)
                       :: Control.Lens.Type.Prism
                            Data.ByteString.Lazy.Internal.ByteString
                            Data.ByteString.Lazy.Internal.ByteString
                            (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                            (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                          ~R# Control.Lens.Cons.Cons
                                Data.ByteString.Lazy.Internal.ByteString
                                Data.ByteString.Lazy.Internal.ByteString
                                GHC.Word.Word8
                                GHC.Word.Word8))
              ((\ (@(p_abmT :: * -> * -> *))
                  (@(f_abmU :: * -> *))
                  ($dChoice_abmV :: Data.Profunctor.Choice.Choice p_abmT)
                  ($dApplicative_abmW :: GHC.Base.Applicative f_abmU) ->
                  let {
                    f1_abmX
                      :: p_abmT
                           (Data.Either.Either Data.ByteString.Lazy.Internal.ByteString ())
                           (Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString (f_abmU ()))
                         -> p_abmT
                              Data.ByteString.Lazy.Internal.ByteString
                              (f_abmU Data.ByteString.Lazy.Internal.ByteString)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 290 0}]
                    f1_abmX
                      = Data.Profunctor.Unsafe.dimap
                          @p_abmT
                          (Data.Profunctor.Choice.$p1Choice @p_abmT $dChoice_abmV)
                          @Data.ByteString.Lazy.Internal.ByteString
                          @(Data.Either.Either Data.ByteString.Lazy.Internal.ByteString ())
                          @(Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString (f_abmU ()))
                          @(f_abmU Data.ByteString.Lazy.Internal.ByteString)
                          (\ (s_abmY :: Data.ByteString.Lazy.Internal.ByteString) ->
                             case s_abmY of wild_abmZ {
                               Data.ByteString.Lazy.Internal.Empty ->
                                 Data.Either.Right
                                   @Data.ByteString.Lazy.Internal.ByteString @() GHC.Tuple.Prim.();
                               Data.ByteString.Lazy.Internal.Chunk ipv_abn0 ipv1_abn1 ipv2_abn2
                                                                   ipv3_abn3 ->
                                 Data.Either.Left
                                   @Data.ByteString.Lazy.Internal.ByteString @() wild_abmZ
                             })
                          (let {
                             f2_abn5
                               :: Data.ByteString.Lazy.Internal.ByteString
                                  -> f_abmU Data.ByteString.Lazy.Internal.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abn5
                               = GHC.Base.pure
                                   @f_abmU
                                   $dApplicative_abmW
                                   @Data.ByteString.Lazy.Internal.ByteString } in
                           let {
                             ds2_abn6
                               :: f_abmU () -> f_abmU Data.ByteString.Lazy.Internal.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 70 0}]
                             ds2_abn6
                               = GHC.Base.fmap
                                   @f_abmU
                                   (GHC.Base.$p1Applicative @f_abmU $dApplicative_abmW)
                                   @()
                                   @Data.ByteString.Lazy.Internal.ByteString
                                   (\ (ds3_abn7 :: ()) ->
                                      case ds3_abn7 of { () ->
                                      Data.ByteString.Lazy.Internal.Empty
                                      }) } in
                           \ (ds3_abn9
                                :: Data.Either.Either
                                     Data.ByteString.Lazy.Internal.ByteString (f_abmU ())) ->
                             case ds3_abn9 of {
                               Data.Either.Left x_abnb -> f2_abn5 x_abnb;
                               Data.Either.Right y_abnd -> ds2_abn6 y_abnd
                             }) } in
                  let {
                    g_abnf
                      :: p_abmT () (f_abmU ())
                         -> p_abmT
                              (Data.Either.Either Data.ByteString.Lazy.Internal.ByteString ())
                              (Data.Either.Either
                                 Data.ByteString.Lazy.Internal.ByteString (f_abmU ()))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abnf
                      = Data.Profunctor.Choice.right'
                          @p_abmT
                          $dChoice_abmV
                          @()
                          @(f_abmU ())
                          @Data.ByteString.Lazy.Internal.ByteString } in
                  \ (x_abng :: p_abmT () (f_abmU ())) -> f1_abmX (g_abnf x_abng))
               `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                <Data.ByteString.Lazy.Internal.ByteString>_N)
                       :: Control.Lens.Type.Prism'
                            Data.ByteString.Lazy.Internal.ByteString ()
                          ~R# Control.Lens.Empty.AsEmpty
                                Data.ByteString.Lazy.Internal.ByteString))
              (Data.Functor.Contravariant.$fContravariantConst
                 @Data.ByteString.Lazy.Internal.ByteString)
              (Data.Functor.Const.$fFunctorConst
                 @Data.ByteString.Lazy.Internal.ByteString)
    Cont:   ApplyToVal nodup hole Control.Lens.Getter.Getting
                                    Data.ByteString.Lazy.Internal.ByteString
                                    Data.ByteString.Lazy.Internal.ByteString
                                    Data.ByteString.Lazy.Internal.ByteString
              ((\ (ds_abdj [Occ=Once1] :: a_abdg) -> ds_abdj)
               `cast` (<a_abdg>_R
                       %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                          <*>_N <a_abdg>_R <a_abdg>_P)
                       :: (a_abdg -> a_abdg)
                          ~R# (a_abdg -> Data.Functor.Const.Const a_abdg a_abdg)))
            ApplyToVal nodup hole Data.ByteString.Lazy.Internal.ByteString
                                  -> Data.Functor.Const.Const
                                       Data.ByteString.Lazy.Internal.ByteString
                                       Data.ByteString.Lazy.Internal.ByteString
              s_a8My
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N
                        <Data.ByteString.Lazy.Internal.ByteString>_R
                        <Data.ByteString.Lazy.Internal.ByteString>_P
                    :: Data.Functor.Const.Const
                         Data.ByteString.Lazy.Internal.ByteString
                         Data.ByteString.Lazy.Internal.ByteString
                       ~R# Data.ByteString.Lazy.Internal.ByteString)
            Stop[RuleArgCtxt] Data.ByteString.Lazy.Internal.ByteString
Rule fired
    Rule: Class op ==
    Module: (BUILTIN)
    Before: GHC.Classes.==
              TyArg Data.ByteString.Lazy.Internal.ByteString
              ValArg Data.ByteString.Lazy.Internal.$fEqByteString
              ValArg s_a8My
              ValArg s_a8My
    After:  Data.ByteString.Lazy.Internal.eq
              ValArg s_a8My ValArg s_a8My
    Cont:   Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: unpack
    Module: (GHC.Base)
    Before: GHC.CString.unpackCString# ValArg "Str -> T -> Str"#
    After:  (\ (a_ab5Y :: GHC.Prim.Addr#) ->
               GHC.Base.build
                 @GHC.Types.Char
                 (\ (@b_ab5Z) -> GHC.CString.unpackFoldrCString# @b_ab5Z a_ab5Y))
              "Str -> T -> Str"#
    Cont:   Stop[BoringCtxt] Test.Tasty.Core.TestName
Rule fired
    Rule: Class op property
    Module: (BUILTIN)
    Before: Test.QuickCheck.Property.property
              TyArg GHC.Base.String -> GHC.Types.Bool ValArg $dTestable_a911
    After:  Test.QuickCheck.Property.$fTestableFUN_$cproperty
              @[GHC.Types.Char]
              @GHC.Types.Bool
              $dArbitrary_a9Ip
              GHC.Show.$fShowList_$s$fShowList1
              Test.QuickCheck.Property.$fTestableBool
    Cont:   ApplyToVal nodup hole (GHC.Base.String -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              prop_ab6b
            CastIt (Sym (Test.Tasty.QuickCheck.N:QC[0])
                    :: Test.QuickCheck.Property.Property ~R# Test.Tasty.QuickCheck.QC)
            Stop[BoringCtxt] Test.Tasty.QuickCheck.QC
Rule fired
    Rule: Class op propertyForAllShrinkShow
    Module: (BUILTIN)
    Before: Test.QuickCheck.Property.propertyForAllShrinkShow
              TyArg GHC.Types.Bool ValArg Test.QuickCheck.Property.$fTestableBool
    After:  Test.QuickCheck.Property.$fTestableBool1
            `cast` (forall (a :: <*>_N).
                    <Test.QuickCheck.Gen.Gen a>_R
                    %<'GHC.Types.Many>_N ->_R <a -> [a]>_R
                    %<'GHC.Types.Many>_N ->_R <a -> [GHC.Base.String]>_R
                    %<'GHC.Types.Many>_N ->_R <a -> GHC.Types.Bool>_R
                    %<'GHC.Types.Many>_N ->_R Sym (Test.QuickCheck.Gen.N:Gen[0]
                                                       (Test.QuickCheck.Property.N:Prop[0]))
                                              ; Sym (Test.QuickCheck.Property.N:Property[0])
                    :: (forall {a}.
                        Test.QuickCheck.Gen.Gen a
                        -> (a -> [a])
                        -> (a -> [GHC.Base.String])
                        -> (a -> GHC.Types.Bool)
                        -> Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int
                        -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result)
                       ~R# (forall {a}.
                            Test.QuickCheck.Gen.Gen a
                            -> (a -> [a])
                            -> (a -> [GHC.Base.String])
                            -> (a -> GHC.Types.Bool)
                            -> Test.QuickCheck.Property.Property))
    Cont:   ApplyToTy [GHC.Types.Char]
            ApplyToVal nodup hole Test.QuickCheck.Gen.Gen [GHC.Types.Char]
                                  -> ([GHC.Types.Char] -> [[GHC.Types.Char]])
                                  -> ([GHC.Types.Char] -> [GHC.Base.String])
                                  -> ([GHC.Types.Char] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (Test.QuickCheck.Arbitrary.arbitrary @a_ab7T $dArbitrary_ab7V)
            ApplyToVal nodup hole ([GHC.Types.Char] -> [[GHC.Types.Char]])
                                  -> ([GHC.Types.Char] -> [GHC.Base.String])
                                  -> ([GHC.Types.Char] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (Test.QuickCheck.Arbitrary.shrink @a_ab7T $dArbitrary_ab7V)
            ApplyToVal nodup hole ([GHC.Types.Char] -> [GHC.Base.String])
                                  -> ([GHC.Types.Char] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (let {
                 g_ab7Z [Occ=OnceL1!] :: a_ab7T -> GHC.Base.String
                 [LclId]
                 g_ab7Z = GHC.Show.show @a_ab7T $dShow_ab7W } in
               \ (x_ab80 [Occ=Once1] :: a_ab7T) ->
                 GHC.Types.:
                   @GHC.Base.String (g_ab7Z x_ab80) (GHC.Types.[] @GHC.Base.String))
            ApplyToVal nodup hole ([GHC.Types.Char] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              f_ab7Y
            CastIt (Sym (Test.Tasty.QuickCheck.N:QC[0])
                    :: Test.QuickCheck.Property.Property ~R# Test.Tasty.QuickCheck.QC)
            Stop[BoringCtxt] Test.Tasty.QuickCheck.QC
Rule fired
    Rule: Class op arbitrary
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.arbitrary
              TyArg [GHC.Types.Char] ValArg $dArbitrary_a9Ip
    After:  (Test.QuickCheck.Arbitrary.$fArbitraryList1
               @GHC.Types.Char Test.QuickCheck.Arbitrary.$fArbitraryChar)
            `cast` (Sym (Test.QuickCheck.Gen.N:Gen[0] <[GHC.Types.Char]>_R)
                    :: (Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int -> [GHC.Types.Char])
                       ~R# Test.QuickCheck.Gen.Gen [GHC.Types.Char])
    Cont:   Stop[BoringCtxt] Test.QuickCheck.Gen.Gen [GHC.Types.Char]
Rule fired
    Rule: Class op arbitrary
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.arbitrary
              TyArg GHC.Types.Char
              ValArg Test.QuickCheck.Arbitrary.$fArbitraryChar
    After:  Test.QuickCheck.Arbitrary.$fArbitraryChar_$carbitrary
    Cont:   Stop[BoringCtxt, C(S,C(1,L))] Test.QuickCheck.Gen.Gen
                                            GHC.Types.Char
Rule fired
    Rule: Class op shrink
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.shrink
              TyArg [GHC.Types.Char] ValArg $dArbitrary_a9Ip
    After:  Test.QuickCheck.Arbitrary.$fArbitraryList_$cshrink
              @GHC.Types.Char Test.QuickCheck.Arbitrary.$fArbitraryChar
    Cont:   Stop[BoringCtxt] [GHC.Types.Char] -> [[GHC.Types.Char]]
Rule fired
    Rule: Class op shrink
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.shrink
              TyArg GHC.Types.Char
              ValArg Test.QuickCheck.Arbitrary.$fArbitraryChar
    After:  Test.QuickCheck.Arbitrary.$fArbitraryChar_$cshrink
    Cont:   Stop[DiscArgCtxt, C(S,L)] GHC.Types.Char
                                      -> [GHC.Types.Char]
Rule fired
    Rule: Class op show
    Module: (BUILTIN)
    Before: GHC.Show.show
              TyArg [GHC.Types.Char] ValArg GHC.Show.$fShowList_$s$fShowList1
    After:  GHC.Show.$fShowList_$s$cshow1
    Cont:   Stop[RhsCtxt(NonRecursive)] [GHC.Types.Char]
                                        -> GHC.Base.String
Rule fired
    Rule: Class op reader
    Module: (BUILTIN)
    Before: Control.Monad.Reader.Class.reader
              TyArg Data.Text.Internal.Text
              TyArg (->) Data.Text.Internal.Text
              ValArg Control.Monad.Reader.Class.$fMonadReaderrFUN
                       @Data.Text.Internal.Text
    After:  \ (@a_abdo) ->
              GHC.Base.id @(Data.Text.Internal.Text -> a_abdo)
    Cont:   ApplyToTy GHC.Base.String
            ApplyToVal nodup hole (Data.Text.Internal.Text -> GHC.Base.String)
                                  -> Data.Text.Internal.Text -> GHC.Base.String
              ((l_abdi
                  ((\ (ds_abdj [Occ=Once1] :: a_abdg) -> ds_abdj)
                   `cast` (<a_abdg>_R
                           %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                              <*>_N <a_abdg>_R <a_abdg>_P)
                           :: (a_abdg -> a_abdg)
                              ~R# (a_abdg -> Data.Functor.Const.Const a_abdg a_abdg))))
               `cast` (<s_abde>_R
                       %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                     <*>_N <a_abdg>_R <s_abde>_P
                       :: (s_abde -> Data.Functor.Const.Const a_abdg s_abde)
                          ~R# (s_abde -> a_abdg)))
            ApplyToVal nodup hole Data.Text.Internal.Text -> GHC.Base.String
              (Control.Lens.Getter.view
                 @[GHC.Types.Char]
                 @((->) GHC.Base.String)
                 @Data.Text.Internal.Text
                 (Control.Monad.Reader.Class.$fMonadReaderrFUN @[GHC.Types.Char])
                 (Control.Lens.Cons.Extras.recons
                    @[GHC.Types.Char]
                    @GHC.Types.Char
                    @Data.Text.Internal.Text
                    (Control.Lens.Cons.$fConsListListab
                       @GHC.Types.Char @GHC.Types.Char)
                    Control.Lens.Cons.$fConsTextTextCharChar0
                    Control.Lens.Empty.$fAsEmptyText0
                    @(Data.Functor.Const.Const Data.Text.Internal.Text)
                    (Data.Functor.Contravariant.$fContravariantConst
                       @Data.Text.Internal.Text)
                    (Data.Functor.Const.$fFunctorConst @Data.Text.Internal.Text))
                 s_a8Oc)
            Stop[RuleArgCtxt] GHC.Base.String
Rule fired
    Rule: recons/text-string
    Module: (Control.Lens.Cons.Extras)
    Before: Control.Lens.Cons.Extras.recons
              TyArg Data.Text.Internal.Text
              TyArg GHC.Types.Char
              TyArg GHC.Base.String
              ValArg (\ (@(p_abgP :: * -> * -> *))
                        (@(f_abgQ :: * -> *))
                        ($dChoice_abgR :: Data.Profunctor.Choice.Choice p_abgP)
                        ($dApplicative_abgS :: GHC.Base.Applicative f_abgQ) ->
                        let {
                          f1_abgT
                            :: p_abgP
                                 (Data.Either.Either
                                    Data.Text.Internal.Text
                                    (GHC.Types.Char, Data.Text.Internal.Text))
                                 (Data.Either.Either
                                    Data.Text.Internal.Text
                                    (f_abgQ (GHC.Types.Char, Data.Text.Internal.Text)))
                               -> p_abgP Data.Text.Internal.Text (f_abgQ Data.Text.Internal.Text)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 340 0}]
                          f1_abgT
                            = Data.Profunctor.Unsafe.dimap
                                @p_abgP
                                (Data.Profunctor.Choice.$p1Choice @p_abgP $dChoice_abgR)
                                @Data.Text.Internal.Text
                                @(Data.Either.Either
                                    Data.Text.Internal.Text
                                    (GHC.Types.Char, Data.Text.Internal.Text))
                                @(Data.Either.Either
                                    Data.Text.Internal.Text
                                    (f_abgQ (GHC.Types.Char, Data.Text.Internal.Text)))
                                @(f_abgQ Data.Text.Internal.Text)
                                (\ (s1_abgU :: Data.Text.Internal.Text) ->
                                   case Data.Text.uncons s1_abgU of {
                                     GHC.Maybe.Nothing ->
                                       Data.Either.Left
                                         @Data.Text.Internal.Text
                                         @(GHC.Types.Char, Data.Text.Internal.Text)
                                         s1_abgU;
                                     GHC.Maybe.Just x_abgX ->
                                       Data.Either.Right
                                         @Data.Text.Internal.Text
                                         @(GHC.Types.Char, Data.Text.Internal.Text)
                                         x_abgX
                                   })
                                (let {
                                   f2_abgZ
                                     :: Data.Text.Internal.Text -> f_abgQ Data.Text.Internal.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abgZ
                                     = GHC.Base.pure
                                         @f_abgQ $dApplicative_abgS @Data.Text.Internal.Text } in
                                 let {
                                   ds2_abh0
                                     :: f_abgQ (GHC.Types.Char, Data.Text.Internal.Text)
                                        -> f_abgQ Data.Text.Internal.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 100 0}]
                                   ds2_abh0
                                     = GHC.Base.fmap
                                         @f_abgQ
                                         (GHC.Base.$p1Applicative @f_abgQ $dApplicative_abgS)
                                         @(GHC.Types.Char, Data.Text.Internal.Text)
                                         @Data.Text.Internal.Text
                                         (\ (p1_abh1
                                               :: (GHC.Types.Char, Data.Text.Internal.Text)) ->
                                            case p1_abh1 of { (x_abh3, ds_abh4) ->
                                            Data.Text.cons x_abh3 ds_abh4
                                            }) } in
                                 \ (ds3_abh6
                                      :: Data.Either.Either
                                           Data.Text.Internal.Text
                                           (f_abgQ (GHC.Types.Char, Data.Text.Internal.Text))) ->
                                   case ds3_abh6 of {
                                     Data.Either.Left x_abh8 -> f2_abgZ x_abh8;
                                     Data.Either.Right y_abha -> ds2_abh0 y_abha
                                   }) } in
                        let {
                          g_abhc
                            :: p_abgP
                                 (GHC.Types.Char, Data.Text.Internal.Text)
                                 (f_abgQ (GHC.Types.Char, Data.Text.Internal.Text))
                               -> p_abgP
                                    (Data.Either.Either
                                       Data.Text.Internal.Text
                                       (GHC.Types.Char, Data.Text.Internal.Text))
                                    (Data.Either.Either
                                       Data.Text.Internal.Text
                                       (f_abgQ (GHC.Types.Char, Data.Text.Internal.Text)))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abhc
                            = Data.Profunctor.Choice.right'
                                @p_abgP
                                $dChoice_abgR
                                @(GHC.Types.Char, Data.Text.Internal.Text)
                                @(f_abgQ (GHC.Types.Char, Data.Text.Internal.Text))
                                @Data.Text.Internal.Text } in
                        \ (x_abhd
                             :: p_abgP
                                  (GHC.Types.Char, Data.Text.Internal.Text)
                                  (f_abgQ (GHC.Types.Char, Data.Text.Internal.Text))) ->
                          f1_abgT (g_abhc x_abhd))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <Data.Text.Internal.Text>_N
                                      <Data.Text.Internal.Text>_N
                                      <GHC.Types.Char>_N
                                      <GHC.Types.Char>_N)
                             :: Control.Lens.Type.Prism
                                  Data.Text.Internal.Text
                                  Data.Text.Internal.Text
                                  (GHC.Types.Char, Data.Text.Internal.Text)
                                  (GHC.Types.Char, Data.Text.Internal.Text)
                                ~R# Control.Lens.Cons.Cons
                                      Data.Text.Internal.Text
                                      Data.Text.Internal.Text
                                      GHC.Types.Char
                                      GHC.Types.Char)
              ValArg (\ (@(p_abeP :: * -> * -> *))
                        (@(f_abeQ :: * -> *))
                        ($dChoice_abeR :: Data.Profunctor.Choice.Choice p_abeP)
                        ($dApplicative_abeS :: GHC.Base.Applicative f_abeQ) ->
                        let {
                          f1_abeT
                            :: p_abeP
                                 (Data.Either.Either
                                    [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                                 (Data.Either.Either
                                    [GHC.Types.Char] (f_abeQ (GHC.Types.Char, [GHC.Types.Char])))
                               -> p_abeP [GHC.Types.Char] (f_abeQ [GHC.Types.Char])
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 320 0}]
                          f1_abeT
                            = Data.Profunctor.Unsafe.dimap
                                @p_abeP
                                (Data.Profunctor.Choice.$p1Choice @p_abeP $dChoice_abeR)
                                @[GHC.Types.Char]
                                @(Data.Either.Either
                                    [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                                @(Data.Either.Either
                                    [GHC.Types.Char] (f_abeQ (GHC.Types.Char, [GHC.Types.Char])))
                                @(f_abeQ [GHC.Types.Char])
                                (\ (aas_abeU :: [GHC.Types.Char]) ->
                                   case aas_abeU of {
                                     [] ->
                                       Data.Either.Left
                                         @[GHC.Types.Char]
                                         @(GHC.Types.Char, [GHC.Types.Char])
                                         (GHC.Types.[] @GHC.Types.Char);
                                     : a1_abeW as_abeX ->
                                       Data.Either.Right
                                         @[GHC.Types.Char]
                                         @(GHC.Types.Char, [GHC.Types.Char])
                                         (a1_abeW, as_abeX)
                                   })
                                (let {
                                   f2_abeZ :: [GHC.Types.Char] -> f_abeQ [GHC.Types.Char]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abeZ
                                     = GHC.Base.pure
                                         @f_abeQ $dApplicative_abeS @[GHC.Types.Char] } in
                                 let {
                                   ds2_abf0
                                     :: f_abeQ (GHC.Types.Char, [GHC.Types.Char])
                                        -> f_abeQ [GHC.Types.Char]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 90 0}]
                                   ds2_abf0
                                     = GHC.Base.fmap
                                         @f_abeQ
                                         (GHC.Base.$p1Applicative @f_abeQ $dApplicative_abeS)
                                         @(GHC.Types.Char, [GHC.Types.Char])
                                         @[GHC.Types.Char]
                                         (\ (p1_abf1 :: (GHC.Types.Char, [GHC.Types.Char])) ->
                                            GHC.Types.:
                                              @GHC.Types.Char
                                              (case p1_abf1 of { (x_abf3, ds_abf4) -> x_abf3 })
                                              (case p1_abf1 of { (ds_abf7, y_abf8) ->
                                               y_abf8
                                               })) } in
                                 \ (ds3_abfa
                                      :: Data.Either.Either
                                           [GHC.Types.Char]
                                           (f_abeQ (GHC.Types.Char, [GHC.Types.Char]))) ->
                                   case ds3_abfa of {
                                     Data.Either.Left x_abfc -> f2_abeZ x_abfc;
                                     Data.Either.Right y_abfe -> ds2_abf0 y_abfe
                                   }) } in
                        let {
                          g_abfg
                            :: p_abeP
                                 (GHC.Types.Char, [GHC.Types.Char])
                                 (f_abeQ (GHC.Types.Char, [GHC.Types.Char]))
                               -> p_abeP
                                    (Data.Either.Either
                                       [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                                    (Data.Either.Either
                                       [GHC.Types.Char] (f_abeQ (GHC.Types.Char, [GHC.Types.Char])))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abfg
                            = Data.Profunctor.Choice.right'
                                @p_abeP
                                $dChoice_abeR
                                @(GHC.Types.Char, [GHC.Types.Char])
                                @(f_abeQ (GHC.Types.Char, [GHC.Types.Char]))
                                @[GHC.Types.Char] } in
                        \ (x_abfh
                             :: p_abeP
                                  (GHC.Types.Char, [GHC.Types.Char])
                                  (f_abeQ (GHC.Types.Char, [GHC.Types.Char]))) ->
                          f1_abeT (g_abfg x_abfh))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <[GHC.Types.Char]>_N
                                      <[GHC.Types.Char]>_N
                                      <GHC.Types.Char>_N
                                      <GHC.Types.Char>_N)
                             :: Control.Lens.Type.Prism
                                  [GHC.Types.Char]
                                  [GHC.Types.Char]
                                  (GHC.Types.Char, [GHC.Types.Char])
                                  (GHC.Types.Char, [GHC.Types.Char])
                                ~R# Control.Lens.Cons.Cons
                                      [GHC.Types.Char]
                                      [GHC.Types.Char]
                                      GHC.Types.Char
                                      GHC.Types.Char)
              ValArg (\ (@(p_abfm :: * -> * -> *))
                        (@(f_abfn :: * -> *))
                        ($dChoice_abfo :: Data.Profunctor.Choice.Choice p_abfm)
                        ($dApplicative_abfp :: GHC.Base.Applicative f_abfn) ->
                        let {
                          f1_abfq
                            :: p_abfm
                                 (Data.Either.Either [GHC.Types.Char] ())
                                 (Data.Either.Either [GHC.Types.Char] (f_abfn ()))
                               -> p_abfm [GHC.Types.Char] (f_abfn [GHC.Types.Char])
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 290 0}]
                          f1_abfq
                            = Data.Profunctor.Unsafe.dimap
                                @p_abfm
                                (Data.Profunctor.Choice.$p1Choice @p_abfm $dChoice_abfo)
                                @[GHC.Types.Char]
                                @(Data.Either.Either [GHC.Types.Char] ())
                                @(Data.Either.Either [GHC.Types.Char] (f_abfn ()))
                                @(f_abfn [GHC.Types.Char])
                                (\ (s_abfr :: [GHC.Types.Char]) ->
                                   case s_abfr of wild_abfs {
                                     [] ->
                                       Data.Either.Right @[GHC.Types.Char] @() GHC.Tuple.Prim.();
                                     : ds1_abft ds2_abfu ->
                                       Data.Either.Left @[GHC.Types.Char] @() wild_abfs
                                   })
                                (let {
                                   f2_abfw :: [GHC.Types.Char] -> f_abfn [GHC.Types.Char]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abfw
                                     = GHC.Base.pure
                                         @f_abfn $dApplicative_abfp @[GHC.Types.Char] } in
                                 let {
                                   ds2_abfx :: f_abfn () -> f_abfn [GHC.Types.Char]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 70 0}]
                                   ds2_abfx
                                     = GHC.Base.fmap
                                         @f_abfn
                                         (GHC.Base.$p1Applicative @f_abfn $dApplicative_abfp)
                                         @()
                                         @[GHC.Types.Char]
                                         (\ (ds3_abfy :: ()) ->
                                            case ds3_abfy of { () ->
                                            GHC.Types.[] @GHC.Types.Char
                                            }) } in
                                 \ (ds3_abfA :: Data.Either.Either [GHC.Types.Char] (f_abfn ())) ->
                                   case ds3_abfA of {
                                     Data.Either.Left x_abfC -> f2_abfw x_abfC;
                                     Data.Either.Right y_abfE -> ds2_abfx y_abfE
                                   }) } in
                        let {
                          g_abfG
                            :: p_abfm () (f_abfn ())
                               -> p_abfm
                                    (Data.Either.Either [GHC.Types.Char] ())
                                    (Data.Either.Either [GHC.Types.Char] (f_abfn ()))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abfG
                            = Data.Profunctor.Choice.right'
                                @p_abfm $dChoice_abfo @() @(f_abfn ()) @[GHC.Types.Char] } in
                        \ (x_abfH :: p_abfm () (f_abfn ())) -> f1_abfq (g_abfG x_abfH))
                     `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0] <[GHC.Types.Char]>_N)
                             :: Control.Lens.Type.Prism' [GHC.Types.Char] ()
                                ~R# Control.Lens.Empty.AsEmpty [GHC.Types.Char])
              TyArg Data.Functor.Const.Const GHC.Base.String
              ValArg Data.Functor.Contravariant.$fContravariantConst
                       @[GHC.Types.Char]
              ValArg Data.Functor.Const.$fFunctorConst @[GHC.Types.Char]
    After:  (\ (@(f_abdr :: * -> *))
               ($dCons_abds
                  :: Control.Lens.Cons.Cons
                       Data.Text.Internal.Text
                       Data.Text.Internal.Text
                       GHC.Types.Char
                       GHC.Types.Char)
               ($dCons1_abdt
                  :: Control.Lens.Cons.Cons
                       GHC.Base.String GHC.Base.String GHC.Types.Char GHC.Types.Char)
               ($dAsEmpty_abdu :: Control.Lens.Empty.AsEmpty GHC.Base.String)
               ($dContravariant_abdv
                  :: Data.Functor.Contravariant.Contravariant f_abdr)
               ($dFunctor_abdw :: GHC.Base.Functor f_abdr) ->
               Data.Profunctor.Unsafe.$fProfunctorFUN_$cdimap
                 @Data.Text.Internal.Text
                 @GHC.Base.String
                 @(f_abdr GHC.Base.String)
                 @(f_abdr Data.Text.Internal.Text)
                 Data.Text.Show.unpack
                 (GHC.Base.fmap
                    @f_abdr
                    $dFunctor_abdw
                    @GHC.Base.String
                    @Data.Text.Internal.Text
                    Data.Text.Internal.pack))
              @(Data.Functor.Const.Const GHC.Base.String)
              ((\ (@(p_abgP :: * -> * -> *))
                  (@(f_abgQ :: * -> *))
                  ($dChoice_abgR :: Data.Profunctor.Choice.Choice p_abgP)
                  ($dApplicative_abgS :: GHC.Base.Applicative f_abgQ) ->
                  let {
                    f1_abgT
                      :: p_abgP
                           (Data.Either.Either
                              Data.Text.Internal.Text (GHC.Types.Char, Data.Text.Internal.Text))
                           (Data.Either.Either
                              Data.Text.Internal.Text
                              (f_abgQ (GHC.Types.Char, Data.Text.Internal.Text)))
                         -> p_abgP Data.Text.Internal.Text (f_abgQ Data.Text.Internal.Text)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 340 0}]
                    f1_abgT
                      = Data.Profunctor.Unsafe.dimap
                          @p_abgP
                          (Data.Profunctor.Choice.$p1Choice @p_abgP $dChoice_abgR)
                          @Data.Text.Internal.Text
                          @(Data.Either.Either
                              Data.Text.Internal.Text (GHC.Types.Char, Data.Text.Internal.Text))
                          @(Data.Either.Either
                              Data.Text.Internal.Text
                              (f_abgQ (GHC.Types.Char, Data.Text.Internal.Text)))
                          @(f_abgQ Data.Text.Internal.Text)
                          (\ (s1_abgU :: Data.Text.Internal.Text) ->
                             case Data.Text.uncons s1_abgU of {
                               GHC.Maybe.Nothing ->
                                 Data.Either.Left
                                   @Data.Text.Internal.Text
                                   @(GHC.Types.Char, Data.Text.Internal.Text)
                                   s1_abgU;
                               GHC.Maybe.Just x_abgX ->
                                 Data.Either.Right
                                   @Data.Text.Internal.Text
                                   @(GHC.Types.Char, Data.Text.Internal.Text)
                                   x_abgX
                             })
                          (let {
                             f2_abgZ
                               :: Data.Text.Internal.Text -> f_abgQ Data.Text.Internal.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abgZ
                               = GHC.Base.pure
                                   @f_abgQ $dApplicative_abgS @Data.Text.Internal.Text } in
                           let {
                             ds2_abh0
                               :: f_abgQ (GHC.Types.Char, Data.Text.Internal.Text)
                                  -> f_abgQ Data.Text.Internal.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 100 0}]
                             ds2_abh0
                               = GHC.Base.fmap
                                   @f_abgQ
                                   (GHC.Base.$p1Applicative @f_abgQ $dApplicative_abgS)
                                   @(GHC.Types.Char, Data.Text.Internal.Text)
                                   @Data.Text.Internal.Text
                                   (\ (p1_abh1 :: (GHC.Types.Char, Data.Text.Internal.Text)) ->
                                      case p1_abh1 of { (x_abh3, ds_abh4) ->
                                      Data.Text.cons x_abh3 ds_abh4
                                      }) } in
                           \ (ds3_abh6
                                :: Data.Either.Either
                                     Data.Text.Internal.Text
                                     (f_abgQ (GHC.Types.Char, Data.Text.Internal.Text))) ->
                             case ds3_abh6 of {
                               Data.Either.Left x_abh8 -> f2_abgZ x_abh8;
                               Data.Either.Right y_abha -> ds2_abh0 y_abha
                             }) } in
                  let {
                    g_abhc
                      :: p_abgP
                           (GHC.Types.Char, Data.Text.Internal.Text)
                           (f_abgQ (GHC.Types.Char, Data.Text.Internal.Text))
                         -> p_abgP
                              (Data.Either.Either
                                 Data.Text.Internal.Text (GHC.Types.Char, Data.Text.Internal.Text))
                              (Data.Either.Either
                                 Data.Text.Internal.Text
                                 (f_abgQ (GHC.Types.Char, Data.Text.Internal.Text)))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abhc
                      = Data.Profunctor.Choice.right'
                          @p_abgP
                          $dChoice_abgR
                          @(GHC.Types.Char, Data.Text.Internal.Text)
                          @(f_abgQ (GHC.Types.Char, Data.Text.Internal.Text))
                          @Data.Text.Internal.Text } in
                  \ (x_abhd
                       :: p_abgP
                            (GHC.Types.Char, Data.Text.Internal.Text)
                            (f_abgQ (GHC.Types.Char, Data.Text.Internal.Text))) ->
                    f1_abgT (g_abhc x_abhd))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <Data.Text.Internal.Text>_N
                                <Data.Text.Internal.Text>_N
                                <GHC.Types.Char>_N
                                <GHC.Types.Char>_N)
                       :: Control.Lens.Type.Prism
                            Data.Text.Internal.Text
                            Data.Text.Internal.Text
                            (GHC.Types.Char, Data.Text.Internal.Text)
                            (GHC.Types.Char, Data.Text.Internal.Text)
                          ~R# Control.Lens.Cons.Cons
                                Data.Text.Internal.Text
                                Data.Text.Internal.Text
                                GHC.Types.Char
                                GHC.Types.Char))
              ((\ (@(p_abeP :: * -> * -> *))
                  (@(f_abeQ :: * -> *))
                  ($dChoice_abeR :: Data.Profunctor.Choice.Choice p_abeP)
                  ($dApplicative_abeS :: GHC.Base.Applicative f_abeQ) ->
                  let {
                    f1_abeT
                      :: p_abeP
                           (Data.Either.Either
                              [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                           (Data.Either.Either
                              [GHC.Types.Char] (f_abeQ (GHC.Types.Char, [GHC.Types.Char])))
                         -> p_abeP [GHC.Types.Char] (f_abeQ [GHC.Types.Char])
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 320 0}]
                    f1_abeT
                      = Data.Profunctor.Unsafe.dimap
                          @p_abeP
                          (Data.Profunctor.Choice.$p1Choice @p_abeP $dChoice_abeR)
                          @[GHC.Types.Char]
                          @(Data.Either.Either
                              [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                          @(Data.Either.Either
                              [GHC.Types.Char] (f_abeQ (GHC.Types.Char, [GHC.Types.Char])))
                          @(f_abeQ [GHC.Types.Char])
                          (\ (aas_abeU :: [GHC.Types.Char]) ->
                             case aas_abeU of {
                               [] ->
                                 Data.Either.Left
                                   @[GHC.Types.Char]
                                   @(GHC.Types.Char, [GHC.Types.Char])
                                   (GHC.Types.[] @GHC.Types.Char);
                               : a1_abeW as_abeX ->
                                 Data.Either.Right
                                   @[GHC.Types.Char]
                                   @(GHC.Types.Char, [GHC.Types.Char])
                                   (a1_abeW, as_abeX)
                             })
                          (let {
                             f2_abeZ :: [GHC.Types.Char] -> f_abeQ [GHC.Types.Char]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abeZ
                               = GHC.Base.pure @f_abeQ $dApplicative_abeS @[GHC.Types.Char] } in
                           let {
                             ds2_abf0
                               :: f_abeQ (GHC.Types.Char, [GHC.Types.Char])
                                  -> f_abeQ [GHC.Types.Char]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 90 0}]
                             ds2_abf0
                               = GHC.Base.fmap
                                   @f_abeQ
                                   (GHC.Base.$p1Applicative @f_abeQ $dApplicative_abeS)
                                   @(GHC.Types.Char, [GHC.Types.Char])
                                   @[GHC.Types.Char]
                                   (\ (p1_abf1 :: (GHC.Types.Char, [GHC.Types.Char])) ->
                                      GHC.Types.:
                                        @GHC.Types.Char
                                        (case p1_abf1 of { (x_abf3, ds_abf4) -> x_abf3 })
                                        (case p1_abf1 of { (ds_abf7, y_abf8) -> y_abf8 })) } in
                           \ (ds3_abfa
                                :: Data.Either.Either
                                     [GHC.Types.Char]
                                     (f_abeQ (GHC.Types.Char, [GHC.Types.Char]))) ->
                             case ds3_abfa of {
                               Data.Either.Left x_abfc -> f2_abeZ x_abfc;
                               Data.Either.Right y_abfe -> ds2_abf0 y_abfe
                             }) } in
                  let {
                    g_abfg
                      :: p_abeP
                           (GHC.Types.Char, [GHC.Types.Char])
                           (f_abeQ (GHC.Types.Char, [GHC.Types.Char]))
                         -> p_abeP
                              (Data.Either.Either
                                 [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                              (Data.Either.Either
                                 [GHC.Types.Char] (f_abeQ (GHC.Types.Char, [GHC.Types.Char])))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abfg
                      = Data.Profunctor.Choice.right'
                          @p_abeP
                          $dChoice_abeR
                          @(GHC.Types.Char, [GHC.Types.Char])
                          @(f_abeQ (GHC.Types.Char, [GHC.Types.Char]))
                          @[GHC.Types.Char] } in
                  \ (x_abfh
                       :: p_abeP
                            (GHC.Types.Char, [GHC.Types.Char])
                            (f_abeQ (GHC.Types.Char, [GHC.Types.Char]))) ->
                    f1_abeT (g_abfg x_abfh))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <[GHC.Types.Char]>_N
                                <[GHC.Types.Char]>_N
                                <GHC.Types.Char>_N
                                <GHC.Types.Char>_N)
                       :: Control.Lens.Type.Prism
                            [GHC.Types.Char]
                            [GHC.Types.Char]
                            (GHC.Types.Char, [GHC.Types.Char])
                            (GHC.Types.Char, [GHC.Types.Char])
                          ~R# Control.Lens.Cons.Cons
                                [GHC.Types.Char] [GHC.Types.Char] GHC.Types.Char GHC.Types.Char))
              ((\ (@(p_abfm :: * -> * -> *))
                  (@(f_abfn :: * -> *))
                  ($dChoice_abfo :: Data.Profunctor.Choice.Choice p_abfm)
                  ($dApplicative_abfp :: GHC.Base.Applicative f_abfn) ->
                  let {
                    f1_abfq
                      :: p_abfm
                           (Data.Either.Either [GHC.Types.Char] ())
                           (Data.Either.Either [GHC.Types.Char] (f_abfn ()))
                         -> p_abfm [GHC.Types.Char] (f_abfn [GHC.Types.Char])
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 290 0}]
                    f1_abfq
                      = Data.Profunctor.Unsafe.dimap
                          @p_abfm
                          (Data.Profunctor.Choice.$p1Choice @p_abfm $dChoice_abfo)
                          @[GHC.Types.Char]
                          @(Data.Either.Either [GHC.Types.Char] ())
                          @(Data.Either.Either [GHC.Types.Char] (f_abfn ()))
                          @(f_abfn [GHC.Types.Char])
                          (\ (s_abfr :: [GHC.Types.Char]) ->
                             case s_abfr of wild_abfs {
                               [] -> Data.Either.Right @[GHC.Types.Char] @() GHC.Tuple.Prim.();
                               : ds1_abft ds2_abfu ->
                                 Data.Either.Left @[GHC.Types.Char] @() wild_abfs
                             })
                          (let {
                             f2_abfw :: [GHC.Types.Char] -> f_abfn [GHC.Types.Char]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abfw
                               = GHC.Base.pure @f_abfn $dApplicative_abfp @[GHC.Types.Char] } in
                           let {
                             ds2_abfx :: f_abfn () -> f_abfn [GHC.Types.Char]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 70 0}]
                             ds2_abfx
                               = GHC.Base.fmap
                                   @f_abfn
                                   (GHC.Base.$p1Applicative @f_abfn $dApplicative_abfp)
                                   @()
                                   @[GHC.Types.Char]
                                   (\ (ds3_abfy :: ()) ->
                                      case ds3_abfy of { () -> GHC.Types.[] @GHC.Types.Char }) } in
                           \ (ds3_abfA :: Data.Either.Either [GHC.Types.Char] (f_abfn ())) ->
                             case ds3_abfA of {
                               Data.Either.Left x_abfC -> f2_abfw x_abfC;
                               Data.Either.Right y_abfE -> ds2_abfx y_abfE
                             }) } in
                  let {
                    g_abfG
                      :: p_abfm () (f_abfn ())
                         -> p_abfm
                              (Data.Either.Either [GHC.Types.Char] ())
                              (Data.Either.Either [GHC.Types.Char] (f_abfn ()))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abfG
                      = Data.Profunctor.Choice.right'
                          @p_abfm $dChoice_abfo @() @(f_abfn ()) @[GHC.Types.Char] } in
                  \ (x_abfH :: p_abfm () (f_abfn ())) -> f1_abfq (g_abfG x_abfH))
               `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0] <[GHC.Types.Char]>_N)
                       :: Control.Lens.Type.Prism' [GHC.Types.Char] ()
                          ~R# Control.Lens.Empty.AsEmpty [GHC.Types.Char]))
              (Data.Functor.Contravariant.$fContravariantConst @[GHC.Types.Char])
              (Data.Functor.Const.$fFunctorConst @[GHC.Types.Char])
    Cont:   ApplyToVal nodup hole Control.Lens.Getter.Getting
                                    GHC.Base.String Data.Text.Internal.Text GHC.Base.String
              ((\ (ds_abdj [Occ=Once1] :: a_abdg) -> ds_abdj)
               `cast` (<a_abdg>_R
                       %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                          <*>_N <a_abdg>_R <a_abdg>_P)
                       :: (a_abdg -> a_abdg)
                          ~R# (a_abdg -> Data.Functor.Const.Const a_abdg a_abdg)))
            ApplyToVal nodup hole Data.Text.Internal.Text
                                  -> Data.Functor.Const.Const
                                       GHC.Base.String Data.Text.Internal.Text
              (Control.Lens.Getter.view
                 @[GHC.Types.Char]
                 @((->) GHC.Base.String)
                 @Data.Text.Internal.Text
                 (Control.Monad.Reader.Class.$fMonadReaderrFUN @[GHC.Types.Char])
                 (Control.Lens.Cons.Extras.recons
                    @[GHC.Types.Char]
                    @GHC.Types.Char
                    @Data.Text.Internal.Text
                    (Control.Lens.Cons.$fConsListListab
                       @GHC.Types.Char @GHC.Types.Char)
                    Control.Lens.Cons.$fConsTextTextCharChar0
                    Control.Lens.Empty.$fAsEmptyText0
                    @(Data.Functor.Const.Const Data.Text.Internal.Text)
                    (Data.Functor.Contravariant.$fContravariantConst
                       @Data.Text.Internal.Text)
                    (Data.Functor.Const.$fFunctorConst @Data.Text.Internal.Text))
                 s_a8Oc)
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N <GHC.Base.String>_R <Data.Text.Internal.Text>_P
                    :: Data.Functor.Const.Const GHC.Base.String Data.Text.Internal.Text
                       ~R# GHC.Base.String)
            Stop[RuleArgCtxt] GHC.Base.String
Rule fired
    Rule: Class op fmap
    Module: (BUILTIN)
    Before: GHC.Base.fmap
              TyArg Data.Functor.Const.Const GHC.Base.String
              ValArg Data.Functor.Const.$fFunctorConst @[GHC.Types.Char]
    After:  (Data.Functor.Const.$fFunctorConst2 @[GHC.Types.Char])
            `cast` (forall (a :: <*>_N) (b :: <*>_N).
                    <a -> b>_R
                    %<'GHC.Types.Many>_N ->_R <Data.Functor.Const.Const
                                                 [GHC.Types.Char] a>_R
                    %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                  <*>_N <[GHC.Types.Char]>_R <a>_P
                                              ; Sym (Data.Functor.Const.N:Const[0]
                                                         <*>_N <[GHC.Types.Char]>_R <b>_P)
                    :: (forall {a} {b}.
                        (a -> b)
                        -> Data.Functor.Const.Const [GHC.Types.Char] a
                        -> Data.Functor.Const.Const [GHC.Types.Char] a)
                       ~R# (forall {a} {b}.
                            (a -> b)
                            -> Data.Functor.Const.Const [GHC.Types.Char] a
                            -> Data.Functor.Const.Const [GHC.Types.Char] b))
    Cont:   ApplyToTy GHC.Base.String
            ApplyToTy Data.Text.Internal.Text
            ApplyToVal nodup hole (GHC.Base.String -> Data.Text.Internal.Text)
                                  -> Data.Functor.Const.Const GHC.Base.String GHC.Base.String
                                  -> Data.Functor.Const.Const
                                       GHC.Base.String Data.Text.Internal.Text
              Data.Text.Internal.pack
            ApplyToVal nodup hole Data.Functor.Const.Const
                                    GHC.Base.String GHC.Base.String
                                  -> Data.Functor.Const.Const
                                       GHC.Base.String Data.Text.Internal.Text
              (bc_abny (ab_abnw x_abnz))
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N <GHC.Base.String>_R <Data.Text.Internal.Text>_P
                    :: Data.Functor.Const.Const GHC.Base.String Data.Text.Internal.Text
                       ~R# GHC.Base.String)
            Stop[RuleArgCtxt] GHC.Base.String
Rule fired
    Rule: Class op reader
    Module: (BUILTIN)
    Before: Control.Monad.Reader.Class.reader
              TyArg [GHC.Types.Char]
              TyArg (->) GHC.Base.String
              ValArg Control.Monad.Reader.Class.$fMonadReaderrFUN
                       @[GHC.Types.Char]
    After:  \ (@a_abdo) -> GHC.Base.id @([GHC.Types.Char] -> a_abdo)
    Cont:   ApplyToTy Data.Text.Internal.Text
            ApplyToVal nodup hole ([GHC.Types.Char] -> Data.Text.Internal.Text)
                                  -> GHC.Base.String -> Data.Text.Internal.Text
              ((l_abdi
                  ((\ (ds_abdj [Occ=Once1] :: a_abdg) -> ds_abdj)
                   `cast` (<a_abdg>_R
                           %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                              <*>_N <a_abdg>_R <a_abdg>_P)
                           :: (a_abdg -> a_abdg)
                              ~R# (a_abdg -> Data.Functor.Const.Const a_abdg a_abdg))))
               `cast` (<s_abde>_R
                       %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                     <*>_N <a_abdg>_R <s_abde>_P
                       :: (s_abde -> Data.Functor.Const.Const a_abdg s_abde)
                          ~R# (s_abde -> a_abdg)))
            ApplyToVal nodup hole GHC.Base.String -> Data.Text.Internal.Text
              s_a8Oc
            Stop[RuleArgCtxt, !P(L,L,L)] Data.Text.Internal.Text
Rule fired
    Rule: recons/string-text
    Module: (Control.Lens.Cons.Extras)
    Before: Control.Lens.Cons.Extras.recons
              TyArg [GHC.Types.Char]
              TyArg GHC.Types.Char
              TyArg Data.Text.Internal.Text
              ValArg (\ (@(p_abeP :: * -> * -> *))
                        (@(f_abeQ :: * -> *))
                        ($dChoice_abeR :: Data.Profunctor.Choice.Choice p_abeP)
                        ($dApplicative_abeS :: GHC.Base.Applicative f_abeQ) ->
                        let {
                          f1_abeT
                            :: p_abeP
                                 (Data.Either.Either
                                    [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                                 (Data.Either.Either
                                    [GHC.Types.Char] (f_abeQ (GHC.Types.Char, [GHC.Types.Char])))
                               -> p_abeP [GHC.Types.Char] (f_abeQ [GHC.Types.Char])
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 320 0}]
                          f1_abeT
                            = Data.Profunctor.Unsafe.dimap
                                @p_abeP
                                (Data.Profunctor.Choice.$p1Choice @p_abeP $dChoice_abeR)
                                @[GHC.Types.Char]
                                @(Data.Either.Either
                                    [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                                @(Data.Either.Either
                                    [GHC.Types.Char] (f_abeQ (GHC.Types.Char, [GHC.Types.Char])))
                                @(f_abeQ [GHC.Types.Char])
                                (\ (aas_abeU :: [GHC.Types.Char]) ->
                                   case aas_abeU of {
                                     [] ->
                                       Data.Either.Left
                                         @[GHC.Types.Char]
                                         @(GHC.Types.Char, [GHC.Types.Char])
                                         (GHC.Types.[] @GHC.Types.Char);
                                     : a1_abeW as_abeX ->
                                       Data.Either.Right
                                         @[GHC.Types.Char]
                                         @(GHC.Types.Char, [GHC.Types.Char])
                                         (a1_abeW, as_abeX)
                                   })
                                (let {
                                   f2_abeZ :: [GHC.Types.Char] -> f_abeQ [GHC.Types.Char]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abeZ
                                     = GHC.Base.pure
                                         @f_abeQ $dApplicative_abeS @[GHC.Types.Char] } in
                                 let {
                                   ds2_abf0
                                     :: f_abeQ (GHC.Types.Char, [GHC.Types.Char])
                                        -> f_abeQ [GHC.Types.Char]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 90 0}]
                                   ds2_abf0
                                     = GHC.Base.fmap
                                         @f_abeQ
                                         (GHC.Base.$p1Applicative @f_abeQ $dApplicative_abeS)
                                         @(GHC.Types.Char, [GHC.Types.Char])
                                         @[GHC.Types.Char]
                                         (\ (p1_abf1 :: (GHC.Types.Char, [GHC.Types.Char])) ->
                                            GHC.Types.:
                                              @GHC.Types.Char
                                              (case p1_abf1 of { (x_abf3, ds_abf4) -> x_abf3 })
                                              (case p1_abf1 of { (ds_abf7, y_abf8) ->
                                               y_abf8
                                               })) } in
                                 \ (ds3_abfa
                                      :: Data.Either.Either
                                           [GHC.Types.Char]
                                           (f_abeQ (GHC.Types.Char, [GHC.Types.Char]))) ->
                                   case ds3_abfa of {
                                     Data.Either.Left x_abfc -> f2_abeZ x_abfc;
                                     Data.Either.Right y_abfe -> ds2_abf0 y_abfe
                                   }) } in
                        let {
                          g_abfg
                            :: p_abeP
                                 (GHC.Types.Char, [GHC.Types.Char])
                                 (f_abeQ (GHC.Types.Char, [GHC.Types.Char]))
                               -> p_abeP
                                    (Data.Either.Either
                                       [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                                    (Data.Either.Either
                                       [GHC.Types.Char] (f_abeQ (GHC.Types.Char, [GHC.Types.Char])))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abfg
                            = Data.Profunctor.Choice.right'
                                @p_abeP
                                $dChoice_abeR
                                @(GHC.Types.Char, [GHC.Types.Char])
                                @(f_abeQ (GHC.Types.Char, [GHC.Types.Char]))
                                @[GHC.Types.Char] } in
                        \ (x_abfh
                             :: p_abeP
                                  (GHC.Types.Char, [GHC.Types.Char])
                                  (f_abeQ (GHC.Types.Char, [GHC.Types.Char]))) ->
                          f1_abeT (g_abfg x_abfh))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <[GHC.Types.Char]>_N
                                      <[GHC.Types.Char]>_N
                                      <GHC.Types.Char>_N
                                      <GHC.Types.Char>_N)
                             :: Control.Lens.Type.Prism
                                  [GHC.Types.Char]
                                  [GHC.Types.Char]
                                  (GHC.Types.Char, [GHC.Types.Char])
                                  (GHC.Types.Char, [GHC.Types.Char])
                                ~R# Control.Lens.Cons.Cons
                                      [GHC.Types.Char]
                                      [GHC.Types.Char]
                                      GHC.Types.Char
                                      GHC.Types.Char)
              ValArg (\ (@(p_abgP :: * -> * -> *))
                        (@(f_abgQ :: * -> *))
                        ($dChoice_abgR :: Data.Profunctor.Choice.Choice p_abgP)
                        ($dApplicative_abgS :: GHC.Base.Applicative f_abgQ) ->
                        let {
                          f1_abgT
                            :: p_abgP
                                 (Data.Either.Either
                                    Data.Text.Internal.Text
                                    (GHC.Types.Char, Data.Text.Internal.Text))
                                 (Data.Either.Either
                                    Data.Text.Internal.Text
                                    (f_abgQ (GHC.Types.Char, Data.Text.Internal.Text)))
                               -> p_abgP Data.Text.Internal.Text (f_abgQ Data.Text.Internal.Text)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 340 0}]
                          f1_abgT
                            = Data.Profunctor.Unsafe.dimap
                                @p_abgP
                                (Data.Profunctor.Choice.$p1Choice @p_abgP $dChoice_abgR)
                                @Data.Text.Internal.Text
                                @(Data.Either.Either
                                    Data.Text.Internal.Text
                                    (GHC.Types.Char, Data.Text.Internal.Text))
                                @(Data.Either.Either
                                    Data.Text.Internal.Text
                                    (f_abgQ (GHC.Types.Char, Data.Text.Internal.Text)))
                                @(f_abgQ Data.Text.Internal.Text)
                                (\ (s1_abgU :: Data.Text.Internal.Text) ->
                                   case Data.Text.uncons s1_abgU of {
                                     GHC.Maybe.Nothing ->
                                       Data.Either.Left
                                         @Data.Text.Internal.Text
                                         @(GHC.Types.Char, Data.Text.Internal.Text)
                                         s1_abgU;
                                     GHC.Maybe.Just x_abgX ->
                                       Data.Either.Right
                                         @Data.Text.Internal.Text
                                         @(GHC.Types.Char, Data.Text.Internal.Text)
                                         x_abgX
                                   })
                                (let {
                                   f2_abgZ
                                     :: Data.Text.Internal.Text -> f_abgQ Data.Text.Internal.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abgZ
                                     = GHC.Base.pure
                                         @f_abgQ $dApplicative_abgS @Data.Text.Internal.Text } in
                                 let {
                                   ds2_abh0
                                     :: f_abgQ (GHC.Types.Char, Data.Text.Internal.Text)
                                        -> f_abgQ Data.Text.Internal.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 100 0}]
                                   ds2_abh0
                                     = GHC.Base.fmap
                                         @f_abgQ
                                         (GHC.Base.$p1Applicative @f_abgQ $dApplicative_abgS)
                                         @(GHC.Types.Char, Data.Text.Internal.Text)
                                         @Data.Text.Internal.Text
                                         (\ (p1_abh1
                                               :: (GHC.Types.Char, Data.Text.Internal.Text)) ->
                                            case p1_abh1 of { (x_abh3, ds_abh4) ->
                                            Data.Text.cons x_abh3 ds_abh4
                                            }) } in
                                 \ (ds3_abh6
                                      :: Data.Either.Either
                                           Data.Text.Internal.Text
                                           (f_abgQ (GHC.Types.Char, Data.Text.Internal.Text))) ->
                                   case ds3_abh6 of {
                                     Data.Either.Left x_abh8 -> f2_abgZ x_abh8;
                                     Data.Either.Right y_abha -> ds2_abh0 y_abha
                                   }) } in
                        let {
                          g_abhc
                            :: p_abgP
                                 (GHC.Types.Char, Data.Text.Internal.Text)
                                 (f_abgQ (GHC.Types.Char, Data.Text.Internal.Text))
                               -> p_abgP
                                    (Data.Either.Either
                                       Data.Text.Internal.Text
                                       (GHC.Types.Char, Data.Text.Internal.Text))
                                    (Data.Either.Either
                                       Data.Text.Internal.Text
                                       (f_abgQ (GHC.Types.Char, Data.Text.Internal.Text)))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abhc
                            = Data.Profunctor.Choice.right'
                                @p_abgP
                                $dChoice_abgR
                                @(GHC.Types.Char, Data.Text.Internal.Text)
                                @(f_abgQ (GHC.Types.Char, Data.Text.Internal.Text))
                                @Data.Text.Internal.Text } in
                        \ (x_abhd
                             :: p_abgP
                                  (GHC.Types.Char, Data.Text.Internal.Text)
                                  (f_abgQ (GHC.Types.Char, Data.Text.Internal.Text))) ->
                          f1_abgT (g_abhc x_abhd))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <Data.Text.Internal.Text>_N
                                      <Data.Text.Internal.Text>_N
                                      <GHC.Types.Char>_N
                                      <GHC.Types.Char>_N)
                             :: Control.Lens.Type.Prism
                                  Data.Text.Internal.Text
                                  Data.Text.Internal.Text
                                  (GHC.Types.Char, Data.Text.Internal.Text)
                                  (GHC.Types.Char, Data.Text.Internal.Text)
                                ~R# Control.Lens.Cons.Cons
                                      Data.Text.Internal.Text
                                      Data.Text.Internal.Text
                                      GHC.Types.Char
                                      GHC.Types.Char)
              ValArg (\ (@(p_abhe :: * -> * -> *))
                        (@(f_abhf :: * -> *))
                        ($dChoice_abhg :: Data.Profunctor.Choice.Choice p_abhe)
                        ($dApplicative_abhh :: GHC.Base.Applicative f_abhf) ->
                        let {
                          f1_abhi
                            :: p_abhe
                                 (Data.Either.Either Data.Text.Internal.Text ())
                                 (Data.Either.Either Data.Text.Internal.Text (f_abhf ()))
                               -> p_abhe Data.Text.Internal.Text (f_abhf Data.Text.Internal.Text)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 310 0}]
                          f1_abhi
                            = Data.Profunctor.Unsafe.dimap
                                @p_abhe
                                (Data.Profunctor.Choice.$p1Choice @p_abhe $dChoice_abhg)
                                @Data.Text.Internal.Text
                                @(Data.Either.Either Data.Text.Internal.Text ())
                                @(Data.Either.Either Data.Text.Internal.Text (f_abhf ()))
                                @(f_abhf Data.Text.Internal.Text)
                                (\ (s_abhj :: Data.Text.Internal.Text) ->
                                   case Data.Text.null s_abhj of {
                                     GHC.Types.False ->
                                       Data.Either.Left @Data.Text.Internal.Text @() s_abhj;
                                     GHC.Types.True ->
                                       Data.Either.Right
                                         @Data.Text.Internal.Text @() GHC.Tuple.Prim.()
                                   })
                                (let {
                                   f2_abhm
                                     :: Data.Text.Internal.Text -> f_abhf Data.Text.Internal.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abhm
                                     = GHC.Base.pure
                                         @f_abhf $dApplicative_abhh @Data.Text.Internal.Text } in
                                 let {
                                   ds2_abhn :: f_abhf () -> f_abhf Data.Text.Internal.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 70 0}]
                                   ds2_abhn
                                     = GHC.Base.fmap
                                         @f_abhf
                                         (GHC.Base.$p1Applicative @f_abhf $dApplicative_abhh)
                                         @()
                                         @Data.Text.Internal.Text
                                         (\ (ds3_abho :: ()) ->
                                            case ds3_abho of { () ->
                                            Data.Text.Internal.empty
                                            }) } in
                                 \ (ds3_abhq
                                      :: Data.Either.Either Data.Text.Internal.Text (f_abhf ())) ->
                                   case ds3_abhq of {
                                     Data.Either.Left x_abhs -> f2_abhm x_abhs;
                                     Data.Either.Right y_abhu -> ds2_abhn y_abhu
                                   }) } in
                        let {
                          g_abhw
                            :: p_abhe () (f_abhf ())
                               -> p_abhe
                                    (Data.Either.Either Data.Text.Internal.Text ())
                                    (Data.Either.Either Data.Text.Internal.Text (f_abhf ()))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abhw
                            = Data.Profunctor.Choice.right'
                                @p_abhe
                                $dChoice_abhg
                                @()
                                @(f_abhf ())
                                @Data.Text.Internal.Text } in
                        \ (x_abhx :: p_abhe () (f_abhf ())) -> f1_abhi (g_abhw x_abhx))
                     `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                      <Data.Text.Internal.Text>_N)
                             :: Control.Lens.Type.Prism' Data.Text.Internal.Text ()
                                ~R# Control.Lens.Empty.AsEmpty Data.Text.Internal.Text)
              TyArg Data.Functor.Const.Const Data.Text.Internal.Text
              ValArg Data.Functor.Contravariant.$fContravariantConst
                       @Data.Text.Internal.Text
              ValArg Data.Functor.Const.$fFunctorConst @Data.Text.Internal.Text
    After:  (\ (@(f_abdN :: * -> *))
               ($dCons_abdO
                  :: Control.Lens.Cons.Cons
                       GHC.Base.String GHC.Base.String GHC.Types.Char GHC.Types.Char)
               ($dCons1_abdP
                  :: Control.Lens.Cons.Cons
                       Data.Text.Internal.Text
                       Data.Text.Internal.Text
                       GHC.Types.Char
                       GHC.Types.Char)
               ($dAsEmpty_abdQ
                  :: Control.Lens.Empty.AsEmpty Data.Text.Internal.Text)
               ($dContravariant_abdR
                  :: Data.Functor.Contravariant.Contravariant f_abdN)
               ($dFunctor_abdS :: GHC.Base.Functor f_abdN) ->
               Data.Profunctor.Unsafe.$fProfunctorFUN_$cdimap
                 @GHC.Base.String
                 @Data.Text.Internal.Text
                 @(f_abdN Data.Text.Internal.Text)
                 @(f_abdN GHC.Base.String)
                 Data.Text.Internal.pack
                 (GHC.Base.fmap
                    @f_abdN
                    $dFunctor_abdS
                    @Data.Text.Internal.Text
                    @GHC.Base.String
                    Data.Text.Show.unpack))
              @(Data.Functor.Const.Const Data.Text.Internal.Text)
              ((\ (@(p_abeP :: * -> * -> *))
                  (@(f_abeQ :: * -> *))
                  ($dChoice_abeR :: Data.Profunctor.Choice.Choice p_abeP)
                  ($dApplicative_abeS :: GHC.Base.Applicative f_abeQ) ->
                  let {
                    f1_abeT
                      :: p_abeP
                           (Data.Either.Either
                              [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                           (Data.Either.Either
                              [GHC.Types.Char] (f_abeQ (GHC.Types.Char, [GHC.Types.Char])))
                         -> p_abeP [GHC.Types.Char] (f_abeQ [GHC.Types.Char])
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 320 0}]
                    f1_abeT
                      = Data.Profunctor.Unsafe.dimap
                          @p_abeP
                          (Data.Profunctor.Choice.$p1Choice @p_abeP $dChoice_abeR)
                          @[GHC.Types.Char]
                          @(Data.Either.Either
                              [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                          @(Data.Either.Either
                              [GHC.Types.Char] (f_abeQ (GHC.Types.Char, [GHC.Types.Char])))
                          @(f_abeQ [GHC.Types.Char])
                          (\ (aas_abeU :: [GHC.Types.Char]) ->
                             case aas_abeU of {
                               [] ->
                                 Data.Either.Left
                                   @[GHC.Types.Char]
                                   @(GHC.Types.Char, [GHC.Types.Char])
                                   (GHC.Types.[] @GHC.Types.Char);
                               : a1_abeW as_abeX ->
                                 Data.Either.Right
                                   @[GHC.Types.Char]
                                   @(GHC.Types.Char, [GHC.Types.Char])
                                   (a1_abeW, as_abeX)
                             })
                          (let {
                             f2_abeZ :: [GHC.Types.Char] -> f_abeQ [GHC.Types.Char]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abeZ
                               = GHC.Base.pure @f_abeQ $dApplicative_abeS @[GHC.Types.Char] } in
                           let {
                             ds2_abf0
                               :: f_abeQ (GHC.Types.Char, [GHC.Types.Char])
                                  -> f_abeQ [GHC.Types.Char]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 90 0}]
                             ds2_abf0
                               = GHC.Base.fmap
                                   @f_abeQ
                                   (GHC.Base.$p1Applicative @f_abeQ $dApplicative_abeS)
                                   @(GHC.Types.Char, [GHC.Types.Char])
                                   @[GHC.Types.Char]
                                   (\ (p1_abf1 :: (GHC.Types.Char, [GHC.Types.Char])) ->
                                      GHC.Types.:
                                        @GHC.Types.Char
                                        (case p1_abf1 of { (x_abf3, ds_abf4) -> x_abf3 })
                                        (case p1_abf1 of { (ds_abf7, y_abf8) -> y_abf8 })) } in
                           \ (ds3_abfa
                                :: Data.Either.Either
                                     [GHC.Types.Char]
                                     (f_abeQ (GHC.Types.Char, [GHC.Types.Char]))) ->
                             case ds3_abfa of {
                               Data.Either.Left x_abfc -> f2_abeZ x_abfc;
                               Data.Either.Right y_abfe -> ds2_abf0 y_abfe
                             }) } in
                  let {
                    g_abfg
                      :: p_abeP
                           (GHC.Types.Char, [GHC.Types.Char])
                           (f_abeQ (GHC.Types.Char, [GHC.Types.Char]))
                         -> p_abeP
                              (Data.Either.Either
                                 [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                              (Data.Either.Either
                                 [GHC.Types.Char] (f_abeQ (GHC.Types.Char, [GHC.Types.Char])))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abfg
                      = Data.Profunctor.Choice.right'
                          @p_abeP
                          $dChoice_abeR
                          @(GHC.Types.Char, [GHC.Types.Char])
                          @(f_abeQ (GHC.Types.Char, [GHC.Types.Char]))
                          @[GHC.Types.Char] } in
                  \ (x_abfh
                       :: p_abeP
                            (GHC.Types.Char, [GHC.Types.Char])
                            (f_abeQ (GHC.Types.Char, [GHC.Types.Char]))) ->
                    f1_abeT (g_abfg x_abfh))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <[GHC.Types.Char]>_N
                                <[GHC.Types.Char]>_N
                                <GHC.Types.Char>_N
                                <GHC.Types.Char>_N)
                       :: Control.Lens.Type.Prism
                            [GHC.Types.Char]
                            [GHC.Types.Char]
                            (GHC.Types.Char, [GHC.Types.Char])
                            (GHC.Types.Char, [GHC.Types.Char])
                          ~R# Control.Lens.Cons.Cons
                                [GHC.Types.Char] [GHC.Types.Char] GHC.Types.Char GHC.Types.Char))
              ((\ (@(p_abgP :: * -> * -> *))
                  (@(f_abgQ :: * -> *))
                  ($dChoice_abgR :: Data.Profunctor.Choice.Choice p_abgP)
                  ($dApplicative_abgS :: GHC.Base.Applicative f_abgQ) ->
                  let {
                    f1_abgT
                      :: p_abgP
                           (Data.Either.Either
                              Data.Text.Internal.Text (GHC.Types.Char, Data.Text.Internal.Text))
                           (Data.Either.Either
                              Data.Text.Internal.Text
                              (f_abgQ (GHC.Types.Char, Data.Text.Internal.Text)))
                         -> p_abgP Data.Text.Internal.Text (f_abgQ Data.Text.Internal.Text)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 340 0}]
                    f1_abgT
                      = Data.Profunctor.Unsafe.dimap
                          @p_abgP
                          (Data.Profunctor.Choice.$p1Choice @p_abgP $dChoice_abgR)
                          @Data.Text.Internal.Text
                          @(Data.Either.Either
                              Data.Text.Internal.Text (GHC.Types.Char, Data.Text.Internal.Text))
                          @(Data.Either.Either
                              Data.Text.Internal.Text
                              (f_abgQ (GHC.Types.Char, Data.Text.Internal.Text)))
                          @(f_abgQ Data.Text.Internal.Text)
                          (\ (s1_abgU :: Data.Text.Internal.Text) ->
                             case Data.Text.uncons s1_abgU of {
                               GHC.Maybe.Nothing ->
                                 Data.Either.Left
                                   @Data.Text.Internal.Text
                                   @(GHC.Types.Char, Data.Text.Internal.Text)
                                   s1_abgU;
                               GHC.Maybe.Just x_abgX ->
                                 Data.Either.Right
                                   @Data.Text.Internal.Text
                                   @(GHC.Types.Char, Data.Text.Internal.Text)
                                   x_abgX
                             })
                          (let {
                             f2_abgZ
                               :: Data.Text.Internal.Text -> f_abgQ Data.Text.Internal.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abgZ
                               = GHC.Base.pure
                                   @f_abgQ $dApplicative_abgS @Data.Text.Internal.Text } in
                           let {
                             ds2_abh0
                               :: f_abgQ (GHC.Types.Char, Data.Text.Internal.Text)
                                  -> f_abgQ Data.Text.Internal.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 100 0}]
                             ds2_abh0
                               = GHC.Base.fmap
                                   @f_abgQ
                                   (GHC.Base.$p1Applicative @f_abgQ $dApplicative_abgS)
                                   @(GHC.Types.Char, Data.Text.Internal.Text)
                                   @Data.Text.Internal.Text
                                   (\ (p1_abh1 :: (GHC.Types.Char, Data.Text.Internal.Text)) ->
                                      case p1_abh1 of { (x_abh3, ds_abh4) ->
                                      Data.Text.cons x_abh3 ds_abh4
                                      }) } in
                           \ (ds3_abh6
                                :: Data.Either.Either
                                     Data.Text.Internal.Text
                                     (f_abgQ (GHC.Types.Char, Data.Text.Internal.Text))) ->
                             case ds3_abh6 of {
                               Data.Either.Left x_abh8 -> f2_abgZ x_abh8;
                               Data.Either.Right y_abha -> ds2_abh0 y_abha
                             }) } in
                  let {
                    g_abhc
                      :: p_abgP
                           (GHC.Types.Char, Data.Text.Internal.Text)
                           (f_abgQ (GHC.Types.Char, Data.Text.Internal.Text))
                         -> p_abgP
                              (Data.Either.Either
                                 Data.Text.Internal.Text (GHC.Types.Char, Data.Text.Internal.Text))
                              (Data.Either.Either
                                 Data.Text.Internal.Text
                                 (f_abgQ (GHC.Types.Char, Data.Text.Internal.Text)))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abhc
                      = Data.Profunctor.Choice.right'
                          @p_abgP
                          $dChoice_abgR
                          @(GHC.Types.Char, Data.Text.Internal.Text)
                          @(f_abgQ (GHC.Types.Char, Data.Text.Internal.Text))
                          @Data.Text.Internal.Text } in
                  \ (x_abhd
                       :: p_abgP
                            (GHC.Types.Char, Data.Text.Internal.Text)
                            (f_abgQ (GHC.Types.Char, Data.Text.Internal.Text))) ->
                    f1_abgT (g_abhc x_abhd))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <Data.Text.Internal.Text>_N
                                <Data.Text.Internal.Text>_N
                                <GHC.Types.Char>_N
                                <GHC.Types.Char>_N)
                       :: Control.Lens.Type.Prism
                            Data.Text.Internal.Text
                            Data.Text.Internal.Text
                            (GHC.Types.Char, Data.Text.Internal.Text)
                            (GHC.Types.Char, Data.Text.Internal.Text)
                          ~R# Control.Lens.Cons.Cons
                                Data.Text.Internal.Text
                                Data.Text.Internal.Text
                                GHC.Types.Char
                                GHC.Types.Char))
              ((\ (@(p_abhe :: * -> * -> *))
                  (@(f_abhf :: * -> *))
                  ($dChoice_abhg :: Data.Profunctor.Choice.Choice p_abhe)
                  ($dApplicative_abhh :: GHC.Base.Applicative f_abhf) ->
                  let {
                    f1_abhi
                      :: p_abhe
                           (Data.Either.Either Data.Text.Internal.Text ())
                           (Data.Either.Either Data.Text.Internal.Text (f_abhf ()))
                         -> p_abhe Data.Text.Internal.Text (f_abhf Data.Text.Internal.Text)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 310 0}]
                    f1_abhi
                      = Data.Profunctor.Unsafe.dimap
                          @p_abhe
                          (Data.Profunctor.Choice.$p1Choice @p_abhe $dChoice_abhg)
                          @Data.Text.Internal.Text
                          @(Data.Either.Either Data.Text.Internal.Text ())
                          @(Data.Either.Either Data.Text.Internal.Text (f_abhf ()))
                          @(f_abhf Data.Text.Internal.Text)
                          (\ (s_abhj :: Data.Text.Internal.Text) ->
                             case Data.Text.null s_abhj of {
                               GHC.Types.False ->
                                 Data.Either.Left @Data.Text.Internal.Text @() s_abhj;
                               GHC.Types.True ->
                                 Data.Either.Right @Data.Text.Internal.Text @() GHC.Tuple.Prim.()
                             })
                          (let {
                             f2_abhm
                               :: Data.Text.Internal.Text -> f_abhf Data.Text.Internal.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abhm
                               = GHC.Base.pure
                                   @f_abhf $dApplicative_abhh @Data.Text.Internal.Text } in
                           let {
                             ds2_abhn :: f_abhf () -> f_abhf Data.Text.Internal.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 70 0}]
                             ds2_abhn
                               = GHC.Base.fmap
                                   @f_abhf
                                   (GHC.Base.$p1Applicative @f_abhf $dApplicative_abhh)
                                   @()
                                   @Data.Text.Internal.Text
                                   (\ (ds3_abho :: ()) ->
                                      case ds3_abho of { () -> Data.Text.Internal.empty }) } in
                           \ (ds3_abhq
                                :: Data.Either.Either Data.Text.Internal.Text (f_abhf ())) ->
                             case ds3_abhq of {
                               Data.Either.Left x_abhs -> f2_abhm x_abhs;
                               Data.Either.Right y_abhu -> ds2_abhn y_abhu
                             }) } in
                  let {
                    g_abhw
                      :: p_abhe () (f_abhf ())
                         -> p_abhe
                              (Data.Either.Either Data.Text.Internal.Text ())
                              (Data.Either.Either Data.Text.Internal.Text (f_abhf ()))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abhw
                      = Data.Profunctor.Choice.right'
                          @p_abhe
                          $dChoice_abhg
                          @()
                          @(f_abhf ())
                          @Data.Text.Internal.Text } in
                  \ (x_abhx :: p_abhe () (f_abhf ())) -> f1_abhi (g_abhw x_abhx))
               `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                <Data.Text.Internal.Text>_N)
                       :: Control.Lens.Type.Prism' Data.Text.Internal.Text ()
                          ~R# Control.Lens.Empty.AsEmpty Data.Text.Internal.Text))
              (Data.Functor.Contravariant.$fContravariantConst
                 @Data.Text.Internal.Text)
              (Data.Functor.Const.$fFunctorConst @Data.Text.Internal.Text)
    Cont:   ApplyToVal nodup hole Control.Lens.Getter.Getting
                                    Data.Text.Internal.Text [GHC.Types.Char] Data.Text.Internal.Text
              ((\ (ds_abdj [Occ=Once1] :: a_abdg) -> ds_abdj)
               `cast` (<a_abdg>_R
                       %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                          <*>_N <a_abdg>_R <a_abdg>_P)
                       :: (a_abdg -> a_abdg)
                          ~R# (a_abdg -> Data.Functor.Const.Const a_abdg a_abdg)))
            ApplyToVal nodup hole [GHC.Types.Char]
                                  -> Data.Functor.Const.Const
                                       Data.Text.Internal.Text [GHC.Types.Char]
              s_a8Oc
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N <Data.Text.Internal.Text>_R <[GHC.Types.Char]>_P
                    :: Data.Functor.Const.Const
                         Data.Text.Internal.Text [GHC.Types.Char]
                       ~R# Data.Text.Internal.Text)
            Stop[RuleArgCtxt, !P(L,L,L)] Data.Text.Internal.Text
Rule fired
    Rule: Class op fmap
    Module: (BUILTIN)
    Before: GHC.Base.fmap
              TyArg Data.Functor.Const.Const Data.Text.Internal.Text
              ValArg Data.Functor.Const.$fFunctorConst @Data.Text.Internal.Text
    After:  (Data.Functor.Const.$fFunctorConst2
               @Data.Text.Internal.Text)
            `cast` (forall (a :: <*>_N) (b :: <*>_N).
                    <a -> b>_R
                    %<'GHC.Types.Many>_N ->_R <Data.Functor.Const.Const
                                                 Data.Text.Internal.Text a>_R
                    %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                  <*>_N <Data.Text.Internal.Text>_R <a>_P
                                              ; Sym (Data.Functor.Const.N:Const[0]
                                                         <*>_N <Data.Text.Internal.Text>_R <b>_P)
                    :: (forall {a} {b}.
                        (a -> b)
                        -> Data.Functor.Const.Const Data.Text.Internal.Text a
                        -> Data.Functor.Const.Const Data.Text.Internal.Text a)
                       ~R# (forall {a} {b}.
                            (a -> b)
                            -> Data.Functor.Const.Const Data.Text.Internal.Text a
                            -> Data.Functor.Const.Const Data.Text.Internal.Text b))
    Cont:   ApplyToTy Data.Text.Internal.Text
            ApplyToTy GHC.Base.String
            ApplyToVal nodup hole (Data.Text.Internal.Text -> GHC.Base.String)
                                  -> Data.Functor.Const.Const
                                       Data.Text.Internal.Text Data.Text.Internal.Text
                                  -> Data.Functor.Const.Const
                                       Data.Text.Internal.Text GHC.Base.String
              Data.Text.Show.unpack
            ApplyToVal nodup hole Data.Functor.Const.Const
                                    Data.Text.Internal.Text Data.Text.Internal.Text
                                  -> Data.Functor.Const.Const
                                       Data.Text.Internal.Text GHC.Base.String
              (bc_abny (ab_abnw x_abnz))
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N <Data.Text.Internal.Text>_R <[GHC.Types.Char]>_P
                    :: Data.Functor.Const.Const
                         Data.Text.Internal.Text [GHC.Types.Char]
                       ~R# Data.Text.Internal.Text)
            Stop[RuleArgCtxt, !P(L,L,L)] Data.Text.Internal.Text
Rule fired
    Rule: eqString
    Module: (GHC.Base)
    Before: GHC.Classes.==
              TyArg GHC.Base.String
              ValArg GHC.Classes.$fEqList_$s$fEqList1
              ValArg Data.Text.Show.unpack (Data.Text.Internal.pack s_a8Oc)
              ValArg s_a8Oc
    After:  (\ ($dEq_aaYU :: GHC.Classes.Eq GHC.Base.String) ->
               GHC.Base.eqString)
              GHC.Classes.$fEqList_$s$fEqList1
              ValArg Data.Text.Show.unpack (Data.Text.Internal.pack s_a8Oc)
              ValArg s_a8Oc
    Cont:   Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: unpack
    Module: (GHC.Base)
    Before: GHC.CString.unpackCString# ValArg "Str -> TL -> Str"#
    After:  (\ (a_ab5Y :: GHC.Prim.Addr#) ->
               GHC.Base.build
                 @GHC.Types.Char
                 (\ (@b_ab5Z) -> GHC.CString.unpackFoldrCString# @b_ab5Z a_ab5Y))
              "Str -> TL -> Str"#
    Cont:   Stop[BoringCtxt] Test.Tasty.Core.TestName
Rule fired
    Rule: Class op property
    Module: (BUILTIN)
    Before: Test.QuickCheck.Property.property
              TyArg GHC.Base.String -> GHC.Types.Bool ValArg $dTestable_a911
    After:  Test.QuickCheck.Property.$fTestableFUN_$cproperty
              @[GHC.Types.Char]
              @GHC.Types.Bool
              $dArbitrary_a9Ip
              GHC.Show.$fShowList_$s$fShowList1
              Test.QuickCheck.Property.$fTestableBool
    Cont:   ApplyToVal nodup hole (GHC.Base.String -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              prop_ab6b
            CastIt (Sym (Test.Tasty.QuickCheck.N:QC[0])
                    :: Test.QuickCheck.Property.Property ~R# Test.Tasty.QuickCheck.QC)
            Stop[BoringCtxt] Test.Tasty.QuickCheck.QC
Rule fired
    Rule: Class op propertyForAllShrinkShow
    Module: (BUILTIN)
    Before: Test.QuickCheck.Property.propertyForAllShrinkShow
              TyArg GHC.Types.Bool ValArg Test.QuickCheck.Property.$fTestableBool
    After:  Test.QuickCheck.Property.$fTestableBool1
            `cast` (forall (a :: <*>_N).
                    <Test.QuickCheck.Gen.Gen a>_R
                    %<'GHC.Types.Many>_N ->_R <a -> [a]>_R
                    %<'GHC.Types.Many>_N ->_R <a -> [GHC.Base.String]>_R
                    %<'GHC.Types.Many>_N ->_R <a -> GHC.Types.Bool>_R
                    %<'GHC.Types.Many>_N ->_R Sym (Test.QuickCheck.Gen.N:Gen[0]
                                                       (Test.QuickCheck.Property.N:Prop[0]))
                                              ; Sym (Test.QuickCheck.Property.N:Property[0])
                    :: (forall {a}.
                        Test.QuickCheck.Gen.Gen a
                        -> (a -> [a])
                        -> (a -> [GHC.Base.String])
                        -> (a -> GHC.Types.Bool)
                        -> Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int
                        -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result)
                       ~R# (forall {a}.
                            Test.QuickCheck.Gen.Gen a
                            -> (a -> [a])
                            -> (a -> [GHC.Base.String])
                            -> (a -> GHC.Types.Bool)
                            -> Test.QuickCheck.Property.Property))
    Cont:   ApplyToTy [GHC.Types.Char]
            ApplyToVal nodup hole Test.QuickCheck.Gen.Gen [GHC.Types.Char]
                                  -> ([GHC.Types.Char] -> [[GHC.Types.Char]])
                                  -> ([GHC.Types.Char] -> [GHC.Base.String])
                                  -> ([GHC.Types.Char] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (Test.QuickCheck.Arbitrary.arbitrary @a_ab7T $dArbitrary_ab7V)
            ApplyToVal nodup hole ([GHC.Types.Char] -> [[GHC.Types.Char]])
                                  -> ([GHC.Types.Char] -> [GHC.Base.String])
                                  -> ([GHC.Types.Char] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (Test.QuickCheck.Arbitrary.shrink @a_ab7T $dArbitrary_ab7V)
            ApplyToVal nodup hole ([GHC.Types.Char] -> [GHC.Base.String])
                                  -> ([GHC.Types.Char] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (let {
                 g_ab7Z [Occ=OnceL1!] :: a_ab7T -> GHC.Base.String
                 [LclId]
                 g_ab7Z = GHC.Show.show @a_ab7T $dShow_ab7W } in
               \ (x_ab80 [Occ=Once1] :: a_ab7T) ->
                 GHC.Types.:
                   @GHC.Base.String (g_ab7Z x_ab80) (GHC.Types.[] @GHC.Base.String))
            ApplyToVal nodup hole ([GHC.Types.Char] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              f_ab7Y
            CastIt (Sym (Test.Tasty.QuickCheck.N:QC[0])
                    :: Test.QuickCheck.Property.Property ~R# Test.Tasty.QuickCheck.QC)
            Stop[BoringCtxt] Test.Tasty.QuickCheck.QC
Rule fired
    Rule: Class op arbitrary
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.arbitrary
              TyArg [GHC.Types.Char] ValArg $dArbitrary_a9Ip
    After:  (Test.QuickCheck.Arbitrary.$fArbitraryList1
               @GHC.Types.Char Test.QuickCheck.Arbitrary.$fArbitraryChar)
            `cast` (Sym (Test.QuickCheck.Gen.N:Gen[0] <[GHC.Types.Char]>_R)
                    :: (Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int -> [GHC.Types.Char])
                       ~R# Test.QuickCheck.Gen.Gen [GHC.Types.Char])
    Cont:   Stop[BoringCtxt] Test.QuickCheck.Gen.Gen [GHC.Types.Char]
Rule fired
    Rule: Class op arbitrary
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.arbitrary
              TyArg GHC.Types.Char
              ValArg Test.QuickCheck.Arbitrary.$fArbitraryChar
    After:  Test.QuickCheck.Arbitrary.$fArbitraryChar_$carbitrary
    Cont:   Stop[BoringCtxt, C(S,C(1,L))] Test.QuickCheck.Gen.Gen
                                            GHC.Types.Char
Rule fired
    Rule: Class op shrink
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.shrink
              TyArg [GHC.Types.Char] ValArg $dArbitrary_a9Ip
    After:  Test.QuickCheck.Arbitrary.$fArbitraryList_$cshrink
              @GHC.Types.Char Test.QuickCheck.Arbitrary.$fArbitraryChar
    Cont:   Stop[BoringCtxt] [GHC.Types.Char] -> [[GHC.Types.Char]]
Rule fired
    Rule: Class op shrink
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.shrink
              TyArg GHC.Types.Char
              ValArg Test.QuickCheck.Arbitrary.$fArbitraryChar
    After:  Test.QuickCheck.Arbitrary.$fArbitraryChar_$cshrink
    Cont:   Stop[DiscArgCtxt, C(S,L)] GHC.Types.Char
                                      -> [GHC.Types.Char]
Rule fired
    Rule: Class op show
    Module: (BUILTIN)
    Before: GHC.Show.show
              TyArg [GHC.Types.Char] ValArg GHC.Show.$fShowList_$s$fShowList1
    After:  GHC.Show.$fShowList_$s$cshow1
    Cont:   Stop[RhsCtxt(NonRecursive)] [GHC.Types.Char]
                                        -> GHC.Base.String
Rule fired
    Rule: Class op reader
    Module: (BUILTIN)
    Before: Control.Monad.Reader.Class.reader
              TyArg Data.Text.Internal.Lazy.Text
              TyArg (->) Data.Text.Internal.Lazy.Text
              ValArg Control.Monad.Reader.Class.$fMonadReaderrFUN
                       @Data.Text.Internal.Lazy.Text
    After:  \ (@a_abdo) ->
              GHC.Base.id @(Data.Text.Internal.Lazy.Text -> a_abdo)
    Cont:   ApplyToTy GHC.Base.String
            ApplyToVal nodup hole (Data.Text.Internal.Lazy.Text
                                   -> GHC.Base.String)
                                  -> Data.Text.Internal.Lazy.Text -> GHC.Base.String
              ((l_abdi
                  ((\ (ds_abdj [Occ=Once1] :: a_abdg) -> ds_abdj)
                   `cast` (<a_abdg>_R
                           %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                              <*>_N <a_abdg>_R <a_abdg>_P)
                           :: (a_abdg -> a_abdg)
                              ~R# (a_abdg -> Data.Functor.Const.Const a_abdg a_abdg))))
               `cast` (<s_abde>_R
                       %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                     <*>_N <a_abdg>_R <s_abde>_P
                       :: (s_abde -> Data.Functor.Const.Const a_abdg s_abde)
                          ~R# (s_abde -> a_abdg)))
            ApplyToVal nodup hole Data.Text.Internal.Lazy.Text
                                  -> GHC.Base.String
              (Control.Lens.Getter.view
                 @[GHC.Types.Char]
                 @((->) GHC.Base.String)
                 @Data.Text.Internal.Lazy.Text
                 (Control.Monad.Reader.Class.$fMonadReaderrFUN @[GHC.Types.Char])
                 (Control.Lens.Cons.Extras.recons
                    @[GHC.Types.Char]
                    @GHC.Types.Char
                    @Data.Text.Internal.Lazy.Text
                    (Control.Lens.Cons.$fConsListListab
                       @GHC.Types.Char @GHC.Types.Char)
                    Control.Lens.Cons.$fConsTextTextCharChar
                    Control.Lens.Empty.$fAsEmptyText
                    @(Data.Functor.Const.Const Data.Text.Internal.Lazy.Text)
                    (Data.Functor.Contravariant.$fContravariantConst
                       @Data.Text.Internal.Lazy.Text)
                    (Data.Functor.Const.$fFunctorConst @Data.Text.Internal.Lazy.Text))
                 s_a8Od)
            Stop[RuleArgCtxt] GHC.Base.String
Rule fired
    Rule: recons/lazytext-string
    Module: (Control.Lens.Cons.Extras)
    Before: Control.Lens.Cons.Extras.recons
              TyArg Data.Text.Internal.Lazy.Text
              TyArg GHC.Types.Char
              TyArg GHC.Base.String
              ValArg (\ (@(p_abhE :: * -> * -> *))
                        (@(f_abhF :: * -> *))
                        ($dChoice_abhG :: Data.Profunctor.Choice.Choice p_abhE)
                        ($dApplicative_abhH :: GHC.Base.Applicative f_abhF) ->
                        let {
                          f1_abhI
                            :: p_abhE
                                 (Data.Either.Either
                                    Data.Text.Internal.Lazy.Text
                                    (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                                 (Data.Either.Either
                                    Data.Text.Internal.Lazy.Text
                                    (f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                               -> p_abhE
                                    Data.Text.Internal.Lazy.Text
                                    (f_abhF Data.Text.Internal.Lazy.Text)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 639 0}]
                          f1_abhI
                            = Data.Profunctor.Unsafe.dimap
                                @p_abhE
                                (Data.Profunctor.Choice.$p1Choice @p_abhE $dChoice_abhG)
                                @Data.Text.Internal.Lazy.Text
                                @(Data.Either.Either
                                    Data.Text.Internal.Lazy.Text
                                    (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                                @(Data.Either.Either
                                    Data.Text.Internal.Lazy.Text
                                    (f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                                @(f_abhF Data.Text.Internal.Lazy.Text)
                                (\ (s1_abhJ :: Data.Text.Internal.Lazy.Text) ->
                                   case s1_abhJ of {
                                     Data.Text.Internal.Lazy.Empty ->
                                       Data.Either.Left
                                         @Data.Text.Internal.Lazy.Text
                                         @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                         Data.Text.Internal.Lazy.Empty;
                                     Data.Text.Internal.Lazy.Chunk bx_abhQ bx1_abhR bx2_abhS
                                                                   ts_abhT ->
                                       Data.Either.Right
                                         @Data.Text.Internal.Lazy.Text
                                         @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                         (case GHC.Prim.indexWord8Array# bx_abhQ bx1_abhR of r#_abhV
                                          { __DEFAULT ->
                                          let {
                                            c#_abhW :: GHC.Prim.Int#
                                            [LclId,
                                             Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                     Value=False, ConLike=False, WorkFree=False,
                                                     Expandable=False,
                                                     Guidance=IF_ARGS [] 4 0}]
                                            c#_abhW
                                              = GHC.Prim.word2Int#
                                                  (GHC.Prim.clz8#
                                                     (GHC.Prim.and#
                                                        (GHC.Prim.not#
                                                           (GHC.Prim.word8ToWord# r#_abhV))
                                                        255##)) } in
                                          case GHC.Prim.xorI# c#_abhW (GHC.Prim.<=# c#_abhW 0#) of {
                                            __DEFAULT ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abhQ (GHC.Prim.+# bx1_abhR 1#)
                                              of r#1_abhY
                                              { __DEFAULT ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abhQ (GHC.Prim.+# bx1_abhR 2#)
                                              of r#2_abhZ
                                              { __DEFAULT ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abhQ (GHC.Prim.+# bx1_abhR 3#)
                                              of r#3_abi0
                                              { __DEFAULT ->
                                              GHC.Types.C#
                                                (GHC.Prim.chr#
                                                   (GHC.Prim.-#
                                                      (GHC.Prim.+#
                                                         (GHC.Prim.+#
                                                            (GHC.Prim.+#
                                                               (GHC.Prim.uncheckedIShiftL#
                                                                  (GHC.Prim.-#
                                                                     (GHC.Prim.word2Int#
                                                                        (GHC.Prim.word8ToWord#
                                                                           r#_abhV))
                                                                     240#)
                                                                  18#)
                                                               (GHC.Prim.uncheckedIShiftL#
                                                                  (GHC.Prim.-#
                                                                     (GHC.Prim.word2Int#
                                                                        (GHC.Prim.word8ToWord#
                                                                           r#1_abhY))
                                                                     128#)
                                                                  12#))
                                                            (GHC.Prim.uncheckedIShiftL#
                                                               (GHC.Prim.-#
                                                                  (GHC.Prim.word2Int#
                                                                     (GHC.Prim.word8ToWord#
                                                                        r#2_abhZ))
                                                                  128#)
                                                               6#))
                                                         (GHC.Prim.word2Int#
                                                            (GHC.Prim.word8ToWord# r#3_abi0)))
                                                      128#))
                                              }
                                              }
                                              };
                                            1# ->
                                              GHC.Types.C#
                                                (GHC.Prim.chr#
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.word8ToWord# r#_abhV)));
                                            2# ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abhQ (GHC.Prim.+# bx1_abhR 1#)
                                              of r#1_abi1
                                              { __DEFAULT ->
                                              GHC.Types.C#
                                                (GHC.Prim.chr#
                                                   (GHC.Prim.-#
                                                      (GHC.Prim.+#
                                                         (GHC.Prim.uncheckedIShiftL#
                                                            (GHC.Prim.-#
                                                               (GHC.Prim.word2Int#
                                                                  (GHC.Prim.word8ToWord# r#_abhV))
                                                               192#)
                                                            6#)
                                                         (GHC.Prim.word2Int#
                                                            (GHC.Prim.word8ToWord# r#1_abi1)))
                                                      128#))
                                              };
                                            3# ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abhQ (GHC.Prim.+# bx1_abhR 1#)
                                              of r#1_abi2
                                              { __DEFAULT ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abhQ (GHC.Prim.+# bx1_abhR 2#)
                                              of r#2_abi3
                                              { __DEFAULT ->
                                              GHC.Types.C#
                                                (GHC.Prim.chr#
                                                   (GHC.Prim.-#
                                                      (GHC.Prim.+#
                                                         (GHC.Prim.+#
                                                            (GHC.Prim.uncheckedIShiftL#
                                                               (GHC.Prim.-#
                                                                  (GHC.Prim.word2Int#
                                                                     (GHC.Prim.word8ToWord#
                                                                        r#_abhV))
                                                                  224#)
                                                               12#)
                                                            (GHC.Prim.uncheckedIShiftL#
                                                               (GHC.Prim.-#
                                                                  (GHC.Prim.word2Int#
                                                                     (GHC.Prim.word8ToWord#
                                                                        r#1_abi2))
                                                                  128#)
                                                               6#))
                                                         (GHC.Prim.word2Int#
                                                            (GHC.Prim.word8ToWord# r#2_abi3)))
                                                      128#))
                                              }
                                              }
                                          }
                                          },
                                          case Data.Text.compareLength
                                                 (Data.Text.Internal.Text bx_abhQ bx1_abhR bx2_abhS)
                                                 (GHC.Types.I# 1#)
                                          of {
                                            __DEFAULT ->
                                              case GHC.Prim.indexWord8Array# bx_abhQ bx1_abhR
                                              of r#_abi5
                                              { __DEFAULT ->
                                              let {
                                                c#_abi6 :: GHC.Prim.Int#
                                                [LclId,
                                                 Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                         Value=False, ConLike=False, WorkFree=False,
                                                         Expandable=False,
                                                         Guidance=IF_ARGS [] 4 0}]
                                                c#_abi6
                                                  = GHC.Prim.word2Int#
                                                      (GHC.Prim.clz8#
                                                         (GHC.Prim.and#
                                                            (GHC.Prim.not#
                                                               (GHC.Prim.word8ToWord# r#_abi5))
                                                            255##)) } in
                                              let {
                                                y_abi7 :: GHC.Prim.Int#
                                                [LclId,
                                                 Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                         Value=False, ConLike=False, WorkFree=False,
                                                         Expandable=False,
                                                         Guidance=IF_ARGS [] 2 0}]
                                                y_abi7
                                                  = GHC.Prim.xorI#
                                                      c#_abi6 (GHC.Prim.<=# c#_abi6 0#) } in
                                              Data.Text.Internal.Lazy.$WChunk
                                                (Data.Text.Internal.$WText
                                                   (Data.Text.Array.ByteArray bx_abhQ)
                                                   (GHC.Types.I# (GHC.Prim.+# bx1_abhR y_abi7))
                                                   (GHC.Types.I# (GHC.Prim.-# bx2_abhS y_abi7)))
                                                ts_abhT
                                              };
                                            GHC.Types.EQ -> ts_abhT
                                          })
                                   })
                                (let {
                                   f2_abi9
                                     :: Data.Text.Internal.Lazy.Text
                                        -> f_abhF Data.Text.Internal.Lazy.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abi9
                                     = GHC.Base.pure
                                         @f_abhF
                                         $dApplicative_abhH
                                         @Data.Text.Internal.Lazy.Text } in
                                 let {
                                   ds2_abia
                                     :: f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                        -> f_abhF Data.Text.Internal.Lazy.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 100 0}]
                                   ds2_abia
                                     = GHC.Base.fmap
                                         @f_abhF
                                         (GHC.Base.$p1Applicative @f_abhF $dApplicative_abhH)
                                         @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                         @Data.Text.Internal.Lazy.Text
                                         (\ (p1_abib
                                               :: (GHC.Types.Char, Data.Text.Internal.Lazy.Text)) ->
                                            case p1_abib of { (x_abid, ds_abie) ->
                                            Data.Text.Lazy.cons x_abid ds_abie
                                            }) } in
                                 \ (ds3_abig
                                      :: Data.Either.Either
                                           Data.Text.Internal.Lazy.Text
                                           (f_abhF
                                              (GHC.Types.Char, Data.Text.Internal.Lazy.Text))) ->
                                   case ds3_abig of {
                                     Data.Either.Left x_abii -> f2_abi9 x_abii;
                                     Data.Either.Right y_abik -> ds2_abia y_abik
                                   }) } in
                        let {
                          g_abim
                            :: p_abhE
                                 (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                 (f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                               -> p_abhE
                                    (Data.Either.Either
                                       Data.Text.Internal.Lazy.Text
                                       (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                                    (Data.Either.Either
                                       Data.Text.Internal.Lazy.Text
                                       (f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abim
                            = Data.Profunctor.Choice.right'
                                @p_abhE
                                $dChoice_abhG
                                @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                @(f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                                @Data.Text.Internal.Lazy.Text } in
                        \ (x_abin
                             :: p_abhE
                                  (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                  (f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text))) ->
                          f1_abhI (g_abim x_abin))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <Data.Text.Internal.Lazy.Text>_N
                                      <Data.Text.Internal.Lazy.Text>_N
                                      <GHC.Types.Char>_N
                                      <GHC.Types.Char>_N)
                             :: Control.Lens.Type.Prism
                                  Data.Text.Internal.Lazy.Text
                                  Data.Text.Internal.Lazy.Text
                                  (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                  (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                ~R# Control.Lens.Cons.Cons
                                      Data.Text.Internal.Lazy.Text
                                      Data.Text.Internal.Lazy.Text
                                      GHC.Types.Char
                                      GHC.Types.Char)
              ValArg (\ (@(p_abeP :: * -> * -> *))
                        (@(f_abeQ :: * -> *))
                        ($dChoice_abeR :: Data.Profunctor.Choice.Choice p_abeP)
                        ($dApplicative_abeS :: GHC.Base.Applicative f_abeQ) ->
                        let {
                          f1_abeT
                            :: p_abeP
                                 (Data.Either.Either
                                    [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                                 (Data.Either.Either
                                    [GHC.Types.Char] (f_abeQ (GHC.Types.Char, [GHC.Types.Char])))
                               -> p_abeP [GHC.Types.Char] (f_abeQ [GHC.Types.Char])
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 320 0}]
                          f1_abeT
                            = Data.Profunctor.Unsafe.dimap
                                @p_abeP
                                (Data.Profunctor.Choice.$p1Choice @p_abeP $dChoice_abeR)
                                @[GHC.Types.Char]
                                @(Data.Either.Either
                                    [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                                @(Data.Either.Either
                                    [GHC.Types.Char] (f_abeQ (GHC.Types.Char, [GHC.Types.Char])))
                                @(f_abeQ [GHC.Types.Char])
                                (\ (aas_abeU :: [GHC.Types.Char]) ->
                                   case aas_abeU of {
                                     [] ->
                                       Data.Either.Left
                                         @[GHC.Types.Char]
                                         @(GHC.Types.Char, [GHC.Types.Char])
                                         (GHC.Types.[] @GHC.Types.Char);
                                     : a1_abeW as_abeX ->
                                       Data.Either.Right
                                         @[GHC.Types.Char]
                                         @(GHC.Types.Char, [GHC.Types.Char])
                                         (a1_abeW, as_abeX)
                                   })
                                (let {
                                   f2_abeZ :: [GHC.Types.Char] -> f_abeQ [GHC.Types.Char]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abeZ
                                     = GHC.Base.pure
                                         @f_abeQ $dApplicative_abeS @[GHC.Types.Char] } in
                                 let {
                                   ds2_abf0
                                     :: f_abeQ (GHC.Types.Char, [GHC.Types.Char])
                                        -> f_abeQ [GHC.Types.Char]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 90 0}]
                                   ds2_abf0
                                     = GHC.Base.fmap
                                         @f_abeQ
                                         (GHC.Base.$p1Applicative @f_abeQ $dApplicative_abeS)
                                         @(GHC.Types.Char, [GHC.Types.Char])
                                         @[GHC.Types.Char]
                                         (\ (p1_abf1 :: (GHC.Types.Char, [GHC.Types.Char])) ->
                                            GHC.Types.:
                                              @GHC.Types.Char
                                              (case p1_abf1 of { (x_abf3, ds_abf4) -> x_abf3 })
                                              (case p1_abf1 of { (ds_abf7, y_abf8) ->
                                               y_abf8
                                               })) } in
                                 \ (ds3_abfa
                                      :: Data.Either.Either
                                           [GHC.Types.Char]
                                           (f_abeQ (GHC.Types.Char, [GHC.Types.Char]))) ->
                                   case ds3_abfa of {
                                     Data.Either.Left x_abfc -> f2_abeZ x_abfc;
                                     Data.Either.Right y_abfe -> ds2_abf0 y_abfe
                                   }) } in
                        let {
                          g_abfg
                            :: p_abeP
                                 (GHC.Types.Char, [GHC.Types.Char])
                                 (f_abeQ (GHC.Types.Char, [GHC.Types.Char]))
                               -> p_abeP
                                    (Data.Either.Either
                                       [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                                    (Data.Either.Either
                                       [GHC.Types.Char] (f_abeQ (GHC.Types.Char, [GHC.Types.Char])))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abfg
                            = Data.Profunctor.Choice.right'
                                @p_abeP
                                $dChoice_abeR
                                @(GHC.Types.Char, [GHC.Types.Char])
                                @(f_abeQ (GHC.Types.Char, [GHC.Types.Char]))
                                @[GHC.Types.Char] } in
                        \ (x_abfh
                             :: p_abeP
                                  (GHC.Types.Char, [GHC.Types.Char])
                                  (f_abeQ (GHC.Types.Char, [GHC.Types.Char]))) ->
                          f1_abeT (g_abfg x_abfh))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <[GHC.Types.Char]>_N
                                      <[GHC.Types.Char]>_N
                                      <GHC.Types.Char>_N
                                      <GHC.Types.Char>_N)
                             :: Control.Lens.Type.Prism
                                  [GHC.Types.Char]
                                  [GHC.Types.Char]
                                  (GHC.Types.Char, [GHC.Types.Char])
                                  (GHC.Types.Char, [GHC.Types.Char])
                                ~R# Control.Lens.Cons.Cons
                                      [GHC.Types.Char]
                                      [GHC.Types.Char]
                                      GHC.Types.Char
                                      GHC.Types.Char)
              ValArg (\ (@(p_abfm :: * -> * -> *))
                        (@(f_abfn :: * -> *))
                        ($dChoice_abfo :: Data.Profunctor.Choice.Choice p_abfm)
                        ($dApplicative_abfp :: GHC.Base.Applicative f_abfn) ->
                        let {
                          f1_abfq
                            :: p_abfm
                                 (Data.Either.Either [GHC.Types.Char] ())
                                 (Data.Either.Either [GHC.Types.Char] (f_abfn ()))
                               -> p_abfm [GHC.Types.Char] (f_abfn [GHC.Types.Char])
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 290 0}]
                          f1_abfq
                            = Data.Profunctor.Unsafe.dimap
                                @p_abfm
                                (Data.Profunctor.Choice.$p1Choice @p_abfm $dChoice_abfo)
                                @[GHC.Types.Char]
                                @(Data.Either.Either [GHC.Types.Char] ())
                                @(Data.Either.Either [GHC.Types.Char] (f_abfn ()))
                                @(f_abfn [GHC.Types.Char])
                                (\ (s_abfr :: [GHC.Types.Char]) ->
                                   case s_abfr of wild_abfs {
                                     [] ->
                                       Data.Either.Right @[GHC.Types.Char] @() GHC.Tuple.Prim.();
                                     : ds1_abft ds2_abfu ->
                                       Data.Either.Left @[GHC.Types.Char] @() wild_abfs
                                   })
                                (let {
                                   f2_abfw :: [GHC.Types.Char] -> f_abfn [GHC.Types.Char]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abfw
                                     = GHC.Base.pure
                                         @f_abfn $dApplicative_abfp @[GHC.Types.Char] } in
                                 let {
                                   ds2_abfx :: f_abfn () -> f_abfn [GHC.Types.Char]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 70 0}]
                                   ds2_abfx
                                     = GHC.Base.fmap
                                         @f_abfn
                                         (GHC.Base.$p1Applicative @f_abfn $dApplicative_abfp)
                                         @()
                                         @[GHC.Types.Char]
                                         (\ (ds3_abfy :: ()) ->
                                            case ds3_abfy of { () ->
                                            GHC.Types.[] @GHC.Types.Char
                                            }) } in
                                 \ (ds3_abfA :: Data.Either.Either [GHC.Types.Char] (f_abfn ())) ->
                                   case ds3_abfA of {
                                     Data.Either.Left x_abfC -> f2_abfw x_abfC;
                                     Data.Either.Right y_abfE -> ds2_abfx y_abfE
                                   }) } in
                        let {
                          g_abfG
                            :: p_abfm () (f_abfn ())
                               -> p_abfm
                                    (Data.Either.Either [GHC.Types.Char] ())
                                    (Data.Either.Either [GHC.Types.Char] (f_abfn ()))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abfG
                            = Data.Profunctor.Choice.right'
                                @p_abfm $dChoice_abfo @() @(f_abfn ()) @[GHC.Types.Char] } in
                        \ (x_abfH :: p_abfm () (f_abfn ())) -> f1_abfq (g_abfG x_abfH))
                     `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0] <[GHC.Types.Char]>_N)
                             :: Control.Lens.Type.Prism' [GHC.Types.Char] ()
                                ~R# Control.Lens.Empty.AsEmpty [GHC.Types.Char])
              TyArg Data.Functor.Const.Const GHC.Base.String
              ValArg Data.Functor.Contravariant.$fContravariantConst
                       @[GHC.Types.Char]
              ValArg Data.Functor.Const.$fFunctorConst @[GHC.Types.Char]
    After:  (\ (@(f_abeb :: * -> *))
               ($dCons_abec
                  :: Control.Lens.Cons.Cons
                       Data.Text.Internal.Lazy.Text
                       Data.Text.Internal.Lazy.Text
                       GHC.Types.Char
                       GHC.Types.Char)
               ($dCons1_abed
                  :: Control.Lens.Cons.Cons
                       GHC.Base.String GHC.Base.String GHC.Types.Char GHC.Types.Char)
               ($dAsEmpty_abee :: Control.Lens.Empty.AsEmpty GHC.Base.String)
               ($dContravariant_abef
                  :: Data.Functor.Contravariant.Contravariant f_abeb)
               ($dFunctor_abeg :: GHC.Base.Functor f_abeb) ->
               Data.Profunctor.Unsafe.$fProfunctorFUN_$cdimap
                 @Data.Text.Internal.Lazy.Text
                 @GHC.Base.String
                 @(f_abeb GHC.Base.String)
                 @(f_abeb Data.Text.Internal.Lazy.Text)
                 Data.Text.Lazy.unpack
                 (GHC.Base.fmap
                    @f_abeb
                    $dFunctor_abeg
                    @GHC.Base.String
                    @Data.Text.Internal.Lazy.Text
                    Data.Text.Lazy.pack))
              @(Data.Functor.Const.Const GHC.Base.String)
              ((\ (@(p_abhE :: * -> * -> *))
                  (@(f_abhF :: * -> *))
                  ($dChoice_abhG :: Data.Profunctor.Choice.Choice p_abhE)
                  ($dApplicative_abhH :: GHC.Base.Applicative f_abhF) ->
                  let {
                    f1_abhI
                      :: p_abhE
                           (Data.Either.Either
                              Data.Text.Internal.Lazy.Text
                              (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                           (Data.Either.Either
                              Data.Text.Internal.Lazy.Text
                              (f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                         -> p_abhE
                              Data.Text.Internal.Lazy.Text (f_abhF Data.Text.Internal.Lazy.Text)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 639 0}]
                    f1_abhI
                      = Data.Profunctor.Unsafe.dimap
                          @p_abhE
                          (Data.Profunctor.Choice.$p1Choice @p_abhE $dChoice_abhG)
                          @Data.Text.Internal.Lazy.Text
                          @(Data.Either.Either
                              Data.Text.Internal.Lazy.Text
                              (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                          @(Data.Either.Either
                              Data.Text.Internal.Lazy.Text
                              (f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                          @(f_abhF Data.Text.Internal.Lazy.Text)
                          (\ (s1_abhJ :: Data.Text.Internal.Lazy.Text) ->
                             case s1_abhJ of {
                               Data.Text.Internal.Lazy.Empty ->
                                 Data.Either.Left
                                   @Data.Text.Internal.Lazy.Text
                                   @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                   Data.Text.Internal.Lazy.Empty;
                               Data.Text.Internal.Lazy.Chunk bx_abhQ bx1_abhR bx2_abhS ts_abhT ->
                                 Data.Either.Right
                                   @Data.Text.Internal.Lazy.Text
                                   @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                   (case GHC.Prim.indexWord8Array# bx_abhQ bx1_abhR of r#_abhV
                                    { __DEFAULT ->
                                    let {
                                      c#_abhW :: GHC.Prim.Int#
                                      [LclId,
                                       Unf=Unf{Src=<vanilla>, TopLvl=False,
                                               Value=False, ConLike=False, WorkFree=False,
                                               Expandable=False,
                                               Guidance=IF_ARGS [] 4 0}]
                                      c#_abhW
                                        = GHC.Prim.word2Int#
                                            (GHC.Prim.clz8#
                                               (GHC.Prim.and#
                                                  (GHC.Prim.not# (GHC.Prim.word8ToWord# r#_abhV))
                                                  255##)) } in
                                    case GHC.Prim.xorI# c#_abhW (GHC.Prim.<=# c#_abhW 0#) of {
                                      __DEFAULT ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abhQ (GHC.Prim.+# bx1_abhR 1#)
                                        of r#1_abhY
                                        { __DEFAULT ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abhQ (GHC.Prim.+# bx1_abhR 2#)
                                        of r#2_abhZ
                                        { __DEFAULT ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abhQ (GHC.Prim.+# bx1_abhR 3#)
                                        of r#3_abi0
                                        { __DEFAULT ->
                                        GHC.Types.C#
                                          (GHC.Prim.chr#
                                             (GHC.Prim.-#
                                                (GHC.Prim.+#
                                                   (GHC.Prim.+#
                                                      (GHC.Prim.+#
                                                         (GHC.Prim.uncheckedIShiftL#
                                                            (GHC.Prim.-#
                                                               (GHC.Prim.word2Int#
                                                                  (GHC.Prim.word8ToWord# r#_abhV))
                                                               240#)
                                                            18#)
                                                         (GHC.Prim.uncheckedIShiftL#
                                                            (GHC.Prim.-#
                                                               (GHC.Prim.word2Int#
                                                                  (GHC.Prim.word8ToWord# r#1_abhY))
                                                               128#)
                                                            12#))
                                                      (GHC.Prim.uncheckedIShiftL#
                                                         (GHC.Prim.-#
                                                            (GHC.Prim.word2Int#
                                                               (GHC.Prim.word8ToWord# r#2_abhZ))
                                                            128#)
                                                         6#))
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.word8ToWord# r#3_abi0)))
                                                128#))
                                        }
                                        }
                                        };
                                      1# ->
                                        GHC.Types.C#
                                          (GHC.Prim.chr#
                                             (GHC.Prim.word2Int# (GHC.Prim.word8ToWord# r#_abhV)));
                                      2# ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abhQ (GHC.Prim.+# bx1_abhR 1#)
                                        of r#1_abi1
                                        { __DEFAULT ->
                                        GHC.Types.C#
                                          (GHC.Prim.chr#
                                             (GHC.Prim.-#
                                                (GHC.Prim.+#
                                                   (GHC.Prim.uncheckedIShiftL#
                                                      (GHC.Prim.-#
                                                         (GHC.Prim.word2Int#
                                                            (GHC.Prim.word8ToWord# r#_abhV))
                                                         192#)
                                                      6#)
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.word8ToWord# r#1_abi1)))
                                                128#))
                                        };
                                      3# ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abhQ (GHC.Prim.+# bx1_abhR 1#)
                                        of r#1_abi2
                                        { __DEFAULT ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abhQ (GHC.Prim.+# bx1_abhR 2#)
                                        of r#2_abi3
                                        { __DEFAULT ->
                                        GHC.Types.C#
                                          (GHC.Prim.chr#
                                             (GHC.Prim.-#
                                                (GHC.Prim.+#
                                                   (GHC.Prim.+#
                                                      (GHC.Prim.uncheckedIShiftL#
                                                         (GHC.Prim.-#
                                                            (GHC.Prim.word2Int#
                                                               (GHC.Prim.word8ToWord# r#_abhV))
                                                            224#)
                                                         12#)
                                                      (GHC.Prim.uncheckedIShiftL#
                                                         (GHC.Prim.-#
                                                            (GHC.Prim.word2Int#
                                                               (GHC.Prim.word8ToWord# r#1_abi2))
                                                            128#)
                                                         6#))
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.word8ToWord# r#2_abi3)))
                                                128#))
                                        }
                                        }
                                    }
                                    },
                                    case Data.Text.compareLength
                                           (Data.Text.Internal.Text bx_abhQ bx1_abhR bx2_abhS)
                                           (GHC.Types.I# 1#)
                                    of {
                                      __DEFAULT ->
                                        case GHC.Prim.indexWord8Array# bx_abhQ bx1_abhR of r#_abi5
                                        { __DEFAULT ->
                                        let {
                                          c#_abi6 :: GHC.Prim.Int#
                                          [LclId,
                                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                   Value=False, ConLike=False, WorkFree=False,
                                                   Expandable=False,
                                                   Guidance=IF_ARGS [] 4 0}]
                                          c#_abi6
                                            = GHC.Prim.word2Int#
                                                (GHC.Prim.clz8#
                                                   (GHC.Prim.and#
                                                      (GHC.Prim.not#
                                                         (GHC.Prim.word8ToWord# r#_abi5))
                                                      255##)) } in
                                        let {
                                          y_abi7 :: GHC.Prim.Int#
                                          [LclId,
                                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                   Value=False, ConLike=False, WorkFree=False,
                                                   Expandable=False,
                                                   Guidance=IF_ARGS [] 2 0}]
                                          y_abi7
                                            = GHC.Prim.xorI# c#_abi6 (GHC.Prim.<=# c#_abi6 0#) } in
                                        Data.Text.Internal.Lazy.$WChunk
                                          (Data.Text.Internal.$WText
                                             (Data.Text.Array.ByteArray bx_abhQ)
                                             (GHC.Types.I# (GHC.Prim.+# bx1_abhR y_abi7))
                                             (GHC.Types.I# (GHC.Prim.-# bx2_abhS y_abi7)))
                                          ts_abhT
                                        };
                                      GHC.Types.EQ -> ts_abhT
                                    })
                             })
                          (let {
                             f2_abi9
                               :: Data.Text.Internal.Lazy.Text
                                  -> f_abhF Data.Text.Internal.Lazy.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abi9
                               = GHC.Base.pure
                                   @f_abhF $dApplicative_abhH @Data.Text.Internal.Lazy.Text } in
                           let {
                             ds2_abia
                               :: f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                  -> f_abhF Data.Text.Internal.Lazy.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 100 0}]
                             ds2_abia
                               = GHC.Base.fmap
                                   @f_abhF
                                   (GHC.Base.$p1Applicative @f_abhF $dApplicative_abhH)
                                   @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                   @Data.Text.Internal.Lazy.Text
                                   (\ (p1_abib :: (GHC.Types.Char, Data.Text.Internal.Lazy.Text)) ->
                                      case p1_abib of { (x_abid, ds_abie) ->
                                      Data.Text.Lazy.cons x_abid ds_abie
                                      }) } in
                           \ (ds3_abig
                                :: Data.Either.Either
                                     Data.Text.Internal.Lazy.Text
                                     (f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text))) ->
                             case ds3_abig of {
                               Data.Either.Left x_abii -> f2_abi9 x_abii;
                               Data.Either.Right y_abik -> ds2_abia y_abik
                             }) } in
                  let {
                    g_abim
                      :: p_abhE
                           (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                           (f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                         -> p_abhE
                              (Data.Either.Either
                                 Data.Text.Internal.Lazy.Text
                                 (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                              (Data.Either.Either
                                 Data.Text.Internal.Lazy.Text
                                 (f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abim
                      = Data.Profunctor.Choice.right'
                          @p_abhE
                          $dChoice_abhG
                          @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                          @(f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                          @Data.Text.Internal.Lazy.Text } in
                  \ (x_abin
                       :: p_abhE
                            (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                            (f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text))) ->
                    f1_abhI (g_abim x_abin))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <Data.Text.Internal.Lazy.Text>_N
                                <Data.Text.Internal.Lazy.Text>_N
                                <GHC.Types.Char>_N
                                <GHC.Types.Char>_N)
                       :: Control.Lens.Type.Prism
                            Data.Text.Internal.Lazy.Text
                            Data.Text.Internal.Lazy.Text
                            (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                            (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                          ~R# Control.Lens.Cons.Cons
                                Data.Text.Internal.Lazy.Text
                                Data.Text.Internal.Lazy.Text
                                GHC.Types.Char
                                GHC.Types.Char))
              ((\ (@(p_abeP :: * -> * -> *))
                  (@(f_abeQ :: * -> *))
                  ($dChoice_abeR :: Data.Profunctor.Choice.Choice p_abeP)
                  ($dApplicative_abeS :: GHC.Base.Applicative f_abeQ) ->
                  let {
                    f1_abeT
                      :: p_abeP
                           (Data.Either.Either
                              [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                           (Data.Either.Either
                              [GHC.Types.Char] (f_abeQ (GHC.Types.Char, [GHC.Types.Char])))
                         -> p_abeP [GHC.Types.Char] (f_abeQ [GHC.Types.Char])
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 320 0}]
                    f1_abeT
                      = Data.Profunctor.Unsafe.dimap
                          @p_abeP
                          (Data.Profunctor.Choice.$p1Choice @p_abeP $dChoice_abeR)
                          @[GHC.Types.Char]
                          @(Data.Either.Either
                              [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                          @(Data.Either.Either
                              [GHC.Types.Char] (f_abeQ (GHC.Types.Char, [GHC.Types.Char])))
                          @(f_abeQ [GHC.Types.Char])
                          (\ (aas_abeU :: [GHC.Types.Char]) ->
                             case aas_abeU of {
                               [] ->
                                 Data.Either.Left
                                   @[GHC.Types.Char]
                                   @(GHC.Types.Char, [GHC.Types.Char])
                                   (GHC.Types.[] @GHC.Types.Char);
                               : a1_abeW as_abeX ->
                                 Data.Either.Right
                                   @[GHC.Types.Char]
                                   @(GHC.Types.Char, [GHC.Types.Char])
                                   (a1_abeW, as_abeX)
                             })
                          (let {
                             f2_abeZ :: [GHC.Types.Char] -> f_abeQ [GHC.Types.Char]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abeZ
                               = GHC.Base.pure @f_abeQ $dApplicative_abeS @[GHC.Types.Char] } in
                           let {
                             ds2_abf0
                               :: f_abeQ (GHC.Types.Char, [GHC.Types.Char])
                                  -> f_abeQ [GHC.Types.Char]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 90 0}]
                             ds2_abf0
                               = GHC.Base.fmap
                                   @f_abeQ
                                   (GHC.Base.$p1Applicative @f_abeQ $dApplicative_abeS)
                                   @(GHC.Types.Char, [GHC.Types.Char])
                                   @[GHC.Types.Char]
                                   (\ (p1_abf1 :: (GHC.Types.Char, [GHC.Types.Char])) ->
                                      GHC.Types.:
                                        @GHC.Types.Char
                                        (case p1_abf1 of { (x_abf3, ds_abf4) -> x_abf3 })
                                        (case p1_abf1 of { (ds_abf7, y_abf8) -> y_abf8 })) } in
                           \ (ds3_abfa
                                :: Data.Either.Either
                                     [GHC.Types.Char]
                                     (f_abeQ (GHC.Types.Char, [GHC.Types.Char]))) ->
                             case ds3_abfa of {
                               Data.Either.Left x_abfc -> f2_abeZ x_abfc;
                               Data.Either.Right y_abfe -> ds2_abf0 y_abfe
                             }) } in
                  let {
                    g_abfg
                      :: p_abeP
                           (GHC.Types.Char, [GHC.Types.Char])
                           (f_abeQ (GHC.Types.Char, [GHC.Types.Char]))
                         -> p_abeP
                              (Data.Either.Either
                                 [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                              (Data.Either.Either
                                 [GHC.Types.Char] (f_abeQ (GHC.Types.Char, [GHC.Types.Char])))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abfg
                      = Data.Profunctor.Choice.right'
                          @p_abeP
                          $dChoice_abeR
                          @(GHC.Types.Char, [GHC.Types.Char])
                          @(f_abeQ (GHC.Types.Char, [GHC.Types.Char]))
                          @[GHC.Types.Char] } in
                  \ (x_abfh
                       :: p_abeP
                            (GHC.Types.Char, [GHC.Types.Char])
                            (f_abeQ (GHC.Types.Char, [GHC.Types.Char]))) ->
                    f1_abeT (g_abfg x_abfh))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <[GHC.Types.Char]>_N
                                <[GHC.Types.Char]>_N
                                <GHC.Types.Char>_N
                                <GHC.Types.Char>_N)
                       :: Control.Lens.Type.Prism
                            [GHC.Types.Char]
                            [GHC.Types.Char]
                            (GHC.Types.Char, [GHC.Types.Char])
                            (GHC.Types.Char, [GHC.Types.Char])
                          ~R# Control.Lens.Cons.Cons
                                [GHC.Types.Char] [GHC.Types.Char] GHC.Types.Char GHC.Types.Char))
              ((\ (@(p_abfm :: * -> * -> *))
                  (@(f_abfn :: * -> *))
                  ($dChoice_abfo :: Data.Profunctor.Choice.Choice p_abfm)
                  ($dApplicative_abfp :: GHC.Base.Applicative f_abfn) ->
                  let {
                    f1_abfq
                      :: p_abfm
                           (Data.Either.Either [GHC.Types.Char] ())
                           (Data.Either.Either [GHC.Types.Char] (f_abfn ()))
                         -> p_abfm [GHC.Types.Char] (f_abfn [GHC.Types.Char])
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 290 0}]
                    f1_abfq
                      = Data.Profunctor.Unsafe.dimap
                          @p_abfm
                          (Data.Profunctor.Choice.$p1Choice @p_abfm $dChoice_abfo)
                          @[GHC.Types.Char]
                          @(Data.Either.Either [GHC.Types.Char] ())
                          @(Data.Either.Either [GHC.Types.Char] (f_abfn ()))
                          @(f_abfn [GHC.Types.Char])
                          (\ (s_abfr :: [GHC.Types.Char]) ->
                             case s_abfr of wild_abfs {
                               [] -> Data.Either.Right @[GHC.Types.Char] @() GHC.Tuple.Prim.();
                               : ds1_abft ds2_abfu ->
                                 Data.Either.Left @[GHC.Types.Char] @() wild_abfs
                             })
                          (let {
                             f2_abfw :: [GHC.Types.Char] -> f_abfn [GHC.Types.Char]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abfw
                               = GHC.Base.pure @f_abfn $dApplicative_abfp @[GHC.Types.Char] } in
                           let {
                             ds2_abfx :: f_abfn () -> f_abfn [GHC.Types.Char]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 70 0}]
                             ds2_abfx
                               = GHC.Base.fmap
                                   @f_abfn
                                   (GHC.Base.$p1Applicative @f_abfn $dApplicative_abfp)
                                   @()
                                   @[GHC.Types.Char]
                                   (\ (ds3_abfy :: ()) ->
                                      case ds3_abfy of { () -> GHC.Types.[] @GHC.Types.Char }) } in
                           \ (ds3_abfA :: Data.Either.Either [GHC.Types.Char] (f_abfn ())) ->
                             case ds3_abfA of {
                               Data.Either.Left x_abfC -> f2_abfw x_abfC;
                               Data.Either.Right y_abfE -> ds2_abfx y_abfE
                             }) } in
                  let {
                    g_abfG
                      :: p_abfm () (f_abfn ())
                         -> p_abfm
                              (Data.Either.Either [GHC.Types.Char] ())
                              (Data.Either.Either [GHC.Types.Char] (f_abfn ()))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abfG
                      = Data.Profunctor.Choice.right'
                          @p_abfm $dChoice_abfo @() @(f_abfn ()) @[GHC.Types.Char] } in
                  \ (x_abfH :: p_abfm () (f_abfn ())) -> f1_abfq (g_abfG x_abfH))
               `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0] <[GHC.Types.Char]>_N)
                       :: Control.Lens.Type.Prism' [GHC.Types.Char] ()
                          ~R# Control.Lens.Empty.AsEmpty [GHC.Types.Char]))
              (Data.Functor.Contravariant.$fContravariantConst @[GHC.Types.Char])
              (Data.Functor.Const.$fFunctorConst @[GHC.Types.Char])
    Cont:   ApplyToVal nodup hole Control.Lens.Getter.Getting
                                    GHC.Base.String Data.Text.Internal.Lazy.Text GHC.Base.String
              ((\ (ds_abdj [Occ=Once1] :: a_abdg) -> ds_abdj)
               `cast` (<a_abdg>_R
                       %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                          <*>_N <a_abdg>_R <a_abdg>_P)
                       :: (a_abdg -> a_abdg)
                          ~R# (a_abdg -> Data.Functor.Const.Const a_abdg a_abdg)))
            ApplyToVal nodup hole Data.Text.Internal.Lazy.Text
                                  -> Data.Functor.Const.Const
                                       GHC.Base.String Data.Text.Internal.Lazy.Text
              (Control.Lens.Getter.view
                 @[GHC.Types.Char]
                 @((->) GHC.Base.String)
                 @Data.Text.Internal.Lazy.Text
                 (Control.Monad.Reader.Class.$fMonadReaderrFUN @[GHC.Types.Char])
                 (Control.Lens.Cons.Extras.recons
                    @[GHC.Types.Char]
                    @GHC.Types.Char
                    @Data.Text.Internal.Lazy.Text
                    (Control.Lens.Cons.$fConsListListab
                       @GHC.Types.Char @GHC.Types.Char)
                    Control.Lens.Cons.$fConsTextTextCharChar
                    Control.Lens.Empty.$fAsEmptyText
                    @(Data.Functor.Const.Const Data.Text.Internal.Lazy.Text)
                    (Data.Functor.Contravariant.$fContravariantConst
                       @Data.Text.Internal.Lazy.Text)
                    (Data.Functor.Const.$fFunctorConst @Data.Text.Internal.Lazy.Text))
                 s_a8Od)
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N <GHC.Base.String>_R <Data.Text.Internal.Lazy.Text>_P
                    :: Data.Functor.Const.Const
                         GHC.Base.String Data.Text.Internal.Lazy.Text
                       ~R# GHC.Base.String)
            Stop[RuleArgCtxt] GHC.Base.String
Rule fired
    Rule: Class op fmap
    Module: (BUILTIN)
    Before: GHC.Base.fmap
              TyArg Data.Functor.Const.Const GHC.Base.String
              ValArg Data.Functor.Const.$fFunctorConst @[GHC.Types.Char]
    After:  (Data.Functor.Const.$fFunctorConst2 @[GHC.Types.Char])
            `cast` (forall (a :: <*>_N) (b :: <*>_N).
                    <a -> b>_R
                    %<'GHC.Types.Many>_N ->_R <Data.Functor.Const.Const
                                                 [GHC.Types.Char] a>_R
                    %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                  <*>_N <[GHC.Types.Char]>_R <a>_P
                                              ; Sym (Data.Functor.Const.N:Const[0]
                                                         <*>_N <[GHC.Types.Char]>_R <b>_P)
                    :: (forall {a} {b}.
                        (a -> b)
                        -> Data.Functor.Const.Const [GHC.Types.Char] a
                        -> Data.Functor.Const.Const [GHC.Types.Char] a)
                       ~R# (forall {a} {b}.
                            (a -> b)
                            -> Data.Functor.Const.Const [GHC.Types.Char] a
                            -> Data.Functor.Const.Const [GHC.Types.Char] b))
    Cont:   ApplyToTy GHC.Base.String
            ApplyToTy Data.Text.Internal.Lazy.Text
            ApplyToVal nodup hole (GHC.Base.String
                                   -> Data.Text.Internal.Lazy.Text)
                                  -> Data.Functor.Const.Const GHC.Base.String GHC.Base.String
                                  -> Data.Functor.Const.Const
                                       GHC.Base.String Data.Text.Internal.Lazy.Text
              Data.Text.Lazy.pack
            ApplyToVal nodup hole Data.Functor.Const.Const
                                    GHC.Base.String GHC.Base.String
                                  -> Data.Functor.Const.Const
                                       GHC.Base.String Data.Text.Internal.Lazy.Text
              (bc_abny (ab_abnw x_abnz))
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N <GHC.Base.String>_R <Data.Text.Internal.Lazy.Text>_P
                    :: Data.Functor.Const.Const
                         GHC.Base.String Data.Text.Internal.Lazy.Text
                       ~R# GHC.Base.String)
            Stop[RuleArgCtxt] GHC.Base.String
Rule fired
    Rule: Class op reader
    Module: (BUILTIN)
    Before: Control.Monad.Reader.Class.reader
              TyArg [GHC.Types.Char]
              TyArg (->) GHC.Base.String
              ValArg Control.Monad.Reader.Class.$fMonadReaderrFUN
                       @[GHC.Types.Char]
    After:  \ (@a_abdo) -> GHC.Base.id @([GHC.Types.Char] -> a_abdo)
    Cont:   ApplyToTy Data.Text.Internal.Lazy.Text
            ApplyToVal nodup hole ([GHC.Types.Char]
                                   -> Data.Text.Internal.Lazy.Text)
                                  -> GHC.Base.String -> Data.Text.Internal.Lazy.Text
              ((l_abdi
                  ((\ (ds_abdj [Occ=Once1] :: a_abdg) -> ds_abdj)
                   `cast` (<a_abdg>_R
                           %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                              <*>_N <a_abdg>_R <a_abdg>_P)
                           :: (a_abdg -> a_abdg)
                              ~R# (a_abdg -> Data.Functor.Const.Const a_abdg a_abdg))))
               `cast` (<s_abde>_R
                       %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                     <*>_N <a_abdg>_R <s_abde>_P
                       :: (s_abde -> Data.Functor.Const.Const a_abdg s_abde)
                          ~R# (s_abde -> a_abdg)))
            ApplyToVal nodup hole GHC.Base.String
                                  -> Data.Text.Internal.Lazy.Text
              s_a8Od
            Stop[RuleArgCtxt] Data.Text.Internal.Lazy.Text
Rule fired
    Rule: recons/string-lazytext
    Module: (Control.Lens.Cons.Extras)
    Before: Control.Lens.Cons.Extras.recons
              TyArg [GHC.Types.Char]
              TyArg GHC.Types.Char
              TyArg Data.Text.Internal.Lazy.Text
              ValArg (\ (@(p_abeP :: * -> * -> *))
                        (@(f_abeQ :: * -> *))
                        ($dChoice_abeR :: Data.Profunctor.Choice.Choice p_abeP)
                        ($dApplicative_abeS :: GHC.Base.Applicative f_abeQ) ->
                        let {
                          f1_abeT
                            :: p_abeP
                                 (Data.Either.Either
                                    [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                                 (Data.Either.Either
                                    [GHC.Types.Char] (f_abeQ (GHC.Types.Char, [GHC.Types.Char])))
                               -> p_abeP [GHC.Types.Char] (f_abeQ [GHC.Types.Char])
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 320 0}]
                          f1_abeT
                            = Data.Profunctor.Unsafe.dimap
                                @p_abeP
                                (Data.Profunctor.Choice.$p1Choice @p_abeP $dChoice_abeR)
                                @[GHC.Types.Char]
                                @(Data.Either.Either
                                    [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                                @(Data.Either.Either
                                    [GHC.Types.Char] (f_abeQ (GHC.Types.Char, [GHC.Types.Char])))
                                @(f_abeQ [GHC.Types.Char])
                                (\ (aas_abeU :: [GHC.Types.Char]) ->
                                   case aas_abeU of {
                                     [] ->
                                       Data.Either.Left
                                         @[GHC.Types.Char]
                                         @(GHC.Types.Char, [GHC.Types.Char])
                                         (GHC.Types.[] @GHC.Types.Char);
                                     : a1_abeW as_abeX ->
                                       Data.Either.Right
                                         @[GHC.Types.Char]
                                         @(GHC.Types.Char, [GHC.Types.Char])
                                         (a1_abeW, as_abeX)
                                   })
                                (let {
                                   f2_abeZ :: [GHC.Types.Char] -> f_abeQ [GHC.Types.Char]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abeZ
                                     = GHC.Base.pure
                                         @f_abeQ $dApplicative_abeS @[GHC.Types.Char] } in
                                 let {
                                   ds2_abf0
                                     :: f_abeQ (GHC.Types.Char, [GHC.Types.Char])
                                        -> f_abeQ [GHC.Types.Char]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 90 0}]
                                   ds2_abf0
                                     = GHC.Base.fmap
                                         @f_abeQ
                                         (GHC.Base.$p1Applicative @f_abeQ $dApplicative_abeS)
                                         @(GHC.Types.Char, [GHC.Types.Char])
                                         @[GHC.Types.Char]
                                         (\ (p1_abf1 :: (GHC.Types.Char, [GHC.Types.Char])) ->
                                            GHC.Types.:
                                              @GHC.Types.Char
                                              (case p1_abf1 of { (x_abf3, ds_abf4) -> x_abf3 })
                                              (case p1_abf1 of { (ds_abf7, y_abf8) ->
                                               y_abf8
                                               })) } in
                                 \ (ds3_abfa
                                      :: Data.Either.Either
                                           [GHC.Types.Char]
                                           (f_abeQ (GHC.Types.Char, [GHC.Types.Char]))) ->
                                   case ds3_abfa of {
                                     Data.Either.Left x_abfc -> f2_abeZ x_abfc;
                                     Data.Either.Right y_abfe -> ds2_abf0 y_abfe
                                   }) } in
                        let {
                          g_abfg
                            :: p_abeP
                                 (GHC.Types.Char, [GHC.Types.Char])
                                 (f_abeQ (GHC.Types.Char, [GHC.Types.Char]))
                               -> p_abeP
                                    (Data.Either.Either
                                       [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                                    (Data.Either.Either
                                       [GHC.Types.Char] (f_abeQ (GHC.Types.Char, [GHC.Types.Char])))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abfg
                            = Data.Profunctor.Choice.right'
                                @p_abeP
                                $dChoice_abeR
                                @(GHC.Types.Char, [GHC.Types.Char])
                                @(f_abeQ (GHC.Types.Char, [GHC.Types.Char]))
                                @[GHC.Types.Char] } in
                        \ (x_abfh
                             :: p_abeP
                                  (GHC.Types.Char, [GHC.Types.Char])
                                  (f_abeQ (GHC.Types.Char, [GHC.Types.Char]))) ->
                          f1_abeT (g_abfg x_abfh))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <[GHC.Types.Char]>_N
                                      <[GHC.Types.Char]>_N
                                      <GHC.Types.Char>_N
                                      <GHC.Types.Char>_N)
                             :: Control.Lens.Type.Prism
                                  [GHC.Types.Char]
                                  [GHC.Types.Char]
                                  (GHC.Types.Char, [GHC.Types.Char])
                                  (GHC.Types.Char, [GHC.Types.Char])
                                ~R# Control.Lens.Cons.Cons
                                      [GHC.Types.Char]
                                      [GHC.Types.Char]
                                      GHC.Types.Char
                                      GHC.Types.Char)
              ValArg (\ (@(p_abhE :: * -> * -> *))
                        (@(f_abhF :: * -> *))
                        ($dChoice_abhG :: Data.Profunctor.Choice.Choice p_abhE)
                        ($dApplicative_abhH :: GHC.Base.Applicative f_abhF) ->
                        let {
                          f1_abhI
                            :: p_abhE
                                 (Data.Either.Either
                                    Data.Text.Internal.Lazy.Text
                                    (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                                 (Data.Either.Either
                                    Data.Text.Internal.Lazy.Text
                                    (f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                               -> p_abhE
                                    Data.Text.Internal.Lazy.Text
                                    (f_abhF Data.Text.Internal.Lazy.Text)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 639 0}]
                          f1_abhI
                            = Data.Profunctor.Unsafe.dimap
                                @p_abhE
                                (Data.Profunctor.Choice.$p1Choice @p_abhE $dChoice_abhG)
                                @Data.Text.Internal.Lazy.Text
                                @(Data.Either.Either
                                    Data.Text.Internal.Lazy.Text
                                    (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                                @(Data.Either.Either
                                    Data.Text.Internal.Lazy.Text
                                    (f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                                @(f_abhF Data.Text.Internal.Lazy.Text)
                                (\ (s1_abhJ :: Data.Text.Internal.Lazy.Text) ->
                                   case s1_abhJ of {
                                     Data.Text.Internal.Lazy.Empty ->
                                       Data.Either.Left
                                         @Data.Text.Internal.Lazy.Text
                                         @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                         Data.Text.Internal.Lazy.Empty;
                                     Data.Text.Internal.Lazy.Chunk bx_abhQ bx1_abhR bx2_abhS
                                                                   ts_abhT ->
                                       Data.Either.Right
                                         @Data.Text.Internal.Lazy.Text
                                         @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                         (case GHC.Prim.indexWord8Array# bx_abhQ bx1_abhR of r#_abhV
                                          { __DEFAULT ->
                                          let {
                                            c#_abhW :: GHC.Prim.Int#
                                            [LclId,
                                             Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                     Value=False, ConLike=False, WorkFree=False,
                                                     Expandable=False,
                                                     Guidance=IF_ARGS [] 4 0}]
                                            c#_abhW
                                              = GHC.Prim.word2Int#
                                                  (GHC.Prim.clz8#
                                                     (GHC.Prim.and#
                                                        (GHC.Prim.not#
                                                           (GHC.Prim.word8ToWord# r#_abhV))
                                                        255##)) } in
                                          case GHC.Prim.xorI# c#_abhW (GHC.Prim.<=# c#_abhW 0#) of {
                                            __DEFAULT ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abhQ (GHC.Prim.+# bx1_abhR 1#)
                                              of r#1_abhY
                                              { __DEFAULT ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abhQ (GHC.Prim.+# bx1_abhR 2#)
                                              of r#2_abhZ
                                              { __DEFAULT ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abhQ (GHC.Prim.+# bx1_abhR 3#)
                                              of r#3_abi0
                                              { __DEFAULT ->
                                              GHC.Types.C#
                                                (GHC.Prim.chr#
                                                   (GHC.Prim.-#
                                                      (GHC.Prim.+#
                                                         (GHC.Prim.+#
                                                            (GHC.Prim.+#
                                                               (GHC.Prim.uncheckedIShiftL#
                                                                  (GHC.Prim.-#
                                                                     (GHC.Prim.word2Int#
                                                                        (GHC.Prim.word8ToWord#
                                                                           r#_abhV))
                                                                     240#)
                                                                  18#)
                                                               (GHC.Prim.uncheckedIShiftL#
                                                                  (GHC.Prim.-#
                                                                     (GHC.Prim.word2Int#
                                                                        (GHC.Prim.word8ToWord#
                                                                           r#1_abhY))
                                                                     128#)
                                                                  12#))
                                                            (GHC.Prim.uncheckedIShiftL#
                                                               (GHC.Prim.-#
                                                                  (GHC.Prim.word2Int#
                                                                     (GHC.Prim.word8ToWord#
                                                                        r#2_abhZ))
                                                                  128#)
                                                               6#))
                                                         (GHC.Prim.word2Int#
                                                            (GHC.Prim.word8ToWord# r#3_abi0)))
                                                      128#))
                                              }
                                              }
                                              };
                                            1# ->
                                              GHC.Types.C#
                                                (GHC.Prim.chr#
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.word8ToWord# r#_abhV)));
                                            2# ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abhQ (GHC.Prim.+# bx1_abhR 1#)
                                              of r#1_abi1
                                              { __DEFAULT ->
                                              GHC.Types.C#
                                                (GHC.Prim.chr#
                                                   (GHC.Prim.-#
                                                      (GHC.Prim.+#
                                                         (GHC.Prim.uncheckedIShiftL#
                                                            (GHC.Prim.-#
                                                               (GHC.Prim.word2Int#
                                                                  (GHC.Prim.word8ToWord# r#_abhV))
                                                               192#)
                                                            6#)
                                                         (GHC.Prim.word2Int#
                                                            (GHC.Prim.word8ToWord# r#1_abi1)))
                                                      128#))
                                              };
                                            3# ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abhQ (GHC.Prim.+# bx1_abhR 1#)
                                              of r#1_abi2
                                              { __DEFAULT ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abhQ (GHC.Prim.+# bx1_abhR 2#)
                                              of r#2_abi3
                                              { __DEFAULT ->
                                              GHC.Types.C#
                                                (GHC.Prim.chr#
                                                   (GHC.Prim.-#
                                                      (GHC.Prim.+#
                                                         (GHC.Prim.+#
                                                            (GHC.Prim.uncheckedIShiftL#
                                                               (GHC.Prim.-#
                                                                  (GHC.Prim.word2Int#
                                                                     (GHC.Prim.word8ToWord#
                                                                        r#_abhV))
                                                                  224#)
                                                               12#)
                                                            (GHC.Prim.uncheckedIShiftL#
                                                               (GHC.Prim.-#
                                                                  (GHC.Prim.word2Int#
                                                                     (GHC.Prim.word8ToWord#
                                                                        r#1_abi2))
                                                                  128#)
                                                               6#))
                                                         (GHC.Prim.word2Int#
                                                            (GHC.Prim.word8ToWord# r#2_abi3)))
                                                      128#))
                                              }
                                              }
                                          }
                                          },
                                          case Data.Text.compareLength
                                                 (Data.Text.Internal.Text bx_abhQ bx1_abhR bx2_abhS)
                                                 (GHC.Types.I# 1#)
                                          of {
                                            __DEFAULT ->
                                              case GHC.Prim.indexWord8Array# bx_abhQ bx1_abhR
                                              of r#_abi5
                                              { __DEFAULT ->
                                              let {
                                                c#_abi6 :: GHC.Prim.Int#
                                                [LclId,
                                                 Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                         Value=False, ConLike=False, WorkFree=False,
                                                         Expandable=False,
                                                         Guidance=IF_ARGS [] 4 0}]
                                                c#_abi6
                                                  = GHC.Prim.word2Int#
                                                      (GHC.Prim.clz8#
                                                         (GHC.Prim.and#
                                                            (GHC.Prim.not#
                                                               (GHC.Prim.word8ToWord# r#_abi5))
                                                            255##)) } in
                                              let {
                                                y_abi7 :: GHC.Prim.Int#
                                                [LclId,
                                                 Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                         Value=False, ConLike=False, WorkFree=False,
                                                         Expandable=False,
                                                         Guidance=IF_ARGS [] 2 0}]
                                                y_abi7
                                                  = GHC.Prim.xorI#
                                                      c#_abi6 (GHC.Prim.<=# c#_abi6 0#) } in
                                              Data.Text.Internal.Lazy.$WChunk
                                                (Data.Text.Internal.$WText
                                                   (Data.Text.Array.ByteArray bx_abhQ)
                                                   (GHC.Types.I# (GHC.Prim.+# bx1_abhR y_abi7))
                                                   (GHC.Types.I# (GHC.Prim.-# bx2_abhS y_abi7)))
                                                ts_abhT
                                              };
                                            GHC.Types.EQ -> ts_abhT
                                          })
                                   })
                                (let {
                                   f2_abi9
                                     :: Data.Text.Internal.Lazy.Text
                                        -> f_abhF Data.Text.Internal.Lazy.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abi9
                                     = GHC.Base.pure
                                         @f_abhF
                                         $dApplicative_abhH
                                         @Data.Text.Internal.Lazy.Text } in
                                 let {
                                   ds2_abia
                                     :: f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                        -> f_abhF Data.Text.Internal.Lazy.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 100 0}]
                                   ds2_abia
                                     = GHC.Base.fmap
                                         @f_abhF
                                         (GHC.Base.$p1Applicative @f_abhF $dApplicative_abhH)
                                         @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                         @Data.Text.Internal.Lazy.Text
                                         (\ (p1_abib
                                               :: (GHC.Types.Char, Data.Text.Internal.Lazy.Text)) ->
                                            case p1_abib of { (x_abid, ds_abie) ->
                                            Data.Text.Lazy.cons x_abid ds_abie
                                            }) } in
                                 \ (ds3_abig
                                      :: Data.Either.Either
                                           Data.Text.Internal.Lazy.Text
                                           (f_abhF
                                              (GHC.Types.Char, Data.Text.Internal.Lazy.Text))) ->
                                   case ds3_abig of {
                                     Data.Either.Left x_abii -> f2_abi9 x_abii;
                                     Data.Either.Right y_abik -> ds2_abia y_abik
                                   }) } in
                        let {
                          g_abim
                            :: p_abhE
                                 (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                 (f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                               -> p_abhE
                                    (Data.Either.Either
                                       Data.Text.Internal.Lazy.Text
                                       (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                                    (Data.Either.Either
                                       Data.Text.Internal.Lazy.Text
                                       (f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abim
                            = Data.Profunctor.Choice.right'
                                @p_abhE
                                $dChoice_abhG
                                @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                @(f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                                @Data.Text.Internal.Lazy.Text } in
                        \ (x_abin
                             :: p_abhE
                                  (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                  (f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text))) ->
                          f1_abhI (g_abim x_abin))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <Data.Text.Internal.Lazy.Text>_N
                                      <Data.Text.Internal.Lazy.Text>_N
                                      <GHC.Types.Char>_N
                                      <GHC.Types.Char>_N)
                             :: Control.Lens.Type.Prism
                                  Data.Text.Internal.Lazy.Text
                                  Data.Text.Internal.Lazy.Text
                                  (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                  (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                ~R# Control.Lens.Cons.Cons
                                      Data.Text.Internal.Lazy.Text
                                      Data.Text.Internal.Lazy.Text
                                      GHC.Types.Char
                                      GHC.Types.Char)
              ValArg (\ (@(p_abiq :: * -> * -> *))
                        (@(f_abir :: * -> *))
                        ($dChoice_abis :: Data.Profunctor.Choice.Choice p_abiq)
                        ($dApplicative_abit :: GHC.Base.Applicative f_abir) ->
                        let {
                          f1_abiu
                            :: p_abiq
                                 (Data.Either.Either Data.Text.Internal.Lazy.Text ())
                                 (Data.Either.Either Data.Text.Internal.Lazy.Text (f_abir ()))
                               -> p_abiq
                                    Data.Text.Internal.Lazy.Text
                                    (f_abir Data.Text.Internal.Lazy.Text)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 310 0}]
                          f1_abiu
                            = Data.Profunctor.Unsafe.dimap
                                @p_abiq
                                (Data.Profunctor.Choice.$p1Choice @p_abiq $dChoice_abis)
                                @Data.Text.Internal.Lazy.Text
                                @(Data.Either.Either Data.Text.Internal.Lazy.Text ())
                                @(Data.Either.Either Data.Text.Internal.Lazy.Text (f_abir ()))
                                @(f_abir Data.Text.Internal.Lazy.Text)
                                (\ (s_abiv :: Data.Text.Internal.Lazy.Text) ->
                                   case Data.Text.Lazy.null s_abiv of {
                                     GHC.Types.False ->
                                       Data.Either.Left @Data.Text.Internal.Lazy.Text @() s_abiv;
                                     GHC.Types.True ->
                                       Data.Either.Right
                                         @Data.Text.Internal.Lazy.Text @() GHC.Tuple.Prim.()
                                   })
                                (let {
                                   f2_abiy
                                     :: Data.Text.Internal.Lazy.Text
                                        -> f_abir Data.Text.Internal.Lazy.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abiy
                                     = GHC.Base.pure
                                         @f_abir
                                         $dApplicative_abit
                                         @Data.Text.Internal.Lazy.Text } in
                                 let {
                                   ds2_abiz :: f_abir () -> f_abir Data.Text.Internal.Lazy.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 70 0}]
                                   ds2_abiz
                                     = GHC.Base.fmap
                                         @f_abir
                                         (GHC.Base.$p1Applicative @f_abir $dApplicative_abit)
                                         @()
                                         @Data.Text.Internal.Lazy.Text
                                         (\ (ds3_abiA :: ()) ->
                                            case ds3_abiA of { () ->
                                            Data.Text.Internal.Lazy.empty
                                            }) } in
                                 \ (ds3_abiC
                                      :: Data.Either.Either
                                           Data.Text.Internal.Lazy.Text (f_abir ())) ->
                                   case ds3_abiC of {
                                     Data.Either.Left x_abiE -> f2_abiy x_abiE;
                                     Data.Either.Right y_abiG -> ds2_abiz y_abiG
                                   }) } in
                        let {
                          g_abiI
                            :: p_abiq () (f_abir ())
                               -> p_abiq
                                    (Data.Either.Either Data.Text.Internal.Lazy.Text ())
                                    (Data.Either.Either Data.Text.Internal.Lazy.Text (f_abir ()))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abiI
                            = Data.Profunctor.Choice.right'
                                @p_abiq
                                $dChoice_abis
                                @()
                                @(f_abir ())
                                @Data.Text.Internal.Lazy.Text } in
                        \ (x_abiJ :: p_abiq () (f_abir ())) -> f1_abiu (g_abiI x_abiJ))
                     `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                      <Data.Text.Internal.Lazy.Text>_N)
                             :: Control.Lens.Type.Prism' Data.Text.Internal.Lazy.Text ()
                                ~R# Control.Lens.Empty.AsEmpty Data.Text.Internal.Lazy.Text)
              TyArg Data.Functor.Const.Const Data.Text.Internal.Lazy.Text
              ValArg Data.Functor.Contravariant.$fContravariantConst
                       @Data.Text.Internal.Lazy.Text
              ValArg Data.Functor.Const.$fFunctorConst
                       @Data.Text.Internal.Lazy.Text
    After:  (\ (@(f_abdT :: * -> *))
               ($dCons_abdU
                  :: Control.Lens.Cons.Cons
                       GHC.Base.String GHC.Base.String GHC.Types.Char GHC.Types.Char)
               ($dCons1_abdV
                  :: Control.Lens.Cons.Cons
                       Data.Text.Internal.Lazy.Text
                       Data.Text.Internal.Lazy.Text
                       GHC.Types.Char
                       GHC.Types.Char)
               ($dAsEmpty_abdW
                  :: Control.Lens.Empty.AsEmpty Data.Text.Internal.Lazy.Text)
               ($dContravariant_abdX
                  :: Data.Functor.Contravariant.Contravariant f_abdT)
               ($dFunctor_abdY :: GHC.Base.Functor f_abdT) ->
               Data.Profunctor.Unsafe.$fProfunctorFUN_$cdimap
                 @GHC.Base.String
                 @Data.Text.Internal.Lazy.Text
                 @(f_abdT Data.Text.Internal.Lazy.Text)
                 @(f_abdT GHC.Base.String)
                 Data.Text.Lazy.pack
                 (GHC.Base.fmap
                    @f_abdT
                    $dFunctor_abdY
                    @Data.Text.Internal.Lazy.Text
                    @GHC.Base.String
                    Data.Text.Lazy.unpack))
              @(Data.Functor.Const.Const Data.Text.Internal.Lazy.Text)
              ((\ (@(p_abeP :: * -> * -> *))
                  (@(f_abeQ :: * -> *))
                  ($dChoice_abeR :: Data.Profunctor.Choice.Choice p_abeP)
                  ($dApplicative_abeS :: GHC.Base.Applicative f_abeQ) ->
                  let {
                    f1_abeT
                      :: p_abeP
                           (Data.Either.Either
                              [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                           (Data.Either.Either
                              [GHC.Types.Char] (f_abeQ (GHC.Types.Char, [GHC.Types.Char])))
                         -> p_abeP [GHC.Types.Char] (f_abeQ [GHC.Types.Char])
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 320 0}]
                    f1_abeT
                      = Data.Profunctor.Unsafe.dimap
                          @p_abeP
                          (Data.Profunctor.Choice.$p1Choice @p_abeP $dChoice_abeR)
                          @[GHC.Types.Char]
                          @(Data.Either.Either
                              [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                          @(Data.Either.Either
                              [GHC.Types.Char] (f_abeQ (GHC.Types.Char, [GHC.Types.Char])))
                          @(f_abeQ [GHC.Types.Char])
                          (\ (aas_abeU :: [GHC.Types.Char]) ->
                             case aas_abeU of {
                               [] ->
                                 Data.Either.Left
                                   @[GHC.Types.Char]
                                   @(GHC.Types.Char, [GHC.Types.Char])
                                   (GHC.Types.[] @GHC.Types.Char);
                               : a1_abeW as_abeX ->
                                 Data.Either.Right
                                   @[GHC.Types.Char]
                                   @(GHC.Types.Char, [GHC.Types.Char])
                                   (a1_abeW, as_abeX)
                             })
                          (let {
                             f2_abeZ :: [GHC.Types.Char] -> f_abeQ [GHC.Types.Char]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abeZ
                               = GHC.Base.pure @f_abeQ $dApplicative_abeS @[GHC.Types.Char] } in
                           let {
                             ds2_abf0
                               :: f_abeQ (GHC.Types.Char, [GHC.Types.Char])
                                  -> f_abeQ [GHC.Types.Char]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 90 0}]
                             ds2_abf0
                               = GHC.Base.fmap
                                   @f_abeQ
                                   (GHC.Base.$p1Applicative @f_abeQ $dApplicative_abeS)
                                   @(GHC.Types.Char, [GHC.Types.Char])
                                   @[GHC.Types.Char]
                                   (\ (p1_abf1 :: (GHC.Types.Char, [GHC.Types.Char])) ->
                                      GHC.Types.:
                                        @GHC.Types.Char
                                        (case p1_abf1 of { (x_abf3, ds_abf4) -> x_abf3 })
                                        (case p1_abf1 of { (ds_abf7, y_abf8) -> y_abf8 })) } in
                           \ (ds3_abfa
                                :: Data.Either.Either
                                     [GHC.Types.Char]
                                     (f_abeQ (GHC.Types.Char, [GHC.Types.Char]))) ->
                             case ds3_abfa of {
                               Data.Either.Left x_abfc -> f2_abeZ x_abfc;
                               Data.Either.Right y_abfe -> ds2_abf0 y_abfe
                             }) } in
                  let {
                    g_abfg
                      :: p_abeP
                           (GHC.Types.Char, [GHC.Types.Char])
                           (f_abeQ (GHC.Types.Char, [GHC.Types.Char]))
                         -> p_abeP
                              (Data.Either.Either
                                 [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                              (Data.Either.Either
                                 [GHC.Types.Char] (f_abeQ (GHC.Types.Char, [GHC.Types.Char])))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abfg
                      = Data.Profunctor.Choice.right'
                          @p_abeP
                          $dChoice_abeR
                          @(GHC.Types.Char, [GHC.Types.Char])
                          @(f_abeQ (GHC.Types.Char, [GHC.Types.Char]))
                          @[GHC.Types.Char] } in
                  \ (x_abfh
                       :: p_abeP
                            (GHC.Types.Char, [GHC.Types.Char])
                            (f_abeQ (GHC.Types.Char, [GHC.Types.Char]))) ->
                    f1_abeT (g_abfg x_abfh))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <[GHC.Types.Char]>_N
                                <[GHC.Types.Char]>_N
                                <GHC.Types.Char>_N
                                <GHC.Types.Char>_N)
                       :: Control.Lens.Type.Prism
                            [GHC.Types.Char]
                            [GHC.Types.Char]
                            (GHC.Types.Char, [GHC.Types.Char])
                            (GHC.Types.Char, [GHC.Types.Char])
                          ~R# Control.Lens.Cons.Cons
                                [GHC.Types.Char] [GHC.Types.Char] GHC.Types.Char GHC.Types.Char))
              ((\ (@(p_abhE :: * -> * -> *))
                  (@(f_abhF :: * -> *))
                  ($dChoice_abhG :: Data.Profunctor.Choice.Choice p_abhE)
                  ($dApplicative_abhH :: GHC.Base.Applicative f_abhF) ->
                  let {
                    f1_abhI
                      :: p_abhE
                           (Data.Either.Either
                              Data.Text.Internal.Lazy.Text
                              (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                           (Data.Either.Either
                              Data.Text.Internal.Lazy.Text
                              (f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                         -> p_abhE
                              Data.Text.Internal.Lazy.Text (f_abhF Data.Text.Internal.Lazy.Text)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 639 0}]
                    f1_abhI
                      = Data.Profunctor.Unsafe.dimap
                          @p_abhE
                          (Data.Profunctor.Choice.$p1Choice @p_abhE $dChoice_abhG)
                          @Data.Text.Internal.Lazy.Text
                          @(Data.Either.Either
                              Data.Text.Internal.Lazy.Text
                              (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                          @(Data.Either.Either
                              Data.Text.Internal.Lazy.Text
                              (f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                          @(f_abhF Data.Text.Internal.Lazy.Text)
                          (\ (s1_abhJ :: Data.Text.Internal.Lazy.Text) ->
                             case s1_abhJ of {
                               Data.Text.Internal.Lazy.Empty ->
                                 Data.Either.Left
                                   @Data.Text.Internal.Lazy.Text
                                   @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                   Data.Text.Internal.Lazy.Empty;
                               Data.Text.Internal.Lazy.Chunk bx_abhQ bx1_abhR bx2_abhS ts_abhT ->
                                 Data.Either.Right
                                   @Data.Text.Internal.Lazy.Text
                                   @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                   (case GHC.Prim.indexWord8Array# bx_abhQ bx1_abhR of r#_abhV
                                    { __DEFAULT ->
                                    let {
                                      c#_abhW :: GHC.Prim.Int#
                                      [LclId,
                                       Unf=Unf{Src=<vanilla>, TopLvl=False,
                                               Value=False, ConLike=False, WorkFree=False,
                                               Expandable=False,
                                               Guidance=IF_ARGS [] 4 0}]
                                      c#_abhW
                                        = GHC.Prim.word2Int#
                                            (GHC.Prim.clz8#
                                               (GHC.Prim.and#
                                                  (GHC.Prim.not# (GHC.Prim.word8ToWord# r#_abhV))
                                                  255##)) } in
                                    case GHC.Prim.xorI# c#_abhW (GHC.Prim.<=# c#_abhW 0#) of {
                                      __DEFAULT ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abhQ (GHC.Prim.+# bx1_abhR 1#)
                                        of r#1_abhY
                                        { __DEFAULT ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abhQ (GHC.Prim.+# bx1_abhR 2#)
                                        of r#2_abhZ
                                        { __DEFAULT ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abhQ (GHC.Prim.+# bx1_abhR 3#)
                                        of r#3_abi0
                                        { __DEFAULT ->
                                        GHC.Types.C#
                                          (GHC.Prim.chr#
                                             (GHC.Prim.-#
                                                (GHC.Prim.+#
                                                   (GHC.Prim.+#
                                                      (GHC.Prim.+#
                                                         (GHC.Prim.uncheckedIShiftL#
                                                            (GHC.Prim.-#
                                                               (GHC.Prim.word2Int#
                                                                  (GHC.Prim.word8ToWord# r#_abhV))
                                                               240#)
                                                            18#)
                                                         (GHC.Prim.uncheckedIShiftL#
                                                            (GHC.Prim.-#
                                                               (GHC.Prim.word2Int#
                                                                  (GHC.Prim.word8ToWord# r#1_abhY))
                                                               128#)
                                                            12#))
                                                      (GHC.Prim.uncheckedIShiftL#
                                                         (GHC.Prim.-#
                                                            (GHC.Prim.word2Int#
                                                               (GHC.Prim.word8ToWord# r#2_abhZ))
                                                            128#)
                                                         6#))
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.word8ToWord# r#3_abi0)))
                                                128#))
                                        }
                                        }
                                        };
                                      1# ->
                                        GHC.Types.C#
                                          (GHC.Prim.chr#
                                             (GHC.Prim.word2Int# (GHC.Prim.word8ToWord# r#_abhV)));
                                      2# ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abhQ (GHC.Prim.+# bx1_abhR 1#)
                                        of r#1_abi1
                                        { __DEFAULT ->
                                        GHC.Types.C#
                                          (GHC.Prim.chr#
                                             (GHC.Prim.-#
                                                (GHC.Prim.+#
                                                   (GHC.Prim.uncheckedIShiftL#
                                                      (GHC.Prim.-#
                                                         (GHC.Prim.word2Int#
                                                            (GHC.Prim.word8ToWord# r#_abhV))
                                                         192#)
                                                      6#)
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.word8ToWord# r#1_abi1)))
                                                128#))
                                        };
                                      3# ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abhQ (GHC.Prim.+# bx1_abhR 1#)
                                        of r#1_abi2
                                        { __DEFAULT ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abhQ (GHC.Prim.+# bx1_abhR 2#)
                                        of r#2_abi3
                                        { __DEFAULT ->
                                        GHC.Types.C#
                                          (GHC.Prim.chr#
                                             (GHC.Prim.-#
                                                (GHC.Prim.+#
                                                   (GHC.Prim.+#
                                                      (GHC.Prim.uncheckedIShiftL#
                                                         (GHC.Prim.-#
                                                            (GHC.Prim.word2Int#
                                                               (GHC.Prim.word8ToWord# r#_abhV))
                                                            224#)
                                                         12#)
                                                      (GHC.Prim.uncheckedIShiftL#
                                                         (GHC.Prim.-#
                                                            (GHC.Prim.word2Int#
                                                               (GHC.Prim.word8ToWord# r#1_abi2))
                                                            128#)
                                                         6#))
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.word8ToWord# r#2_abi3)))
                                                128#))
                                        }
                                        }
                                    }
                                    },
                                    case Data.Text.compareLength
                                           (Data.Text.Internal.Text bx_abhQ bx1_abhR bx2_abhS)
                                           (GHC.Types.I# 1#)
                                    of {
                                      __DEFAULT ->
                                        case GHC.Prim.indexWord8Array# bx_abhQ bx1_abhR of r#_abi5
                                        { __DEFAULT ->
                                        let {
                                          c#_abi6 :: GHC.Prim.Int#
                                          [LclId,
                                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                   Value=False, ConLike=False, WorkFree=False,
                                                   Expandable=False,
                                                   Guidance=IF_ARGS [] 4 0}]
                                          c#_abi6
                                            = GHC.Prim.word2Int#
                                                (GHC.Prim.clz8#
                                                   (GHC.Prim.and#
                                                      (GHC.Prim.not#
                                                         (GHC.Prim.word8ToWord# r#_abi5))
                                                      255##)) } in
                                        let {
                                          y_abi7 :: GHC.Prim.Int#
                                          [LclId,
                                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                   Value=False, ConLike=False, WorkFree=False,
                                                   Expandable=False,
                                                   Guidance=IF_ARGS [] 2 0}]
                                          y_abi7
                                            = GHC.Prim.xorI# c#_abi6 (GHC.Prim.<=# c#_abi6 0#) } in
                                        Data.Text.Internal.Lazy.$WChunk
                                          (Data.Text.Internal.$WText
                                             (Data.Text.Array.ByteArray bx_abhQ)
                                             (GHC.Types.I# (GHC.Prim.+# bx1_abhR y_abi7))
                                             (GHC.Types.I# (GHC.Prim.-# bx2_abhS y_abi7)))
                                          ts_abhT
                                        };
                                      GHC.Types.EQ -> ts_abhT
                                    })
                             })
                          (let {
                             f2_abi9
                               :: Data.Text.Internal.Lazy.Text
                                  -> f_abhF Data.Text.Internal.Lazy.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abi9
                               = GHC.Base.pure
                                   @f_abhF $dApplicative_abhH @Data.Text.Internal.Lazy.Text } in
                           let {
                             ds2_abia
                               :: f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                  -> f_abhF Data.Text.Internal.Lazy.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 100 0}]
                             ds2_abia
                               = GHC.Base.fmap
                                   @f_abhF
                                   (GHC.Base.$p1Applicative @f_abhF $dApplicative_abhH)
                                   @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                   @Data.Text.Internal.Lazy.Text
                                   (\ (p1_abib :: (GHC.Types.Char, Data.Text.Internal.Lazy.Text)) ->
                                      case p1_abib of { (x_abid, ds_abie) ->
                                      Data.Text.Lazy.cons x_abid ds_abie
                                      }) } in
                           \ (ds3_abig
                                :: Data.Either.Either
                                     Data.Text.Internal.Lazy.Text
                                     (f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text))) ->
                             case ds3_abig of {
                               Data.Either.Left x_abii -> f2_abi9 x_abii;
                               Data.Either.Right y_abik -> ds2_abia y_abik
                             }) } in
                  let {
                    g_abim
                      :: p_abhE
                           (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                           (f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                         -> p_abhE
                              (Data.Either.Either
                                 Data.Text.Internal.Lazy.Text
                                 (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                              (Data.Either.Either
                                 Data.Text.Internal.Lazy.Text
                                 (f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abim
                      = Data.Profunctor.Choice.right'
                          @p_abhE
                          $dChoice_abhG
                          @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                          @(f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                          @Data.Text.Internal.Lazy.Text } in
                  \ (x_abin
                       :: p_abhE
                            (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                            (f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text))) ->
                    f1_abhI (g_abim x_abin))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <Data.Text.Internal.Lazy.Text>_N
                                <Data.Text.Internal.Lazy.Text>_N
                                <GHC.Types.Char>_N
                                <GHC.Types.Char>_N)
                       :: Control.Lens.Type.Prism
                            Data.Text.Internal.Lazy.Text
                            Data.Text.Internal.Lazy.Text
                            (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                            (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                          ~R# Control.Lens.Cons.Cons
                                Data.Text.Internal.Lazy.Text
                                Data.Text.Internal.Lazy.Text
                                GHC.Types.Char
                                GHC.Types.Char))
              ((\ (@(p_abiq :: * -> * -> *))
                  (@(f_abir :: * -> *))
                  ($dChoice_abis :: Data.Profunctor.Choice.Choice p_abiq)
                  ($dApplicative_abit :: GHC.Base.Applicative f_abir) ->
                  let {
                    f1_abiu
                      :: p_abiq
                           (Data.Either.Either Data.Text.Internal.Lazy.Text ())
                           (Data.Either.Either Data.Text.Internal.Lazy.Text (f_abir ()))
                         -> p_abiq
                              Data.Text.Internal.Lazy.Text (f_abir Data.Text.Internal.Lazy.Text)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 310 0}]
                    f1_abiu
                      = Data.Profunctor.Unsafe.dimap
                          @p_abiq
                          (Data.Profunctor.Choice.$p1Choice @p_abiq $dChoice_abis)
                          @Data.Text.Internal.Lazy.Text
                          @(Data.Either.Either Data.Text.Internal.Lazy.Text ())
                          @(Data.Either.Either Data.Text.Internal.Lazy.Text (f_abir ()))
                          @(f_abir Data.Text.Internal.Lazy.Text)
                          (\ (s_abiv :: Data.Text.Internal.Lazy.Text) ->
                             case Data.Text.Lazy.null s_abiv of {
                               GHC.Types.False ->
                                 Data.Either.Left @Data.Text.Internal.Lazy.Text @() s_abiv;
                               GHC.Types.True ->
                                 Data.Either.Right
                                   @Data.Text.Internal.Lazy.Text @() GHC.Tuple.Prim.()
                             })
                          (let {
                             f2_abiy
                               :: Data.Text.Internal.Lazy.Text
                                  -> f_abir Data.Text.Internal.Lazy.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abiy
                               = GHC.Base.pure
                                   @f_abir $dApplicative_abit @Data.Text.Internal.Lazy.Text } in
                           let {
                             ds2_abiz :: f_abir () -> f_abir Data.Text.Internal.Lazy.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 70 0}]
                             ds2_abiz
                               = GHC.Base.fmap
                                   @f_abir
                                   (GHC.Base.$p1Applicative @f_abir $dApplicative_abit)
                                   @()
                                   @Data.Text.Internal.Lazy.Text
                                   (\ (ds3_abiA :: ()) ->
                                      case ds3_abiA of { () -> Data.Text.Internal.Lazy.empty }) } in
                           \ (ds3_abiC
                                :: Data.Either.Either Data.Text.Internal.Lazy.Text (f_abir ())) ->
                             case ds3_abiC of {
                               Data.Either.Left x_abiE -> f2_abiy x_abiE;
                               Data.Either.Right y_abiG -> ds2_abiz y_abiG
                             }) } in
                  let {
                    g_abiI
                      :: p_abiq () (f_abir ())
                         -> p_abiq
                              (Data.Either.Either Data.Text.Internal.Lazy.Text ())
                              (Data.Either.Either Data.Text.Internal.Lazy.Text (f_abir ()))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abiI
                      = Data.Profunctor.Choice.right'
                          @p_abiq
                          $dChoice_abis
                          @()
                          @(f_abir ())
                          @Data.Text.Internal.Lazy.Text } in
                  \ (x_abiJ :: p_abiq () (f_abir ())) -> f1_abiu (g_abiI x_abiJ))
               `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                <Data.Text.Internal.Lazy.Text>_N)
                       :: Control.Lens.Type.Prism' Data.Text.Internal.Lazy.Text ()
                          ~R# Control.Lens.Empty.AsEmpty Data.Text.Internal.Lazy.Text))
              (Data.Functor.Contravariant.$fContravariantConst
                 @Data.Text.Internal.Lazy.Text)
              (Data.Functor.Const.$fFunctorConst @Data.Text.Internal.Lazy.Text)
    Cont:   ApplyToVal nodup hole Control.Lens.Getter.Getting
                                    Data.Text.Internal.Lazy.Text
                                    [GHC.Types.Char]
                                    Data.Text.Internal.Lazy.Text
              ((\ (ds_abdj [Occ=Once1] :: a_abdg) -> ds_abdj)
               `cast` (<a_abdg>_R
                       %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                          <*>_N <a_abdg>_R <a_abdg>_P)
                       :: (a_abdg -> a_abdg)
                          ~R# (a_abdg -> Data.Functor.Const.Const a_abdg a_abdg)))
            ApplyToVal nodup hole [GHC.Types.Char]
                                  -> Data.Functor.Const.Const
                                       Data.Text.Internal.Lazy.Text [GHC.Types.Char]
              s_a8Od
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N <Data.Text.Internal.Lazy.Text>_R <[GHC.Types.Char]>_P
                    :: Data.Functor.Const.Const
                         Data.Text.Internal.Lazy.Text [GHC.Types.Char]
                       ~R# Data.Text.Internal.Lazy.Text)
            Stop[RuleArgCtxt] Data.Text.Internal.Lazy.Text
Rule fired
    Rule: Class op fmap
    Module: (BUILTIN)
    Before: GHC.Base.fmap
              TyArg Data.Functor.Const.Const Data.Text.Internal.Lazy.Text
              ValArg Data.Functor.Const.$fFunctorConst
                       @Data.Text.Internal.Lazy.Text
    After:  (Data.Functor.Const.$fFunctorConst2
               @Data.Text.Internal.Lazy.Text)
            `cast` (forall (a :: <*>_N) (b :: <*>_N).
                    <a -> b>_R
                    %<'GHC.Types.Many>_N ->_R <Data.Functor.Const.Const
                                                 Data.Text.Internal.Lazy.Text a>_R
                    %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                  <*>_N <Data.Text.Internal.Lazy.Text>_R <a>_P
                                              ; Sym (Data.Functor.Const.N:Const[0]
                                                         <*>_N
                                                         <Data.Text.Internal.Lazy.Text>_R
                                                         <b>_P)
                    :: (forall {a} {b}.
                        (a -> b)
                        -> Data.Functor.Const.Const Data.Text.Internal.Lazy.Text a
                        -> Data.Functor.Const.Const Data.Text.Internal.Lazy.Text a)
                       ~R# (forall {a} {b}.
                            (a -> b)
                            -> Data.Functor.Const.Const Data.Text.Internal.Lazy.Text a
                            -> Data.Functor.Const.Const Data.Text.Internal.Lazy.Text b))
    Cont:   ApplyToTy Data.Text.Internal.Lazy.Text
            ApplyToTy GHC.Base.String
            ApplyToVal nodup hole (Data.Text.Internal.Lazy.Text
                                   -> GHC.Base.String)
                                  -> Data.Functor.Const.Const
                                       Data.Text.Internal.Lazy.Text Data.Text.Internal.Lazy.Text
                                  -> Data.Functor.Const.Const
                                       Data.Text.Internal.Lazy.Text GHC.Base.String
              Data.Text.Lazy.unpack
            ApplyToVal nodup hole Data.Functor.Const.Const
                                    Data.Text.Internal.Lazy.Text Data.Text.Internal.Lazy.Text
                                  -> Data.Functor.Const.Const
                                       Data.Text.Internal.Lazy.Text GHC.Base.String
              (bc_abny (ab_abnw x_abnz))
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N <Data.Text.Internal.Lazy.Text>_R <[GHC.Types.Char]>_P
                    :: Data.Functor.Const.Const
                         Data.Text.Internal.Lazy.Text [GHC.Types.Char]
                       ~R# Data.Text.Internal.Lazy.Text)
            Stop[RuleArgCtxt] Data.Text.Internal.Lazy.Text
Rule fired
    Rule: eqString
    Module: (GHC.Base)
    Before: GHC.Classes.==
              TyArg GHC.Base.String
              ValArg GHC.Classes.$fEqList_$s$fEqList1
              ValArg Data.Text.Lazy.unpack (Data.Text.Lazy.pack s_a8Od)
              ValArg s_a8Od
    After:  (\ ($dEq_aaYU :: GHC.Classes.Eq GHC.Base.String) ->
               GHC.Base.eqString)
              GHC.Classes.$fEqList_$s$fEqList1
              ValArg Data.Text.Lazy.unpack (Data.Text.Lazy.pack s_a8Od)
              ValArg s_a8Od
    Cont:   Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: unpack
    Module: (GHC.Base)
    Before: GHC.CString.unpackCString# ValArg "T -> TL -> T"#
    After:  (\ (a_ab5Y :: GHC.Prim.Addr#) ->
               GHC.Base.build
                 @GHC.Types.Char
                 (\ (@b_ab5Z) -> GHC.CString.unpackFoldrCString# @b_ab5Z a_ab5Y))
              "T -> TL -> T"#
    Cont:   Stop[BoringCtxt] Test.Tasty.Core.TestName
Rule fired
    Rule: Class op property
    Module: (BUILTIN)
    Before: Test.QuickCheck.Property.property
              TyArg Data.Text.Internal.Text -> GHC.Types.Bool
              ValArg $dTestable_a97v
    After:  Test.QuickCheck.Property.$fTestableFUN_$cproperty
              @Data.Text.Internal.Text
              @GHC.Types.Bool
              Test.QuickCheck.Instances.Text.$fArbitraryText0
              Data.Text.Show.$fShowText
              Test.QuickCheck.Property.$fTestableBool
    Cont:   ApplyToVal nodup hole (Data.Text.Internal.Text
                                   -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              prop_ab6b
            CastIt (Sym (Test.Tasty.QuickCheck.N:QC[0])
                    :: Test.QuickCheck.Property.Property ~R# Test.Tasty.QuickCheck.QC)
            Stop[BoringCtxt] Test.Tasty.QuickCheck.QC
Rule fired
    Rule: Class op propertyForAllShrinkShow
    Module: (BUILTIN)
    Before: Test.QuickCheck.Property.propertyForAllShrinkShow
              TyArg GHC.Types.Bool ValArg Test.QuickCheck.Property.$fTestableBool
    After:  Test.QuickCheck.Property.$fTestableBool1
            `cast` (forall (a :: <*>_N).
                    <Test.QuickCheck.Gen.Gen a>_R
                    %<'GHC.Types.Many>_N ->_R <a -> [a]>_R
                    %<'GHC.Types.Many>_N ->_R <a -> [GHC.Base.String]>_R
                    %<'GHC.Types.Many>_N ->_R <a -> GHC.Types.Bool>_R
                    %<'GHC.Types.Many>_N ->_R Sym (Test.QuickCheck.Gen.N:Gen[0]
                                                       (Test.QuickCheck.Property.N:Prop[0]))
                                              ; Sym (Test.QuickCheck.Property.N:Property[0])
                    :: (forall {a}.
                        Test.QuickCheck.Gen.Gen a
                        -> (a -> [a])
                        -> (a -> [GHC.Base.String])
                        -> (a -> GHC.Types.Bool)
                        -> Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int
                        -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result)
                       ~R# (forall {a}.
                            Test.QuickCheck.Gen.Gen a
                            -> (a -> [a])
                            -> (a -> [GHC.Base.String])
                            -> (a -> GHC.Types.Bool)
                            -> Test.QuickCheck.Property.Property))
    Cont:   ApplyToTy Data.Text.Internal.Text
            ApplyToVal nodup hole Test.QuickCheck.Gen.Gen
                                    Data.Text.Internal.Text
                                  -> (Data.Text.Internal.Text -> [Data.Text.Internal.Text])
                                  -> (Data.Text.Internal.Text -> [GHC.Base.String])
                                  -> (Data.Text.Internal.Text -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (Test.QuickCheck.Arbitrary.arbitrary @a_ab7T $dArbitrary_ab7V)
            ApplyToVal nodup hole (Data.Text.Internal.Text
                                   -> [Data.Text.Internal.Text])
                                  -> (Data.Text.Internal.Text -> [GHC.Base.String])
                                  -> (Data.Text.Internal.Text -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (Test.QuickCheck.Arbitrary.shrink @a_ab7T $dArbitrary_ab7V)
            ApplyToVal nodup hole (Data.Text.Internal.Text
                                   -> [GHC.Base.String])
                                  -> (Data.Text.Internal.Text -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (let {
                 g_ab7Z [Occ=OnceL1!] :: a_ab7T -> GHC.Base.String
                 [LclId]
                 g_ab7Z = GHC.Show.show @a_ab7T $dShow_ab7W } in
               \ (x_ab80 [Occ=Once1] :: a_ab7T) ->
                 GHC.Types.:
                   @GHC.Base.String (g_ab7Z x_ab80) (GHC.Types.[] @GHC.Base.String))
            ApplyToVal nodup hole (Data.Text.Internal.Text -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              f_ab7Y
            CastIt (Sym (Test.Tasty.QuickCheck.N:QC[0])
                    :: Test.QuickCheck.Property.Property ~R# Test.Tasty.QuickCheck.QC)
            Stop[BoringCtxt] Test.Tasty.QuickCheck.QC
Rule fired
    Rule: Class op arbitrary
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.arbitrary
              TyArg Data.Text.Internal.Text
              ValArg Test.QuickCheck.Instances.Text.$fArbitraryText0
    After:  Test.QuickCheck.Instances.Text.$fArbitraryText3
            `cast` (Sym (Test.QuickCheck.Gen.N:Gen[0]
                             <Data.Text.Internal.Text>_R)
                    :: (Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int -> Data.Text.Internal.Text)
                       ~R# Test.QuickCheck.Gen.Gen Data.Text.Internal.Text)
    Cont:   Stop[BoringCtxt] Test.QuickCheck.Gen.Gen
                               Data.Text.Internal.Text
Rule fired
    Rule: Class op shrink
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.shrink
              TyArg Data.Text.Internal.Text
              ValArg Test.QuickCheck.Instances.Text.$fArbitraryText0
    After:  Test.QuickCheck.Instances.Text.$fArbitraryText0_$cshrink
    Cont:   Stop[BoringCtxt] Data.Text.Internal.Text
                             -> [Data.Text.Internal.Text]
Rule fired
    Rule: Class op show
    Module: (BUILTIN)
    Before: GHC.Show.show
              TyArg Data.Text.Internal.Text ValArg Data.Text.Show.$fShowText
    After:  Data.Text.Show.$fShowText_$cshow
    Cont:   Stop[RhsCtxt(NonRecursive)] Data.Text.Internal.Text
                                        -> GHC.Base.String
Rule fired
    Rule: Class op reader
    Module: (BUILTIN)
    Before: Control.Monad.Reader.Class.reader
              TyArg Data.Text.Internal.Lazy.Text
              TyArg (->) Data.Text.Internal.Lazy.Text
              ValArg Control.Monad.Reader.Class.$fMonadReaderrFUN
                       @Data.Text.Internal.Lazy.Text
    After:  \ (@a_abdo) ->
              GHC.Base.id @(Data.Text.Internal.Lazy.Text -> a_abdo)
    Cont:   ApplyToTy Data.Text.Internal.Text
            ApplyToVal nodup hole (Data.Text.Internal.Lazy.Text
                                   -> Data.Text.Internal.Text)
                                  -> Data.Text.Internal.Lazy.Text -> Data.Text.Internal.Text
              ((l_abdi
                  ((\ (ds_abdj [Occ=Once1] :: a_abdg) -> ds_abdj)
                   `cast` (<a_abdg>_R
                           %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                              <*>_N <a_abdg>_R <a_abdg>_P)
                           :: (a_abdg -> a_abdg)
                              ~R# (a_abdg -> Data.Functor.Const.Const a_abdg a_abdg))))
               `cast` (<s_abde>_R
                       %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                     <*>_N <a_abdg>_R <s_abde>_P
                       :: (s_abde -> Data.Functor.Const.Const a_abdg s_abde)
                          ~R# (s_abde -> a_abdg)))
            ApplyToVal nodup hole Data.Text.Internal.Lazy.Text
                                  -> Data.Text.Internal.Text
              (Control.Lens.Getter.view
                 @Data.Text.Internal.Text
                 @((->) Data.Text.Internal.Text)
                 @Data.Text.Internal.Lazy.Text
                 (Control.Monad.Reader.Class.$fMonadReaderrFUN
                    @Data.Text.Internal.Text)
                 (Control.Lens.Cons.Extras.recons
                    @Data.Text.Internal.Text
                    @GHC.Types.Char
                    @Data.Text.Internal.Lazy.Text
                    Control.Lens.Cons.$fConsTextTextCharChar0
                    Control.Lens.Cons.$fConsTextTextCharChar
                    Control.Lens.Empty.$fAsEmptyText
                    @(Data.Functor.Const.Const Data.Text.Internal.Lazy.Text)
                    (Data.Functor.Contravariant.$fContravariantConst
                       @Data.Text.Internal.Lazy.Text)
                    (Data.Functor.Const.$fFunctorConst @Data.Text.Internal.Lazy.Text))
                 s_a8Oe)
            Stop[RuleArgCtxt] Data.Text.Internal.Text
Rule fired
    Rule: recons/text-strict
    Module: (Control.Lens.Cons.Extras)
    Before: Control.Lens.Cons.Extras.recons
              TyArg Data.Text.Internal.Lazy.Text
              TyArg GHC.Types.Char
              TyArg Data.Text.Internal.Text
              ValArg (\ (@(p_abhE :: * -> * -> *))
                        (@(f_abhF :: * -> *))
                        ($dChoice_abhG :: Data.Profunctor.Choice.Choice p_abhE)
                        ($dApplicative_abhH :: GHC.Base.Applicative f_abhF) ->
                        let {
                          f1_abhI
                            :: p_abhE
                                 (Data.Either.Either
                                    Data.Text.Internal.Lazy.Text
                                    (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                                 (Data.Either.Either
                                    Data.Text.Internal.Lazy.Text
                                    (f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                               -> p_abhE
                                    Data.Text.Internal.Lazy.Text
                                    (f_abhF Data.Text.Internal.Lazy.Text)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 639 0}]
                          f1_abhI
                            = Data.Profunctor.Unsafe.dimap
                                @p_abhE
                                (Data.Profunctor.Choice.$p1Choice @p_abhE $dChoice_abhG)
                                @Data.Text.Internal.Lazy.Text
                                @(Data.Either.Either
                                    Data.Text.Internal.Lazy.Text
                                    (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                                @(Data.Either.Either
                                    Data.Text.Internal.Lazy.Text
                                    (f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                                @(f_abhF Data.Text.Internal.Lazy.Text)
                                (\ (s1_abhJ :: Data.Text.Internal.Lazy.Text) ->
                                   case s1_abhJ of {
                                     Data.Text.Internal.Lazy.Empty ->
                                       Data.Either.Left
                                         @Data.Text.Internal.Lazy.Text
                                         @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                         Data.Text.Internal.Lazy.Empty;
                                     Data.Text.Internal.Lazy.Chunk bx_abhQ bx1_abhR bx2_abhS
                                                                   ts_abhT ->
                                       Data.Either.Right
                                         @Data.Text.Internal.Lazy.Text
                                         @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                         (case GHC.Prim.indexWord8Array# bx_abhQ bx1_abhR of r#_abhV
                                          { __DEFAULT ->
                                          let {
                                            c#_abhW :: GHC.Prim.Int#
                                            [LclId,
                                             Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                     Value=False, ConLike=False, WorkFree=False,
                                                     Expandable=False,
                                                     Guidance=IF_ARGS [] 4 0}]
                                            c#_abhW
                                              = GHC.Prim.word2Int#
                                                  (GHC.Prim.clz8#
                                                     (GHC.Prim.and#
                                                        (GHC.Prim.not#
                                                           (GHC.Prim.word8ToWord# r#_abhV))
                                                        255##)) } in
                                          case GHC.Prim.xorI# c#_abhW (GHC.Prim.<=# c#_abhW 0#) of {
                                            __DEFAULT ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abhQ (GHC.Prim.+# bx1_abhR 1#)
                                              of r#1_abhY
                                              { __DEFAULT ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abhQ (GHC.Prim.+# bx1_abhR 2#)
                                              of r#2_abhZ
                                              { __DEFAULT ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abhQ (GHC.Prim.+# bx1_abhR 3#)
                                              of r#3_abi0
                                              { __DEFAULT ->
                                              GHC.Types.C#
                                                (GHC.Prim.chr#
                                                   (GHC.Prim.-#
                                                      (GHC.Prim.+#
                                                         (GHC.Prim.+#
                                                            (GHC.Prim.+#
                                                               (GHC.Prim.uncheckedIShiftL#
                                                                  (GHC.Prim.-#
                                                                     (GHC.Prim.word2Int#
                                                                        (GHC.Prim.word8ToWord#
                                                                           r#_abhV))
                                                                     240#)
                                                                  18#)
                                                               (GHC.Prim.uncheckedIShiftL#
                                                                  (GHC.Prim.-#
                                                                     (GHC.Prim.word2Int#
                                                                        (GHC.Prim.word8ToWord#
                                                                           r#1_abhY))
                                                                     128#)
                                                                  12#))
                                                            (GHC.Prim.uncheckedIShiftL#
                                                               (GHC.Prim.-#
                                                                  (GHC.Prim.word2Int#
                                                                     (GHC.Prim.word8ToWord#
                                                                        r#2_abhZ))
                                                                  128#)
                                                               6#))
                                                         (GHC.Prim.word2Int#
                                                            (GHC.Prim.word8ToWord# r#3_abi0)))
                                                      128#))
                                              }
                                              }
                                              };
                                            1# ->
                                              GHC.Types.C#
                                                (GHC.Prim.chr#
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.word8ToWord# r#_abhV)));
                                            2# ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abhQ (GHC.Prim.+# bx1_abhR 1#)
                                              of r#1_abi1
                                              { __DEFAULT ->
                                              GHC.Types.C#
                                                (GHC.Prim.chr#
                                                   (GHC.Prim.-#
                                                      (GHC.Prim.+#
                                                         (GHC.Prim.uncheckedIShiftL#
                                                            (GHC.Prim.-#
                                                               (GHC.Prim.word2Int#
                                                                  (GHC.Prim.word8ToWord# r#_abhV))
                                                               192#)
                                                            6#)
                                                         (GHC.Prim.word2Int#
                                                            (GHC.Prim.word8ToWord# r#1_abi1)))
                                                      128#))
                                              };
                                            3# ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abhQ (GHC.Prim.+# bx1_abhR 1#)
                                              of r#1_abi2
                                              { __DEFAULT ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abhQ (GHC.Prim.+# bx1_abhR 2#)
                                              of r#2_abi3
                                              { __DEFAULT ->
                                              GHC.Types.C#
                                                (GHC.Prim.chr#
                                                   (GHC.Prim.-#
                                                      (GHC.Prim.+#
                                                         (GHC.Prim.+#
                                                            (GHC.Prim.uncheckedIShiftL#
                                                               (GHC.Prim.-#
                                                                  (GHC.Prim.word2Int#
                                                                     (GHC.Prim.word8ToWord#
                                                                        r#_abhV))
                                                                  224#)
                                                               12#)
                                                            (GHC.Prim.uncheckedIShiftL#
                                                               (GHC.Prim.-#
                                                                  (GHC.Prim.word2Int#
                                                                     (GHC.Prim.word8ToWord#
                                                                        r#1_abi2))
                                                                  128#)
                                                               6#))
                                                         (GHC.Prim.word2Int#
                                                            (GHC.Prim.word8ToWord# r#2_abi3)))
                                                      128#))
                                              }
                                              }
                                          }
                                          },
                                          case Data.Text.compareLength
                                                 (Data.Text.Internal.Text bx_abhQ bx1_abhR bx2_abhS)
                                                 (GHC.Types.I# 1#)
                                          of {
                                            __DEFAULT ->
                                              case GHC.Prim.indexWord8Array# bx_abhQ bx1_abhR
                                              of r#_abi5
                                              { __DEFAULT ->
                                              let {
                                                c#_abi6 :: GHC.Prim.Int#
                                                [LclId,
                                                 Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                         Value=False, ConLike=False, WorkFree=False,
                                                         Expandable=False,
                                                         Guidance=IF_ARGS [] 4 0}]
                                                c#_abi6
                                                  = GHC.Prim.word2Int#
                                                      (GHC.Prim.clz8#
                                                         (GHC.Prim.and#
                                                            (GHC.Prim.not#
                                                               (GHC.Prim.word8ToWord# r#_abi5))
                                                            255##)) } in
                                              let {
                                                y_abi7 :: GHC.Prim.Int#
                                                [LclId,
                                                 Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                         Value=False, ConLike=False, WorkFree=False,
                                                         Expandable=False,
                                                         Guidance=IF_ARGS [] 2 0}]
                                                y_abi7
                                                  = GHC.Prim.xorI#
                                                      c#_abi6 (GHC.Prim.<=# c#_abi6 0#) } in
                                              Data.Text.Internal.Lazy.$WChunk
                                                (Data.Text.Internal.$WText
                                                   (Data.Text.Array.ByteArray bx_abhQ)
                                                   (GHC.Types.I# (GHC.Prim.+# bx1_abhR y_abi7))
                                                   (GHC.Types.I# (GHC.Prim.-# bx2_abhS y_abi7)))
                                                ts_abhT
                                              };
                                            GHC.Types.EQ -> ts_abhT
                                          })
                                   })
                                (let {
                                   f2_abi9
                                     :: Data.Text.Internal.Lazy.Text
                                        -> f_abhF Data.Text.Internal.Lazy.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abi9
                                     = GHC.Base.pure
                                         @f_abhF
                                         $dApplicative_abhH
                                         @Data.Text.Internal.Lazy.Text } in
                                 let {
                                   ds2_abia
                                     :: f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                        -> f_abhF Data.Text.Internal.Lazy.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 100 0}]
                                   ds2_abia
                                     = GHC.Base.fmap
                                         @f_abhF
                                         (GHC.Base.$p1Applicative @f_abhF $dApplicative_abhH)
                                         @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                         @Data.Text.Internal.Lazy.Text
                                         (\ (p1_abib
                                               :: (GHC.Types.Char, Data.Text.Internal.Lazy.Text)) ->
                                            case p1_abib of { (x_abid, ds_abie) ->
                                            Data.Text.Lazy.cons x_abid ds_abie
                                            }) } in
                                 \ (ds3_abig
                                      :: Data.Either.Either
                                           Data.Text.Internal.Lazy.Text
                                           (f_abhF
                                              (GHC.Types.Char, Data.Text.Internal.Lazy.Text))) ->
                                   case ds3_abig of {
                                     Data.Either.Left x_abii -> f2_abi9 x_abii;
                                     Data.Either.Right y_abik -> ds2_abia y_abik
                                   }) } in
                        let {
                          g_abim
                            :: p_abhE
                                 (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                 (f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                               -> p_abhE
                                    (Data.Either.Either
                                       Data.Text.Internal.Lazy.Text
                                       (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                                    (Data.Either.Either
                                       Data.Text.Internal.Lazy.Text
                                       (f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abim
                            = Data.Profunctor.Choice.right'
                                @p_abhE
                                $dChoice_abhG
                                @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                @(f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                                @Data.Text.Internal.Lazy.Text } in
                        \ (x_abin
                             :: p_abhE
                                  (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                  (f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text))) ->
                          f1_abhI (g_abim x_abin))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <Data.Text.Internal.Lazy.Text>_N
                                      <Data.Text.Internal.Lazy.Text>_N
                                      <GHC.Types.Char>_N
                                      <GHC.Types.Char>_N)
                             :: Control.Lens.Type.Prism
                                  Data.Text.Internal.Lazy.Text
                                  Data.Text.Internal.Lazy.Text
                                  (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                  (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                ~R# Control.Lens.Cons.Cons
                                      Data.Text.Internal.Lazy.Text
                                      Data.Text.Internal.Lazy.Text
                                      GHC.Types.Char
                                      GHC.Types.Char)
              ValArg (\ (@(p_abgP :: * -> * -> *))
                        (@(f_abgQ :: * -> *))
                        ($dChoice_abgR :: Data.Profunctor.Choice.Choice p_abgP)
                        ($dApplicative_abgS :: GHC.Base.Applicative f_abgQ) ->
                        let {
                          f1_abgT
                            :: p_abgP
                                 (Data.Either.Either
                                    Data.Text.Internal.Text
                                    (GHC.Types.Char, Data.Text.Internal.Text))
                                 (Data.Either.Either
                                    Data.Text.Internal.Text
                                    (f_abgQ (GHC.Types.Char, Data.Text.Internal.Text)))
                               -> p_abgP Data.Text.Internal.Text (f_abgQ Data.Text.Internal.Text)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 340 0}]
                          f1_abgT
                            = Data.Profunctor.Unsafe.dimap
                                @p_abgP
                                (Data.Profunctor.Choice.$p1Choice @p_abgP $dChoice_abgR)
                                @Data.Text.Internal.Text
                                @(Data.Either.Either
                                    Data.Text.Internal.Text
                                    (GHC.Types.Char, Data.Text.Internal.Text))
                                @(Data.Either.Either
                                    Data.Text.Internal.Text
                                    (f_abgQ (GHC.Types.Char, Data.Text.Internal.Text)))
                                @(f_abgQ Data.Text.Internal.Text)
                                (\ (s1_abgU :: Data.Text.Internal.Text) ->
                                   case Data.Text.uncons s1_abgU of {
                                     GHC.Maybe.Nothing ->
                                       Data.Either.Left
                                         @Data.Text.Internal.Text
                                         @(GHC.Types.Char, Data.Text.Internal.Text)
                                         s1_abgU;
                                     GHC.Maybe.Just x_abgX ->
                                       Data.Either.Right
                                         @Data.Text.Internal.Text
                                         @(GHC.Types.Char, Data.Text.Internal.Text)
                                         x_abgX
                                   })
                                (let {
                                   f2_abgZ
                                     :: Data.Text.Internal.Text -> f_abgQ Data.Text.Internal.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abgZ
                                     = GHC.Base.pure
                                         @f_abgQ $dApplicative_abgS @Data.Text.Internal.Text } in
                                 let {
                                   ds2_abh0
                                     :: f_abgQ (GHC.Types.Char, Data.Text.Internal.Text)
                                        -> f_abgQ Data.Text.Internal.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 100 0}]
                                   ds2_abh0
                                     = GHC.Base.fmap
                                         @f_abgQ
                                         (GHC.Base.$p1Applicative @f_abgQ $dApplicative_abgS)
                                         @(GHC.Types.Char, Data.Text.Internal.Text)
                                         @Data.Text.Internal.Text
                                         (\ (p1_abh1
                                               :: (GHC.Types.Char, Data.Text.Internal.Text)) ->
                                            case p1_abh1 of { (x_abh3, ds_abh4) ->
                                            Data.Text.cons x_abh3 ds_abh4
                                            }) } in
                                 \ (ds3_abh6
                                      :: Data.Either.Either
                                           Data.Text.Internal.Text
                                           (f_abgQ (GHC.Types.Char, Data.Text.Internal.Text))) ->
                                   case ds3_abh6 of {
                                     Data.Either.Left x_abh8 -> f2_abgZ x_abh8;
                                     Data.Either.Right y_abha -> ds2_abh0 y_abha
                                   }) } in
                        let {
                          g_abhc
                            :: p_abgP
                                 (GHC.Types.Char, Data.Text.Internal.Text)
                                 (f_abgQ (GHC.Types.Char, Data.Text.Internal.Text))
                               -> p_abgP
                                    (Data.Either.Either
                                       Data.Text.Internal.Text
                                       (GHC.Types.Char, Data.Text.Internal.Text))
                                    (Data.Either.Either
                                       Data.Text.Internal.Text
                                       (f_abgQ (GHC.Types.Char, Data.Text.Internal.Text)))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abhc
                            = Data.Profunctor.Choice.right'
                                @p_abgP
                                $dChoice_abgR
                                @(GHC.Types.Char, Data.Text.Internal.Text)
                                @(f_abgQ (GHC.Types.Char, Data.Text.Internal.Text))
                                @Data.Text.Internal.Text } in
                        \ (x_abhd
                             :: p_abgP
                                  (GHC.Types.Char, Data.Text.Internal.Text)
                                  (f_abgQ (GHC.Types.Char, Data.Text.Internal.Text))) ->
                          f1_abgT (g_abhc x_abhd))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <Data.Text.Internal.Text>_N
                                      <Data.Text.Internal.Text>_N
                                      <GHC.Types.Char>_N
                                      <GHC.Types.Char>_N)
                             :: Control.Lens.Type.Prism
                                  Data.Text.Internal.Text
                                  Data.Text.Internal.Text
                                  (GHC.Types.Char, Data.Text.Internal.Text)
                                  (GHC.Types.Char, Data.Text.Internal.Text)
                                ~R# Control.Lens.Cons.Cons
                                      Data.Text.Internal.Text
                                      Data.Text.Internal.Text
                                      GHC.Types.Char
                                      GHC.Types.Char)
              ValArg (\ (@(p_abhe :: * -> * -> *))
                        (@(f_abhf :: * -> *))
                        ($dChoice_abhg :: Data.Profunctor.Choice.Choice p_abhe)
                        ($dApplicative_abhh :: GHC.Base.Applicative f_abhf) ->
                        let {
                          f1_abhi
                            :: p_abhe
                                 (Data.Either.Either Data.Text.Internal.Text ())
                                 (Data.Either.Either Data.Text.Internal.Text (f_abhf ()))
                               -> p_abhe Data.Text.Internal.Text (f_abhf Data.Text.Internal.Text)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 310 0}]
                          f1_abhi
                            = Data.Profunctor.Unsafe.dimap
                                @p_abhe
                                (Data.Profunctor.Choice.$p1Choice @p_abhe $dChoice_abhg)
                                @Data.Text.Internal.Text
                                @(Data.Either.Either Data.Text.Internal.Text ())
                                @(Data.Either.Either Data.Text.Internal.Text (f_abhf ()))
                                @(f_abhf Data.Text.Internal.Text)
                                (\ (s_abhj :: Data.Text.Internal.Text) ->
                                   case Data.Text.null s_abhj of {
                                     GHC.Types.False ->
                                       Data.Either.Left @Data.Text.Internal.Text @() s_abhj;
                                     GHC.Types.True ->
                                       Data.Either.Right
                                         @Data.Text.Internal.Text @() GHC.Tuple.Prim.()
                                   })
                                (let {
                                   f2_abhm
                                     :: Data.Text.Internal.Text -> f_abhf Data.Text.Internal.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abhm
                                     = GHC.Base.pure
                                         @f_abhf $dApplicative_abhh @Data.Text.Internal.Text } in
                                 let {
                                   ds2_abhn :: f_abhf () -> f_abhf Data.Text.Internal.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 70 0}]
                                   ds2_abhn
                                     = GHC.Base.fmap
                                         @f_abhf
                                         (GHC.Base.$p1Applicative @f_abhf $dApplicative_abhh)
                                         @()
                                         @Data.Text.Internal.Text
                                         (\ (ds3_abho :: ()) ->
                                            case ds3_abho of { () ->
                                            Data.Text.Internal.empty
                                            }) } in
                                 \ (ds3_abhq
                                      :: Data.Either.Either Data.Text.Internal.Text (f_abhf ())) ->
                                   case ds3_abhq of {
                                     Data.Either.Left x_abhs -> f2_abhm x_abhs;
                                     Data.Either.Right y_abhu -> ds2_abhn y_abhu
                                   }) } in
                        let {
                          g_abhw
                            :: p_abhe () (f_abhf ())
                               -> p_abhe
                                    (Data.Either.Either Data.Text.Internal.Text ())
                                    (Data.Either.Either Data.Text.Internal.Text (f_abhf ()))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abhw
                            = Data.Profunctor.Choice.right'
                                @p_abhe
                                $dChoice_abhg
                                @()
                                @(f_abhf ())
                                @Data.Text.Internal.Text } in
                        \ (x_abhx :: p_abhe () (f_abhf ())) -> f1_abhi (g_abhw x_abhx))
                     `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                      <Data.Text.Internal.Text>_N)
                             :: Control.Lens.Type.Prism' Data.Text.Internal.Text ()
                                ~R# Control.Lens.Empty.AsEmpty Data.Text.Internal.Text)
              TyArg Data.Functor.Const.Const Data.Text.Internal.Text
              ValArg Data.Functor.Contravariant.$fContravariantConst
                       @Data.Text.Internal.Text
              ValArg Data.Functor.Const.$fFunctorConst @Data.Text.Internal.Text
    After:  (\ (@(f_abdB :: * -> *))
               ($dCons_abdC
                  :: Control.Lens.Cons.Cons
                       Data.Text.Internal.Lazy.Text
                       Data.Text.Internal.Lazy.Text
                       GHC.Types.Char
                       GHC.Types.Char)
               ($dCons1_abdD
                  :: Control.Lens.Cons.Cons
                       Data.Text.Internal.Text
                       Data.Text.Internal.Text
                       GHC.Types.Char
                       GHC.Types.Char)
               ($dAsEmpty_abdE
                  :: Control.Lens.Empty.AsEmpty Data.Text.Internal.Text)
               ($dContravariant_abdF
                  :: Data.Functor.Contravariant.Contravariant f_abdB)
               ($dFunctor_abdG :: GHC.Base.Functor f_abdB) ->
               Data.Profunctor.Unsafe.$fProfunctorFUN_$cdimap
                 @Data.Text.Internal.Lazy.Text
                 @Data.Text.Internal.Text
                 @(f_abdB Data.Text.Internal.Text)
                 @(f_abdB Data.Text.Internal.Lazy.Text)
                 Data.Text.Lazy.toStrict
                 (GHC.Base.fmap
                    @f_abdB
                    $dFunctor_abdG
                    @Data.Text.Internal.Text
                    @Data.Text.Internal.Lazy.Text
                    Data.Text.Lazy.fromStrict))
              @(Data.Functor.Const.Const Data.Text.Internal.Text)
              ((\ (@(p_abhE :: * -> * -> *))
                  (@(f_abhF :: * -> *))
                  ($dChoice_abhG :: Data.Profunctor.Choice.Choice p_abhE)
                  ($dApplicative_abhH :: GHC.Base.Applicative f_abhF) ->
                  let {
                    f1_abhI
                      :: p_abhE
                           (Data.Either.Either
                              Data.Text.Internal.Lazy.Text
                              (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                           (Data.Either.Either
                              Data.Text.Internal.Lazy.Text
                              (f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                         -> p_abhE
                              Data.Text.Internal.Lazy.Text (f_abhF Data.Text.Internal.Lazy.Text)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 639 0}]
                    f1_abhI
                      = Data.Profunctor.Unsafe.dimap
                          @p_abhE
                          (Data.Profunctor.Choice.$p1Choice @p_abhE $dChoice_abhG)
                          @Data.Text.Internal.Lazy.Text
                          @(Data.Either.Either
                              Data.Text.Internal.Lazy.Text
                              (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                          @(Data.Either.Either
                              Data.Text.Internal.Lazy.Text
                              (f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                          @(f_abhF Data.Text.Internal.Lazy.Text)
                          (\ (s1_abhJ :: Data.Text.Internal.Lazy.Text) ->
                             case s1_abhJ of {
                               Data.Text.Internal.Lazy.Empty ->
                                 Data.Either.Left
                                   @Data.Text.Internal.Lazy.Text
                                   @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                   Data.Text.Internal.Lazy.Empty;
                               Data.Text.Internal.Lazy.Chunk bx_abhQ bx1_abhR bx2_abhS ts_abhT ->
                                 Data.Either.Right
                                   @Data.Text.Internal.Lazy.Text
                                   @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                   (case GHC.Prim.indexWord8Array# bx_abhQ bx1_abhR of r#_abhV
                                    { __DEFAULT ->
                                    let {
                                      c#_abhW :: GHC.Prim.Int#
                                      [LclId,
                                       Unf=Unf{Src=<vanilla>, TopLvl=False,
                                               Value=False, ConLike=False, WorkFree=False,
                                               Expandable=False,
                                               Guidance=IF_ARGS [] 4 0}]
                                      c#_abhW
                                        = GHC.Prim.word2Int#
                                            (GHC.Prim.clz8#
                                               (GHC.Prim.and#
                                                  (GHC.Prim.not# (GHC.Prim.word8ToWord# r#_abhV))
                                                  255##)) } in
                                    case GHC.Prim.xorI# c#_abhW (GHC.Prim.<=# c#_abhW 0#) of {
                                      __DEFAULT ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abhQ (GHC.Prim.+# bx1_abhR 1#)
                                        of r#1_abhY
                                        { __DEFAULT ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abhQ (GHC.Prim.+# bx1_abhR 2#)
                                        of r#2_abhZ
                                        { __DEFAULT ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abhQ (GHC.Prim.+# bx1_abhR 3#)
                                        of r#3_abi0
                                        { __DEFAULT ->
                                        GHC.Types.C#
                                          (GHC.Prim.chr#
                                             (GHC.Prim.-#
                                                (GHC.Prim.+#
                                                   (GHC.Prim.+#
                                                      (GHC.Prim.+#
                                                         (GHC.Prim.uncheckedIShiftL#
                                                            (GHC.Prim.-#
                                                               (GHC.Prim.word2Int#
                                                                  (GHC.Prim.word8ToWord# r#_abhV))
                                                               240#)
                                                            18#)
                                                         (GHC.Prim.uncheckedIShiftL#
                                                            (GHC.Prim.-#
                                                               (GHC.Prim.word2Int#
                                                                  (GHC.Prim.word8ToWord# r#1_abhY))
                                                               128#)
                                                            12#))
                                                      (GHC.Prim.uncheckedIShiftL#
                                                         (GHC.Prim.-#
                                                            (GHC.Prim.word2Int#
                                                               (GHC.Prim.word8ToWord# r#2_abhZ))
                                                            128#)
                                                         6#))
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.word8ToWord# r#3_abi0)))
                                                128#))
                                        }
                                        }
                                        };
                                      1# ->
                                        GHC.Types.C#
                                          (GHC.Prim.chr#
                                             (GHC.Prim.word2Int# (GHC.Prim.word8ToWord# r#_abhV)));
                                      2# ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abhQ (GHC.Prim.+# bx1_abhR 1#)
                                        of r#1_abi1
                                        { __DEFAULT ->
                                        GHC.Types.C#
                                          (GHC.Prim.chr#
                                             (GHC.Prim.-#
                                                (GHC.Prim.+#
                                                   (GHC.Prim.uncheckedIShiftL#
                                                      (GHC.Prim.-#
                                                         (GHC.Prim.word2Int#
                                                            (GHC.Prim.word8ToWord# r#_abhV))
                                                         192#)
                                                      6#)
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.word8ToWord# r#1_abi1)))
                                                128#))
                                        };
                                      3# ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abhQ (GHC.Prim.+# bx1_abhR 1#)
                                        of r#1_abi2
                                        { __DEFAULT ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abhQ (GHC.Prim.+# bx1_abhR 2#)
                                        of r#2_abi3
                                        { __DEFAULT ->
                                        GHC.Types.C#
                                          (GHC.Prim.chr#
                                             (GHC.Prim.-#
                                                (GHC.Prim.+#
                                                   (GHC.Prim.+#
                                                      (GHC.Prim.uncheckedIShiftL#
                                                         (GHC.Prim.-#
                                                            (GHC.Prim.word2Int#
                                                               (GHC.Prim.word8ToWord# r#_abhV))
                                                            224#)
                                                         12#)
                                                      (GHC.Prim.uncheckedIShiftL#
                                                         (GHC.Prim.-#
                                                            (GHC.Prim.word2Int#
                                                               (GHC.Prim.word8ToWord# r#1_abi2))
                                                            128#)
                                                         6#))
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.word8ToWord# r#2_abi3)))
                                                128#))
                                        }
                                        }
                                    }
                                    },
                                    case Data.Text.compareLength
                                           (Data.Text.Internal.Text bx_abhQ bx1_abhR bx2_abhS)
                                           (GHC.Types.I# 1#)
                                    of {
                                      __DEFAULT ->
                                        case GHC.Prim.indexWord8Array# bx_abhQ bx1_abhR of r#_abi5
                                        { __DEFAULT ->
                                        let {
                                          c#_abi6 :: GHC.Prim.Int#
                                          [LclId,
                                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                   Value=False, ConLike=False, WorkFree=False,
                                                   Expandable=False,
                                                   Guidance=IF_ARGS [] 4 0}]
                                          c#_abi6
                                            = GHC.Prim.word2Int#
                                                (GHC.Prim.clz8#
                                                   (GHC.Prim.and#
                                                      (GHC.Prim.not#
                                                         (GHC.Prim.word8ToWord# r#_abi5))
                                                      255##)) } in
                                        let {
                                          y_abi7 :: GHC.Prim.Int#
                                          [LclId,
                                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                   Value=False, ConLike=False, WorkFree=False,
                                                   Expandable=False,
                                                   Guidance=IF_ARGS [] 2 0}]
                                          y_abi7
                                            = GHC.Prim.xorI# c#_abi6 (GHC.Prim.<=# c#_abi6 0#) } in
                                        Data.Text.Internal.Lazy.$WChunk
                                          (Data.Text.Internal.$WText
                                             (Data.Text.Array.ByteArray bx_abhQ)
                                             (GHC.Types.I# (GHC.Prim.+# bx1_abhR y_abi7))
                                             (GHC.Types.I# (GHC.Prim.-# bx2_abhS y_abi7)))
                                          ts_abhT
                                        };
                                      GHC.Types.EQ -> ts_abhT
                                    })
                             })
                          (let {
                             f2_abi9
                               :: Data.Text.Internal.Lazy.Text
                                  -> f_abhF Data.Text.Internal.Lazy.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abi9
                               = GHC.Base.pure
                                   @f_abhF $dApplicative_abhH @Data.Text.Internal.Lazy.Text } in
                           let {
                             ds2_abia
                               :: f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                  -> f_abhF Data.Text.Internal.Lazy.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 100 0}]
                             ds2_abia
                               = GHC.Base.fmap
                                   @f_abhF
                                   (GHC.Base.$p1Applicative @f_abhF $dApplicative_abhH)
                                   @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                   @Data.Text.Internal.Lazy.Text
                                   (\ (p1_abib :: (GHC.Types.Char, Data.Text.Internal.Lazy.Text)) ->
                                      case p1_abib of { (x_abid, ds_abie) ->
                                      Data.Text.Lazy.cons x_abid ds_abie
                                      }) } in
                           \ (ds3_abig
                                :: Data.Either.Either
                                     Data.Text.Internal.Lazy.Text
                                     (f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text))) ->
                             case ds3_abig of {
                               Data.Either.Left x_abii -> f2_abi9 x_abii;
                               Data.Either.Right y_abik -> ds2_abia y_abik
                             }) } in
                  let {
                    g_abim
                      :: p_abhE
                           (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                           (f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                         -> p_abhE
                              (Data.Either.Either
                                 Data.Text.Internal.Lazy.Text
                                 (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                              (Data.Either.Either
                                 Data.Text.Internal.Lazy.Text
                                 (f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abim
                      = Data.Profunctor.Choice.right'
                          @p_abhE
                          $dChoice_abhG
                          @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                          @(f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                          @Data.Text.Internal.Lazy.Text } in
                  \ (x_abin
                       :: p_abhE
                            (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                            (f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text))) ->
                    f1_abhI (g_abim x_abin))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <Data.Text.Internal.Lazy.Text>_N
                                <Data.Text.Internal.Lazy.Text>_N
                                <GHC.Types.Char>_N
                                <GHC.Types.Char>_N)
                       :: Control.Lens.Type.Prism
                            Data.Text.Internal.Lazy.Text
                            Data.Text.Internal.Lazy.Text
                            (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                            (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                          ~R# Control.Lens.Cons.Cons
                                Data.Text.Internal.Lazy.Text
                                Data.Text.Internal.Lazy.Text
                                GHC.Types.Char
                                GHC.Types.Char))
              ((\ (@(p_abgP :: * -> * -> *))
                  (@(f_abgQ :: * -> *))
                  ($dChoice_abgR :: Data.Profunctor.Choice.Choice p_abgP)
                  ($dApplicative_abgS :: GHC.Base.Applicative f_abgQ) ->
                  let {
                    f1_abgT
                      :: p_abgP
                           (Data.Either.Either
                              Data.Text.Internal.Text (GHC.Types.Char, Data.Text.Internal.Text))
                           (Data.Either.Either
                              Data.Text.Internal.Text
                              (f_abgQ (GHC.Types.Char, Data.Text.Internal.Text)))
                         -> p_abgP Data.Text.Internal.Text (f_abgQ Data.Text.Internal.Text)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 340 0}]
                    f1_abgT
                      = Data.Profunctor.Unsafe.dimap
                          @p_abgP
                          (Data.Profunctor.Choice.$p1Choice @p_abgP $dChoice_abgR)
                          @Data.Text.Internal.Text
                          @(Data.Either.Either
                              Data.Text.Internal.Text (GHC.Types.Char, Data.Text.Internal.Text))
                          @(Data.Either.Either
                              Data.Text.Internal.Text
                              (f_abgQ (GHC.Types.Char, Data.Text.Internal.Text)))
                          @(f_abgQ Data.Text.Internal.Text)
                          (\ (s1_abgU :: Data.Text.Internal.Text) ->
                             case Data.Text.uncons s1_abgU of {
                               GHC.Maybe.Nothing ->
                                 Data.Either.Left
                                   @Data.Text.Internal.Text
                                   @(GHC.Types.Char, Data.Text.Internal.Text)
                                   s1_abgU;
                               GHC.Maybe.Just x_abgX ->
                                 Data.Either.Right
                                   @Data.Text.Internal.Text
                                   @(GHC.Types.Char, Data.Text.Internal.Text)
                                   x_abgX
                             })
                          (let {
                             f2_abgZ
                               :: Data.Text.Internal.Text -> f_abgQ Data.Text.Internal.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abgZ
                               = GHC.Base.pure
                                   @f_abgQ $dApplicative_abgS @Data.Text.Internal.Text } in
                           let {
                             ds2_abh0
                               :: f_abgQ (GHC.Types.Char, Data.Text.Internal.Text)
                                  -> f_abgQ Data.Text.Internal.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 100 0}]
                             ds2_abh0
                               = GHC.Base.fmap
                                   @f_abgQ
                                   (GHC.Base.$p1Applicative @f_abgQ $dApplicative_abgS)
                                   @(GHC.Types.Char, Data.Text.Internal.Text)
                                   @Data.Text.Internal.Text
                                   (\ (p1_abh1 :: (GHC.Types.Char, Data.Text.Internal.Text)) ->
                                      case p1_abh1 of { (x_abh3, ds_abh4) ->
                                      Data.Text.cons x_abh3 ds_abh4
                                      }) } in
                           \ (ds3_abh6
                                :: Data.Either.Either
                                     Data.Text.Internal.Text
                                     (f_abgQ (GHC.Types.Char, Data.Text.Internal.Text))) ->
                             case ds3_abh6 of {
                               Data.Either.Left x_abh8 -> f2_abgZ x_abh8;
                               Data.Either.Right y_abha -> ds2_abh0 y_abha
                             }) } in
                  let {
                    g_abhc
                      :: p_abgP
                           (GHC.Types.Char, Data.Text.Internal.Text)
                           (f_abgQ (GHC.Types.Char, Data.Text.Internal.Text))
                         -> p_abgP
                              (Data.Either.Either
                                 Data.Text.Internal.Text (GHC.Types.Char, Data.Text.Internal.Text))
                              (Data.Either.Either
                                 Data.Text.Internal.Text
                                 (f_abgQ (GHC.Types.Char, Data.Text.Internal.Text)))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abhc
                      = Data.Profunctor.Choice.right'
                          @p_abgP
                          $dChoice_abgR
                          @(GHC.Types.Char, Data.Text.Internal.Text)
                          @(f_abgQ (GHC.Types.Char, Data.Text.Internal.Text))
                          @Data.Text.Internal.Text } in
                  \ (x_abhd
                       :: p_abgP
                            (GHC.Types.Char, Data.Text.Internal.Text)
                            (f_abgQ (GHC.Types.Char, Data.Text.Internal.Text))) ->
                    f1_abgT (g_abhc x_abhd))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <Data.Text.Internal.Text>_N
                                <Data.Text.Internal.Text>_N
                                <GHC.Types.Char>_N
                                <GHC.Types.Char>_N)
                       :: Control.Lens.Type.Prism
                            Data.Text.Internal.Text
                            Data.Text.Internal.Text
                            (GHC.Types.Char, Data.Text.Internal.Text)
                            (GHC.Types.Char, Data.Text.Internal.Text)
                          ~R# Control.Lens.Cons.Cons
                                Data.Text.Internal.Text
                                Data.Text.Internal.Text
                                GHC.Types.Char
                                GHC.Types.Char))
              ((\ (@(p_abhe :: * -> * -> *))
                  (@(f_abhf :: * -> *))
                  ($dChoice_abhg :: Data.Profunctor.Choice.Choice p_abhe)
                  ($dApplicative_abhh :: GHC.Base.Applicative f_abhf) ->
                  let {
                    f1_abhi
                      :: p_abhe
                           (Data.Either.Either Data.Text.Internal.Text ())
                           (Data.Either.Either Data.Text.Internal.Text (f_abhf ()))
                         -> p_abhe Data.Text.Internal.Text (f_abhf Data.Text.Internal.Text)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 310 0}]
                    f1_abhi
                      = Data.Profunctor.Unsafe.dimap
                          @p_abhe
                          (Data.Profunctor.Choice.$p1Choice @p_abhe $dChoice_abhg)
                          @Data.Text.Internal.Text
                          @(Data.Either.Either Data.Text.Internal.Text ())
                          @(Data.Either.Either Data.Text.Internal.Text (f_abhf ()))
                          @(f_abhf Data.Text.Internal.Text)
                          (\ (s_abhj :: Data.Text.Internal.Text) ->
                             case Data.Text.null s_abhj of {
                               GHC.Types.False ->
                                 Data.Either.Left @Data.Text.Internal.Text @() s_abhj;
                               GHC.Types.True ->
                                 Data.Either.Right @Data.Text.Internal.Text @() GHC.Tuple.Prim.()
                             })
                          (let {
                             f2_abhm
                               :: Data.Text.Internal.Text -> f_abhf Data.Text.Internal.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abhm
                               = GHC.Base.pure
                                   @f_abhf $dApplicative_abhh @Data.Text.Internal.Text } in
                           let {
                             ds2_abhn :: f_abhf () -> f_abhf Data.Text.Internal.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 70 0}]
                             ds2_abhn
                               = GHC.Base.fmap
                                   @f_abhf
                                   (GHC.Base.$p1Applicative @f_abhf $dApplicative_abhh)
                                   @()
                                   @Data.Text.Internal.Text
                                   (\ (ds3_abho :: ()) ->
                                      case ds3_abho of { () -> Data.Text.Internal.empty }) } in
                           \ (ds3_abhq
                                :: Data.Either.Either Data.Text.Internal.Text (f_abhf ())) ->
                             case ds3_abhq of {
                               Data.Either.Left x_abhs -> f2_abhm x_abhs;
                               Data.Either.Right y_abhu -> ds2_abhn y_abhu
                             }) } in
                  let {
                    g_abhw
                      :: p_abhe () (f_abhf ())
                         -> p_abhe
                              (Data.Either.Either Data.Text.Internal.Text ())
                              (Data.Either.Either Data.Text.Internal.Text (f_abhf ()))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abhw
                      = Data.Profunctor.Choice.right'
                          @p_abhe
                          $dChoice_abhg
                          @()
                          @(f_abhf ())
                          @Data.Text.Internal.Text } in
                  \ (x_abhx :: p_abhe () (f_abhf ())) -> f1_abhi (g_abhw x_abhx))
               `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                <Data.Text.Internal.Text>_N)
                       :: Control.Lens.Type.Prism' Data.Text.Internal.Text ()
                          ~R# Control.Lens.Empty.AsEmpty Data.Text.Internal.Text))
              (Data.Functor.Contravariant.$fContravariantConst
                 @Data.Text.Internal.Text)
              (Data.Functor.Const.$fFunctorConst @Data.Text.Internal.Text)
    Cont:   ApplyToVal nodup hole Control.Lens.Getter.Getting
                                    Data.Text.Internal.Text
                                    Data.Text.Internal.Lazy.Text
                                    Data.Text.Internal.Text
              ((\ (ds_abdj [Occ=Once1] :: a_abdg) -> ds_abdj)
               `cast` (<a_abdg>_R
                       %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                          <*>_N <a_abdg>_R <a_abdg>_P)
                       :: (a_abdg -> a_abdg)
                          ~R# (a_abdg -> Data.Functor.Const.Const a_abdg a_abdg)))
            ApplyToVal nodup hole Data.Text.Internal.Lazy.Text
                                  -> Data.Functor.Const.Const
                                       Data.Text.Internal.Text Data.Text.Internal.Lazy.Text
              (Control.Lens.Getter.view
                 @Data.Text.Internal.Text
                 @((->) Data.Text.Internal.Text)
                 @Data.Text.Internal.Lazy.Text
                 (Control.Monad.Reader.Class.$fMonadReaderrFUN
                    @Data.Text.Internal.Text)
                 (Control.Lens.Cons.Extras.recons
                    @Data.Text.Internal.Text
                    @GHC.Types.Char
                    @Data.Text.Internal.Lazy.Text
                    Control.Lens.Cons.$fConsTextTextCharChar0
                    Control.Lens.Cons.$fConsTextTextCharChar
                    Control.Lens.Empty.$fAsEmptyText
                    @(Data.Functor.Const.Const Data.Text.Internal.Lazy.Text)
                    (Data.Functor.Contravariant.$fContravariantConst
                       @Data.Text.Internal.Lazy.Text)
                    (Data.Functor.Const.$fFunctorConst @Data.Text.Internal.Lazy.Text))
                 s_a8Oe)
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N <Data.Text.Internal.Text>_R <Data.Text.Internal.Lazy.Text>_P
                    :: Data.Functor.Const.Const
                         Data.Text.Internal.Text Data.Text.Internal.Lazy.Text
                       ~R# Data.Text.Internal.Text)
            Stop[RuleArgCtxt] Data.Text.Internal.Text
Rule fired
    Rule: Class op fmap
    Module: (BUILTIN)
    Before: GHC.Base.fmap
              TyArg Data.Functor.Const.Const Data.Text.Internal.Text
              ValArg Data.Functor.Const.$fFunctorConst @Data.Text.Internal.Text
    After:  (Data.Functor.Const.$fFunctorConst2
               @Data.Text.Internal.Text)
            `cast` (forall (a :: <*>_N) (b :: <*>_N).
                    <a -> b>_R
                    %<'GHC.Types.Many>_N ->_R <Data.Functor.Const.Const
                                                 Data.Text.Internal.Text a>_R
                    %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                  <*>_N <Data.Text.Internal.Text>_R <a>_P
                                              ; Sym (Data.Functor.Const.N:Const[0]
                                                         <*>_N <Data.Text.Internal.Text>_R <b>_P)
                    :: (forall {a} {b}.
                        (a -> b)
                        -> Data.Functor.Const.Const Data.Text.Internal.Text a
                        -> Data.Functor.Const.Const Data.Text.Internal.Text a)
                       ~R# (forall {a} {b}.
                            (a -> b)
                            -> Data.Functor.Const.Const Data.Text.Internal.Text a
                            -> Data.Functor.Const.Const Data.Text.Internal.Text b))
    Cont:   ApplyToTy Data.Text.Internal.Text
            ApplyToTy Data.Text.Internal.Lazy.Text
            ApplyToVal nodup hole (Data.Text.Internal.Text
                                   -> Data.Text.Internal.Lazy.Text)
                                  -> Data.Functor.Const.Const
                                       Data.Text.Internal.Text Data.Text.Internal.Text
                                  -> Data.Functor.Const.Const
                                       Data.Text.Internal.Text Data.Text.Internal.Lazy.Text
              Data.Text.Lazy.fromStrict
            ApplyToVal nodup hole Data.Functor.Const.Const
                                    Data.Text.Internal.Text Data.Text.Internal.Text
                                  -> Data.Functor.Const.Const
                                       Data.Text.Internal.Text Data.Text.Internal.Lazy.Text
              (bc_abny (ab_abnw x_abnz))
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N <Data.Text.Internal.Text>_R <Data.Text.Internal.Lazy.Text>_P
                    :: Data.Functor.Const.Const
                         Data.Text.Internal.Text Data.Text.Internal.Lazy.Text
                       ~R# Data.Text.Internal.Text)
            Stop[RuleArgCtxt] Data.Text.Internal.Text
Rule fired
    Rule: Class op reader
    Module: (BUILTIN)
    Before: Control.Monad.Reader.Class.reader
              TyArg Data.Text.Internal.Text
              TyArg (->) Data.Text.Internal.Text
              ValArg Control.Monad.Reader.Class.$fMonadReaderrFUN
                       @Data.Text.Internal.Text
    After:  \ (@a_abdo) ->
              GHC.Base.id @(Data.Text.Internal.Text -> a_abdo)
    Cont:   ApplyToTy Data.Text.Internal.Lazy.Text
            ApplyToVal nodup hole (Data.Text.Internal.Text
                                   -> Data.Text.Internal.Lazy.Text)
                                  -> Data.Text.Internal.Text -> Data.Text.Internal.Lazy.Text
              ((l_abdi
                  ((\ (ds_abdj [Occ=Once1] :: a_abdg) -> ds_abdj)
                   `cast` (<a_abdg>_R
                           %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                              <*>_N <a_abdg>_R <a_abdg>_P)
                           :: (a_abdg -> a_abdg)
                              ~R# (a_abdg -> Data.Functor.Const.Const a_abdg a_abdg))))
               `cast` (<s_abde>_R
                       %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                     <*>_N <a_abdg>_R <s_abde>_P
                       :: (s_abde -> Data.Functor.Const.Const a_abdg s_abde)
                          ~R# (s_abde -> a_abdg)))
            ApplyToVal nodup hole Data.Text.Internal.Text
                                  -> Data.Text.Internal.Lazy.Text
              s_a8Oe
            Stop[RuleArgCtxt] Data.Text.Internal.Lazy.Text
Rule fired
    Rule: recons/text-lazy
    Module: (Control.Lens.Cons.Extras)
    Before: Control.Lens.Cons.Extras.recons
              TyArg Data.Text.Internal.Text
              TyArg GHC.Types.Char
              TyArg Data.Text.Internal.Lazy.Text
              ValArg (\ (@(p_abgP :: * -> * -> *))
                        (@(f_abgQ :: * -> *))
                        ($dChoice_abgR :: Data.Profunctor.Choice.Choice p_abgP)
                        ($dApplicative_abgS :: GHC.Base.Applicative f_abgQ) ->
                        let {
                          f1_abgT
                            :: p_abgP
                                 (Data.Either.Either
                                    Data.Text.Internal.Text
                                    (GHC.Types.Char, Data.Text.Internal.Text))
                                 (Data.Either.Either
                                    Data.Text.Internal.Text
                                    (f_abgQ (GHC.Types.Char, Data.Text.Internal.Text)))
                               -> p_abgP Data.Text.Internal.Text (f_abgQ Data.Text.Internal.Text)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 340 0}]
                          f1_abgT
                            = Data.Profunctor.Unsafe.dimap
                                @p_abgP
                                (Data.Profunctor.Choice.$p1Choice @p_abgP $dChoice_abgR)
                                @Data.Text.Internal.Text
                                @(Data.Either.Either
                                    Data.Text.Internal.Text
                                    (GHC.Types.Char, Data.Text.Internal.Text))
                                @(Data.Either.Either
                                    Data.Text.Internal.Text
                                    (f_abgQ (GHC.Types.Char, Data.Text.Internal.Text)))
                                @(f_abgQ Data.Text.Internal.Text)
                                (\ (s1_abgU :: Data.Text.Internal.Text) ->
                                   case Data.Text.uncons s1_abgU of {
                                     GHC.Maybe.Nothing ->
                                       Data.Either.Left
                                         @Data.Text.Internal.Text
                                         @(GHC.Types.Char, Data.Text.Internal.Text)
                                         s1_abgU;
                                     GHC.Maybe.Just x_abgX ->
                                       Data.Either.Right
                                         @Data.Text.Internal.Text
                                         @(GHC.Types.Char, Data.Text.Internal.Text)
                                         x_abgX
                                   })
                                (let {
                                   f2_abgZ
                                     :: Data.Text.Internal.Text -> f_abgQ Data.Text.Internal.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abgZ
                                     = GHC.Base.pure
                                         @f_abgQ $dApplicative_abgS @Data.Text.Internal.Text } in
                                 let {
                                   ds2_abh0
                                     :: f_abgQ (GHC.Types.Char, Data.Text.Internal.Text)
                                        -> f_abgQ Data.Text.Internal.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 100 0}]
                                   ds2_abh0
                                     = GHC.Base.fmap
                                         @f_abgQ
                                         (GHC.Base.$p1Applicative @f_abgQ $dApplicative_abgS)
                                         @(GHC.Types.Char, Data.Text.Internal.Text)
                                         @Data.Text.Internal.Text
                                         (\ (p1_abh1
                                               :: (GHC.Types.Char, Data.Text.Internal.Text)) ->
                                            case p1_abh1 of { (x_abh3, ds_abh4) ->
                                            Data.Text.cons x_abh3 ds_abh4
                                            }) } in
                                 \ (ds3_abh6
                                      :: Data.Either.Either
                                           Data.Text.Internal.Text
                                           (f_abgQ (GHC.Types.Char, Data.Text.Internal.Text))) ->
                                   case ds3_abh6 of {
                                     Data.Either.Left x_abh8 -> f2_abgZ x_abh8;
                                     Data.Either.Right y_abha -> ds2_abh0 y_abha
                                   }) } in
                        let {
                          g_abhc
                            :: p_abgP
                                 (GHC.Types.Char, Data.Text.Internal.Text)
                                 (f_abgQ (GHC.Types.Char, Data.Text.Internal.Text))
                               -> p_abgP
                                    (Data.Either.Either
                                       Data.Text.Internal.Text
                                       (GHC.Types.Char, Data.Text.Internal.Text))
                                    (Data.Either.Either
                                       Data.Text.Internal.Text
                                       (f_abgQ (GHC.Types.Char, Data.Text.Internal.Text)))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abhc
                            = Data.Profunctor.Choice.right'
                                @p_abgP
                                $dChoice_abgR
                                @(GHC.Types.Char, Data.Text.Internal.Text)
                                @(f_abgQ (GHC.Types.Char, Data.Text.Internal.Text))
                                @Data.Text.Internal.Text } in
                        \ (x_abhd
                             :: p_abgP
                                  (GHC.Types.Char, Data.Text.Internal.Text)
                                  (f_abgQ (GHC.Types.Char, Data.Text.Internal.Text))) ->
                          f1_abgT (g_abhc x_abhd))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <Data.Text.Internal.Text>_N
                                      <Data.Text.Internal.Text>_N
                                      <GHC.Types.Char>_N
                                      <GHC.Types.Char>_N)
                             :: Control.Lens.Type.Prism
                                  Data.Text.Internal.Text
                                  Data.Text.Internal.Text
                                  (GHC.Types.Char, Data.Text.Internal.Text)
                                  (GHC.Types.Char, Data.Text.Internal.Text)
                                ~R# Control.Lens.Cons.Cons
                                      Data.Text.Internal.Text
                                      Data.Text.Internal.Text
                                      GHC.Types.Char
                                      GHC.Types.Char)
              ValArg (\ (@(p_abhE :: * -> * -> *))
                        (@(f_abhF :: * -> *))
                        ($dChoice_abhG :: Data.Profunctor.Choice.Choice p_abhE)
                        ($dApplicative_abhH :: GHC.Base.Applicative f_abhF) ->
                        let {
                          f1_abhI
                            :: p_abhE
                                 (Data.Either.Either
                                    Data.Text.Internal.Lazy.Text
                                    (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                                 (Data.Either.Either
                                    Data.Text.Internal.Lazy.Text
                                    (f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                               -> p_abhE
                                    Data.Text.Internal.Lazy.Text
                                    (f_abhF Data.Text.Internal.Lazy.Text)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 639 0}]
                          f1_abhI
                            = Data.Profunctor.Unsafe.dimap
                                @p_abhE
                                (Data.Profunctor.Choice.$p1Choice @p_abhE $dChoice_abhG)
                                @Data.Text.Internal.Lazy.Text
                                @(Data.Either.Either
                                    Data.Text.Internal.Lazy.Text
                                    (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                                @(Data.Either.Either
                                    Data.Text.Internal.Lazy.Text
                                    (f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                                @(f_abhF Data.Text.Internal.Lazy.Text)
                                (\ (s1_abhJ :: Data.Text.Internal.Lazy.Text) ->
                                   case s1_abhJ of {
                                     Data.Text.Internal.Lazy.Empty ->
                                       Data.Either.Left
                                         @Data.Text.Internal.Lazy.Text
                                         @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                         Data.Text.Internal.Lazy.Empty;
                                     Data.Text.Internal.Lazy.Chunk bx_abhQ bx1_abhR bx2_abhS
                                                                   ts_abhT ->
                                       Data.Either.Right
                                         @Data.Text.Internal.Lazy.Text
                                         @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                         (case GHC.Prim.indexWord8Array# bx_abhQ bx1_abhR of r#_abhV
                                          { __DEFAULT ->
                                          let {
                                            c#_abhW :: GHC.Prim.Int#
                                            [LclId,
                                             Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                     Value=False, ConLike=False, WorkFree=False,
                                                     Expandable=False,
                                                     Guidance=IF_ARGS [] 4 0}]
                                            c#_abhW
                                              = GHC.Prim.word2Int#
                                                  (GHC.Prim.clz8#
                                                     (GHC.Prim.and#
                                                        (GHC.Prim.not#
                                                           (GHC.Prim.word8ToWord# r#_abhV))
                                                        255##)) } in
                                          case GHC.Prim.xorI# c#_abhW (GHC.Prim.<=# c#_abhW 0#) of {
                                            __DEFAULT ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abhQ (GHC.Prim.+# bx1_abhR 1#)
                                              of r#1_abhY
                                              { __DEFAULT ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abhQ (GHC.Prim.+# bx1_abhR 2#)
                                              of r#2_abhZ
                                              { __DEFAULT ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abhQ (GHC.Prim.+# bx1_abhR 3#)
                                              of r#3_abi0
                                              { __DEFAULT ->
                                              GHC.Types.C#
                                                (GHC.Prim.chr#
                                                   (GHC.Prim.-#
                                                      (GHC.Prim.+#
                                                         (GHC.Prim.+#
                                                            (GHC.Prim.+#
                                                               (GHC.Prim.uncheckedIShiftL#
                                                                  (GHC.Prim.-#
                                                                     (GHC.Prim.word2Int#
                                                                        (GHC.Prim.word8ToWord#
                                                                           r#_abhV))
                                                                     240#)
                                                                  18#)
                                                               (GHC.Prim.uncheckedIShiftL#
                                                                  (GHC.Prim.-#
                                                                     (GHC.Prim.word2Int#
                                                                        (GHC.Prim.word8ToWord#
                                                                           r#1_abhY))
                                                                     128#)
                                                                  12#))
                                                            (GHC.Prim.uncheckedIShiftL#
                                                               (GHC.Prim.-#
                                                                  (GHC.Prim.word2Int#
                                                                     (GHC.Prim.word8ToWord#
                                                                        r#2_abhZ))
                                                                  128#)
                                                               6#))
                                                         (GHC.Prim.word2Int#
                                                            (GHC.Prim.word8ToWord# r#3_abi0)))
                                                      128#))
                                              }
                                              }
                                              };
                                            1# ->
                                              GHC.Types.C#
                                                (GHC.Prim.chr#
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.word8ToWord# r#_abhV)));
                                            2# ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abhQ (GHC.Prim.+# bx1_abhR 1#)
                                              of r#1_abi1
                                              { __DEFAULT ->
                                              GHC.Types.C#
                                                (GHC.Prim.chr#
                                                   (GHC.Prim.-#
                                                      (GHC.Prim.+#
                                                         (GHC.Prim.uncheckedIShiftL#
                                                            (GHC.Prim.-#
                                                               (GHC.Prim.word2Int#
                                                                  (GHC.Prim.word8ToWord# r#_abhV))
                                                               192#)
                                                            6#)
                                                         (GHC.Prim.word2Int#
                                                            (GHC.Prim.word8ToWord# r#1_abi1)))
                                                      128#))
                                              };
                                            3# ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abhQ (GHC.Prim.+# bx1_abhR 1#)
                                              of r#1_abi2
                                              { __DEFAULT ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abhQ (GHC.Prim.+# bx1_abhR 2#)
                                              of r#2_abi3
                                              { __DEFAULT ->
                                              GHC.Types.C#
                                                (GHC.Prim.chr#
                                                   (GHC.Prim.-#
                                                      (GHC.Prim.+#
                                                         (GHC.Prim.+#
                                                            (GHC.Prim.uncheckedIShiftL#
                                                               (GHC.Prim.-#
                                                                  (GHC.Prim.word2Int#
                                                                     (GHC.Prim.word8ToWord#
                                                                        r#_abhV))
                                                                  224#)
                                                               12#)
                                                            (GHC.Prim.uncheckedIShiftL#
                                                               (GHC.Prim.-#
                                                                  (GHC.Prim.word2Int#
                                                                     (GHC.Prim.word8ToWord#
                                                                        r#1_abi2))
                                                                  128#)
                                                               6#))
                                                         (GHC.Prim.word2Int#
                                                            (GHC.Prim.word8ToWord# r#2_abi3)))
                                                      128#))
                                              }
                                              }
                                          }
                                          },
                                          case Data.Text.compareLength
                                                 (Data.Text.Internal.Text bx_abhQ bx1_abhR bx2_abhS)
                                                 (GHC.Types.I# 1#)
                                          of {
                                            __DEFAULT ->
                                              case GHC.Prim.indexWord8Array# bx_abhQ bx1_abhR
                                              of r#_abi5
                                              { __DEFAULT ->
                                              let {
                                                c#_abi6 :: GHC.Prim.Int#
                                                [LclId,
                                                 Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                         Value=False, ConLike=False, WorkFree=False,
                                                         Expandable=False,
                                                         Guidance=IF_ARGS [] 4 0}]
                                                c#_abi6
                                                  = GHC.Prim.word2Int#
                                                      (GHC.Prim.clz8#
                                                         (GHC.Prim.and#
                                                            (GHC.Prim.not#
                                                               (GHC.Prim.word8ToWord# r#_abi5))
                                                            255##)) } in
                                              let {
                                                y_abi7 :: GHC.Prim.Int#
                                                [LclId,
                                                 Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                         Value=False, ConLike=False, WorkFree=False,
                                                         Expandable=False,
                                                         Guidance=IF_ARGS [] 2 0}]
                                                y_abi7
                                                  = GHC.Prim.xorI#
                                                      c#_abi6 (GHC.Prim.<=# c#_abi6 0#) } in
                                              Data.Text.Internal.Lazy.$WChunk
                                                (Data.Text.Internal.$WText
                                                   (Data.Text.Array.ByteArray bx_abhQ)
                                                   (GHC.Types.I# (GHC.Prim.+# bx1_abhR y_abi7))
                                                   (GHC.Types.I# (GHC.Prim.-# bx2_abhS y_abi7)))
                                                ts_abhT
                                              };
                                            GHC.Types.EQ -> ts_abhT
                                          })
                                   })
                                (let {
                                   f2_abi9
                                     :: Data.Text.Internal.Lazy.Text
                                        -> f_abhF Data.Text.Internal.Lazy.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abi9
                                     = GHC.Base.pure
                                         @f_abhF
                                         $dApplicative_abhH
                                         @Data.Text.Internal.Lazy.Text } in
                                 let {
                                   ds2_abia
                                     :: f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                        -> f_abhF Data.Text.Internal.Lazy.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 100 0}]
                                   ds2_abia
                                     = GHC.Base.fmap
                                         @f_abhF
                                         (GHC.Base.$p1Applicative @f_abhF $dApplicative_abhH)
                                         @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                         @Data.Text.Internal.Lazy.Text
                                         (\ (p1_abib
                                               :: (GHC.Types.Char, Data.Text.Internal.Lazy.Text)) ->
                                            case p1_abib of { (x_abid, ds_abie) ->
                                            Data.Text.Lazy.cons x_abid ds_abie
                                            }) } in
                                 \ (ds3_abig
                                      :: Data.Either.Either
                                           Data.Text.Internal.Lazy.Text
                                           (f_abhF
                                              (GHC.Types.Char, Data.Text.Internal.Lazy.Text))) ->
                                   case ds3_abig of {
                                     Data.Either.Left x_abii -> f2_abi9 x_abii;
                                     Data.Either.Right y_abik -> ds2_abia y_abik
                                   }) } in
                        let {
                          g_abim
                            :: p_abhE
                                 (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                 (f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                               -> p_abhE
                                    (Data.Either.Either
                                       Data.Text.Internal.Lazy.Text
                                       (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                                    (Data.Either.Either
                                       Data.Text.Internal.Lazy.Text
                                       (f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abim
                            = Data.Profunctor.Choice.right'
                                @p_abhE
                                $dChoice_abhG
                                @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                @(f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                                @Data.Text.Internal.Lazy.Text } in
                        \ (x_abin
                             :: p_abhE
                                  (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                  (f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text))) ->
                          f1_abhI (g_abim x_abin))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <Data.Text.Internal.Lazy.Text>_N
                                      <Data.Text.Internal.Lazy.Text>_N
                                      <GHC.Types.Char>_N
                                      <GHC.Types.Char>_N)
                             :: Control.Lens.Type.Prism
                                  Data.Text.Internal.Lazy.Text
                                  Data.Text.Internal.Lazy.Text
                                  (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                  (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                ~R# Control.Lens.Cons.Cons
                                      Data.Text.Internal.Lazy.Text
                                      Data.Text.Internal.Lazy.Text
                                      GHC.Types.Char
                                      GHC.Types.Char)
              ValArg (\ (@(p_abiq :: * -> * -> *))
                        (@(f_abir :: * -> *))
                        ($dChoice_abis :: Data.Profunctor.Choice.Choice p_abiq)
                        ($dApplicative_abit :: GHC.Base.Applicative f_abir) ->
                        let {
                          f1_abiu
                            :: p_abiq
                                 (Data.Either.Either Data.Text.Internal.Lazy.Text ())
                                 (Data.Either.Either Data.Text.Internal.Lazy.Text (f_abir ()))
                               -> p_abiq
                                    Data.Text.Internal.Lazy.Text
                                    (f_abir Data.Text.Internal.Lazy.Text)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 310 0}]
                          f1_abiu
                            = Data.Profunctor.Unsafe.dimap
                                @p_abiq
                                (Data.Profunctor.Choice.$p1Choice @p_abiq $dChoice_abis)
                                @Data.Text.Internal.Lazy.Text
                                @(Data.Either.Either Data.Text.Internal.Lazy.Text ())
                                @(Data.Either.Either Data.Text.Internal.Lazy.Text (f_abir ()))
                                @(f_abir Data.Text.Internal.Lazy.Text)
                                (\ (s_abiv :: Data.Text.Internal.Lazy.Text) ->
                                   case Data.Text.Lazy.null s_abiv of {
                                     GHC.Types.False ->
                                       Data.Either.Left @Data.Text.Internal.Lazy.Text @() s_abiv;
                                     GHC.Types.True ->
                                       Data.Either.Right
                                         @Data.Text.Internal.Lazy.Text @() GHC.Tuple.Prim.()
                                   })
                                (let {
                                   f2_abiy
                                     :: Data.Text.Internal.Lazy.Text
                                        -> f_abir Data.Text.Internal.Lazy.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abiy
                                     = GHC.Base.pure
                                         @f_abir
                                         $dApplicative_abit
                                         @Data.Text.Internal.Lazy.Text } in
                                 let {
                                   ds2_abiz :: f_abir () -> f_abir Data.Text.Internal.Lazy.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 70 0}]
                                   ds2_abiz
                                     = GHC.Base.fmap
                                         @f_abir
                                         (GHC.Base.$p1Applicative @f_abir $dApplicative_abit)
                                         @()
                                         @Data.Text.Internal.Lazy.Text
                                         (\ (ds3_abiA :: ()) ->
                                            case ds3_abiA of { () ->
                                            Data.Text.Internal.Lazy.empty
                                            }) } in
                                 \ (ds3_abiC
                                      :: Data.Either.Either
                                           Data.Text.Internal.Lazy.Text (f_abir ())) ->
                                   case ds3_abiC of {
                                     Data.Either.Left x_abiE -> f2_abiy x_abiE;
                                     Data.Either.Right y_abiG -> ds2_abiz y_abiG
                                   }) } in
                        let {
                          g_abiI
                            :: p_abiq () (f_abir ())
                               -> p_abiq
                                    (Data.Either.Either Data.Text.Internal.Lazy.Text ())
                                    (Data.Either.Either Data.Text.Internal.Lazy.Text (f_abir ()))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abiI
                            = Data.Profunctor.Choice.right'
                                @p_abiq
                                $dChoice_abis
                                @()
                                @(f_abir ())
                                @Data.Text.Internal.Lazy.Text } in
                        \ (x_abiJ :: p_abiq () (f_abir ())) -> f1_abiu (g_abiI x_abiJ))
                     `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                      <Data.Text.Internal.Lazy.Text>_N)
                             :: Control.Lens.Type.Prism' Data.Text.Internal.Lazy.Text ()
                                ~R# Control.Lens.Empty.AsEmpty Data.Text.Internal.Lazy.Text)
              TyArg Data.Functor.Const.Const Data.Text.Internal.Lazy.Text
              ValArg Data.Functor.Contravariant.$fContravariantConst
                       @Data.Text.Internal.Lazy.Text
              ValArg Data.Functor.Const.$fFunctorConst
                       @Data.Text.Internal.Lazy.Text
    After:  (\ (@(f_abdH :: * -> *))
               ($dCons_abdI
                  :: Control.Lens.Cons.Cons
                       Data.Text.Internal.Text
                       Data.Text.Internal.Text
                       GHC.Types.Char
                       GHC.Types.Char)
               ($dCons1_abdJ
                  :: Control.Lens.Cons.Cons
                       Data.Text.Internal.Lazy.Text
                       Data.Text.Internal.Lazy.Text
                       GHC.Types.Char
                       GHC.Types.Char)
               ($dAsEmpty_abdK
                  :: Control.Lens.Empty.AsEmpty Data.Text.Internal.Lazy.Text)
               ($dContravariant_abdL
                  :: Data.Functor.Contravariant.Contravariant f_abdH)
               ($dFunctor_abdM :: GHC.Base.Functor f_abdH) ->
               Data.Profunctor.Unsafe.$fProfunctorFUN_$cdimap
                 @Data.Text.Internal.Text
                 @Data.Text.Internal.Lazy.Text
                 @(f_abdH Data.Text.Internal.Lazy.Text)
                 @(f_abdH Data.Text.Internal.Text)
                 Data.Text.Lazy.fromStrict
                 (GHC.Base.fmap
                    @f_abdH
                    $dFunctor_abdM
                    @Data.Text.Internal.Lazy.Text
                    @Data.Text.Internal.Text
                    Data.Text.Lazy.toStrict))
              @(Data.Functor.Const.Const Data.Text.Internal.Lazy.Text)
              ((\ (@(p_abgP :: * -> * -> *))
                  (@(f_abgQ :: * -> *))
                  ($dChoice_abgR :: Data.Profunctor.Choice.Choice p_abgP)
                  ($dApplicative_abgS :: GHC.Base.Applicative f_abgQ) ->
                  let {
                    f1_abgT
                      :: p_abgP
                           (Data.Either.Either
                              Data.Text.Internal.Text (GHC.Types.Char, Data.Text.Internal.Text))
                           (Data.Either.Either
                              Data.Text.Internal.Text
                              (f_abgQ (GHC.Types.Char, Data.Text.Internal.Text)))
                         -> p_abgP Data.Text.Internal.Text (f_abgQ Data.Text.Internal.Text)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 340 0}]
                    f1_abgT
                      = Data.Profunctor.Unsafe.dimap
                          @p_abgP
                          (Data.Profunctor.Choice.$p1Choice @p_abgP $dChoice_abgR)
                          @Data.Text.Internal.Text
                          @(Data.Either.Either
                              Data.Text.Internal.Text (GHC.Types.Char, Data.Text.Internal.Text))
                          @(Data.Either.Either
                              Data.Text.Internal.Text
                              (f_abgQ (GHC.Types.Char, Data.Text.Internal.Text)))
                          @(f_abgQ Data.Text.Internal.Text)
                          (\ (s1_abgU :: Data.Text.Internal.Text) ->
                             case Data.Text.uncons s1_abgU of {
                               GHC.Maybe.Nothing ->
                                 Data.Either.Left
                                   @Data.Text.Internal.Text
                                   @(GHC.Types.Char, Data.Text.Internal.Text)
                                   s1_abgU;
                               GHC.Maybe.Just x_abgX ->
                                 Data.Either.Right
                                   @Data.Text.Internal.Text
                                   @(GHC.Types.Char, Data.Text.Internal.Text)
                                   x_abgX
                             })
                          (let {
                             f2_abgZ
                               :: Data.Text.Internal.Text -> f_abgQ Data.Text.Internal.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abgZ
                               = GHC.Base.pure
                                   @f_abgQ $dApplicative_abgS @Data.Text.Internal.Text } in
                           let {
                             ds2_abh0
                               :: f_abgQ (GHC.Types.Char, Data.Text.Internal.Text)
                                  -> f_abgQ Data.Text.Internal.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 100 0}]
                             ds2_abh0
                               = GHC.Base.fmap
                                   @f_abgQ
                                   (GHC.Base.$p1Applicative @f_abgQ $dApplicative_abgS)
                                   @(GHC.Types.Char, Data.Text.Internal.Text)
                                   @Data.Text.Internal.Text
                                   (\ (p1_abh1 :: (GHC.Types.Char, Data.Text.Internal.Text)) ->
                                      case p1_abh1 of { (x_abh3, ds_abh4) ->
                                      Data.Text.cons x_abh3 ds_abh4
                                      }) } in
                           \ (ds3_abh6
                                :: Data.Either.Either
                                     Data.Text.Internal.Text
                                     (f_abgQ (GHC.Types.Char, Data.Text.Internal.Text))) ->
                             case ds3_abh6 of {
                               Data.Either.Left x_abh8 -> f2_abgZ x_abh8;
                               Data.Either.Right y_abha -> ds2_abh0 y_abha
                             }) } in
                  let {
                    g_abhc
                      :: p_abgP
                           (GHC.Types.Char, Data.Text.Internal.Text)
                           (f_abgQ (GHC.Types.Char, Data.Text.Internal.Text))
                         -> p_abgP
                              (Data.Either.Either
                                 Data.Text.Internal.Text (GHC.Types.Char, Data.Text.Internal.Text))
                              (Data.Either.Either
                                 Data.Text.Internal.Text
                                 (f_abgQ (GHC.Types.Char, Data.Text.Internal.Text)))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abhc
                      = Data.Profunctor.Choice.right'
                          @p_abgP
                          $dChoice_abgR
                          @(GHC.Types.Char, Data.Text.Internal.Text)
                          @(f_abgQ (GHC.Types.Char, Data.Text.Internal.Text))
                          @Data.Text.Internal.Text } in
                  \ (x_abhd
                       :: p_abgP
                            (GHC.Types.Char, Data.Text.Internal.Text)
                            (f_abgQ (GHC.Types.Char, Data.Text.Internal.Text))) ->
                    f1_abgT (g_abhc x_abhd))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <Data.Text.Internal.Text>_N
                                <Data.Text.Internal.Text>_N
                                <GHC.Types.Char>_N
                                <GHC.Types.Char>_N)
                       :: Control.Lens.Type.Prism
                            Data.Text.Internal.Text
                            Data.Text.Internal.Text
                            (GHC.Types.Char, Data.Text.Internal.Text)
                            (GHC.Types.Char, Data.Text.Internal.Text)
                          ~R# Control.Lens.Cons.Cons
                                Data.Text.Internal.Text
                                Data.Text.Internal.Text
                                GHC.Types.Char
                                GHC.Types.Char))
              ((\ (@(p_abhE :: * -> * -> *))
                  (@(f_abhF :: * -> *))
                  ($dChoice_abhG :: Data.Profunctor.Choice.Choice p_abhE)
                  ($dApplicative_abhH :: GHC.Base.Applicative f_abhF) ->
                  let {
                    f1_abhI
                      :: p_abhE
                           (Data.Either.Either
                              Data.Text.Internal.Lazy.Text
                              (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                           (Data.Either.Either
                              Data.Text.Internal.Lazy.Text
                              (f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                         -> p_abhE
                              Data.Text.Internal.Lazy.Text (f_abhF Data.Text.Internal.Lazy.Text)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 639 0}]
                    f1_abhI
                      = Data.Profunctor.Unsafe.dimap
                          @p_abhE
                          (Data.Profunctor.Choice.$p1Choice @p_abhE $dChoice_abhG)
                          @Data.Text.Internal.Lazy.Text
                          @(Data.Either.Either
                              Data.Text.Internal.Lazy.Text
                              (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                          @(Data.Either.Either
                              Data.Text.Internal.Lazy.Text
                              (f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                          @(f_abhF Data.Text.Internal.Lazy.Text)
                          (\ (s1_abhJ :: Data.Text.Internal.Lazy.Text) ->
                             case s1_abhJ of {
                               Data.Text.Internal.Lazy.Empty ->
                                 Data.Either.Left
                                   @Data.Text.Internal.Lazy.Text
                                   @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                   Data.Text.Internal.Lazy.Empty;
                               Data.Text.Internal.Lazy.Chunk bx_abhQ bx1_abhR bx2_abhS ts_abhT ->
                                 Data.Either.Right
                                   @Data.Text.Internal.Lazy.Text
                                   @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                   (case GHC.Prim.indexWord8Array# bx_abhQ bx1_abhR of r#_abhV
                                    { __DEFAULT ->
                                    let {
                                      c#_abhW :: GHC.Prim.Int#
                                      [LclId,
                                       Unf=Unf{Src=<vanilla>, TopLvl=False,
                                               Value=False, ConLike=False, WorkFree=False,
                                               Expandable=False,
                                               Guidance=IF_ARGS [] 4 0}]
                                      c#_abhW
                                        = GHC.Prim.word2Int#
                                            (GHC.Prim.clz8#
                                               (GHC.Prim.and#
                                                  (GHC.Prim.not# (GHC.Prim.word8ToWord# r#_abhV))
                                                  255##)) } in
                                    case GHC.Prim.xorI# c#_abhW (GHC.Prim.<=# c#_abhW 0#) of {
                                      __DEFAULT ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abhQ (GHC.Prim.+# bx1_abhR 1#)
                                        of r#1_abhY
                                        { __DEFAULT ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abhQ (GHC.Prim.+# bx1_abhR 2#)
                                        of r#2_abhZ
                                        { __DEFAULT ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abhQ (GHC.Prim.+# bx1_abhR 3#)
                                        of r#3_abi0
                                        { __DEFAULT ->
                                        GHC.Types.C#
                                          (GHC.Prim.chr#
                                             (GHC.Prim.-#
                                                (GHC.Prim.+#
                                                   (GHC.Prim.+#
                                                      (GHC.Prim.+#
                                                         (GHC.Prim.uncheckedIShiftL#
                                                            (GHC.Prim.-#
                                                               (GHC.Prim.word2Int#
                                                                  (GHC.Prim.word8ToWord# r#_abhV))
                                                               240#)
                                                            18#)
                                                         (GHC.Prim.uncheckedIShiftL#
                                                            (GHC.Prim.-#
                                                               (GHC.Prim.word2Int#
                                                                  (GHC.Prim.word8ToWord# r#1_abhY))
                                                               128#)
                                                            12#))
                                                      (GHC.Prim.uncheckedIShiftL#
                                                         (GHC.Prim.-#
                                                            (GHC.Prim.word2Int#
                                                               (GHC.Prim.word8ToWord# r#2_abhZ))
                                                            128#)
                                                         6#))
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.word8ToWord# r#3_abi0)))
                                                128#))
                                        }
                                        }
                                        };
                                      1# ->
                                        GHC.Types.C#
                                          (GHC.Prim.chr#
                                             (GHC.Prim.word2Int# (GHC.Prim.word8ToWord# r#_abhV)));
                                      2# ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abhQ (GHC.Prim.+# bx1_abhR 1#)
                                        of r#1_abi1
                                        { __DEFAULT ->
                                        GHC.Types.C#
                                          (GHC.Prim.chr#
                                             (GHC.Prim.-#
                                                (GHC.Prim.+#
                                                   (GHC.Prim.uncheckedIShiftL#
                                                      (GHC.Prim.-#
                                                         (GHC.Prim.word2Int#
                                                            (GHC.Prim.word8ToWord# r#_abhV))
                                                         192#)
                                                      6#)
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.word8ToWord# r#1_abi1)))
                                                128#))
                                        };
                                      3# ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abhQ (GHC.Prim.+# bx1_abhR 1#)
                                        of r#1_abi2
                                        { __DEFAULT ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abhQ (GHC.Prim.+# bx1_abhR 2#)
                                        of r#2_abi3
                                        { __DEFAULT ->
                                        GHC.Types.C#
                                          (GHC.Prim.chr#
                                             (GHC.Prim.-#
                                                (GHC.Prim.+#
                                                   (GHC.Prim.+#
                                                      (GHC.Prim.uncheckedIShiftL#
                                                         (GHC.Prim.-#
                                                            (GHC.Prim.word2Int#
                                                               (GHC.Prim.word8ToWord# r#_abhV))
                                                            224#)
                                                         12#)
                                                      (GHC.Prim.uncheckedIShiftL#
                                                         (GHC.Prim.-#
                                                            (GHC.Prim.word2Int#
                                                               (GHC.Prim.word8ToWord# r#1_abi2))
                                                            128#)
                                                         6#))
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.word8ToWord# r#2_abi3)))
                                                128#))
                                        }
                                        }
                                    }
                                    },
                                    case Data.Text.compareLength
                                           (Data.Text.Internal.Text bx_abhQ bx1_abhR bx2_abhS)
                                           (GHC.Types.I# 1#)
                                    of {
                                      __DEFAULT ->
                                        case GHC.Prim.indexWord8Array# bx_abhQ bx1_abhR of r#_abi5
                                        { __DEFAULT ->
                                        let {
                                          c#_abi6 :: GHC.Prim.Int#
                                          [LclId,
                                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                   Value=False, ConLike=False, WorkFree=False,
                                                   Expandable=False,
                                                   Guidance=IF_ARGS [] 4 0}]
                                          c#_abi6
                                            = GHC.Prim.word2Int#
                                                (GHC.Prim.clz8#
                                                   (GHC.Prim.and#
                                                      (GHC.Prim.not#
                                                         (GHC.Prim.word8ToWord# r#_abi5))
                                                      255##)) } in
                                        let {
                                          y_abi7 :: GHC.Prim.Int#
                                          [LclId,
                                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                   Value=False, ConLike=False, WorkFree=False,
                                                   Expandable=False,
                                                   Guidance=IF_ARGS [] 2 0}]
                                          y_abi7
                                            = GHC.Prim.xorI# c#_abi6 (GHC.Prim.<=# c#_abi6 0#) } in
                                        Data.Text.Internal.Lazy.$WChunk
                                          (Data.Text.Internal.$WText
                                             (Data.Text.Array.ByteArray bx_abhQ)
                                             (GHC.Types.I# (GHC.Prim.+# bx1_abhR y_abi7))
                                             (GHC.Types.I# (GHC.Prim.-# bx2_abhS y_abi7)))
                                          ts_abhT
                                        };
                                      GHC.Types.EQ -> ts_abhT
                                    })
                             })
                          (let {
                             f2_abi9
                               :: Data.Text.Internal.Lazy.Text
                                  -> f_abhF Data.Text.Internal.Lazy.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abi9
                               = GHC.Base.pure
                                   @f_abhF $dApplicative_abhH @Data.Text.Internal.Lazy.Text } in
                           let {
                             ds2_abia
                               :: f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                  -> f_abhF Data.Text.Internal.Lazy.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 100 0}]
                             ds2_abia
                               = GHC.Base.fmap
                                   @f_abhF
                                   (GHC.Base.$p1Applicative @f_abhF $dApplicative_abhH)
                                   @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                   @Data.Text.Internal.Lazy.Text
                                   (\ (p1_abib :: (GHC.Types.Char, Data.Text.Internal.Lazy.Text)) ->
                                      case p1_abib of { (x_abid, ds_abie) ->
                                      Data.Text.Lazy.cons x_abid ds_abie
                                      }) } in
                           \ (ds3_abig
                                :: Data.Either.Either
                                     Data.Text.Internal.Lazy.Text
                                     (f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text))) ->
                             case ds3_abig of {
                               Data.Either.Left x_abii -> f2_abi9 x_abii;
                               Data.Either.Right y_abik -> ds2_abia y_abik
                             }) } in
                  let {
                    g_abim
                      :: p_abhE
                           (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                           (f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                         -> p_abhE
                              (Data.Either.Either
                                 Data.Text.Internal.Lazy.Text
                                 (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                              (Data.Either.Either
                                 Data.Text.Internal.Lazy.Text
                                 (f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abim
                      = Data.Profunctor.Choice.right'
                          @p_abhE
                          $dChoice_abhG
                          @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                          @(f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                          @Data.Text.Internal.Lazy.Text } in
                  \ (x_abin
                       :: p_abhE
                            (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                            (f_abhF (GHC.Types.Char, Data.Text.Internal.Lazy.Text))) ->
                    f1_abhI (g_abim x_abin))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <Data.Text.Internal.Lazy.Text>_N
                                <Data.Text.Internal.Lazy.Text>_N
                                <GHC.Types.Char>_N
                                <GHC.Types.Char>_N)
                       :: Control.Lens.Type.Prism
                            Data.Text.Internal.Lazy.Text
                            Data.Text.Internal.Lazy.Text
                            (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                            (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                          ~R# Control.Lens.Cons.Cons
                                Data.Text.Internal.Lazy.Text
                                Data.Text.Internal.Lazy.Text
                                GHC.Types.Char
                                GHC.Types.Char))
              ((\ (@(p_abiq :: * -> * -> *))
                  (@(f_abir :: * -> *))
                  ($dChoice_abis :: Data.Profunctor.Choice.Choice p_abiq)
                  ($dApplicative_abit :: GHC.Base.Applicative f_abir) ->
                  let {
                    f1_abiu
                      :: p_abiq
                           (Data.Either.Either Data.Text.Internal.Lazy.Text ())
                           (Data.Either.Either Data.Text.Internal.Lazy.Text (f_abir ()))
                         -> p_abiq
                              Data.Text.Internal.Lazy.Text (f_abir Data.Text.Internal.Lazy.Text)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 310 0}]
                    f1_abiu
                      = Data.Profunctor.Unsafe.dimap
                          @p_abiq
                          (Data.Profunctor.Choice.$p1Choice @p_abiq $dChoice_abis)
                          @Data.Text.Internal.Lazy.Text
                          @(Data.Either.Either Data.Text.Internal.Lazy.Text ())
                          @(Data.Either.Either Data.Text.Internal.Lazy.Text (f_abir ()))
                          @(f_abir Data.Text.Internal.Lazy.Text)
                          (\ (s_abiv :: Data.Text.Internal.Lazy.Text) ->
                             case Data.Text.Lazy.null s_abiv of {
                               GHC.Types.False ->
                                 Data.Either.Left @Data.Text.Internal.Lazy.Text @() s_abiv;
                               GHC.Types.True ->
                                 Data.Either.Right
                                   @Data.Text.Internal.Lazy.Text @() GHC.Tuple.Prim.()
                             })
                          (let {
                             f2_abiy
                               :: Data.Text.Internal.Lazy.Text
                                  -> f_abir Data.Text.Internal.Lazy.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abiy
                               = GHC.Base.pure
                                   @f_abir $dApplicative_abit @Data.Text.Internal.Lazy.Text } in
                           let {
                             ds2_abiz :: f_abir () -> f_abir Data.Text.Internal.Lazy.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 70 0}]
                             ds2_abiz
                               = GHC.Base.fmap
                                   @f_abir
                                   (GHC.Base.$p1Applicative @f_abir $dApplicative_abit)
                                   @()
                                   @Data.Text.Internal.Lazy.Text
                                   (\ (ds3_abiA :: ()) ->
                                      case ds3_abiA of { () -> Data.Text.Internal.Lazy.empty }) } in
                           \ (ds3_abiC
                                :: Data.Either.Either Data.Text.Internal.Lazy.Text (f_abir ())) ->
                             case ds3_abiC of {
                               Data.Either.Left x_abiE -> f2_abiy x_abiE;
                               Data.Either.Right y_abiG -> ds2_abiz y_abiG
                             }) } in
                  let {
                    g_abiI
                      :: p_abiq () (f_abir ())
                         -> p_abiq
                              (Data.Either.Either Data.Text.Internal.Lazy.Text ())
                              (Data.Either.Either Data.Text.Internal.Lazy.Text (f_abir ()))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abiI
                      = Data.Profunctor.Choice.right'
                          @p_abiq
                          $dChoice_abis
                          @()
                          @(f_abir ())
                          @Data.Text.Internal.Lazy.Text } in
                  \ (x_abiJ :: p_abiq () (f_abir ())) -> f1_abiu (g_abiI x_abiJ))
               `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                <Data.Text.Internal.Lazy.Text>_N)
                       :: Control.Lens.Type.Prism' Data.Text.Internal.Lazy.Text ()
                          ~R# Control.Lens.Empty.AsEmpty Data.Text.Internal.Lazy.Text))
              (Data.Functor.Contravariant.$fContravariantConst
                 @Data.Text.Internal.Lazy.Text)
              (Data.Functor.Const.$fFunctorConst @Data.Text.Internal.Lazy.Text)
    Cont:   ApplyToVal nodup hole Control.Lens.Getter.Getting
                                    Data.Text.Internal.Lazy.Text
                                    Data.Text.Internal.Text
                                    Data.Text.Internal.Lazy.Text
              ((\ (ds_abdj [Occ=Once1] :: a_abdg) -> ds_abdj)
               `cast` (<a_abdg>_R
                       %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                          <*>_N <a_abdg>_R <a_abdg>_P)
                       :: (a_abdg -> a_abdg)
                          ~R# (a_abdg -> Data.Functor.Const.Const a_abdg a_abdg)))
            ApplyToVal nodup hole Data.Text.Internal.Text
                                  -> Data.Functor.Const.Const
                                       Data.Text.Internal.Lazy.Text Data.Text.Internal.Text
              s_a8Oe
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N <Data.Text.Internal.Lazy.Text>_R <Data.Text.Internal.Text>_P
                    :: Data.Functor.Const.Const
                         Data.Text.Internal.Lazy.Text Data.Text.Internal.Text
                       ~R# Data.Text.Internal.Lazy.Text)
            Stop[RuleArgCtxt] Data.Text.Internal.Lazy.Text
Rule fired
    Rule: Class op fmap
    Module: (BUILTIN)
    Before: GHC.Base.fmap
              TyArg Data.Functor.Const.Const Data.Text.Internal.Lazy.Text
              ValArg Data.Functor.Const.$fFunctorConst
                       @Data.Text.Internal.Lazy.Text
    After:  (Data.Functor.Const.$fFunctorConst2
               @Data.Text.Internal.Lazy.Text)
            `cast` (forall (a :: <*>_N) (b :: <*>_N).
                    <a -> b>_R
                    %<'GHC.Types.Many>_N ->_R <Data.Functor.Const.Const
                                                 Data.Text.Internal.Lazy.Text a>_R
                    %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                  <*>_N <Data.Text.Internal.Lazy.Text>_R <a>_P
                                              ; Sym (Data.Functor.Const.N:Const[0]
                                                         <*>_N
                                                         <Data.Text.Internal.Lazy.Text>_R
                                                         <b>_P)
                    :: (forall {a} {b}.
                        (a -> b)
                        -> Data.Functor.Const.Const Data.Text.Internal.Lazy.Text a
                        -> Data.Functor.Const.Const Data.Text.Internal.Lazy.Text a)
                       ~R# (forall {a} {b}.
                            (a -> b)
                            -> Data.Functor.Const.Const Data.Text.Internal.Lazy.Text a
                            -> Data.Functor.Const.Const Data.Text.Internal.Lazy.Text b))
    Cont:   ApplyToTy Data.Text.Internal.Lazy.Text
            ApplyToTy Data.Text.Internal.Text
            ApplyToVal nodup hole (Data.Text.Internal.Lazy.Text
                                   -> Data.Text.Internal.Text)
                                  -> Data.Functor.Const.Const
                                       Data.Text.Internal.Lazy.Text Data.Text.Internal.Lazy.Text
                                  -> Data.Functor.Const.Const
                                       Data.Text.Internal.Lazy.Text Data.Text.Internal.Text
              Data.Text.Lazy.toStrict
            ApplyToVal nodup hole Data.Functor.Const.Const
                                    Data.Text.Internal.Lazy.Text Data.Text.Internal.Lazy.Text
                                  -> Data.Functor.Const.Const
                                       Data.Text.Internal.Lazy.Text Data.Text.Internal.Text
              (bc_abny (ab_abnw x_abnz))
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N <Data.Text.Internal.Lazy.Text>_R <Data.Text.Internal.Text>_P
                    :: Data.Functor.Const.Const
                         Data.Text.Internal.Lazy.Text Data.Text.Internal.Text
                       ~R# Data.Text.Internal.Lazy.Text)
            Stop[RuleArgCtxt] Data.Text.Internal.Lazy.Text
Rule fired
    Rule: Class op ==
    Module: (BUILTIN)
    Before: GHC.Classes.==
              TyArg Data.Text.Internal.Text
              ValArg Data.Text.$fEqText
              ValArg Data.Text.Lazy.toStrict (Data.Text.Lazy.fromStrict s_a8Oe)
              ValArg s_a8Oe
    After:  Data.Text.$fEqText_$c==
              ValArg Data.Text.Lazy.toStrict (Data.Text.Lazy.fromStrict s_a8Oe)
              ValArg s_a8Oe
    Cont:   Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: unpack
    Module: (GHC.Base)
    Before: GHC.CString.unpackCString# ValArg "[W8] -> B -> [W8]"#
    After:  (\ (a_ab5Y :: GHC.Prim.Addr#) ->
               GHC.Base.build
                 @GHC.Types.Char
                 (\ (@b_ab5Z) -> GHC.CString.unpackFoldrCString# @b_ab5Z a_ab5Y))
              "[W8] -> B -> [W8]"#
    Cont:   Stop[BoringCtxt] Test.Tasty.Core.TestName
Rule fired
    Rule: Class op property
    Module: (BUILTIN)
    Before: Test.QuickCheck.Property.property
              TyArg [GHC.Word.Word8] -> GHC.Types.Bool ValArg $dTestable_a9d4
    After:  Test.QuickCheck.Property.$fTestableFUN_$cproperty
              @[GHC.Word.Word8]
              @GHC.Types.Bool
              $dArbitrary_aabi
              $dShow_aabj
              Test.QuickCheck.Property.$fTestableBool
    Cont:   ApplyToVal nodup hole ([GHC.Word.Word8] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              prop_ab6b
            CastIt (Sym (Test.Tasty.QuickCheck.N:QC[0])
                    :: Test.QuickCheck.Property.Property ~R# Test.Tasty.QuickCheck.QC)
            Stop[BoringCtxt] Test.Tasty.QuickCheck.QC
Rule fired
    Rule: Class op propertyForAllShrinkShow
    Module: (BUILTIN)
    Before: Test.QuickCheck.Property.propertyForAllShrinkShow
              TyArg GHC.Types.Bool ValArg Test.QuickCheck.Property.$fTestableBool
    After:  Test.QuickCheck.Property.$fTestableBool1
            `cast` (forall (a :: <*>_N).
                    <Test.QuickCheck.Gen.Gen a>_R
                    %<'GHC.Types.Many>_N ->_R <a -> [a]>_R
                    %<'GHC.Types.Many>_N ->_R <a -> [GHC.Base.String]>_R
                    %<'GHC.Types.Many>_N ->_R <a -> GHC.Types.Bool>_R
                    %<'GHC.Types.Many>_N ->_R Sym (Test.QuickCheck.Gen.N:Gen[0]
                                                       (Test.QuickCheck.Property.N:Prop[0]))
                                              ; Sym (Test.QuickCheck.Property.N:Property[0])
                    :: (forall {a}.
                        Test.QuickCheck.Gen.Gen a
                        -> (a -> [a])
                        -> (a -> [GHC.Base.String])
                        -> (a -> GHC.Types.Bool)
                        -> Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int
                        -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result)
                       ~R# (forall {a}.
                            Test.QuickCheck.Gen.Gen a
                            -> (a -> [a])
                            -> (a -> [GHC.Base.String])
                            -> (a -> GHC.Types.Bool)
                            -> Test.QuickCheck.Property.Property))
    Cont:   ApplyToTy [GHC.Word.Word8]
            ApplyToVal nodup hole Test.QuickCheck.Gen.Gen [GHC.Word.Word8]
                                  -> ([GHC.Word.Word8] -> [[GHC.Word.Word8]])
                                  -> ([GHC.Word.Word8] -> [GHC.Base.String])
                                  -> ([GHC.Word.Word8] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (Test.QuickCheck.Arbitrary.arbitrary @a_ab7T $dArbitrary_ab7V)
            ApplyToVal nodup hole ([GHC.Word.Word8] -> [[GHC.Word.Word8]])
                                  -> ([GHC.Word.Word8] -> [GHC.Base.String])
                                  -> ([GHC.Word.Word8] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (Test.QuickCheck.Arbitrary.shrink @a_ab7T $dArbitrary_ab7V)
            ApplyToVal nodup hole ([GHC.Word.Word8] -> [GHC.Base.String])
                                  -> ([GHC.Word.Word8] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (let {
                 g_ab7Z [Occ=OnceL1!] :: a_ab7T -> GHC.Base.String
                 [LclId]
                 g_ab7Z = GHC.Show.show @a_ab7T $dShow_ab7W } in
               \ (x_ab80 [Occ=Once1] :: a_ab7T) ->
                 GHC.Types.:
                   @GHC.Base.String (g_ab7Z x_ab80) (GHC.Types.[] @GHC.Base.String))
            ApplyToVal nodup hole ([GHC.Word.Word8] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              f_ab7Y
            CastIt (Sym (Test.Tasty.QuickCheck.N:QC[0])
                    :: Test.QuickCheck.Property.Property ~R# Test.Tasty.QuickCheck.QC)
            Stop[BoringCtxt] Test.Tasty.QuickCheck.QC
Rule fired
    Rule: Class op arbitrary
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.arbitrary
              TyArg [GHC.Word.Word8] ValArg $dArbitrary_aabi
    After:  (Test.QuickCheck.Arbitrary.$fArbitraryList1
               @GHC.Word.Word8 Test.QuickCheck.Arbitrary.$fArbitraryWord8)
            `cast` (Sym (Test.QuickCheck.Gen.N:Gen[0] <[GHC.Word.Word8]>_R)
                    :: (Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int -> [GHC.Word.Word8])
                       ~R# Test.QuickCheck.Gen.Gen [GHC.Word.Word8])
    Cont:   Stop[BoringCtxt] Test.QuickCheck.Gen.Gen [GHC.Word.Word8]
Rule fired
    Rule: Class op arbitrary
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.arbitrary
              TyArg GHC.Word.Word8
              ValArg Test.QuickCheck.Arbitrary.$fArbitraryWord8
    After:  Test.QuickCheck.Arbitrary.$fArbitraryWord8_$sarbitrarySizedBoundedIntegral
            `cast` (Sym (Test.QuickCheck.Gen.N:Gen[0] <GHC.Word.Word8>_R)
                    :: (Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int -> GHC.Word.Word8)
                       ~R# Test.QuickCheck.Gen.Gen GHC.Word.Word8)
    Cont:   Stop[BoringCtxt, C(S,C(1,L))] Test.QuickCheck.Gen.Gen
                                            GHC.Word.Word8
Rule fired
    Rule: Class op shrink
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.shrink
              TyArg [GHC.Word.Word8] ValArg $dArbitrary_aabi
    After:  Test.QuickCheck.Arbitrary.$fArbitraryList_$cshrink
              @GHC.Word.Word8 Test.QuickCheck.Arbitrary.$fArbitraryWord8
    Cont:   Stop[BoringCtxt] [GHC.Word.Word8] -> [[GHC.Word.Word8]]
Rule fired
    Rule: Class op shrink
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.shrink
              TyArg GHC.Word.Word8
              ValArg Test.QuickCheck.Arbitrary.$fArbitraryWord8
    After:  Test.QuickCheck.Arbitrary.$fArbitraryWord8_$sshrinkIntegral
    Cont:   Stop[DiscArgCtxt, C(S,L)] GHC.Word.Word8
                                      -> [GHC.Word.Word8]
Rule fired
    Rule: Class op show
    Module: (BUILTIN)
    Before: GHC.Show.show TyArg [GHC.Word.Word8] ValArg $dShow_aabj
    After:  GHC.Show.$fShowList_$cshow
              @GHC.Word.Word8 GHC.Word.$fShowWord8
    Cont:   Stop[RhsCtxt(NonRecursive)] [GHC.Word.Word8]
                                        -> GHC.Base.String
Rule fired
    Rule: Class op showList
    Module: (BUILTIN)
    Before: GHC.Show.showList
              TyArg GHC.Word.Word8 ValArg GHC.Word.$fShowWord8
    After:  GHC.Word.$fShowWord8_$cshowList
    Cont:   ApplyToVal nodup hole [GHC.Word.Word8] -> GHC.Show.ShowS
              x_abqh
            ApplyToVal nodup hole GHC.Show.ShowS (GHC.Types.[] @GHC.Types.Char)
            Stop[BoringCtxt] GHC.Base.String
Rule fired
    Rule: Class op reader
    Module: (BUILTIN)
    Before: Control.Monad.Reader.Class.reader
              TyArg Data.ByteString.Internal.Type.ByteString
              TyArg (->) Data.ByteString.Internal.Type.ByteString
              ValArg Control.Monad.Reader.Class.$fMonadReaderrFUN
                       @Data.ByteString.Internal.Type.ByteString
    After:  \ (@a_abdo) ->
              GHC.Base.id @(Data.ByteString.Internal.Type.ByteString -> a_abdo)
    Cont:   ApplyToTy [GHC.Word.Word8]
            ApplyToVal nodup hole (Data.ByteString.Internal.Type.ByteString
                                   -> [GHC.Word.Word8])
                                  -> Data.ByteString.Internal.Type.ByteString -> [GHC.Word.Word8]
              ((l_abdi
                  ((\ (ds_abdj [Occ=Once1] :: a_abdg) -> ds_abdj)
                   `cast` (<a_abdg>_R
                           %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                              <*>_N <a_abdg>_R <a_abdg>_P)
                           :: (a_abdg -> a_abdg)
                              ~R# (a_abdg -> Data.Functor.Const.Const a_abdg a_abdg))))
               `cast` (<s_abde>_R
                       %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                     <*>_N <a_abdg>_R <s_abde>_P
                       :: (s_abde -> Data.Functor.Const.Const a_abdg s_abde)
                          ~R# (s_abde -> a_abdg)))
            ApplyToVal nodup hole Data.ByteString.Internal.Type.ByteString
                                  -> [GHC.Word.Word8]
              (Control.Lens.Getter.view
                 @[GHC.Word.Word8]
                 @((->) [GHC.Word.Word8])
                 @Data.ByteString.Internal.Type.ByteString
                 (Control.Monad.Reader.Class.$fMonadReaderrFUN @[GHC.Word.Word8])
                 (Control.Lens.Cons.Extras.recons
                    @[GHC.Word.Word8]
                    @GHC.Word.Word8
                    @Data.ByteString.Internal.Type.ByteString
                    (Control.Lens.Cons.$fConsListListab
                       @GHC.Word.Word8 @GHC.Word.Word8)
                    Control.Lens.Cons.$fConsByteStringByteStringWord8Word80
                    Control.Lens.Empty.$fAsEmptyByteString0
                    @(Data.Functor.Const.Const
                        Data.ByteString.Internal.Type.ByteString)
                    (Data.Functor.Contravariant.$fContravariantConst
                       @Data.ByteString.Internal.Type.ByteString)
                    (Data.Functor.Const.$fFunctorConst
                       @Data.ByteString.Internal.Type.ByteString))
                 s_a8Of)
            Stop[RuleArgCtxt] [GHC.Word.Word8]
Rule fired
    Rule: recons/bs-list
    Module: (Control.Lens.Cons.Extras)
    Before: Control.Lens.Cons.Extras.recons
              TyArg Data.ByteString.Internal.Type.ByteString
              TyArg GHC.Word.Word8
              TyArg [GHC.Word.Word8]
              ValArg (\ (@(p_abj8 :: * -> * -> *))
                        (@(f_abj9 :: * -> *))
                        ($dChoice_abja :: Data.Profunctor.Choice.Choice p_abj8)
                        ($dApplicative_abjb :: GHC.Base.Applicative f_abj9) ->
                        let {
                          f1_abjc
                            :: p_abj8
                                 (Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                                 (Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString
                                    (f_abj9
                                       (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                               -> p_abj8
                                    Data.ByteString.Internal.Type.ByteString
                                    (f_abj9 Data.ByteString.Internal.Type.ByteString)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 612 0}]
                          f1_abjc
                            = Data.Profunctor.Unsafe.dimap
                                @p_abj8
                                (Data.Profunctor.Choice.$p1Choice @p_abj8 $dChoice_abja)
                                @Data.ByteString.Internal.Type.ByteString
                                @(Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                                @(Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString
                                    (f_abj9
                                       (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                                @(f_abj9 Data.ByteString.Internal.Type.ByteString)
                                (\ (s1_abjd :: Data.ByteString.Internal.Type.ByteString) ->
                                   case s1_abjd of wild_abje
                                   { Data.ByteString.Internal.Type.BS bx_abjf bx1_abjg bx2_abjh ->
                                   case GHC.Classes.leInt (GHC.Types.I# bx2_abjh) (GHC.Types.I# 0#)
                                   of {
                                     GHC.Types.False ->
                                       Data.Either.Right
                                         @Data.ByteString.Internal.Type.ByteString
                                         @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                         (case GHC.Prim.readWord8OffAddr#
                                                 @GHC.Prim.RealWorld bx_abjf 0# GHC.Prim.realWorld#
                                          of
                                          { (# ipv_abjm, ipv1_abjn #) ->
                                          case GHC.Prim.touch#
                                                 @'GHC.Types.Lifted
                                                 @GHC.ForeignPtr.ForeignPtrContents
                                                 bx1_abjg
                                                 ipv_abjm
                                          of
                                          { __DEFAULT ->
                                          GHC.Word.W8# ipv1_abjn
                                          }
                                          },
                                          Data.ByteString.Internal.Type.$WBS
                                            (GHC.ForeignPtr.ForeignPtr
                                               @GHC.Word.Word8
                                               (GHC.Prim.plusAddr# bx_abjf 1#)
                                               bx1_abjg)
                                            (GHC.Types.I# (GHC.Prim.-# bx2_abjh 1#)));
                                     GHC.Types.True ->
                                       Data.Either.Left
                                         @Data.ByteString.Internal.Type.ByteString
                                         @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                         wild_abje
                                   }
                                   })
                                (let {
                                   f2_abjr
                                     :: Data.ByteString.Internal.Type.ByteString
                                        -> f_abj9 Data.ByteString.Internal.Type.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abjr
                                     = GHC.Base.pure
                                         @f_abj9
                                         $dApplicative_abjb
                                         @Data.ByteString.Internal.Type.ByteString } in
                                 let {
                                   ds2_abjs
                                     :: f_abj9
                                          (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                        -> f_abj9 Data.ByteString.Internal.Type.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 259 0}]
                                   ds2_abjs
                                     = GHC.Base.fmap
                                         @f_abj9
                                         (GHC.Base.$p1Applicative @f_abj9 $dApplicative_abjb)
                                         @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                         @Data.ByteString.Internal.Type.ByteString
                                         (\ (p1_abjt
                                               :: (GHC.Word.Word8,
                                                   Data.ByteString.Internal.Type.ByteString)) ->
                                            case p1_abjt of { (ds_abjv, y_abjw) ->
                                            case y_abjw of
                                            { Data.ByteString.Internal.Type.BS bx_abjI bx1_abjJ
                                                                               bx2_abjK ->
                                            GHC.Magic.runRW#
                                              @GHC.Types.LiftedRep
                                              @Data.ByteString.Internal.Type.ByteString
                                              (\ (s_abjG [OS=OneShot]
                                                    :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                                                 let {
                                                   x_abjH :: GHC.Prim.Int#
                                                   [LclId,
                                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                            Value=False, ConLike=False,
                                                            WorkFree=False, Expandable=False,
                                                            Guidance=IF_ARGS [] 1 0}]
                                                   x_abjH = GHC.Prim.+# bx2_abjK 1# } in
                                                 case GHC.Prim.<# x_abjH 0# of {
                                                   __DEFAULT ->
                                                     case GHC.Prim.newPinnedByteArray#
                                                            @GHC.Prim.RealWorld x_abjH s_abjG
                                                     of
                                                     { (# ipv_abjP, ipv1_abjQ #) ->
                                                     let {
                                                       ipv2_abjO :: GHC.Prim.Addr#
                                                       [LclId,
                                                        Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                                Value=False, ConLike=False,
                                                                WorkFree=False, Expandable=False,
                                                                Guidance=IF_ARGS [] 1 0}]
                                                       ipv2_abjO
                                                         = GHC.Prim.mutableByteArrayContents#
                                                             @GHC.Prim.RealWorld ipv1_abjQ } in
                                                     let {
                                                       ipv3_abjS
                                                         :: GHC.ForeignPtr.ForeignPtrContents
                                                       [LclId,
                                                        Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                                Value=True, ConLike=True,
                                                                WorkFree=True, Expandable=True,
                                                                Guidance=IF_ARGS [] 10 10}]
                                                       ipv3_abjS
                                                         = GHC.ForeignPtr.PlainPtr ipv1_abjQ } in
                                                     case ds_abjv of { GHC.Word.W8# x1_abla ->
                                                     case GHC.Prim.writeWord8OffAddr#
                                                            @GHC.Prim.RealWorld
                                                            ipv2_abjO
                                                            0#
                                                            x1_abla
                                                            ipv_abjP
                                                     of s2_ablc
                                                     { __DEFAULT ->
                                                     case GHC.Prim.touch#
                                                            @'GHC.Types.Lifted
                                                            @GHC.ForeignPtr.ForeignPtrContents
                                                            ipv3_abjS
                                                            s2_ablc
                                                     of s'_abld
                                                     { __DEFAULT ->
                                                     case {__ffi_static_ccall_unsafe base:memcpy :: Addr#
                                          -> Addr#
                                          -> Word64#
                                          -> State# RealWorld
                                          -> (# State# RealWorld, Addr# #)}_able
                                                            (GHC.Prim.plusAddr# ipv2_abjO 1#)
                                                            bx_abjI
                                                            (GHC.Prim.int64ToWord64#
                                                               (GHC.Prim.intToInt64# bx2_abjK))
                                                            s'_abld
                                                     of
                                                     { (# ds4_ablg, ds5_ablh #) ->
                                                     case GHC.Prim.touch#
                                                            @'GHC.Types.Lifted
                                                            @GHC.ForeignPtr.ForeignPtrContents
                                                            bx1_abjJ
                                                            ds4_ablg
                                                     of s'1_ablj
                                                     { __DEFAULT ->
                                                     case GHC.Prim.touch#
                                                            @'GHC.Types.Lifted
                                                            @GHC.ForeignPtr.ForeignPtrContents
                                                            ipv3_abjS
                                                            s'1_ablj
                                                     of s'2_ablk
                                                     { __DEFAULT ->
                                                     case GHC.Magic.lazy
                                                            @((GHC.Prim.State# GHC.Prim.RealWorld
                                                               -> (# GHC.Prim.State#
                                                                       GHC.Prim.RealWorld,
                                                                     GHC.Prim.Addr# #))
                                                              -> (# GHC.Prim.State#
                                                                      GHC.Prim.RealWorld,
                                                                    GHC.Prim.Addr# #))
                                                            (GHC.Magic.runRW#
                                                               @('GHC.Types.TupleRep
                                                                   '[GHC.Types.ZeroBitRep,
                                                                     'GHC.Types.AddrRep])
                                                               @(# GHC.Prim.State#
                                                                     GHC.Prim.RealWorld,
                                                                   GHC.Prim.Addr# #))
                                                            (\ _ [Occ=Dead] ->
                                                               (# s'2_ablk, ipv2_abjO #))
                                                     of
                                                     { (# ipv6_abln, ipv7_ablo #) ->
                                                     Data.ByteString.Internal.Type.BS
                                                       ipv7_ablo ipv3_abjS x_abjH
                                                     }
                                                     }
                                                     }
                                                     }
                                                     }
                                                     }
                                                     }
                                                     };
                                                   1# ->
                                                     case GHC.ForeignPtr.mallocPlainForeignPtrBytes2
                                                     of wild_00 {
                                                     }
                                                 })
                                            }
                                            }) } in
                                 \ (ds3_ablr
                                      :: Data.Either.Either
                                           Data.ByteString.Internal.Type.ByteString
                                           (f_abj9
                                              (GHC.Word.Word8,
                                               Data.ByteString.Internal.Type.ByteString))) ->
                                   case ds3_ablr of {
                                     Data.Either.Left x_ablt -> f2_abjr x_ablt;
                                     Data.Either.Right y_ablv -> ds2_abjs y_ablv
                                   }) } in
                        let {
                          g_ablx
                            :: p_abj8
                                 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                 (f_abj9 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                               -> p_abj8
                                    (Data.Either.Either
                                       Data.ByteString.Internal.Type.ByteString
                                       (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                                    (Data.Either.Either
                                       Data.ByteString.Internal.Type.ByteString
                                       (f_abj9
                                          (GHC.Word.Word8,
                                           Data.ByteString.Internal.Type.ByteString)))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_ablx
                            = Data.Profunctor.Choice.right'
                                @p_abj8
                                $dChoice_abja
                                @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                @(f_abj9
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                                @Data.ByteString.Internal.Type.ByteString } in
                        \ (x_ably
                             :: p_abj8
                                  (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                  (f_abj9
                                     (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))) ->
                          f1_abjc (g_ablx x_ably))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <Data.ByteString.Internal.Type.ByteString>_N
                                      <Data.ByteString.Internal.Type.ByteString>_N
                                      <GHC.Word.Word8>_N
                                      <GHC.Word.Word8>_N)
                             :: Control.Lens.Type.Prism
                                  Data.ByteString.Internal.Type.ByteString
                                  Data.ByteString.Internal.Type.ByteString
                                  (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                  (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                ~R# Control.Lens.Cons.Cons
                                      Data.ByteString.Internal.Type.ByteString
                                      Data.ByteString.Internal.Type.ByteString
                                      GHC.Word.Word8
                                      GHC.Word.Word8)
              ValArg (\ (@(p_abeP :: * -> * -> *))
                        (@(f_abeQ :: * -> *))
                        ($dChoice_abeR :: Data.Profunctor.Choice.Choice p_abeP)
                        ($dApplicative_abeS :: GHC.Base.Applicative f_abeQ) ->
                        let {
                          f1_abeT
                            :: p_abeP
                                 (Data.Either.Either
                                    [GHC.Word.Word8] (GHC.Word.Word8, [GHC.Word.Word8]))
                                 (Data.Either.Either
                                    [GHC.Word.Word8] (f_abeQ (GHC.Word.Word8, [GHC.Word.Word8])))
                               -> p_abeP [GHC.Word.Word8] (f_abeQ [GHC.Word.Word8])
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 320 0}]
                          f1_abeT
                            = Data.Profunctor.Unsafe.dimap
                                @p_abeP
                                (Data.Profunctor.Choice.$p1Choice @p_abeP $dChoice_abeR)
                                @[GHC.Word.Word8]
                                @(Data.Either.Either
                                    [GHC.Word.Word8] (GHC.Word.Word8, [GHC.Word.Word8]))
                                @(Data.Either.Either
                                    [GHC.Word.Word8] (f_abeQ (GHC.Word.Word8, [GHC.Word.Word8])))
                                @(f_abeQ [GHC.Word.Word8])
                                (\ (aas_abeU :: [GHC.Word.Word8]) ->
                                   case aas_abeU of {
                                     [] ->
                                       Data.Either.Left
                                         @[GHC.Word.Word8]
                                         @(GHC.Word.Word8, [GHC.Word.Word8])
                                         (GHC.Types.[] @GHC.Word.Word8);
                                     : a1_abeW as_abeX ->
                                       Data.Either.Right
                                         @[GHC.Word.Word8]
                                         @(GHC.Word.Word8, [GHC.Word.Word8])
                                         (a1_abeW, as_abeX)
                                   })
                                (let {
                                   f2_abeZ :: [GHC.Word.Word8] -> f_abeQ [GHC.Word.Word8]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abeZ
                                     = GHC.Base.pure
                                         @f_abeQ $dApplicative_abeS @[GHC.Word.Word8] } in
                                 let {
                                   ds2_abf0
                                     :: f_abeQ (GHC.Word.Word8, [GHC.Word.Word8])
                                        -> f_abeQ [GHC.Word.Word8]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 90 0}]
                                   ds2_abf0
                                     = GHC.Base.fmap
                                         @f_abeQ
                                         (GHC.Base.$p1Applicative @f_abeQ $dApplicative_abeS)
                                         @(GHC.Word.Word8, [GHC.Word.Word8])
                                         @[GHC.Word.Word8]
                                         (\ (p1_abf1 :: (GHC.Word.Word8, [GHC.Word.Word8])) ->
                                            GHC.Types.:
                                              @GHC.Word.Word8
                                              (case p1_abf1 of { (x_abf3, ds_abf4) -> x_abf3 })
                                              (case p1_abf1 of { (ds_abf7, y_abf8) ->
                                               y_abf8
                                               })) } in
                                 \ (ds3_abfa
                                      :: Data.Either.Either
                                           [GHC.Word.Word8]
                                           (f_abeQ (GHC.Word.Word8, [GHC.Word.Word8]))) ->
                                   case ds3_abfa of {
                                     Data.Either.Left x_abfc -> f2_abeZ x_abfc;
                                     Data.Either.Right y_abfe -> ds2_abf0 y_abfe
                                   }) } in
                        let {
                          g_abfg
                            :: p_abeP
                                 (GHC.Word.Word8, [GHC.Word.Word8])
                                 (f_abeQ (GHC.Word.Word8, [GHC.Word.Word8]))
                               -> p_abeP
                                    (Data.Either.Either
                                       [GHC.Word.Word8] (GHC.Word.Word8, [GHC.Word.Word8]))
                                    (Data.Either.Either
                                       [GHC.Word.Word8] (f_abeQ (GHC.Word.Word8, [GHC.Word.Word8])))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abfg
                            = Data.Profunctor.Choice.right'
                                @p_abeP
                                $dChoice_abeR
                                @(GHC.Word.Word8, [GHC.Word.Word8])
                                @(f_abeQ (GHC.Word.Word8, [GHC.Word.Word8]))
                                @[GHC.Word.Word8] } in
                        \ (x_abfh
                             :: p_abeP
                                  (GHC.Word.Word8, [GHC.Word.Word8])
                                  (f_abeQ (GHC.Word.Word8, [GHC.Word.Word8]))) ->
                          f1_abeT (g_abfg x_abfh))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <[GHC.Word.Word8]>_N
                                      <[GHC.Word.Word8]>_N
                                      <GHC.Word.Word8>_N
                                      <GHC.Word.Word8>_N)
                             :: Control.Lens.Type.Prism
                                  [GHC.Word.Word8]
                                  [GHC.Word.Word8]
                                  (GHC.Word.Word8, [GHC.Word.Word8])
                                  (GHC.Word.Word8, [GHC.Word.Word8])
                                ~R# Control.Lens.Cons.Cons
                                      [GHC.Word.Word8]
                                      [GHC.Word.Word8]
                                      GHC.Word.Word8
                                      GHC.Word.Word8)
              ValArg (\ (@(p_abfm :: * -> * -> *))
                        (@(f_abfn :: * -> *))
                        ($dChoice_abfo :: Data.Profunctor.Choice.Choice p_abfm)
                        ($dApplicative_abfp :: GHC.Base.Applicative f_abfn) ->
                        let {
                          f1_abfq
                            :: p_abfm
                                 (Data.Either.Either [GHC.Word.Word8] ())
                                 (Data.Either.Either [GHC.Word.Word8] (f_abfn ()))
                               -> p_abfm [GHC.Word.Word8] (f_abfn [GHC.Word.Word8])
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 290 0}]
                          f1_abfq
                            = Data.Profunctor.Unsafe.dimap
                                @p_abfm
                                (Data.Profunctor.Choice.$p1Choice @p_abfm $dChoice_abfo)
                                @[GHC.Word.Word8]
                                @(Data.Either.Either [GHC.Word.Word8] ())
                                @(Data.Either.Either [GHC.Word.Word8] (f_abfn ()))
                                @(f_abfn [GHC.Word.Word8])
                                (\ (s_abfr :: [GHC.Word.Word8]) ->
                                   case s_abfr of wild_abfs {
                                     [] ->
                                       Data.Either.Right @[GHC.Word.Word8] @() GHC.Tuple.Prim.();
                                     : ds1_abft ds2_abfu ->
                                       Data.Either.Left @[GHC.Word.Word8] @() wild_abfs
                                   })
                                (let {
                                   f2_abfw :: [GHC.Word.Word8] -> f_abfn [GHC.Word.Word8]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abfw
                                     = GHC.Base.pure
                                         @f_abfn $dApplicative_abfp @[GHC.Word.Word8] } in
                                 let {
                                   ds2_abfx :: f_abfn () -> f_abfn [GHC.Word.Word8]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 70 0}]
                                   ds2_abfx
                                     = GHC.Base.fmap
                                         @f_abfn
                                         (GHC.Base.$p1Applicative @f_abfn $dApplicative_abfp)
                                         @()
                                         @[GHC.Word.Word8]
                                         (\ (ds3_abfy :: ()) ->
                                            case ds3_abfy of { () ->
                                            GHC.Types.[] @GHC.Word.Word8
                                            }) } in
                                 \ (ds3_abfA :: Data.Either.Either [GHC.Word.Word8] (f_abfn ())) ->
                                   case ds3_abfA of {
                                     Data.Either.Left x_abfC -> f2_abfw x_abfC;
                                     Data.Either.Right y_abfE -> ds2_abfx y_abfE
                                   }) } in
                        let {
                          g_abfG
                            :: p_abfm () (f_abfn ())
                               -> p_abfm
                                    (Data.Either.Either [GHC.Word.Word8] ())
                                    (Data.Either.Either [GHC.Word.Word8] (f_abfn ()))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abfG
                            = Data.Profunctor.Choice.right'
                                @p_abfm $dChoice_abfo @() @(f_abfn ()) @[GHC.Word.Word8] } in
                        \ (x_abfH :: p_abfm () (f_abfn ())) -> f1_abfq (g_abfG x_abfH))
                     `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0] <[GHC.Word.Word8]>_N)
                             :: Control.Lens.Type.Prism' [GHC.Word.Word8] ()
                                ~R# Control.Lens.Empty.AsEmpty [GHC.Word.Word8])
              TyArg Data.Functor.Const.Const [GHC.Word.Word8]
              ValArg Data.Functor.Contravariant.$fContravariantConst
                       @[GHC.Word.Word8]
              ValArg Data.Functor.Const.$fFunctorConst @[GHC.Word.Word8]
    After:  (\ (@(f_abeB :: * -> *))
               ($dCons_abeC
                  :: Control.Lens.Cons.Cons
                       Data.ByteString.Internal.Type.ByteString
                       Data.ByteString.Internal.Type.ByteString
                       GHC.Word.Word8
                       GHC.Word.Word8)
               ($dCons1_abeD
                  :: Control.Lens.Cons.Cons
                       [GHC.Word.Word8] [GHC.Word.Word8] GHC.Word.Word8 GHC.Word.Word8)
               ($dAsEmpty_abeE :: Control.Lens.Empty.AsEmpty [GHC.Word.Word8])
               ($dContravariant_abeF
                  :: Data.Functor.Contravariant.Contravariant f_abeB)
               ($dFunctor_abeG :: GHC.Base.Functor f_abeB) ->
               Data.Profunctor.Unsafe.$fProfunctorFUN_$cdimap
                 @Data.ByteString.Internal.Type.ByteString
                 @[GHC.Word.Word8]
                 @(f_abeB [GHC.Word.Word8])
                 @(f_abeB Data.ByteString.Internal.Type.ByteString)
                 Data.ByteString.unpack
                 (GHC.Base.fmap
                    @f_abeB
                    $dFunctor_abeG
                    @[GHC.Word.Word8]
                    @Data.ByteString.Internal.Type.ByteString
                    Data.ByteString.Internal.Type.packBytes))
              @(Data.Functor.Const.Const [GHC.Word.Word8])
              ((\ (@(p_abj8 :: * -> * -> *))
                  (@(f_abj9 :: * -> *))
                  ($dChoice_abja :: Data.Profunctor.Choice.Choice p_abj8)
                  ($dApplicative_abjb :: GHC.Base.Applicative f_abj9) ->
                  let {
                    f1_abjc
                      :: p_abj8
                           (Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString
                              (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                           (Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString
                              (f_abj9
                                 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                         -> p_abj8
                              Data.ByteString.Internal.Type.ByteString
                              (f_abj9 Data.ByteString.Internal.Type.ByteString)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 612 0}]
                    f1_abjc
                      = Data.Profunctor.Unsafe.dimap
                          @p_abj8
                          (Data.Profunctor.Choice.$p1Choice @p_abj8 $dChoice_abja)
                          @Data.ByteString.Internal.Type.ByteString
                          @(Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString
                              (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                          @(Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString
                              (f_abj9
                                 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                          @(f_abj9 Data.ByteString.Internal.Type.ByteString)
                          (\ (s1_abjd :: Data.ByteString.Internal.Type.ByteString) ->
                             case s1_abjd of wild_abje
                             { Data.ByteString.Internal.Type.BS bx_abjf bx1_abjg bx2_abjh ->
                             case GHC.Classes.leInt (GHC.Types.I# bx2_abjh) (GHC.Types.I# 0#)
                             of {
                               GHC.Types.False ->
                                 Data.Either.Right
                                   @Data.ByteString.Internal.Type.ByteString
                                   @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                   (case GHC.Prim.readWord8OffAddr#
                                           @GHC.Prim.RealWorld bx_abjf 0# GHC.Prim.realWorld#
                                    of
                                    { (# ipv_abjm, ipv1_abjn #) ->
                                    case GHC.Prim.touch#
                                           @'GHC.Types.Lifted
                                           @GHC.ForeignPtr.ForeignPtrContents
                                           bx1_abjg
                                           ipv_abjm
                                    of
                                    { __DEFAULT ->
                                    GHC.Word.W8# ipv1_abjn
                                    }
                                    },
                                    Data.ByteString.Internal.Type.$WBS
                                      (GHC.ForeignPtr.ForeignPtr
                                         @GHC.Word.Word8 (GHC.Prim.plusAddr# bx_abjf 1#) bx1_abjg)
                                      (GHC.Types.I# (GHC.Prim.-# bx2_abjh 1#)));
                               GHC.Types.True ->
                                 Data.Either.Left
                                   @Data.ByteString.Internal.Type.ByteString
                                   @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                   wild_abje
                             }
                             })
                          (let {
                             f2_abjr
                               :: Data.ByteString.Internal.Type.ByteString
                                  -> f_abj9 Data.ByteString.Internal.Type.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abjr
                               = GHC.Base.pure
                                   @f_abj9
                                   $dApplicative_abjb
                                   @Data.ByteString.Internal.Type.ByteString } in
                           let {
                             ds2_abjs
                               :: f_abj9
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                  -> f_abj9 Data.ByteString.Internal.Type.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 259 0}]
                             ds2_abjs
                               = GHC.Base.fmap
                                   @f_abj9
                                   (GHC.Base.$p1Applicative @f_abj9 $dApplicative_abjb)
                                   @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                   @Data.ByteString.Internal.Type.ByteString
                                   (\ (p1_abjt
                                         :: (GHC.Word.Word8,
                                             Data.ByteString.Internal.Type.ByteString)) ->
                                      case p1_abjt of { (ds_abjv, y_abjw) ->
                                      case y_abjw of
                                      { Data.ByteString.Internal.Type.BS bx_abjI bx1_abjJ
                                                                         bx2_abjK ->
                                      GHC.Magic.runRW#
                                        @GHC.Types.LiftedRep
                                        @Data.ByteString.Internal.Type.ByteString
                                        (\ (s_abjG [OS=OneShot]
                                              :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                                           let {
                                             x_abjH :: GHC.Prim.Int#
                                             [LclId,
                                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                      Value=False, ConLike=False, WorkFree=False,
                                                      Expandable=False,
                                                      Guidance=IF_ARGS [] 1 0}]
                                             x_abjH = GHC.Prim.+# bx2_abjK 1# } in
                                           case GHC.Prim.<# x_abjH 0# of {
                                             __DEFAULT ->
                                               case GHC.Prim.newPinnedByteArray#
                                                      @GHC.Prim.RealWorld x_abjH s_abjG
                                               of
                                               { (# ipv_abjP, ipv1_abjQ #) ->
                                               let {
                                                 ipv2_abjO :: GHC.Prim.Addr#
                                                 [LclId,
                                                  Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                          Value=False, ConLike=False,
                                                          WorkFree=False, Expandable=False,
                                                          Guidance=IF_ARGS [] 1 0}]
                                                 ipv2_abjO
                                                   = GHC.Prim.mutableByteArrayContents#
                                                       @GHC.Prim.RealWorld ipv1_abjQ } in
                                               let {
                                                 ipv3_abjS :: GHC.ForeignPtr.ForeignPtrContents
                                                 [LclId,
                                                  Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                          Value=True, ConLike=True, WorkFree=True,
                                                          Expandable=True,
                                                          Guidance=IF_ARGS [] 10 10}]
                                                 ipv3_abjS = GHC.ForeignPtr.PlainPtr ipv1_abjQ } in
                                               case ds_abjv of { GHC.Word.W8# x1_abla ->
                                               case GHC.Prim.writeWord8OffAddr#
                                                      @GHC.Prim.RealWorld
                                                      ipv2_abjO
                                                      0#
                                                      x1_abla
                                                      ipv_abjP
                                               of s2_ablc
                                               { __DEFAULT ->
                                               case GHC.Prim.touch#
                                                      @'GHC.Types.Lifted
                                                      @GHC.ForeignPtr.ForeignPtrContents
                                                      ipv3_abjS
                                                      s2_ablc
                                               of s'_abld
                                               { __DEFAULT ->
                                               case {__ffi_static_ccall_unsafe base:memcpy :: Addr#
                                          -> Addr#
                                          -> Word64#
                                          -> State# RealWorld
                                          -> (# State# RealWorld, Addr# #)}_able
                                                      (GHC.Prim.plusAddr# ipv2_abjO 1#)
                                                      bx_abjI
                                                      (GHC.Prim.int64ToWord64#
                                                         (GHC.Prim.intToInt64# bx2_abjK))
                                                      s'_abld
                                               of
                                               { (# ds4_ablg, ds5_ablh #) ->
                                               case GHC.Prim.touch#
                                                      @'GHC.Types.Lifted
                                                      @GHC.ForeignPtr.ForeignPtrContents
                                                      bx1_abjJ
                                                      ds4_ablg
                                               of s'1_ablj
                                               { __DEFAULT ->
                                               case GHC.Prim.touch#
                                                      @'GHC.Types.Lifted
                                                      @GHC.ForeignPtr.ForeignPtrContents
                                                      ipv3_abjS
                                                      s'1_ablj
                                               of s'2_ablk
                                               { __DEFAULT ->
                                               case GHC.Magic.lazy
                                                      @((GHC.Prim.State# GHC.Prim.RealWorld
                                                         -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                               GHC.Prim.Addr# #))
                                                        -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                              GHC.Prim.Addr# #))
                                                      (GHC.Magic.runRW#
                                                         @('GHC.Types.TupleRep
                                                             '[GHC.Types.ZeroBitRep,
                                                               'GHC.Types.AddrRep])
                                                         @(# GHC.Prim.State# GHC.Prim.RealWorld,
                                                             GHC.Prim.Addr# #))
                                                      (\ _ [Occ=Dead] -> (# s'2_ablk, ipv2_abjO #))
                                               of
                                               { (# ipv6_abln, ipv7_ablo #) ->
                                               Data.ByteString.Internal.Type.BS
                                                 ipv7_ablo ipv3_abjS x_abjH
                                               }
                                               }
                                               }
                                               }
                                               }
                                               }
                                               }
                                               };
                                             1# ->
                                               case GHC.ForeignPtr.mallocPlainForeignPtrBytes2
                                               of wild_00 {
                                               }
                                           })
                                      }
                                      }) } in
                           \ (ds3_ablr
                                :: Data.Either.Either
                                     Data.ByteString.Internal.Type.ByteString
                                     (f_abj9
                                        (GHC.Word.Word8,
                                         Data.ByteString.Internal.Type.ByteString))) ->
                             case ds3_ablr of {
                               Data.Either.Left x_ablt -> f2_abjr x_ablt;
                               Data.Either.Right y_ablv -> ds2_abjs y_ablv
                             }) } in
                  let {
                    g_ablx
                      :: p_abj8
                           (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                           (f_abj9 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                         -> p_abj8
                              (Data.Either.Either
                                 Data.ByteString.Internal.Type.ByteString
                                 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                              (Data.Either.Either
                                 Data.ByteString.Internal.Type.ByteString
                                 (f_abj9
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_ablx
                      = Data.Profunctor.Choice.right'
                          @p_abj8
                          $dChoice_abja
                          @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                          @(f_abj9
                              (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                          @Data.ByteString.Internal.Type.ByteString } in
                  \ (x_ably
                       :: p_abj8
                            (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                            (f_abj9
                               (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))) ->
                    f1_abjc (g_ablx x_ably))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <Data.ByteString.Internal.Type.ByteString>_N
                                <Data.ByteString.Internal.Type.ByteString>_N
                                <GHC.Word.Word8>_N
                                <GHC.Word.Word8>_N)
                       :: Control.Lens.Type.Prism
                            Data.ByteString.Internal.Type.ByteString
                            Data.ByteString.Internal.Type.ByteString
                            (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                            (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                          ~R# Control.Lens.Cons.Cons
                                Data.ByteString.Internal.Type.ByteString
                                Data.ByteString.Internal.Type.ByteString
                                GHC.Word.Word8
                                GHC.Word.Word8))
              ((\ (@(p_abeP :: * -> * -> *))
                  (@(f_abeQ :: * -> *))
                  ($dChoice_abeR :: Data.Profunctor.Choice.Choice p_abeP)
                  ($dApplicative_abeS :: GHC.Base.Applicative f_abeQ) ->
                  let {
                    f1_abeT
                      :: p_abeP
                           (Data.Either.Either
                              [GHC.Word.Word8] (GHC.Word.Word8, [GHC.Word.Word8]))
                           (Data.Either.Either
                              [GHC.Word.Word8] (f_abeQ (GHC.Word.Word8, [GHC.Word.Word8])))
                         -> p_abeP [GHC.Word.Word8] (f_abeQ [GHC.Word.Word8])
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 320 0}]
                    f1_abeT
                      = Data.Profunctor.Unsafe.dimap
                          @p_abeP
                          (Data.Profunctor.Choice.$p1Choice @p_abeP $dChoice_abeR)
                          @[GHC.Word.Word8]
                          @(Data.Either.Either
                              [GHC.Word.Word8] (GHC.Word.Word8, [GHC.Word.Word8]))
                          @(Data.Either.Either
                              [GHC.Word.Word8] (f_abeQ (GHC.Word.Word8, [GHC.Word.Word8])))
                          @(f_abeQ [GHC.Word.Word8])
                          (\ (aas_abeU :: [GHC.Word.Word8]) ->
                             case aas_abeU of {
                               [] ->
                                 Data.Either.Left
                                   @[GHC.Word.Word8]
                                   @(GHC.Word.Word8, [GHC.Word.Word8])
                                   (GHC.Types.[] @GHC.Word.Word8);
                               : a1_abeW as_abeX ->
                                 Data.Either.Right
                                   @[GHC.Word.Word8]
                                   @(GHC.Word.Word8, [GHC.Word.Word8])
                                   (a1_abeW, as_abeX)
                             })
                          (let {
                             f2_abeZ :: [GHC.Word.Word8] -> f_abeQ [GHC.Word.Word8]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abeZ
                               = GHC.Base.pure @f_abeQ $dApplicative_abeS @[GHC.Word.Word8] } in
                           let {
                             ds2_abf0
                               :: f_abeQ (GHC.Word.Word8, [GHC.Word.Word8])
                                  -> f_abeQ [GHC.Word.Word8]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 90 0}]
                             ds2_abf0
                               = GHC.Base.fmap
                                   @f_abeQ
                                   (GHC.Base.$p1Applicative @f_abeQ $dApplicative_abeS)
                                   @(GHC.Word.Word8, [GHC.Word.Word8])
                                   @[GHC.Word.Word8]
                                   (\ (p1_abf1 :: (GHC.Word.Word8, [GHC.Word.Word8])) ->
                                      GHC.Types.:
                                        @GHC.Word.Word8
                                        (case p1_abf1 of { (x_abf3, ds_abf4) -> x_abf3 })
                                        (case p1_abf1 of { (ds_abf7, y_abf8) -> y_abf8 })) } in
                           \ (ds3_abfa
                                :: Data.Either.Either
                                     [GHC.Word.Word8]
                                     (f_abeQ (GHC.Word.Word8, [GHC.Word.Word8]))) ->
                             case ds3_abfa of {
                               Data.Either.Left x_abfc -> f2_abeZ x_abfc;
                               Data.Either.Right y_abfe -> ds2_abf0 y_abfe
                             }) } in
                  let {
                    g_abfg
                      :: p_abeP
                           (GHC.Word.Word8, [GHC.Word.Word8])
                           (f_abeQ (GHC.Word.Word8, [GHC.Word.Word8]))
                         -> p_abeP
                              (Data.Either.Either
                                 [GHC.Word.Word8] (GHC.Word.Word8, [GHC.Word.Word8]))
                              (Data.Either.Either
                                 [GHC.Word.Word8] (f_abeQ (GHC.Word.Word8, [GHC.Word.Word8])))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abfg
                      = Data.Profunctor.Choice.right'
                          @p_abeP
                          $dChoice_abeR
                          @(GHC.Word.Word8, [GHC.Word.Word8])
                          @(f_abeQ (GHC.Word.Word8, [GHC.Word.Word8]))
                          @[GHC.Word.Word8] } in
                  \ (x_abfh
                       :: p_abeP
                            (GHC.Word.Word8, [GHC.Word.Word8])
                            (f_abeQ (GHC.Word.Word8, [GHC.Word.Word8]))) ->
                    f1_abeT (g_abfg x_abfh))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <[GHC.Word.Word8]>_N
                                <[GHC.Word.Word8]>_N
                                <GHC.Word.Word8>_N
                                <GHC.Word.Word8>_N)
                       :: Control.Lens.Type.Prism
                            [GHC.Word.Word8]
                            [GHC.Word.Word8]
                            (GHC.Word.Word8, [GHC.Word.Word8])
                            (GHC.Word.Word8, [GHC.Word.Word8])
                          ~R# Control.Lens.Cons.Cons
                                [GHC.Word.Word8] [GHC.Word.Word8] GHC.Word.Word8 GHC.Word.Word8))
              ((\ (@(p_abfm :: * -> * -> *))
                  (@(f_abfn :: * -> *))
                  ($dChoice_abfo :: Data.Profunctor.Choice.Choice p_abfm)
                  ($dApplicative_abfp :: GHC.Base.Applicative f_abfn) ->
                  let {
                    f1_abfq
                      :: p_abfm
                           (Data.Either.Either [GHC.Word.Word8] ())
                           (Data.Either.Either [GHC.Word.Word8] (f_abfn ()))
                         -> p_abfm [GHC.Word.Word8] (f_abfn [GHC.Word.Word8])
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 290 0}]
                    f1_abfq
                      = Data.Profunctor.Unsafe.dimap
                          @p_abfm
                          (Data.Profunctor.Choice.$p1Choice @p_abfm $dChoice_abfo)
                          @[GHC.Word.Word8]
                          @(Data.Either.Either [GHC.Word.Word8] ())
                          @(Data.Either.Either [GHC.Word.Word8] (f_abfn ()))
                          @(f_abfn [GHC.Word.Word8])
                          (\ (s_abfr :: [GHC.Word.Word8]) ->
                             case s_abfr of wild_abfs {
                               [] -> Data.Either.Right @[GHC.Word.Word8] @() GHC.Tuple.Prim.();
                               : ds1_abft ds2_abfu ->
                                 Data.Either.Left @[GHC.Word.Word8] @() wild_abfs
                             })
                          (let {
                             f2_abfw :: [GHC.Word.Word8] -> f_abfn [GHC.Word.Word8]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abfw
                               = GHC.Base.pure @f_abfn $dApplicative_abfp @[GHC.Word.Word8] } in
                           let {
                             ds2_abfx :: f_abfn () -> f_abfn [GHC.Word.Word8]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 70 0}]
                             ds2_abfx
                               = GHC.Base.fmap
                                   @f_abfn
                                   (GHC.Base.$p1Applicative @f_abfn $dApplicative_abfp)
                                   @()
                                   @[GHC.Word.Word8]
                                   (\ (ds3_abfy :: ()) ->
                                      case ds3_abfy of { () -> GHC.Types.[] @GHC.Word.Word8 }) } in
                           \ (ds3_abfA :: Data.Either.Either [GHC.Word.Word8] (f_abfn ())) ->
                             case ds3_abfA of {
                               Data.Either.Left x_abfC -> f2_abfw x_abfC;
                               Data.Either.Right y_abfE -> ds2_abfx y_abfE
                             }) } in
                  let {
                    g_abfG
                      :: p_abfm () (f_abfn ())
                         -> p_abfm
                              (Data.Either.Either [GHC.Word.Word8] ())
                              (Data.Either.Either [GHC.Word.Word8] (f_abfn ()))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abfG
                      = Data.Profunctor.Choice.right'
                          @p_abfm $dChoice_abfo @() @(f_abfn ()) @[GHC.Word.Word8] } in
                  \ (x_abfH :: p_abfm () (f_abfn ())) -> f1_abfq (g_abfG x_abfH))
               `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0] <[GHC.Word.Word8]>_N)
                       :: Control.Lens.Type.Prism' [GHC.Word.Word8] ()
                          ~R# Control.Lens.Empty.AsEmpty [GHC.Word.Word8]))
              (Data.Functor.Contravariant.$fContravariantConst @[GHC.Word.Word8])
              (Data.Functor.Const.$fFunctorConst @[GHC.Word.Word8])
    Cont:   ApplyToVal nodup hole Control.Lens.Getter.Getting
                                    [GHC.Word.Word8]
                                    Data.ByteString.Internal.Type.ByteString
                                    [GHC.Word.Word8]
              ((\ (ds_abdj [Occ=Once1] :: a_abdg) -> ds_abdj)
               `cast` (<a_abdg>_R
                       %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                          <*>_N <a_abdg>_R <a_abdg>_P)
                       :: (a_abdg -> a_abdg)
                          ~R# (a_abdg -> Data.Functor.Const.Const a_abdg a_abdg)))
            ApplyToVal nodup hole Data.ByteString.Internal.Type.ByteString
                                  -> Data.Functor.Const.Const
                                       [GHC.Word.Word8] Data.ByteString.Internal.Type.ByteString
              (Control.Lens.Getter.view
                 @[GHC.Word.Word8]
                 @((->) [GHC.Word.Word8])
                 @Data.ByteString.Internal.Type.ByteString
                 (Control.Monad.Reader.Class.$fMonadReaderrFUN @[GHC.Word.Word8])
                 (Control.Lens.Cons.Extras.recons
                    @[GHC.Word.Word8]
                    @GHC.Word.Word8
                    @Data.ByteString.Internal.Type.ByteString
                    (Control.Lens.Cons.$fConsListListab
                       @GHC.Word.Word8 @GHC.Word.Word8)
                    Control.Lens.Cons.$fConsByteStringByteStringWord8Word80
                    Control.Lens.Empty.$fAsEmptyByteString0
                    @(Data.Functor.Const.Const
                        Data.ByteString.Internal.Type.ByteString)
                    (Data.Functor.Contravariant.$fContravariantConst
                       @Data.ByteString.Internal.Type.ByteString)
                    (Data.Functor.Const.$fFunctorConst
                       @Data.ByteString.Internal.Type.ByteString))
                 s_a8Of)
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N
                        <[GHC.Word.Word8]>_R
                        <Data.ByteString.Internal.Type.ByteString>_P
                    :: Data.Functor.Const.Const
                         [GHC.Word.Word8] Data.ByteString.Internal.Type.ByteString
                       ~R# [GHC.Word.Word8])
            Stop[RuleArgCtxt] [GHC.Word.Word8]
Rule fired
    Rule: Class op fmap
    Module: (BUILTIN)
    Before: GHC.Base.fmap
              TyArg Data.Functor.Const.Const [GHC.Word.Word8]
              ValArg Data.Functor.Const.$fFunctorConst @[GHC.Word.Word8]
    After:  (Data.Functor.Const.$fFunctorConst2 @[GHC.Word.Word8])
            `cast` (forall (a :: <*>_N) (b :: <*>_N).
                    <a -> b>_R
                    %<'GHC.Types.Many>_N ->_R <Data.Functor.Const.Const
                                                 [GHC.Word.Word8] a>_R
                    %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                  <*>_N <[GHC.Word.Word8]>_R <a>_P
                                              ; Sym (Data.Functor.Const.N:Const[0]
                                                         <*>_N <[GHC.Word.Word8]>_R <b>_P)
                    :: (forall {a} {b}.
                        (a -> b)
                        -> Data.Functor.Const.Const [GHC.Word.Word8] a
                        -> Data.Functor.Const.Const [GHC.Word.Word8] a)
                       ~R# (forall {a} {b}.
                            (a -> b)
                            -> Data.Functor.Const.Const [GHC.Word.Word8] a
                            -> Data.Functor.Const.Const [GHC.Word.Word8] b))
    Cont:   ApplyToTy [GHC.Word.Word8]
            ApplyToTy Data.ByteString.Internal.Type.ByteString
            ApplyToVal nodup hole ([GHC.Word.Word8]
                                   -> Data.ByteString.Internal.Type.ByteString)
                                  -> Data.Functor.Const.Const [GHC.Word.Word8] [GHC.Word.Word8]
                                  -> Data.Functor.Const.Const
                                       [GHC.Word.Word8] Data.ByteString.Internal.Type.ByteString
              Data.ByteString.Internal.Type.packBytes
            ApplyToVal nodup hole Data.Functor.Const.Const
                                    [GHC.Word.Word8] [GHC.Word.Word8]
                                  -> Data.Functor.Const.Const
                                       [GHC.Word.Word8] Data.ByteString.Internal.Type.ByteString
              (bc_abny (ab_abnw x_abnz))
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N
                        <[GHC.Word.Word8]>_R
                        <Data.ByteString.Internal.Type.ByteString>_P
                    :: Data.Functor.Const.Const
                         [GHC.Word.Word8] Data.ByteString.Internal.Type.ByteString
                       ~R# [GHC.Word.Word8])
            Stop[RuleArgCtxt] [GHC.Word.Word8]
Rule fired
    Rule: Class op reader
    Module: (BUILTIN)
    Before: Control.Monad.Reader.Class.reader
              TyArg [GHC.Word.Word8]
              TyArg (->) [GHC.Word.Word8]
              ValArg Control.Monad.Reader.Class.$fMonadReaderrFUN
                       @[GHC.Word.Word8]
    After:  \ (@a_abdo) -> GHC.Base.id @([GHC.Word.Word8] -> a_abdo)
    Cont:   ApplyToTy Data.ByteString.Internal.Type.ByteString
            ApplyToVal nodup hole ([GHC.Word.Word8]
                                   -> Data.ByteString.Internal.Type.ByteString)
                                  -> [GHC.Word.Word8] -> Data.ByteString.Internal.Type.ByteString
              ((l_abdi
                  ((\ (ds_abdj [Occ=Once1] :: a_abdg) -> ds_abdj)
                   `cast` (<a_abdg>_R
                           %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                              <*>_N <a_abdg>_R <a_abdg>_P)
                           :: (a_abdg -> a_abdg)
                              ~R# (a_abdg -> Data.Functor.Const.Const a_abdg a_abdg))))
               `cast` (<s_abde>_R
                       %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                     <*>_N <a_abdg>_R <s_abde>_P
                       :: (s_abde -> Data.Functor.Const.Const a_abdg s_abde)
                          ~R# (s_abde -> a_abdg)))
            ApplyToVal nodup hole [GHC.Word.Word8]
                                  -> Data.ByteString.Internal.Type.ByteString
              s_a8Of
            Stop[BoringCtxt] Data.ByteString.Internal.Type.ByteString
Rule fired
    Rule: recons/list-bs
    Module: (Control.Lens.Cons.Extras)
    Before: Control.Lens.Cons.Extras.recons
              TyArg [GHC.Word.Word8]
              TyArg GHC.Word.Word8
              TyArg Data.ByteString.Internal.Type.ByteString
              ValArg (\ (@(p_abeP :: * -> * -> *))
                        (@(f_abeQ :: * -> *))
                        ($dChoice_abeR :: Data.Profunctor.Choice.Choice p_abeP)
                        ($dApplicative_abeS :: GHC.Base.Applicative f_abeQ) ->
                        let {
                          f1_abeT
                            :: p_abeP
                                 (Data.Either.Either
                                    [GHC.Word.Word8] (GHC.Word.Word8, [GHC.Word.Word8]))
                                 (Data.Either.Either
                                    [GHC.Word.Word8] (f_abeQ (GHC.Word.Word8, [GHC.Word.Word8])))
                               -> p_abeP [GHC.Word.Word8] (f_abeQ [GHC.Word.Word8])
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 320 0}]
                          f1_abeT
                            = Data.Profunctor.Unsafe.dimap
                                @p_abeP
                                (Data.Profunctor.Choice.$p1Choice @p_abeP $dChoice_abeR)
                                @[GHC.Word.Word8]
                                @(Data.Either.Either
                                    [GHC.Word.Word8] (GHC.Word.Word8, [GHC.Word.Word8]))
                                @(Data.Either.Either
                                    [GHC.Word.Word8] (f_abeQ (GHC.Word.Word8, [GHC.Word.Word8])))
                                @(f_abeQ [GHC.Word.Word8])
                                (\ (aas_abeU :: [GHC.Word.Word8]) ->
                                   case aas_abeU of {
                                     [] ->
                                       Data.Either.Left
                                         @[GHC.Word.Word8]
                                         @(GHC.Word.Word8, [GHC.Word.Word8])
                                         (GHC.Types.[] @GHC.Word.Word8);
                                     : a1_abeW as_abeX ->
                                       Data.Either.Right
                                         @[GHC.Word.Word8]
                                         @(GHC.Word.Word8, [GHC.Word.Word8])
                                         (a1_abeW, as_abeX)
                                   })
                                (let {
                                   f2_abeZ :: [GHC.Word.Word8] -> f_abeQ [GHC.Word.Word8]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abeZ
                                     = GHC.Base.pure
                                         @f_abeQ $dApplicative_abeS @[GHC.Word.Word8] } in
                                 let {
                                   ds2_abf0
                                     :: f_abeQ (GHC.Word.Word8, [GHC.Word.Word8])
                                        -> f_abeQ [GHC.Word.Word8]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 90 0}]
                                   ds2_abf0
                                     = GHC.Base.fmap
                                         @f_abeQ
                                         (GHC.Base.$p1Applicative @f_abeQ $dApplicative_abeS)
                                         @(GHC.Word.Word8, [GHC.Word.Word8])
                                         @[GHC.Word.Word8]
                                         (\ (p1_abf1 :: (GHC.Word.Word8, [GHC.Word.Word8])) ->
                                            GHC.Types.:
                                              @GHC.Word.Word8
                                              (case p1_abf1 of { (x_abf3, ds_abf4) -> x_abf3 })
                                              (case p1_abf1 of { (ds_abf7, y_abf8) ->
                                               y_abf8
                                               })) } in
                                 \ (ds3_abfa
                                      :: Data.Either.Either
                                           [GHC.Word.Word8]
                                           (f_abeQ (GHC.Word.Word8, [GHC.Word.Word8]))) ->
                                   case ds3_abfa of {
                                     Data.Either.Left x_abfc -> f2_abeZ x_abfc;
                                     Data.Either.Right y_abfe -> ds2_abf0 y_abfe
                                   }) } in
                        let {
                          g_abfg
                            :: p_abeP
                                 (GHC.Word.Word8, [GHC.Word.Word8])
                                 (f_abeQ (GHC.Word.Word8, [GHC.Word.Word8]))
                               -> p_abeP
                                    (Data.Either.Either
                                       [GHC.Word.Word8] (GHC.Word.Word8, [GHC.Word.Word8]))
                                    (Data.Either.Either
                                       [GHC.Word.Word8] (f_abeQ (GHC.Word.Word8, [GHC.Word.Word8])))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abfg
                            = Data.Profunctor.Choice.right'
                                @p_abeP
                                $dChoice_abeR
                                @(GHC.Word.Word8, [GHC.Word.Word8])
                                @(f_abeQ (GHC.Word.Word8, [GHC.Word.Word8]))
                                @[GHC.Word.Word8] } in
                        \ (x_abfh
                             :: p_abeP
                                  (GHC.Word.Word8, [GHC.Word.Word8])
                                  (f_abeQ (GHC.Word.Word8, [GHC.Word.Word8]))) ->
                          f1_abeT (g_abfg x_abfh))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <[GHC.Word.Word8]>_N
                                      <[GHC.Word.Word8]>_N
                                      <GHC.Word.Word8>_N
                                      <GHC.Word.Word8>_N)
                             :: Control.Lens.Type.Prism
                                  [GHC.Word.Word8]
                                  [GHC.Word.Word8]
                                  (GHC.Word.Word8, [GHC.Word.Word8])
                                  (GHC.Word.Word8, [GHC.Word.Word8])
                                ~R# Control.Lens.Cons.Cons
                                      [GHC.Word.Word8]
                                      [GHC.Word.Word8]
                                      GHC.Word.Word8
                                      GHC.Word.Word8)
              ValArg (\ (@(p_abj8 :: * -> * -> *))
                        (@(f_abj9 :: * -> *))
                        ($dChoice_abja :: Data.Profunctor.Choice.Choice p_abj8)
                        ($dApplicative_abjb :: GHC.Base.Applicative f_abj9) ->
                        let {
                          f1_abjc
                            :: p_abj8
                                 (Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                                 (Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString
                                    (f_abj9
                                       (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                               -> p_abj8
                                    Data.ByteString.Internal.Type.ByteString
                                    (f_abj9 Data.ByteString.Internal.Type.ByteString)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 612 0}]
                          f1_abjc
                            = Data.Profunctor.Unsafe.dimap
                                @p_abj8
                                (Data.Profunctor.Choice.$p1Choice @p_abj8 $dChoice_abja)
                                @Data.ByteString.Internal.Type.ByteString
                                @(Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                                @(Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString
                                    (f_abj9
                                       (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                                @(f_abj9 Data.ByteString.Internal.Type.ByteString)
                                (\ (s1_abjd :: Data.ByteString.Internal.Type.ByteString) ->
                                   case s1_abjd of wild_abje
                                   { Data.ByteString.Internal.Type.BS bx_abjf bx1_abjg bx2_abjh ->
                                   case GHC.Classes.leInt (GHC.Types.I# bx2_abjh) (GHC.Types.I# 0#)
                                   of {
                                     GHC.Types.False ->
                                       Data.Either.Right
                                         @Data.ByteString.Internal.Type.ByteString
                                         @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                         (case GHC.Prim.readWord8OffAddr#
                                                 @GHC.Prim.RealWorld bx_abjf 0# GHC.Prim.realWorld#
                                          of
                                          { (# ipv_abjm, ipv1_abjn #) ->
                                          case GHC.Prim.touch#
                                                 @'GHC.Types.Lifted
                                                 @GHC.ForeignPtr.ForeignPtrContents
                                                 bx1_abjg
                                                 ipv_abjm
                                          of
                                          { __DEFAULT ->
                                          GHC.Word.W8# ipv1_abjn
                                          }
                                          },
                                          Data.ByteString.Internal.Type.$WBS
                                            (GHC.ForeignPtr.ForeignPtr
                                               @GHC.Word.Word8
                                               (GHC.Prim.plusAddr# bx_abjf 1#)
                                               bx1_abjg)
                                            (GHC.Types.I# (GHC.Prim.-# bx2_abjh 1#)));
                                     GHC.Types.True ->
                                       Data.Either.Left
                                         @Data.ByteString.Internal.Type.ByteString
                                         @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                         wild_abje
                                   }
                                   })
                                (let {
                                   f2_abjr
                                     :: Data.ByteString.Internal.Type.ByteString
                                        -> f_abj9 Data.ByteString.Internal.Type.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abjr
                                     = GHC.Base.pure
                                         @f_abj9
                                         $dApplicative_abjb
                                         @Data.ByteString.Internal.Type.ByteString } in
                                 let {
                                   ds2_abjs
                                     :: f_abj9
                                          (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                        -> f_abj9 Data.ByteString.Internal.Type.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 259 0}]
                                   ds2_abjs
                                     = GHC.Base.fmap
                                         @f_abj9
                                         (GHC.Base.$p1Applicative @f_abj9 $dApplicative_abjb)
                                         @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                         @Data.ByteString.Internal.Type.ByteString
                                         (\ (p1_abjt
                                               :: (GHC.Word.Word8,
                                                   Data.ByteString.Internal.Type.ByteString)) ->
                                            case p1_abjt of { (ds_abjv, y_abjw) ->
                                            case y_abjw of
                                            { Data.ByteString.Internal.Type.BS bx_abjI bx1_abjJ
                                                                               bx2_abjK ->
                                            GHC.Magic.runRW#
                                              @GHC.Types.LiftedRep
                                              @Data.ByteString.Internal.Type.ByteString
                                              (\ (s_abjG [OS=OneShot]
                                                    :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                                                 let {
                                                   x_abjH :: GHC.Prim.Int#
                                                   [LclId,
                                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                            Value=False, ConLike=False,
                                                            WorkFree=False, Expandable=False,
                                                            Guidance=IF_ARGS [] 1 0}]
                                                   x_abjH = GHC.Prim.+# bx2_abjK 1# } in
                                                 case GHC.Prim.<# x_abjH 0# of {
                                                   __DEFAULT ->
                                                     case GHC.Prim.newPinnedByteArray#
                                                            @GHC.Prim.RealWorld x_abjH s_abjG
                                                     of
                                                     { (# ipv_abjP, ipv1_abjQ #) ->
                                                     let {
                                                       ipv2_abjO :: GHC.Prim.Addr#
                                                       [LclId,
                                                        Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                                Value=False, ConLike=False,
                                                                WorkFree=False, Expandable=False,
                                                                Guidance=IF_ARGS [] 1 0}]
                                                       ipv2_abjO
                                                         = GHC.Prim.mutableByteArrayContents#
                                                             @GHC.Prim.RealWorld ipv1_abjQ } in
                                                     let {
                                                       ipv3_abjS
                                                         :: GHC.ForeignPtr.ForeignPtrContents
                                                       [LclId,
                                                        Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                                Value=True, ConLike=True,
                                                                WorkFree=True, Expandable=True,
                                                                Guidance=IF_ARGS [] 10 10}]
                                                       ipv3_abjS
                                                         = GHC.ForeignPtr.PlainPtr ipv1_abjQ } in
                                                     case ds_abjv of { GHC.Word.W8# x1_abla ->
                                                     case GHC.Prim.writeWord8OffAddr#
                                                            @GHC.Prim.RealWorld
                                                            ipv2_abjO
                                                            0#
                                                            x1_abla
                                                            ipv_abjP
                                                     of s2_ablc
                                                     { __DEFAULT ->
                                                     case GHC.Prim.touch#
                                                            @'GHC.Types.Lifted
                                                            @GHC.ForeignPtr.ForeignPtrContents
                                                            ipv3_abjS
                                                            s2_ablc
                                                     of s'_abld
                                                     { __DEFAULT ->
                                                     case {__ffi_static_ccall_unsafe base:memcpy :: Addr#
                                          -> Addr#
                                          -> Word64#
                                          -> State# RealWorld
                                          -> (# State# RealWorld, Addr# #)}_able
                                                            (GHC.Prim.plusAddr# ipv2_abjO 1#)
                                                            bx_abjI
                                                            (GHC.Prim.int64ToWord64#
                                                               (GHC.Prim.intToInt64# bx2_abjK))
                                                            s'_abld
                                                     of
                                                     { (# ds4_ablg, ds5_ablh #) ->
                                                     case GHC.Prim.touch#
                                                            @'GHC.Types.Lifted
                                                            @GHC.ForeignPtr.ForeignPtrContents
                                                            bx1_abjJ
                                                            ds4_ablg
                                                     of s'1_ablj
                                                     { __DEFAULT ->
                                                     case GHC.Prim.touch#
                                                            @'GHC.Types.Lifted
                                                            @GHC.ForeignPtr.ForeignPtrContents
                                                            ipv3_abjS
                                                            s'1_ablj
                                                     of s'2_ablk
                                                     { __DEFAULT ->
                                                     case GHC.Magic.lazy
                                                            @((GHC.Prim.State# GHC.Prim.RealWorld
                                                               -> (# GHC.Prim.State#
                                                                       GHC.Prim.RealWorld,
                                                                     GHC.Prim.Addr# #))
                                                              -> (# GHC.Prim.State#
                                                                      GHC.Prim.RealWorld,
                                                                    GHC.Prim.Addr# #))
                                                            (GHC.Magic.runRW#
                                                               @('GHC.Types.TupleRep
                                                                   '[GHC.Types.ZeroBitRep,
                                                                     'GHC.Types.AddrRep])
                                                               @(# GHC.Prim.State#
                                                                     GHC.Prim.RealWorld,
                                                                   GHC.Prim.Addr# #))
                                                            (\ _ [Occ=Dead] ->
                                                               (# s'2_ablk, ipv2_abjO #))
                                                     of
                                                     { (# ipv6_abln, ipv7_ablo #) ->
                                                     Data.ByteString.Internal.Type.BS
                                                       ipv7_ablo ipv3_abjS x_abjH
                                                     }
                                                     }
                                                     }
                                                     }
                                                     }
                                                     }
                                                     }
                                                     };
                                                   1# ->
                                                     case GHC.ForeignPtr.mallocPlainForeignPtrBytes2
                                                     of wild_00 {
                                                     }
                                                 })
                                            }
                                            }) } in
                                 \ (ds3_ablr
                                      :: Data.Either.Either
                                           Data.ByteString.Internal.Type.ByteString
                                           (f_abj9
                                              (GHC.Word.Word8,
                                               Data.ByteString.Internal.Type.ByteString))) ->
                                   case ds3_ablr of {
                                     Data.Either.Left x_ablt -> f2_abjr x_ablt;
                                     Data.Either.Right y_ablv -> ds2_abjs y_ablv
                                   }) } in
                        let {
                          g_ablx
                            :: p_abj8
                                 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                 (f_abj9 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                               -> p_abj8
                                    (Data.Either.Either
                                       Data.ByteString.Internal.Type.ByteString
                                       (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                                    (Data.Either.Either
                                       Data.ByteString.Internal.Type.ByteString
                                       (f_abj9
                                          (GHC.Word.Word8,
                                           Data.ByteString.Internal.Type.ByteString)))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_ablx
                            = Data.Profunctor.Choice.right'
                                @p_abj8
                                $dChoice_abja
                                @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                @(f_abj9
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                                @Data.ByteString.Internal.Type.ByteString } in
                        \ (x_ably
                             :: p_abj8
                                  (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                  (f_abj9
                                     (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))) ->
                          f1_abjc (g_ablx x_ably))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <Data.ByteString.Internal.Type.ByteString>_N
                                      <Data.ByteString.Internal.Type.ByteString>_N
                                      <GHC.Word.Word8>_N
                                      <GHC.Word.Word8>_N)
                             :: Control.Lens.Type.Prism
                                  Data.ByteString.Internal.Type.ByteString
                                  Data.ByteString.Internal.Type.ByteString
                                  (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                  (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                ~R# Control.Lens.Cons.Cons
                                      Data.ByteString.Internal.Type.ByteString
                                      Data.ByteString.Internal.Type.ByteString
                                      GHC.Word.Word8
                                      GHC.Word.Word8)
              ValArg (\ (@(p_ablF :: * -> * -> *))
                        (@(f_ablG :: * -> *))
                        ($dChoice_ablH :: Data.Profunctor.Choice.Choice p_ablF)
                        ($dApplicative_ablI :: GHC.Base.Applicative f_ablG) ->
                        let {
                          f1_ablJ
                            :: p_ablF
                                 (Data.Either.Either Data.ByteString.Internal.Type.ByteString ())
                                 (Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString (f_ablG ()))
                               -> p_ablF
                                    Data.ByteString.Internal.Type.ByteString
                                    (f_ablG Data.ByteString.Internal.Type.ByteString)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 350 0}]
                          f1_ablJ
                            = Data.Profunctor.Unsafe.dimap
                                @p_ablF
                                (Data.Profunctor.Choice.$p1Choice @p_ablF $dChoice_ablH)
                                @Data.ByteString.Internal.Type.ByteString
                                @(Data.Either.Either Data.ByteString.Internal.Type.ByteString ())
                                @(Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString (f_ablG ()))
                                @(f_ablG Data.ByteString.Internal.Type.ByteString)
                                (\ (s_ablK :: Data.ByteString.Internal.Type.ByteString) ->
                                   case s_ablK of wild_ablL
                                   { Data.ByteString.Internal.Type.BS bx_ablM bx1_ablN bx2_ablO ->
                                   case GHC.Classes.leInt (GHC.Types.I# bx2_ablO) (GHC.Types.I# 0#)
                                   of {
                                     GHC.Types.False ->
                                       Data.Either.Left
                                         @Data.ByteString.Internal.Type.ByteString @() wild_ablL;
                                     GHC.Types.True ->
                                       Data.Either.Right
                                         @Data.ByteString.Internal.Type.ByteString
                                         @()
                                         GHC.Tuple.Prim.()
                                   }
                                   })
                                (let {
                                   f2_ablS
                                     :: Data.ByteString.Internal.Type.ByteString
                                        -> f_ablG Data.ByteString.Internal.Type.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_ablS
                                     = GHC.Base.pure
                                         @f_ablG
                                         $dApplicative_ablI
                                         @Data.ByteString.Internal.Type.ByteString } in
                                 let {
                                   ds2_ablT
                                     :: f_ablG () -> f_ablG Data.ByteString.Internal.Type.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 70 0}]
                                   ds2_ablT
                                     = GHC.Base.fmap
                                         @f_ablG
                                         (GHC.Base.$p1Applicative @f_ablG $dApplicative_ablI)
                                         @()
                                         @Data.ByteString.Internal.Type.ByteString
                                         (\ (ds3_ablU :: ()) ->
                                            case ds3_ablU of { () ->
                                            Data.ByteString.Internal.Type.empty
                                            }) } in
                                 \ (ds3_ablW
                                      :: Data.Either.Either
                                           Data.ByteString.Internal.Type.ByteString (f_ablG ())) ->
                                   case ds3_ablW of {
                                     Data.Either.Left x_ablY -> f2_ablS x_ablY;
                                     Data.Either.Right y_abm0 -> ds2_ablT y_abm0
                                   }) } in
                        let {
                          g_abm2
                            :: p_ablF () (f_ablG ())
                               -> p_ablF
                                    (Data.Either.Either Data.ByteString.Internal.Type.ByteString ())
                                    (Data.Either.Either
                                       Data.ByteString.Internal.Type.ByteString (f_ablG ()))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abm2
                            = Data.Profunctor.Choice.right'
                                @p_ablF
                                $dChoice_ablH
                                @()
                                @(f_ablG ())
                                @Data.ByteString.Internal.Type.ByteString } in
                        \ (x_abm3 :: p_ablF () (f_ablG ())) -> f1_ablJ (g_abm2 x_abm3))
                     `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                      <Data.ByteString.Internal.Type.ByteString>_N)
                             :: Control.Lens.Type.Prism'
                                  Data.ByteString.Internal.Type.ByteString ()
                                ~R# Control.Lens.Empty.AsEmpty
                                      Data.ByteString.Internal.Type.ByteString)
              TyArg Data.Functor.Const.Const
                      Data.ByteString.Internal.Type.ByteString
              ValArg Data.Functor.Contravariant.$fContravariantConst
                       @Data.ByteString.Internal.Type.ByteString
              ValArg Data.Functor.Const.$fFunctorConst
                       @Data.ByteString.Internal.Type.ByteString
    After:  (\ (@(f_abe5 :: * -> *))
               ($dCons_abe6
                  :: Control.Lens.Cons.Cons
                       [GHC.Word.Word8] [GHC.Word.Word8] GHC.Word.Word8 GHC.Word.Word8)
               ($dCons1_abe7
                  :: Control.Lens.Cons.Cons
                       Data.ByteString.Internal.Type.ByteString
                       Data.ByteString.Internal.Type.ByteString
                       GHC.Word.Word8
                       GHC.Word.Word8)
               ($dAsEmpty_abe8
                  :: Control.Lens.Empty.AsEmpty
                       Data.ByteString.Internal.Type.ByteString)
               ($dContravariant_abe9
                  :: Data.Functor.Contravariant.Contravariant f_abe5)
               ($dFunctor_abea :: GHC.Base.Functor f_abe5) ->
               Data.Profunctor.Unsafe.$fProfunctorFUN_$cdimap
                 @[GHC.Word.Word8]
                 @Data.ByteString.Internal.Type.ByteString
                 @(f_abe5 Data.ByteString.Internal.Type.ByteString)
                 @(f_abe5 [GHC.Word.Word8])
                 Data.ByteString.Internal.Type.packBytes
                 (GHC.Base.fmap
                    @f_abe5
                    $dFunctor_abea
                    @Data.ByteString.Internal.Type.ByteString
                    @[GHC.Word.Word8]
                    Data.ByteString.unpack))
              @(Data.Functor.Const.Const
                  Data.ByteString.Internal.Type.ByteString)
              ((\ (@(p_abeP :: * -> * -> *))
                  (@(f_abeQ :: * -> *))
                  ($dChoice_abeR :: Data.Profunctor.Choice.Choice p_abeP)
                  ($dApplicative_abeS :: GHC.Base.Applicative f_abeQ) ->
                  let {
                    f1_abeT
                      :: p_abeP
                           (Data.Either.Either
                              [GHC.Word.Word8] (GHC.Word.Word8, [GHC.Word.Word8]))
                           (Data.Either.Either
                              [GHC.Word.Word8] (f_abeQ (GHC.Word.Word8, [GHC.Word.Word8])))
                         -> p_abeP [GHC.Word.Word8] (f_abeQ [GHC.Word.Word8])
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 320 0}]
                    f1_abeT
                      = Data.Profunctor.Unsafe.dimap
                          @p_abeP
                          (Data.Profunctor.Choice.$p1Choice @p_abeP $dChoice_abeR)
                          @[GHC.Word.Word8]
                          @(Data.Either.Either
                              [GHC.Word.Word8] (GHC.Word.Word8, [GHC.Word.Word8]))
                          @(Data.Either.Either
                              [GHC.Word.Word8] (f_abeQ (GHC.Word.Word8, [GHC.Word.Word8])))
                          @(f_abeQ [GHC.Word.Word8])
                          (\ (aas_abeU :: [GHC.Word.Word8]) ->
                             case aas_abeU of {
                               [] ->
                                 Data.Either.Left
                                   @[GHC.Word.Word8]
                                   @(GHC.Word.Word8, [GHC.Word.Word8])
                                   (GHC.Types.[] @GHC.Word.Word8);
                               : a1_abeW as_abeX ->
                                 Data.Either.Right
                                   @[GHC.Word.Word8]
                                   @(GHC.Word.Word8, [GHC.Word.Word8])
                                   (a1_abeW, as_abeX)
                             })
                          (let {
                             f2_abeZ :: [GHC.Word.Word8] -> f_abeQ [GHC.Word.Word8]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abeZ
                               = GHC.Base.pure @f_abeQ $dApplicative_abeS @[GHC.Word.Word8] } in
                           let {
                             ds2_abf0
                               :: f_abeQ (GHC.Word.Word8, [GHC.Word.Word8])
                                  -> f_abeQ [GHC.Word.Word8]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 90 0}]
                             ds2_abf0
                               = GHC.Base.fmap
                                   @f_abeQ
                                   (GHC.Base.$p1Applicative @f_abeQ $dApplicative_abeS)
                                   @(GHC.Word.Word8, [GHC.Word.Word8])
                                   @[GHC.Word.Word8]
                                   (\ (p1_abf1 :: (GHC.Word.Word8, [GHC.Word.Word8])) ->
                                      GHC.Types.:
                                        @GHC.Word.Word8
                                        (case p1_abf1 of { (x_abf3, ds_abf4) -> x_abf3 })
                                        (case p1_abf1 of { (ds_abf7, y_abf8) -> y_abf8 })) } in
                           \ (ds3_abfa
                                :: Data.Either.Either
                                     [GHC.Word.Word8]
                                     (f_abeQ (GHC.Word.Word8, [GHC.Word.Word8]))) ->
                             case ds3_abfa of {
                               Data.Either.Left x_abfc -> f2_abeZ x_abfc;
                               Data.Either.Right y_abfe -> ds2_abf0 y_abfe
                             }) } in
                  let {
                    g_abfg
                      :: p_abeP
                           (GHC.Word.Word8, [GHC.Word.Word8])
                           (f_abeQ (GHC.Word.Word8, [GHC.Word.Word8]))
                         -> p_abeP
                              (Data.Either.Either
                                 [GHC.Word.Word8] (GHC.Word.Word8, [GHC.Word.Word8]))
                              (Data.Either.Either
                                 [GHC.Word.Word8] (f_abeQ (GHC.Word.Word8, [GHC.Word.Word8])))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abfg
                      = Data.Profunctor.Choice.right'
                          @p_abeP
                          $dChoice_abeR
                          @(GHC.Word.Word8, [GHC.Word.Word8])
                          @(f_abeQ (GHC.Word.Word8, [GHC.Word.Word8]))
                          @[GHC.Word.Word8] } in
                  \ (x_abfh
                       :: p_abeP
                            (GHC.Word.Word8, [GHC.Word.Word8])
                            (f_abeQ (GHC.Word.Word8, [GHC.Word.Word8]))) ->
                    f1_abeT (g_abfg x_abfh))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <[GHC.Word.Word8]>_N
                                <[GHC.Word.Word8]>_N
                                <GHC.Word.Word8>_N
                                <GHC.Word.Word8>_N)
                       :: Control.Lens.Type.Prism
                            [GHC.Word.Word8]
                            [GHC.Word.Word8]
                            (GHC.Word.Word8, [GHC.Word.Word8])
                            (GHC.Word.Word8, [GHC.Word.Word8])
                          ~R# Control.Lens.Cons.Cons
                                [GHC.Word.Word8] [GHC.Word.Word8] GHC.Word.Word8 GHC.Word.Word8))
              ((\ (@(p_abj8 :: * -> * -> *))
                  (@(f_abj9 :: * -> *))
                  ($dChoice_abja :: Data.Profunctor.Choice.Choice p_abj8)
                  ($dApplicative_abjb :: GHC.Base.Applicative f_abj9) ->
                  let {
                    f1_abjc
                      :: p_abj8
                           (Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString
                              (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                           (Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString
                              (f_abj9
                                 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                         -> p_abj8
                              Data.ByteString.Internal.Type.ByteString
                              (f_abj9 Data.ByteString.Internal.Type.ByteString)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 612 0}]
                    f1_abjc
                      = Data.Profunctor.Unsafe.dimap
                          @p_abj8
                          (Data.Profunctor.Choice.$p1Choice @p_abj8 $dChoice_abja)
                          @Data.ByteString.Internal.Type.ByteString
                          @(Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString
                              (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                          @(Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString
                              (f_abj9
                                 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                          @(f_abj9 Data.ByteString.Internal.Type.ByteString)
                          (\ (s1_abjd :: Data.ByteString.Internal.Type.ByteString) ->
                             case s1_abjd of wild_abje
                             { Data.ByteString.Internal.Type.BS bx_abjf bx1_abjg bx2_abjh ->
                             case GHC.Classes.leInt (GHC.Types.I# bx2_abjh) (GHC.Types.I# 0#)
                             of {
                               GHC.Types.False ->
                                 Data.Either.Right
                                   @Data.ByteString.Internal.Type.ByteString
                                   @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                   (case GHC.Prim.readWord8OffAddr#
                                           @GHC.Prim.RealWorld bx_abjf 0# GHC.Prim.realWorld#
                                    of
                                    { (# ipv_abjm, ipv1_abjn #) ->
                                    case GHC.Prim.touch#
                                           @'GHC.Types.Lifted
                                           @GHC.ForeignPtr.ForeignPtrContents
                                           bx1_abjg
                                           ipv_abjm
                                    of
                                    { __DEFAULT ->
                                    GHC.Word.W8# ipv1_abjn
                                    }
                                    },
                                    Data.ByteString.Internal.Type.$WBS
                                      (GHC.ForeignPtr.ForeignPtr
                                         @GHC.Word.Word8 (GHC.Prim.plusAddr# bx_abjf 1#) bx1_abjg)
                                      (GHC.Types.I# (GHC.Prim.-# bx2_abjh 1#)));
                               GHC.Types.True ->
                                 Data.Either.Left
                                   @Data.ByteString.Internal.Type.ByteString
                                   @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                   wild_abje
                             }
                             })
                          (let {
                             f2_abjr
                               :: Data.ByteString.Internal.Type.ByteString
                                  -> f_abj9 Data.ByteString.Internal.Type.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abjr
                               = GHC.Base.pure
                                   @f_abj9
                                   $dApplicative_abjb
                                   @Data.ByteString.Internal.Type.ByteString } in
                           let {
                             ds2_abjs
                               :: f_abj9
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                  -> f_abj9 Data.ByteString.Internal.Type.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 259 0}]
                             ds2_abjs
                               = GHC.Base.fmap
                                   @f_abj9
                                   (GHC.Base.$p1Applicative @f_abj9 $dApplicative_abjb)
                                   @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                   @Data.ByteString.Internal.Type.ByteString
                                   (\ (p1_abjt
                                         :: (GHC.Word.Word8,
                                             Data.ByteString.Internal.Type.ByteString)) ->
                                      case p1_abjt of { (ds_abjv, y_abjw) ->
                                      case y_abjw of
                                      { Data.ByteString.Internal.Type.BS bx_abjI bx1_abjJ
                                                                         bx2_abjK ->
                                      GHC.Magic.runRW#
                                        @GHC.Types.LiftedRep
                                        @Data.ByteString.Internal.Type.ByteString
                                        (\ (s_abjG [OS=OneShot]
                                              :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                                           let {
                                             x_abjH :: GHC.Prim.Int#
                                             [LclId,
                                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                      Value=False, ConLike=False, WorkFree=False,
                                                      Expandable=False,
                                                      Guidance=IF_ARGS [] 1 0}]
                                             x_abjH = GHC.Prim.+# bx2_abjK 1# } in
                                           case GHC.Prim.<# x_abjH 0# of {
                                             __DEFAULT ->
                                               case GHC.Prim.newPinnedByteArray#
                                                      @GHC.Prim.RealWorld x_abjH s_abjG
                                               of
                                               { (# ipv_abjP, ipv1_abjQ #) ->
                                               let {
                                                 ipv2_abjO :: GHC.Prim.Addr#
                                                 [LclId,
                                                  Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                          Value=False, ConLike=False,
                                                          WorkFree=False, Expandable=False,
                                                          Guidance=IF_ARGS [] 1 0}]
                                                 ipv2_abjO
                                                   = GHC.Prim.mutableByteArrayContents#
                                                       @GHC.Prim.RealWorld ipv1_abjQ } in
                                               let {
                                                 ipv3_abjS :: GHC.ForeignPtr.ForeignPtrContents
                                                 [LclId,
                                                  Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                          Value=True, ConLike=True, WorkFree=True,
                                                          Expandable=True,
                                                          Guidance=IF_ARGS [] 10 10}]
                                                 ipv3_abjS = GHC.ForeignPtr.PlainPtr ipv1_abjQ } in
                                               case ds_abjv of { GHC.Word.W8# x1_abla ->
                                               case GHC.Prim.writeWord8OffAddr#
                                                      @GHC.Prim.RealWorld
                                                      ipv2_abjO
                                                      0#
                                                      x1_abla
                                                      ipv_abjP
                                               of s2_ablc
                                               { __DEFAULT ->
                                               case GHC.Prim.touch#
                                                      @'GHC.Types.Lifted
                                                      @GHC.ForeignPtr.ForeignPtrContents
                                                      ipv3_abjS
                                                      s2_ablc
                                               of s'_abld
                                               { __DEFAULT ->
                                               case {__ffi_static_ccall_unsafe base:memcpy :: Addr#
                                          -> Addr#
                                          -> Word64#
                                          -> State# RealWorld
                                          -> (# State# RealWorld, Addr# #)}_able
                                                      (GHC.Prim.plusAddr# ipv2_abjO 1#)
                                                      bx_abjI
                                                      (GHC.Prim.int64ToWord64#
                                                         (GHC.Prim.intToInt64# bx2_abjK))
                                                      s'_abld
                                               of
                                               { (# ds4_ablg, ds5_ablh #) ->
                                               case GHC.Prim.touch#
                                                      @'GHC.Types.Lifted
                                                      @GHC.ForeignPtr.ForeignPtrContents
                                                      bx1_abjJ
                                                      ds4_ablg
                                               of s'1_ablj
                                               { __DEFAULT ->
                                               case GHC.Prim.touch#
                                                      @'GHC.Types.Lifted
                                                      @GHC.ForeignPtr.ForeignPtrContents
                                                      ipv3_abjS
                                                      s'1_ablj
                                               of s'2_ablk
                                               { __DEFAULT ->
                                               case GHC.Magic.lazy
                                                      @((GHC.Prim.State# GHC.Prim.RealWorld
                                                         -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                               GHC.Prim.Addr# #))
                                                        -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                              GHC.Prim.Addr# #))
                                                      (GHC.Magic.runRW#
                                                         @('GHC.Types.TupleRep
                                                             '[GHC.Types.ZeroBitRep,
                                                               'GHC.Types.AddrRep])
                                                         @(# GHC.Prim.State# GHC.Prim.RealWorld,
                                                             GHC.Prim.Addr# #))
                                                      (\ _ [Occ=Dead] -> (# s'2_ablk, ipv2_abjO #))
                                               of
                                               { (# ipv6_abln, ipv7_ablo #) ->
                                               Data.ByteString.Internal.Type.BS
                                                 ipv7_ablo ipv3_abjS x_abjH
                                               }
                                               }
                                               }
                                               }
                                               }
                                               }
                                               }
                                               };
                                             1# ->
                                               case GHC.ForeignPtr.mallocPlainForeignPtrBytes2
                                               of wild_00 {
                                               }
                                           })
                                      }
                                      }) } in
                           \ (ds3_ablr
                                :: Data.Either.Either
                                     Data.ByteString.Internal.Type.ByteString
                                     (f_abj9
                                        (GHC.Word.Word8,
                                         Data.ByteString.Internal.Type.ByteString))) ->
                             case ds3_ablr of {
                               Data.Either.Left x_ablt -> f2_abjr x_ablt;
                               Data.Either.Right y_ablv -> ds2_abjs y_ablv
                             }) } in
                  let {
                    g_ablx
                      :: p_abj8
                           (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                           (f_abj9 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                         -> p_abj8
                              (Data.Either.Either
                                 Data.ByteString.Internal.Type.ByteString
                                 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                              (Data.Either.Either
                                 Data.ByteString.Internal.Type.ByteString
                                 (f_abj9
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_ablx
                      = Data.Profunctor.Choice.right'
                          @p_abj8
                          $dChoice_abja
                          @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                          @(f_abj9
                              (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                          @Data.ByteString.Internal.Type.ByteString } in
                  \ (x_ably
                       :: p_abj8
                            (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                            (f_abj9
                               (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))) ->
                    f1_abjc (g_ablx x_ably))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <Data.ByteString.Internal.Type.ByteString>_N
                                <Data.ByteString.Internal.Type.ByteString>_N
                                <GHC.Word.Word8>_N
                                <GHC.Word.Word8>_N)
                       :: Control.Lens.Type.Prism
                            Data.ByteString.Internal.Type.ByteString
                            Data.ByteString.Internal.Type.ByteString
                            (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                            (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                          ~R# Control.Lens.Cons.Cons
                                Data.ByteString.Internal.Type.ByteString
                                Data.ByteString.Internal.Type.ByteString
                                GHC.Word.Word8
                                GHC.Word.Word8))
              ((\ (@(p_ablF :: * -> * -> *))
                  (@(f_ablG :: * -> *))
                  ($dChoice_ablH :: Data.Profunctor.Choice.Choice p_ablF)
                  ($dApplicative_ablI :: GHC.Base.Applicative f_ablG) ->
                  let {
                    f1_ablJ
                      :: p_ablF
                           (Data.Either.Either Data.ByteString.Internal.Type.ByteString ())
                           (Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString (f_ablG ()))
                         -> p_ablF
                              Data.ByteString.Internal.Type.ByteString
                              (f_ablG Data.ByteString.Internal.Type.ByteString)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 350 0}]
                    f1_ablJ
                      = Data.Profunctor.Unsafe.dimap
                          @p_ablF
                          (Data.Profunctor.Choice.$p1Choice @p_ablF $dChoice_ablH)
                          @Data.ByteString.Internal.Type.ByteString
                          @(Data.Either.Either Data.ByteString.Internal.Type.ByteString ())
                          @(Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString (f_ablG ()))
                          @(f_ablG Data.ByteString.Internal.Type.ByteString)
                          (\ (s_ablK :: Data.ByteString.Internal.Type.ByteString) ->
                             case s_ablK of wild_ablL
                             { Data.ByteString.Internal.Type.BS bx_ablM bx1_ablN bx2_ablO ->
                             case GHC.Classes.leInt (GHC.Types.I# bx2_ablO) (GHC.Types.I# 0#)
                             of {
                               GHC.Types.False ->
                                 Data.Either.Left
                                   @Data.ByteString.Internal.Type.ByteString @() wild_ablL;
                               GHC.Types.True ->
                                 Data.Either.Right
                                   @Data.ByteString.Internal.Type.ByteString @() GHC.Tuple.Prim.()
                             }
                             })
                          (let {
                             f2_ablS
                               :: Data.ByteString.Internal.Type.ByteString
                                  -> f_ablG Data.ByteString.Internal.Type.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_ablS
                               = GHC.Base.pure
                                   @f_ablG
                                   $dApplicative_ablI
                                   @Data.ByteString.Internal.Type.ByteString } in
                           let {
                             ds2_ablT
                               :: f_ablG () -> f_ablG Data.ByteString.Internal.Type.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 70 0}]
                             ds2_ablT
                               = GHC.Base.fmap
                                   @f_ablG
                                   (GHC.Base.$p1Applicative @f_ablG $dApplicative_ablI)
                                   @()
                                   @Data.ByteString.Internal.Type.ByteString
                                   (\ (ds3_ablU :: ()) ->
                                      case ds3_ablU of { () ->
                                      Data.ByteString.Internal.Type.empty
                                      }) } in
                           \ (ds3_ablW
                                :: Data.Either.Either
                                     Data.ByteString.Internal.Type.ByteString (f_ablG ())) ->
                             case ds3_ablW of {
                               Data.Either.Left x_ablY -> f2_ablS x_ablY;
                               Data.Either.Right y_abm0 -> ds2_ablT y_abm0
                             }) } in
                  let {
                    g_abm2
                      :: p_ablF () (f_ablG ())
                         -> p_ablF
                              (Data.Either.Either Data.ByteString.Internal.Type.ByteString ())
                              (Data.Either.Either
                                 Data.ByteString.Internal.Type.ByteString (f_ablG ()))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abm2
                      = Data.Profunctor.Choice.right'
                          @p_ablF
                          $dChoice_ablH
                          @()
                          @(f_ablG ())
                          @Data.ByteString.Internal.Type.ByteString } in
                  \ (x_abm3 :: p_ablF () (f_ablG ())) -> f1_ablJ (g_abm2 x_abm3))
               `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                <Data.ByteString.Internal.Type.ByteString>_N)
                       :: Control.Lens.Type.Prism'
                            Data.ByteString.Internal.Type.ByteString ()
                          ~R# Control.Lens.Empty.AsEmpty
                                Data.ByteString.Internal.Type.ByteString))
              (Data.Functor.Contravariant.$fContravariantConst
                 @Data.ByteString.Internal.Type.ByteString)
              (Data.Functor.Const.$fFunctorConst
                 @Data.ByteString.Internal.Type.ByteString)
    Cont:   ApplyToVal nodup hole Control.Lens.Getter.Getting
                                    Data.ByteString.Internal.Type.ByteString
                                    [GHC.Word.Word8]
                                    Data.ByteString.Internal.Type.ByteString
              ((\ (ds_abdj [Occ=Once1] :: a_abdg) -> ds_abdj)
               `cast` (<a_abdg>_R
                       %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                          <*>_N <a_abdg>_R <a_abdg>_P)
                       :: (a_abdg -> a_abdg)
                          ~R# (a_abdg -> Data.Functor.Const.Const a_abdg a_abdg)))
            ApplyToVal nodup hole [GHC.Word.Word8]
                                  -> Data.Functor.Const.Const
                                       Data.ByteString.Internal.Type.ByteString [GHC.Word.Word8]
              s_a8Of
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N
                        <Data.ByteString.Internal.Type.ByteString>_R
                        <[GHC.Word.Word8]>_P
                    :: Data.Functor.Const.Const
                         Data.ByteString.Internal.Type.ByteString [GHC.Word.Word8]
                       ~R# Data.ByteString.Internal.Type.ByteString)
            Stop[BoringCtxt] Data.ByteString.Internal.Type.ByteString
Rule fired
    Rule: Class op fmap
    Module: (BUILTIN)
    Before: GHC.Base.fmap
              TyArg Data.Functor.Const.Const
                      Data.ByteString.Internal.Type.ByteString
              ValArg Data.Functor.Const.$fFunctorConst
                       @Data.ByteString.Internal.Type.ByteString
    After:  (Data.Functor.Const.$fFunctorConst2
               @Data.ByteString.Internal.Type.ByteString)
            `cast` (forall (a :: <*>_N) (b :: <*>_N).
                    <a -> b>_R
                    %<'GHC.Types.Many>_N ->_R <Data.Functor.Const.Const
                                                 Data.ByteString.Internal.Type.ByteString a>_R
                    %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                  <*>_N
                                                  <Data.ByteString.Internal.Type.ByteString>_R
                                                  <a>_P
                                              ; Sym (Data.Functor.Const.N:Const[0]
                                                         <*>_N
                                                         <Data.ByteString.Internal.Type.ByteString>_R
                                                         <b>_P)
                    :: (forall {a} {b}.
                        (a -> b)
                        -> Data.Functor.Const.Const
                             Data.ByteString.Internal.Type.ByteString a
                        -> Data.Functor.Const.Const
                             Data.ByteString.Internal.Type.ByteString a)
                       ~R# (forall {a} {b}.
                            (a -> b)
                            -> Data.Functor.Const.Const
                                 Data.ByteString.Internal.Type.ByteString a
                            -> Data.Functor.Const.Const
                                 Data.ByteString.Internal.Type.ByteString b))
    Cont:   ApplyToTy Data.ByteString.Internal.Type.ByteString
            ApplyToTy [GHC.Word.Word8]
            ApplyToVal nodup hole (Data.ByteString.Internal.Type.ByteString
                                   -> [GHC.Word.Word8])
                                  -> Data.Functor.Const.Const
                                       Data.ByteString.Internal.Type.ByteString
                                       Data.ByteString.Internal.Type.ByteString
                                  -> Data.Functor.Const.Const
                                       Data.ByteString.Internal.Type.ByteString [GHC.Word.Word8]
              Data.ByteString.unpack
            ApplyToVal nodup hole Data.Functor.Const.Const
                                    Data.ByteString.Internal.Type.ByteString
                                    Data.ByteString.Internal.Type.ByteString
                                  -> Data.Functor.Const.Const
                                       Data.ByteString.Internal.Type.ByteString [GHC.Word.Word8]
              (bc_abny (ab_abnw x_abnz))
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N
                        <Data.ByteString.Internal.Type.ByteString>_R
                        <[GHC.Word.Word8]>_P
                    :: Data.Functor.Const.Const
                         Data.ByteString.Internal.Type.ByteString [GHC.Word.Word8]
                       ~R# Data.ByteString.Internal.Type.ByteString)
            Stop[BoringCtxt] Data.ByteString.Internal.Type.ByteString
Rule fired
    Rule: Class op ==
    Module: (BUILTIN)
    Before: GHC.Classes.==
              TyArg [GHC.Word.Word8]
              ValArg $dEq_a9db
              ValArg GHC.Base.build
                       @GHC.Word.Word8
                       (\ (@b_abqD) ->
                          Data.ByteString.unpackFoldr
                            @b_abqD (Data.ByteString.Internal.Type.packBytes s_a8Of))
              ValArg s_a8Of
    After:  GHC.Classes.$fEqList_$c==
              @GHC.Word.Word8 GHC.Word.$fEqWord8
              ValArg GHC.Base.build
                       @GHC.Word.Word8
                       (\ (@b_abqD) ->
                          Data.ByteString.unpackFoldr
                            @b_abqD (Data.ByteString.Internal.Type.packBytes s_a8Of))
              ValArg s_a8Of
    Cont:   Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: unpack
    Module: (GHC.Base)
    Before: GHC.CString.unpackCString# ValArg "[W8] -> L -> [W8]"#
    After:  (\ (a_ab5Y :: GHC.Prim.Addr#) ->
               GHC.Base.build
                 @GHC.Types.Char
                 (\ (@b_ab5Z) -> GHC.CString.unpackFoldrCString# @b_ab5Z a_ab5Y))
              "[W8] -> L -> [W8]"#
    Cont:   Stop[BoringCtxt] Test.Tasty.Core.TestName
Rule fired
    Rule: Class op property
    Module: (BUILTIN)
    Before: Test.QuickCheck.Property.property
              TyArg [GHC.Word.Word8] -> GHC.Types.Bool ValArg $dTestable_a9d4
    After:  Test.QuickCheck.Property.$fTestableFUN_$cproperty
              @[GHC.Word.Word8]
              @GHC.Types.Bool
              $dArbitrary_aabi
              $dShow_aabj
              Test.QuickCheck.Property.$fTestableBool
    Cont:   ApplyToVal nodup hole ([GHC.Word.Word8] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              prop_ab6b
            CastIt (Sym (Test.Tasty.QuickCheck.N:QC[0])
                    :: Test.QuickCheck.Property.Property ~R# Test.Tasty.QuickCheck.QC)
            Stop[BoringCtxt] Test.Tasty.QuickCheck.QC
Rule fired
    Rule: Class op propertyForAllShrinkShow
    Module: (BUILTIN)
    Before: Test.QuickCheck.Property.propertyForAllShrinkShow
              TyArg GHC.Types.Bool ValArg Test.QuickCheck.Property.$fTestableBool
    After:  Test.QuickCheck.Property.$fTestableBool1
            `cast` (forall (a :: <*>_N).
                    <Test.QuickCheck.Gen.Gen a>_R
                    %<'GHC.Types.Many>_N ->_R <a -> [a]>_R
                    %<'GHC.Types.Many>_N ->_R <a -> [GHC.Base.String]>_R
                    %<'GHC.Types.Many>_N ->_R <a -> GHC.Types.Bool>_R
                    %<'GHC.Types.Many>_N ->_R Sym (Test.QuickCheck.Gen.N:Gen[0]
                                                       (Test.QuickCheck.Property.N:Prop[0]))
                                              ; Sym (Test.QuickCheck.Property.N:Property[0])
                    :: (forall {a}.
                        Test.QuickCheck.Gen.Gen a
                        -> (a -> [a])
                        -> (a -> [GHC.Base.String])
                        -> (a -> GHC.Types.Bool)
                        -> Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int
                        -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result)
                       ~R# (forall {a}.
                            Test.QuickCheck.Gen.Gen a
                            -> (a -> [a])
                            -> (a -> [GHC.Base.String])
                            -> (a -> GHC.Types.Bool)
                            -> Test.QuickCheck.Property.Property))
    Cont:   ApplyToTy [GHC.Word.Word8]
            ApplyToVal nodup hole Test.QuickCheck.Gen.Gen [GHC.Word.Word8]
                                  -> ([GHC.Word.Word8] -> [[GHC.Word.Word8]])
                                  -> ([GHC.Word.Word8] -> [GHC.Base.String])
                                  -> ([GHC.Word.Word8] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (Test.QuickCheck.Arbitrary.arbitrary @a_ab7T $dArbitrary_ab7V)
            ApplyToVal nodup hole ([GHC.Word.Word8] -> [[GHC.Word.Word8]])
                                  -> ([GHC.Word.Word8] -> [GHC.Base.String])
                                  -> ([GHC.Word.Word8] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (Test.QuickCheck.Arbitrary.shrink @a_ab7T $dArbitrary_ab7V)
            ApplyToVal nodup hole ([GHC.Word.Word8] -> [GHC.Base.String])
                                  -> ([GHC.Word.Word8] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (let {
                 g_ab7Z [Occ=OnceL1!] :: a_ab7T -> GHC.Base.String
                 [LclId]
                 g_ab7Z = GHC.Show.show @a_ab7T $dShow_ab7W } in
               \ (x_ab80 [Occ=Once1] :: a_ab7T) ->
                 GHC.Types.:
                   @GHC.Base.String (g_ab7Z x_ab80) (GHC.Types.[] @GHC.Base.String))
            ApplyToVal nodup hole ([GHC.Word.Word8] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              f_ab7Y
            CastIt (Sym (Test.Tasty.QuickCheck.N:QC[0])
                    :: Test.QuickCheck.Property.Property ~R# Test.Tasty.QuickCheck.QC)
            Stop[BoringCtxt] Test.Tasty.QuickCheck.QC
Rule fired
    Rule: Class op arbitrary
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.arbitrary
              TyArg [GHC.Word.Word8] ValArg $dArbitrary_aabi
    After:  (Test.QuickCheck.Arbitrary.$fArbitraryList1
               @GHC.Word.Word8 Test.QuickCheck.Arbitrary.$fArbitraryWord8)
            `cast` (Sym (Test.QuickCheck.Gen.N:Gen[0] <[GHC.Word.Word8]>_R)
                    :: (Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int -> [GHC.Word.Word8])
                       ~R# Test.QuickCheck.Gen.Gen [GHC.Word.Word8])
    Cont:   Stop[BoringCtxt] Test.QuickCheck.Gen.Gen [GHC.Word.Word8]
Rule fired
    Rule: Class op arbitrary
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.arbitrary
              TyArg GHC.Word.Word8
              ValArg Test.QuickCheck.Arbitrary.$fArbitraryWord8
    After:  Test.QuickCheck.Arbitrary.$fArbitraryWord8_$sarbitrarySizedBoundedIntegral
            `cast` (Sym (Test.QuickCheck.Gen.N:Gen[0] <GHC.Word.Word8>_R)
                    :: (Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int -> GHC.Word.Word8)
                       ~R# Test.QuickCheck.Gen.Gen GHC.Word.Word8)
    Cont:   Stop[BoringCtxt, C(S,C(1,L))] Test.QuickCheck.Gen.Gen
                                            GHC.Word.Word8
Rule fired
    Rule: Class op shrink
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.shrink
              TyArg [GHC.Word.Word8] ValArg $dArbitrary_aabi
    After:  Test.QuickCheck.Arbitrary.$fArbitraryList_$cshrink
              @GHC.Word.Word8 Test.QuickCheck.Arbitrary.$fArbitraryWord8
    Cont:   Stop[BoringCtxt] [GHC.Word.Word8] -> [[GHC.Word.Word8]]
Rule fired
    Rule: Class op shrink
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.shrink
              TyArg GHC.Word.Word8
              ValArg Test.QuickCheck.Arbitrary.$fArbitraryWord8
    After:  Test.QuickCheck.Arbitrary.$fArbitraryWord8_$sshrinkIntegral
    Cont:   Stop[DiscArgCtxt, C(S,L)] GHC.Word.Word8
                                      -> [GHC.Word.Word8]
Rule fired
    Rule: Class op show
    Module: (BUILTIN)
    Before: GHC.Show.show TyArg [GHC.Word.Word8] ValArg $dShow_aabj
    After:  GHC.Show.$fShowList_$cshow
              @GHC.Word.Word8 GHC.Word.$fShowWord8
    Cont:   Stop[RhsCtxt(NonRecursive)] [GHC.Word.Word8]
                                        -> GHC.Base.String
Rule fired
    Rule: Class op showList
    Module: (BUILTIN)
    Before: GHC.Show.showList
              TyArg GHC.Word.Word8 ValArg GHC.Word.$fShowWord8
    After:  GHC.Word.$fShowWord8_$cshowList
    Cont:   ApplyToVal nodup hole [GHC.Word.Word8] -> GHC.Show.ShowS
              x_abqh
            ApplyToVal nodup hole GHC.Show.ShowS (GHC.Types.[] @GHC.Types.Char)
            Stop[BoringCtxt] GHC.Base.String
Rule fired
    Rule: Class op reader
    Module: (BUILTIN)
    Before: Control.Monad.Reader.Class.reader
              TyArg Data.ByteString.Lazy.Internal.ByteString
              TyArg (->) Data.ByteString.Lazy.Internal.ByteString
              ValArg Control.Monad.Reader.Class.$fMonadReaderrFUN
                       @Data.ByteString.Lazy.Internal.ByteString
    After:  \ (@a_abdo) ->
              GHC.Base.id @(Data.ByteString.Lazy.Internal.ByteString -> a_abdo)
    Cont:   ApplyToTy [GHC.Word.Word8]
            ApplyToVal nodup hole (Data.ByteString.Lazy.Internal.ByteString
                                   -> [GHC.Word.Word8])
                                  -> Data.ByteString.Lazy.Internal.ByteString -> [GHC.Word.Word8]
              ((l_abdi
                  ((\ (ds_abdj [Occ=Once1] :: a_abdg) -> ds_abdj)
                   `cast` (<a_abdg>_R
                           %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                              <*>_N <a_abdg>_R <a_abdg>_P)
                           :: (a_abdg -> a_abdg)
                              ~R# (a_abdg -> Data.Functor.Const.Const a_abdg a_abdg))))
               `cast` (<s_abde>_R
                       %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                     <*>_N <a_abdg>_R <s_abde>_P
                       :: (s_abde -> Data.Functor.Const.Const a_abdg s_abde)
                          ~R# (s_abde -> a_abdg)))
            ApplyToVal nodup hole Data.ByteString.Lazy.Internal.ByteString
                                  -> [GHC.Word.Word8]
              (Control.Lens.Getter.view
                 @[GHC.Word.Word8]
                 @((->) [GHC.Word.Word8])
                 @Data.ByteString.Lazy.Internal.ByteString
                 (Control.Monad.Reader.Class.$fMonadReaderrFUN @[GHC.Word.Word8])
                 (Control.Lens.Cons.Extras.recons
                    @[GHC.Word.Word8]
                    @GHC.Word.Word8
                    @Data.ByteString.Lazy.Internal.ByteString
                    (Control.Lens.Cons.$fConsListListab
                       @GHC.Word.Word8 @GHC.Word.Word8)
                    Control.Lens.Cons.$fConsByteStringByteStringWord8Word8
                    Control.Lens.Empty.$fAsEmptyByteString
                    @(Data.Functor.Const.Const
                        Data.ByteString.Lazy.Internal.ByteString)
                    (Data.Functor.Contravariant.$fContravariantConst
                       @Data.ByteString.Lazy.Internal.ByteString)
                    (Data.Functor.Const.$fFunctorConst
                       @Data.ByteString.Lazy.Internal.ByteString))
                 s_a8Og)
            Stop[RuleArgCtxt] [GHC.Word.Word8]
Rule fired
    Rule: recons/lazybs-list
    Module: (Control.Lens.Cons.Extras)
    Before: Control.Lens.Cons.Extras.recons
              TyArg Data.ByteString.Lazy.Internal.ByteString
              TyArg GHC.Word.Word8
              TyArg [GHC.Word.Word8]
              ValArg (\ (@(p_abm8 :: * -> * -> *))
                        (@(f_abm9 :: * -> *))
                        ($dChoice_abma :: Data.Profunctor.Choice.Choice p_abm8)
                        ($dApplicative_abmb :: GHC.Base.Applicative f_abm9) ->
                        let {
                          f1_abmc
                            :: p_abm8
                                 (Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                                 (Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (f_abm9
                                       (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                               -> p_abm8
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (f_abm9 Data.ByteString.Lazy.Internal.ByteString)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 536 0}]
                          f1_abmc
                            = Data.Profunctor.Unsafe.dimap
                                @p_abm8
                                (Data.Profunctor.Choice.$p1Choice @p_abm8 $dChoice_abma)
                                @Data.ByteString.Lazy.Internal.ByteString
                                @(Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                                @(Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (f_abm9
                                       (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                                @(f_abm9 Data.ByteString.Lazy.Internal.ByteString)
                                (\ (s1_abmd :: Data.ByteString.Lazy.Internal.ByteString) ->
                                   case s1_abmd of {
                                     Data.ByteString.Lazy.Internal.Empty ->
                                       Data.Either.Left
                                         @Data.ByteString.Lazy.Internal.ByteString
                                         @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                         Data.ByteString.Lazy.Internal.Empty;
                                     Data.ByteString.Lazy.Internal.Chunk bx_abmk bx1_abml bx2_abmm
                                                                         cs_abmn ->
                                       case bx2_abmm of ds1_abmp {
                                         __DEFAULT ->
                                           Data.Either.Right
                                             @Data.ByteString.Lazy.Internal.ByteString
                                             @(GHC.Word.Word8,
                                               Data.ByteString.Lazy.Internal.ByteString)
                                             (case GHC.Prim.readWord8OffAddr#
                                                     @GHC.Prim.RealWorld
                                                     bx_abmk
                                                     0#
                                                     GHC.Prim.realWorld#
                                              of
                                              { (# ipv_abmr, ipv1_abms #) ->
                                              case GHC.Prim.touch#
                                                     @'GHC.Types.Lifted
                                                     @GHC.ForeignPtr.ForeignPtrContents
                                                     bx1_abml
                                                     ipv_abmr
                                              of
                                              { __DEFAULT ->
                                              GHC.Word.W8# ipv1_abms
                                              }
                                              },
                                              Data.ByteString.Lazy.Internal.$WChunk
                                                (Data.ByteString.Internal.Type.$WBS
                                                   (GHC.ForeignPtr.ForeignPtr
                                                      @GHC.Word.Word8
                                                      (GHC.Prim.plusAddr# bx_abmk 1#)
                                                      bx1_abml)
                                                   (GHC.Types.I# (GHC.Prim.-# ds1_abmp 1#)))
                                                cs_abmn);
                                         1# ->
                                           Data.Either.Right
                                             @Data.ByteString.Lazy.Internal.ByteString
                                             @(GHC.Word.Word8,
                                               Data.ByteString.Lazy.Internal.ByteString)
                                             (case GHC.Prim.readWord8OffAddr#
                                                     @GHC.Prim.RealWorld
                                                     bx_abmk
                                                     0#
                                                     GHC.Prim.realWorld#
                                              of
                                              { (# ipv_abmw, ipv1_abmx #) ->
                                              case GHC.Prim.touch#
                                                     @'GHC.Types.Lifted
                                                     @GHC.ForeignPtr.ForeignPtrContents
                                                     bx1_abml
                                                     ipv_abmw
                                              of
                                              { __DEFAULT ->
                                              GHC.Word.W8# ipv1_abmx
                                              }
                                              },
                                              cs_abmn)
                                       }
                                   })
                                (let {
                                   f2_abmA
                                     :: Data.ByteString.Lazy.Internal.ByteString
                                        -> f_abm9 Data.ByteString.Lazy.Internal.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abmA
                                     = GHC.Base.pure
                                         @f_abm9
                                         $dApplicative_abmb
                                         @Data.ByteString.Lazy.Internal.ByteString } in
                                 let {
                                   ds2_abmB
                                     :: f_abm9
                                          (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                        -> f_abm9 Data.ByteString.Lazy.Internal.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 162 0}]
                                   ds2_abmB
                                     = GHC.Base.fmap
                                         @f_abm9
                                         (GHC.Base.$p1Applicative @f_abm9 $dApplicative_abmb)
                                         @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                         @Data.ByteString.Lazy.Internal.ByteString
                                         (\ (p1_abmC
                                               :: (GHC.Word.Word8,
                                                   Data.ByteString.Lazy.Internal.ByteString)) ->
                                            case p1_abmC of { (x_abmE, ds_abmF) ->
                                            case x_abmE of { GHC.Word.W8# x#_abmI ->
                                            Data.ByteString.Lazy.Internal.$WChunk
                                              (Data.ByteString.Internal.Type.$WBS
                                                 (GHC.ForeignPtr.ForeignPtr
                                                    @GHC.Word.Word8
                                                    (GHC.Prim.plusAddr#
                                                       Data.ByteString.singleton1
                                                       (GHC.Prim.word2Int#
                                                          (GHC.Prim.word8ToWord# x#_abmI)))
                                                    GHC.ForeignPtr.FinalPtr)
                                                 (GHC.Types.I# 1#))
                                              ds_abmF
                                            }
                                            }) } in
                                 \ (ds3_abmK
                                      :: Data.Either.Either
                                           Data.ByteString.Lazy.Internal.ByteString
                                           (f_abm9
                                              (GHC.Word.Word8,
                                               Data.ByteString.Lazy.Internal.ByteString))) ->
                                   case ds3_abmK of {
                                     Data.Either.Left x_abmM -> f2_abmA x_abmM;
                                     Data.Either.Right y_abmO -> ds2_abmB y_abmO
                                   }) } in
                        let {
                          g_abmQ
                            :: p_abm8
                                 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                 (f_abm9 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                               -> p_abm8
                                    (Data.Either.Either
                                       Data.ByteString.Lazy.Internal.ByteString
                                       (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                                    (Data.Either.Either
                                       Data.ByteString.Lazy.Internal.ByteString
                                       (f_abm9
                                          (GHC.Word.Word8,
                                           Data.ByteString.Lazy.Internal.ByteString)))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abmQ
                            = Data.Profunctor.Choice.right'
                                @p_abm8
                                $dChoice_abma
                                @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                @(f_abm9
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                                @Data.ByteString.Lazy.Internal.ByteString } in
                        \ (x_abmR
                             :: p_abm8
                                  (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                  (f_abm9
                                     (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))) ->
                          f1_abmc (g_abmQ x_abmR))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <Data.ByteString.Lazy.Internal.ByteString>_N
                                      <Data.ByteString.Lazy.Internal.ByteString>_N
                                      <GHC.Word.Word8>_N
                                      <GHC.Word.Word8>_N)
                             :: Control.Lens.Type.Prism
                                  Data.ByteString.Lazy.Internal.ByteString
                                  Data.ByteString.Lazy.Internal.ByteString
                                  (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                  (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                ~R# Control.Lens.Cons.Cons
                                      Data.ByteString.Lazy.Internal.ByteString
                                      Data.ByteString.Lazy.Internal.ByteString
                                      GHC.Word.Word8
                                      GHC.Word.Word8)
              ValArg (\ (@(p_abeP :: * -> * -> *))
                        (@(f_abeQ :: * -> *))
                        ($dChoice_abeR :: Data.Profunctor.Choice.Choice p_abeP)
                        ($dApplicative_abeS :: GHC.Base.Applicative f_abeQ) ->
                        let {
                          f1_abeT
                            :: p_abeP
                                 (Data.Either.Either
                                    [GHC.Word.Word8] (GHC.Word.Word8, [GHC.Word.Word8]))
                                 (Data.Either.Either
                                    [GHC.Word.Word8] (f_abeQ (GHC.Word.Word8, [GHC.Word.Word8])))
                               -> p_abeP [GHC.Word.Word8] (f_abeQ [GHC.Word.Word8])
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 320 0}]
                          f1_abeT
                            = Data.Profunctor.Unsafe.dimap
                                @p_abeP
                                (Data.Profunctor.Choice.$p1Choice @p_abeP $dChoice_abeR)
                                @[GHC.Word.Word8]
                                @(Data.Either.Either
                                    [GHC.Word.Word8] (GHC.Word.Word8, [GHC.Word.Word8]))
                                @(Data.Either.Either
                                    [GHC.Word.Word8] (f_abeQ (GHC.Word.Word8, [GHC.Word.Word8])))
                                @(f_abeQ [GHC.Word.Word8])
                                (\ (aas_abeU :: [GHC.Word.Word8]) ->
                                   case aas_abeU of {
                                     [] ->
                                       Data.Either.Left
                                         @[GHC.Word.Word8]
                                         @(GHC.Word.Word8, [GHC.Word.Word8])
                                         (GHC.Types.[] @GHC.Word.Word8);
                                     : a1_abeW as_abeX ->
                                       Data.Either.Right
                                         @[GHC.Word.Word8]
                                         @(GHC.Word.Word8, [GHC.Word.Word8])
                                         (a1_abeW, as_abeX)
                                   })
                                (let {
                                   f2_abeZ :: [GHC.Word.Word8] -> f_abeQ [GHC.Word.Word8]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abeZ
                                     = GHC.Base.pure
                                         @f_abeQ $dApplicative_abeS @[GHC.Word.Word8] } in
                                 let {
                                   ds2_abf0
                                     :: f_abeQ (GHC.Word.Word8, [GHC.Word.Word8])
                                        -> f_abeQ [GHC.Word.Word8]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 90 0}]
                                   ds2_abf0
                                     = GHC.Base.fmap
                                         @f_abeQ
                                         (GHC.Base.$p1Applicative @f_abeQ $dApplicative_abeS)
                                         @(GHC.Word.Word8, [GHC.Word.Word8])
                                         @[GHC.Word.Word8]
                                         (\ (p1_abf1 :: (GHC.Word.Word8, [GHC.Word.Word8])) ->
                                            GHC.Types.:
                                              @GHC.Word.Word8
                                              (case p1_abf1 of { (x_abf3, ds_abf4) -> x_abf3 })
                                              (case p1_abf1 of { (ds_abf7, y_abf8) ->
                                               y_abf8
                                               })) } in
                                 \ (ds3_abfa
                                      :: Data.Either.Either
                                           [GHC.Word.Word8]
                                           (f_abeQ (GHC.Word.Word8, [GHC.Word.Word8]))) ->
                                   case ds3_abfa of {
                                     Data.Either.Left x_abfc -> f2_abeZ x_abfc;
                                     Data.Either.Right y_abfe -> ds2_abf0 y_abfe
                                   }) } in
                        let {
                          g_abfg
                            :: p_abeP
                                 (GHC.Word.Word8, [GHC.Word.Word8])
                                 (f_abeQ (GHC.Word.Word8, [GHC.Word.Word8]))
                               -> p_abeP
                                    (Data.Either.Either
                                       [GHC.Word.Word8] (GHC.Word.Word8, [GHC.Word.Word8]))
                                    (Data.Either.Either
                                       [GHC.Word.Word8] (f_abeQ (GHC.Word.Word8, [GHC.Word.Word8])))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abfg
                            = Data.Profunctor.Choice.right'
                                @p_abeP
                                $dChoice_abeR
                                @(GHC.Word.Word8, [GHC.Word.Word8])
                                @(f_abeQ (GHC.Word.Word8, [GHC.Word.Word8]))
                                @[GHC.Word.Word8] } in
                        \ (x_abfh
                             :: p_abeP
                                  (GHC.Word.Word8, [GHC.Word.Word8])
                                  (f_abeQ (GHC.Word.Word8, [GHC.Word.Word8]))) ->
                          f1_abeT (g_abfg x_abfh))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <[GHC.Word.Word8]>_N
                                      <[GHC.Word.Word8]>_N
                                      <GHC.Word.Word8>_N
                                      <GHC.Word.Word8>_N)
                             :: Control.Lens.Type.Prism
                                  [GHC.Word.Word8]
                                  [GHC.Word.Word8]
                                  (GHC.Word.Word8, [GHC.Word.Word8])
                                  (GHC.Word.Word8, [GHC.Word.Word8])
                                ~R# Control.Lens.Cons.Cons
                                      [GHC.Word.Word8]
                                      [GHC.Word.Word8]
                                      GHC.Word.Word8
                                      GHC.Word.Word8)
              ValArg (\ (@(p_abfm :: * -> * -> *))
                        (@(f_abfn :: * -> *))
                        ($dChoice_abfo :: Data.Profunctor.Choice.Choice p_abfm)
                        ($dApplicative_abfp :: GHC.Base.Applicative f_abfn) ->
                        let {
                          f1_abfq
                            :: p_abfm
                                 (Data.Either.Either [GHC.Word.Word8] ())
                                 (Data.Either.Either [GHC.Word.Word8] (f_abfn ()))
                               -> p_abfm [GHC.Word.Word8] (f_abfn [GHC.Word.Word8])
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 290 0}]
                          f1_abfq
                            = Data.Profunctor.Unsafe.dimap
                                @p_abfm
                                (Data.Profunctor.Choice.$p1Choice @p_abfm $dChoice_abfo)
                                @[GHC.Word.Word8]
                                @(Data.Either.Either [GHC.Word.Word8] ())
                                @(Data.Either.Either [GHC.Word.Word8] (f_abfn ()))
                                @(f_abfn [GHC.Word.Word8])
                                (\ (s_abfr :: [GHC.Word.Word8]) ->
                                   case s_abfr of wild_abfs {
                                     [] ->
                                       Data.Either.Right @[GHC.Word.Word8] @() GHC.Tuple.Prim.();
                                     : ds1_abft ds2_abfu ->
                                       Data.Either.Left @[GHC.Word.Word8] @() wild_abfs
                                   })
                                (let {
                                   f2_abfw :: [GHC.Word.Word8] -> f_abfn [GHC.Word.Word8]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abfw
                                     = GHC.Base.pure
                                         @f_abfn $dApplicative_abfp @[GHC.Word.Word8] } in
                                 let {
                                   ds2_abfx :: f_abfn () -> f_abfn [GHC.Word.Word8]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 70 0}]
                                   ds2_abfx
                                     = GHC.Base.fmap
                                         @f_abfn
                                         (GHC.Base.$p1Applicative @f_abfn $dApplicative_abfp)
                                         @()
                                         @[GHC.Word.Word8]
                                         (\ (ds3_abfy :: ()) ->
                                            case ds3_abfy of { () ->
                                            GHC.Types.[] @GHC.Word.Word8
                                            }) } in
                                 \ (ds3_abfA :: Data.Either.Either [GHC.Word.Word8] (f_abfn ())) ->
                                   case ds3_abfA of {
                                     Data.Either.Left x_abfC -> f2_abfw x_abfC;
                                     Data.Either.Right y_abfE -> ds2_abfx y_abfE
                                   }) } in
                        let {
                          g_abfG
                            :: p_abfm () (f_abfn ())
                               -> p_abfm
                                    (Data.Either.Either [GHC.Word.Word8] ())
                                    (Data.Either.Either [GHC.Word.Word8] (f_abfn ()))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abfG
                            = Data.Profunctor.Choice.right'
                                @p_abfm $dChoice_abfo @() @(f_abfn ()) @[GHC.Word.Word8] } in
                        \ (x_abfH :: p_abfm () (f_abfn ())) -> f1_abfq (g_abfG x_abfH))
                     `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0] <[GHC.Word.Word8]>_N)
                             :: Control.Lens.Type.Prism' [GHC.Word.Word8] ()
                                ~R# Control.Lens.Empty.AsEmpty [GHC.Word.Word8])
              TyArg Data.Functor.Const.Const [GHC.Word.Word8]
              ValArg Data.Functor.Contravariant.$fContravariantConst
                       @[GHC.Word.Word8]
              ValArg Data.Functor.Const.$fFunctorConst @[GHC.Word.Word8]
    After:  (\ (@(f_abeh :: * -> *))
               ($dCons_abei
                  :: Control.Lens.Cons.Cons
                       Data.ByteString.Lazy.Internal.ByteString
                       Data.ByteString.Lazy.Internal.ByteString
                       GHC.Word.Word8
                       GHC.Word.Word8)
               ($dCons1_abej
                  :: Control.Lens.Cons.Cons
                       [GHC.Word.Word8] [GHC.Word.Word8] GHC.Word.Word8 GHC.Word.Word8)
               ($dAsEmpty_abek :: Control.Lens.Empty.AsEmpty [GHC.Word.Word8])
               ($dContravariant_abel
                  :: Data.Functor.Contravariant.Contravariant f_abeh)
               ($dFunctor_abem :: GHC.Base.Functor f_abeh) ->
               Data.Profunctor.Unsafe.$fProfunctorFUN_$cdimap
                 @Data.ByteString.Lazy.Internal.ByteString
                 @[GHC.Word.Word8]
                 @(f_abeh [GHC.Word.Word8])
                 @(f_abeh Data.ByteString.Lazy.Internal.ByteString)
                 Data.ByteString.Lazy.Internal.unpackBytes
                 (GHC.Base.fmap
                    @f_abeh
                    $dFunctor_abem
                    @[GHC.Word.Word8]
                    @Data.ByteString.Lazy.Internal.ByteString
                    Data.ByteString.Lazy.Internal.packBytes))
              @(Data.Functor.Const.Const [GHC.Word.Word8])
              ((\ (@(p_abm8 :: * -> * -> *))
                  (@(f_abm9 :: * -> *))
                  ($dChoice_abma :: Data.Profunctor.Choice.Choice p_abm8)
                  ($dApplicative_abmb :: GHC.Base.Applicative f_abm9) ->
                  let {
                    f1_abmc
                      :: p_abm8
                           (Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString
                              (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                           (Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString
                              (f_abm9
                                 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                         -> p_abm8
                              Data.ByteString.Lazy.Internal.ByteString
                              (f_abm9 Data.ByteString.Lazy.Internal.ByteString)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 536 0}]
                    f1_abmc
                      = Data.Profunctor.Unsafe.dimap
                          @p_abm8
                          (Data.Profunctor.Choice.$p1Choice @p_abm8 $dChoice_abma)
                          @Data.ByteString.Lazy.Internal.ByteString
                          @(Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString
                              (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                          @(Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString
                              (f_abm9
                                 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                          @(f_abm9 Data.ByteString.Lazy.Internal.ByteString)
                          (\ (s1_abmd :: Data.ByteString.Lazy.Internal.ByteString) ->
                             case s1_abmd of {
                               Data.ByteString.Lazy.Internal.Empty ->
                                 Data.Either.Left
                                   @Data.ByteString.Lazy.Internal.ByteString
                                   @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                   Data.ByteString.Lazy.Internal.Empty;
                               Data.ByteString.Lazy.Internal.Chunk bx_abmk bx1_abml bx2_abmm
                                                                   cs_abmn ->
                                 case bx2_abmm of ds1_abmp {
                                   __DEFAULT ->
                                     Data.Either.Right
                                       @Data.ByteString.Lazy.Internal.ByteString
                                       @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                       (case GHC.Prim.readWord8OffAddr#
                                               @GHC.Prim.RealWorld bx_abmk 0# GHC.Prim.realWorld#
                                        of
                                        { (# ipv_abmr, ipv1_abms #) ->
                                        case GHC.Prim.touch#
                                               @'GHC.Types.Lifted
                                               @GHC.ForeignPtr.ForeignPtrContents
                                               bx1_abml
                                               ipv_abmr
                                        of
                                        { __DEFAULT ->
                                        GHC.Word.W8# ipv1_abms
                                        }
                                        },
                                        Data.ByteString.Lazy.Internal.$WChunk
                                          (Data.ByteString.Internal.Type.$WBS
                                             (GHC.ForeignPtr.ForeignPtr
                                                @GHC.Word.Word8
                                                (GHC.Prim.plusAddr# bx_abmk 1#)
                                                bx1_abml)
                                             (GHC.Types.I# (GHC.Prim.-# ds1_abmp 1#)))
                                          cs_abmn);
                                   1# ->
                                     Data.Either.Right
                                       @Data.ByteString.Lazy.Internal.ByteString
                                       @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                       (case GHC.Prim.readWord8OffAddr#
                                               @GHC.Prim.RealWorld bx_abmk 0# GHC.Prim.realWorld#
                                        of
                                        { (# ipv_abmw, ipv1_abmx #) ->
                                        case GHC.Prim.touch#
                                               @'GHC.Types.Lifted
                                               @GHC.ForeignPtr.ForeignPtrContents
                                               bx1_abml
                                               ipv_abmw
                                        of
                                        { __DEFAULT ->
                                        GHC.Word.W8# ipv1_abmx
                                        }
                                        },
                                        cs_abmn)
                                 }
                             })
                          (let {
                             f2_abmA
                               :: Data.ByteString.Lazy.Internal.ByteString
                                  -> f_abm9 Data.ByteString.Lazy.Internal.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abmA
                               = GHC.Base.pure
                                   @f_abm9
                                   $dApplicative_abmb
                                   @Data.ByteString.Lazy.Internal.ByteString } in
                           let {
                             ds2_abmB
                               :: f_abm9
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                  -> f_abm9 Data.ByteString.Lazy.Internal.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 162 0}]
                             ds2_abmB
                               = GHC.Base.fmap
                                   @f_abm9
                                   (GHC.Base.$p1Applicative @f_abm9 $dApplicative_abmb)
                                   @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                   @Data.ByteString.Lazy.Internal.ByteString
                                   (\ (p1_abmC
                                         :: (GHC.Word.Word8,
                                             Data.ByteString.Lazy.Internal.ByteString)) ->
                                      case p1_abmC of { (x_abmE, ds_abmF) ->
                                      case x_abmE of { GHC.Word.W8# x#_abmI ->
                                      Data.ByteString.Lazy.Internal.$WChunk
                                        (Data.ByteString.Internal.Type.$WBS
                                           (GHC.ForeignPtr.ForeignPtr
                                              @GHC.Word.Word8
                                              (GHC.Prim.plusAddr#
                                                 Data.ByteString.singleton1
                                                 (GHC.Prim.word2Int#
                                                    (GHC.Prim.word8ToWord# x#_abmI)))
                                              GHC.ForeignPtr.FinalPtr)
                                           (GHC.Types.I# 1#))
                                        ds_abmF
                                      }
                                      }) } in
                           \ (ds3_abmK
                                :: Data.Either.Either
                                     Data.ByteString.Lazy.Internal.ByteString
                                     (f_abm9
                                        (GHC.Word.Word8,
                                         Data.ByteString.Lazy.Internal.ByteString))) ->
                             case ds3_abmK of {
                               Data.Either.Left x_abmM -> f2_abmA x_abmM;
                               Data.Either.Right y_abmO -> ds2_abmB y_abmO
                             }) } in
                  let {
                    g_abmQ
                      :: p_abm8
                           (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                           (f_abm9 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                         -> p_abm8
                              (Data.Either.Either
                                 Data.ByteString.Lazy.Internal.ByteString
                                 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                              (Data.Either.Either
                                 Data.ByteString.Lazy.Internal.ByteString
                                 (f_abm9
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abmQ
                      = Data.Profunctor.Choice.right'
                          @p_abm8
                          $dChoice_abma
                          @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                          @(f_abm9
                              (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                          @Data.ByteString.Lazy.Internal.ByteString } in
                  \ (x_abmR
                       :: p_abm8
                            (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                            (f_abm9
                               (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))) ->
                    f1_abmc (g_abmQ x_abmR))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <Data.ByteString.Lazy.Internal.ByteString>_N
                                <Data.ByteString.Lazy.Internal.ByteString>_N
                                <GHC.Word.Word8>_N
                                <GHC.Word.Word8>_N)
                       :: Control.Lens.Type.Prism
                            Data.ByteString.Lazy.Internal.ByteString
                            Data.ByteString.Lazy.Internal.ByteString
                            (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                            (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                          ~R# Control.Lens.Cons.Cons
                                Data.ByteString.Lazy.Internal.ByteString
                                Data.ByteString.Lazy.Internal.ByteString
                                GHC.Word.Word8
                                GHC.Word.Word8))
              ((\ (@(p_abeP :: * -> * -> *))
                  (@(f_abeQ :: * -> *))
                  ($dChoice_abeR :: Data.Profunctor.Choice.Choice p_abeP)
                  ($dApplicative_abeS :: GHC.Base.Applicative f_abeQ) ->
                  let {
                    f1_abeT
                      :: p_abeP
                           (Data.Either.Either
                              [GHC.Word.Word8] (GHC.Word.Word8, [GHC.Word.Word8]))
                           (Data.Either.Either
                              [GHC.Word.Word8] (f_abeQ (GHC.Word.Word8, [GHC.Word.Word8])))
                         -> p_abeP [GHC.Word.Word8] (f_abeQ [GHC.Word.Word8])
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 320 0}]
                    f1_abeT
                      = Data.Profunctor.Unsafe.dimap
                          @p_abeP
                          (Data.Profunctor.Choice.$p1Choice @p_abeP $dChoice_abeR)
                          @[GHC.Word.Word8]
                          @(Data.Either.Either
                              [GHC.Word.Word8] (GHC.Word.Word8, [GHC.Word.Word8]))
                          @(Data.Either.Either
                              [GHC.Word.Word8] (f_abeQ (GHC.Word.Word8, [GHC.Word.Word8])))
                          @(f_abeQ [GHC.Word.Word8])
                          (\ (aas_abeU :: [GHC.Word.Word8]) ->
                             case aas_abeU of {
                               [] ->
                                 Data.Either.Left
                                   @[GHC.Word.Word8]
                                   @(GHC.Word.Word8, [GHC.Word.Word8])
                                   (GHC.Types.[] @GHC.Word.Word8);
                               : a1_abeW as_abeX ->
                                 Data.Either.Right
                                   @[GHC.Word.Word8]
                                   @(GHC.Word.Word8, [GHC.Word.Word8])
                                   (a1_abeW, as_abeX)
                             })
                          (let {
                             f2_abeZ :: [GHC.Word.Word8] -> f_abeQ [GHC.Word.Word8]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abeZ
                               = GHC.Base.pure @f_abeQ $dApplicative_abeS @[GHC.Word.Word8] } in
                           let {
                             ds2_abf0
                               :: f_abeQ (GHC.Word.Word8, [GHC.Word.Word8])
                                  -> f_abeQ [GHC.Word.Word8]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 90 0}]
                             ds2_abf0
                               = GHC.Base.fmap
                                   @f_abeQ
                                   (GHC.Base.$p1Applicative @f_abeQ $dApplicative_abeS)
                                   @(GHC.Word.Word8, [GHC.Word.Word8])
                                   @[GHC.Word.Word8]
                                   (\ (p1_abf1 :: (GHC.Word.Word8, [GHC.Word.Word8])) ->
                                      GHC.Types.:
                                        @GHC.Word.Word8
                                        (case p1_abf1 of { (x_abf3, ds_abf4) -> x_abf3 })
                                        (case p1_abf1 of { (ds_abf7, y_abf8) -> y_abf8 })) } in
                           \ (ds3_abfa
                                :: Data.Either.Either
                                     [GHC.Word.Word8]
                                     (f_abeQ (GHC.Word.Word8, [GHC.Word.Word8]))) ->
                             case ds3_abfa of {
                               Data.Either.Left x_abfc -> f2_abeZ x_abfc;
                               Data.Either.Right y_abfe -> ds2_abf0 y_abfe
                             }) } in
                  let {
                    g_abfg
                      :: p_abeP
                           (GHC.Word.Word8, [GHC.Word.Word8])
                           (f_abeQ (GHC.Word.Word8, [GHC.Word.Word8]))
                         -> p_abeP
                              (Data.Either.Either
                                 [GHC.Word.Word8] (GHC.Word.Word8, [GHC.Word.Word8]))
                              (Data.Either.Either
                                 [GHC.Word.Word8] (f_abeQ (GHC.Word.Word8, [GHC.Word.Word8])))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abfg
                      = Data.Profunctor.Choice.right'
                          @p_abeP
                          $dChoice_abeR
                          @(GHC.Word.Word8, [GHC.Word.Word8])
                          @(f_abeQ (GHC.Word.Word8, [GHC.Word.Word8]))
                          @[GHC.Word.Word8] } in
                  \ (x_abfh
                       :: p_abeP
                            (GHC.Word.Word8, [GHC.Word.Word8])
                            (f_abeQ (GHC.Word.Word8, [GHC.Word.Word8]))) ->
                    f1_abeT (g_abfg x_abfh))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <[GHC.Word.Word8]>_N
                                <[GHC.Word.Word8]>_N
                                <GHC.Word.Word8>_N
                                <GHC.Word.Word8>_N)
                       :: Control.Lens.Type.Prism
                            [GHC.Word.Word8]
                            [GHC.Word.Word8]
                            (GHC.Word.Word8, [GHC.Word.Word8])
                            (GHC.Word.Word8, [GHC.Word.Word8])
                          ~R# Control.Lens.Cons.Cons
                                [GHC.Word.Word8] [GHC.Word.Word8] GHC.Word.Word8 GHC.Word.Word8))
              ((\ (@(p_abfm :: * -> * -> *))
                  (@(f_abfn :: * -> *))
                  ($dChoice_abfo :: Data.Profunctor.Choice.Choice p_abfm)
                  ($dApplicative_abfp :: GHC.Base.Applicative f_abfn) ->
                  let {
                    f1_abfq
                      :: p_abfm
                           (Data.Either.Either [GHC.Word.Word8] ())
                           (Data.Either.Either [GHC.Word.Word8] (f_abfn ()))
                         -> p_abfm [GHC.Word.Word8] (f_abfn [GHC.Word.Word8])
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 290 0}]
                    f1_abfq
                      = Data.Profunctor.Unsafe.dimap
                          @p_abfm
                          (Data.Profunctor.Choice.$p1Choice @p_abfm $dChoice_abfo)
                          @[GHC.Word.Word8]
                          @(Data.Either.Either [GHC.Word.Word8] ())
                          @(Data.Either.Either [GHC.Word.Word8] (f_abfn ()))
                          @(f_abfn [GHC.Word.Word8])
                          (\ (s_abfr :: [GHC.Word.Word8]) ->
                             case s_abfr of wild_abfs {
                               [] -> Data.Either.Right @[GHC.Word.Word8] @() GHC.Tuple.Prim.();
                               : ds1_abft ds2_abfu ->
                                 Data.Either.Left @[GHC.Word.Word8] @() wild_abfs
                             })
                          (let {
                             f2_abfw :: [GHC.Word.Word8] -> f_abfn [GHC.Word.Word8]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abfw
                               = GHC.Base.pure @f_abfn $dApplicative_abfp @[GHC.Word.Word8] } in
                           let {
                             ds2_abfx :: f_abfn () -> f_abfn [GHC.Word.Word8]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 70 0}]
                             ds2_abfx
                               = GHC.Base.fmap
                                   @f_abfn
                                   (GHC.Base.$p1Applicative @f_abfn $dApplicative_abfp)
                                   @()
                                   @[GHC.Word.Word8]
                                   (\ (ds3_abfy :: ()) ->
                                      case ds3_abfy of { () -> GHC.Types.[] @GHC.Word.Word8 }) } in
                           \ (ds3_abfA :: Data.Either.Either [GHC.Word.Word8] (f_abfn ())) ->
                             case ds3_abfA of {
                               Data.Either.Left x_abfC -> f2_abfw x_abfC;
                               Data.Either.Right y_abfE -> ds2_abfx y_abfE
                             }) } in
                  let {
                    g_abfG
                      :: p_abfm () (f_abfn ())
                         -> p_abfm
                              (Data.Either.Either [GHC.Word.Word8] ())
                              (Data.Either.Either [GHC.Word.Word8] (f_abfn ()))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abfG
                      = Data.Profunctor.Choice.right'
                          @p_abfm $dChoice_abfo @() @(f_abfn ()) @[GHC.Word.Word8] } in
                  \ (x_abfH :: p_abfm () (f_abfn ())) -> f1_abfq (g_abfG x_abfH))
               `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0] <[GHC.Word.Word8]>_N)
                       :: Control.Lens.Type.Prism' [GHC.Word.Word8] ()
                          ~R# Control.Lens.Empty.AsEmpty [GHC.Word.Word8]))
              (Data.Functor.Contravariant.$fContravariantConst @[GHC.Word.Word8])
              (Data.Functor.Const.$fFunctorConst @[GHC.Word.Word8])
    Cont:   ApplyToVal nodup hole Control.Lens.Getter.Getting
                                    [GHC.Word.Word8]
                                    Data.ByteString.Lazy.Internal.ByteString
                                    [GHC.Word.Word8]
              ((\ (ds_abdj [Occ=Once1] :: a_abdg) -> ds_abdj)
               `cast` (<a_abdg>_R
                       %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                          <*>_N <a_abdg>_R <a_abdg>_P)
                       :: (a_abdg -> a_abdg)
                          ~R# (a_abdg -> Data.Functor.Const.Const a_abdg a_abdg)))
            ApplyToVal nodup hole Data.ByteString.Lazy.Internal.ByteString
                                  -> Data.Functor.Const.Const
                                       [GHC.Word.Word8] Data.ByteString.Lazy.Internal.ByteString
              (Control.Lens.Getter.view
                 @[GHC.Word.Word8]
                 @((->) [GHC.Word.Word8])
                 @Data.ByteString.Lazy.Internal.ByteString
                 (Control.Monad.Reader.Class.$fMonadReaderrFUN @[GHC.Word.Word8])
                 (Control.Lens.Cons.Extras.recons
                    @[GHC.Word.Word8]
                    @GHC.Word.Word8
                    @Data.ByteString.Lazy.Internal.ByteString
                    (Control.Lens.Cons.$fConsListListab
                       @GHC.Word.Word8 @GHC.Word.Word8)
                    Control.Lens.Cons.$fConsByteStringByteStringWord8Word8
                    Control.Lens.Empty.$fAsEmptyByteString
                    @(Data.Functor.Const.Const
                        Data.ByteString.Lazy.Internal.ByteString)
                    (Data.Functor.Contravariant.$fContravariantConst
                       @Data.ByteString.Lazy.Internal.ByteString)
                    (Data.Functor.Const.$fFunctorConst
                       @Data.ByteString.Lazy.Internal.ByteString))
                 s_a8Og)
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N
                        <[GHC.Word.Word8]>_R
                        <Data.ByteString.Lazy.Internal.ByteString>_P
                    :: Data.Functor.Const.Const
                         [GHC.Word.Word8] Data.ByteString.Lazy.Internal.ByteString
                       ~R# [GHC.Word.Word8])
            Stop[RuleArgCtxt] [GHC.Word.Word8]
Rule fired
    Rule: Class op fmap
    Module: (BUILTIN)
    Before: GHC.Base.fmap
              TyArg Data.Functor.Const.Const [GHC.Word.Word8]
              ValArg Data.Functor.Const.$fFunctorConst @[GHC.Word.Word8]
    After:  (Data.Functor.Const.$fFunctorConst2 @[GHC.Word.Word8])
            `cast` (forall (a :: <*>_N) (b :: <*>_N).
                    <a -> b>_R
                    %<'GHC.Types.Many>_N ->_R <Data.Functor.Const.Const
                                                 [GHC.Word.Word8] a>_R
                    %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                  <*>_N <[GHC.Word.Word8]>_R <a>_P
                                              ; Sym (Data.Functor.Const.N:Const[0]
                                                         <*>_N <[GHC.Word.Word8]>_R <b>_P)
                    :: (forall {a} {b}.
                        (a -> b)
                        -> Data.Functor.Const.Const [GHC.Word.Word8] a
                        -> Data.Functor.Const.Const [GHC.Word.Word8] a)
                       ~R# (forall {a} {b}.
                            (a -> b)
                            -> Data.Functor.Const.Const [GHC.Word.Word8] a
                            -> Data.Functor.Const.Const [GHC.Word.Word8] b))
    Cont:   ApplyToTy [GHC.Word.Word8]
            ApplyToTy Data.ByteString.Lazy.Internal.ByteString
            ApplyToVal nodup hole ([GHC.Word.Word8]
                                   -> Data.ByteString.Lazy.Internal.ByteString)
                                  -> Data.Functor.Const.Const [GHC.Word.Word8] [GHC.Word.Word8]
                                  -> Data.Functor.Const.Const
                                       [GHC.Word.Word8] Data.ByteString.Lazy.Internal.ByteString
              Data.ByteString.Lazy.Internal.packBytes
            ApplyToVal nodup hole Data.Functor.Const.Const
                                    [GHC.Word.Word8] [GHC.Word.Word8]
                                  -> Data.Functor.Const.Const
                                       [GHC.Word.Word8] Data.ByteString.Lazy.Internal.ByteString
              (bc_abny (ab_abnw x_abnz))
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N
                        <[GHC.Word.Word8]>_R
                        <Data.ByteString.Lazy.Internal.ByteString>_P
                    :: Data.Functor.Const.Const
                         [GHC.Word.Word8] Data.ByteString.Lazy.Internal.ByteString
                       ~R# [GHC.Word.Word8])
            Stop[RuleArgCtxt] [GHC.Word.Word8]
Rule fired
    Rule: Class op reader
    Module: (BUILTIN)
    Before: Control.Monad.Reader.Class.reader
              TyArg [GHC.Word.Word8]
              TyArg (->) [GHC.Word.Word8]
              ValArg Control.Monad.Reader.Class.$fMonadReaderrFUN
                       @[GHC.Word.Word8]
    After:  \ (@a_abdo) -> GHC.Base.id @([GHC.Word.Word8] -> a_abdo)
    Cont:   ApplyToTy Data.ByteString.Lazy.Internal.ByteString
            ApplyToVal nodup hole ([GHC.Word.Word8]
                                   -> Data.ByteString.Lazy.Internal.ByteString)
                                  -> [GHC.Word.Word8] -> Data.ByteString.Lazy.Internal.ByteString
              ((l_abdi
                  ((\ (ds_abdj [Occ=Once1] :: a_abdg) -> ds_abdj)
                   `cast` (<a_abdg>_R
                           %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                              <*>_N <a_abdg>_R <a_abdg>_P)
                           :: (a_abdg -> a_abdg)
                              ~R# (a_abdg -> Data.Functor.Const.Const a_abdg a_abdg))))
               `cast` (<s_abde>_R
                       %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                     <*>_N <a_abdg>_R <s_abde>_P
                       :: (s_abde -> Data.Functor.Const.Const a_abdg s_abde)
                          ~R# (s_abde -> a_abdg)))
            ApplyToVal nodup hole [GHC.Word.Word8]
                                  -> Data.ByteString.Lazy.Internal.ByteString
              s_a8Og
            Stop[RuleArgCtxt] Data.ByteString.Lazy.Internal.ByteString
Rule fired
    Rule: recons/list-lazybs
    Module: (Control.Lens.Cons.Extras)
    Before: Control.Lens.Cons.Extras.recons
              TyArg [GHC.Word.Word8]
              TyArg GHC.Word.Word8
              TyArg Data.ByteString.Lazy.Internal.ByteString
              ValArg (\ (@(p_abeP :: * -> * -> *))
                        (@(f_abeQ :: * -> *))
                        ($dChoice_abeR :: Data.Profunctor.Choice.Choice p_abeP)
                        ($dApplicative_abeS :: GHC.Base.Applicative f_abeQ) ->
                        let {
                          f1_abeT
                            :: p_abeP
                                 (Data.Either.Either
                                    [GHC.Word.Word8] (GHC.Word.Word8, [GHC.Word.Word8]))
                                 (Data.Either.Either
                                    [GHC.Word.Word8] (f_abeQ (GHC.Word.Word8, [GHC.Word.Word8])))
                               -> p_abeP [GHC.Word.Word8] (f_abeQ [GHC.Word.Word8])
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 320 0}]
                          f1_abeT
                            = Data.Profunctor.Unsafe.dimap
                                @p_abeP
                                (Data.Profunctor.Choice.$p1Choice @p_abeP $dChoice_abeR)
                                @[GHC.Word.Word8]
                                @(Data.Either.Either
                                    [GHC.Word.Word8] (GHC.Word.Word8, [GHC.Word.Word8]))
                                @(Data.Either.Either
                                    [GHC.Word.Word8] (f_abeQ (GHC.Word.Word8, [GHC.Word.Word8])))
                                @(f_abeQ [GHC.Word.Word8])
                                (\ (aas_abeU :: [GHC.Word.Word8]) ->
                                   case aas_abeU of {
                                     [] ->
                                       Data.Either.Left
                                         @[GHC.Word.Word8]
                                         @(GHC.Word.Word8, [GHC.Word.Word8])
                                         (GHC.Types.[] @GHC.Word.Word8);
                                     : a1_abeW as_abeX ->
                                       Data.Either.Right
                                         @[GHC.Word.Word8]
                                         @(GHC.Word.Word8, [GHC.Word.Word8])
                                         (a1_abeW, as_abeX)
                                   })
                                (let {
                                   f2_abeZ :: [GHC.Word.Word8] -> f_abeQ [GHC.Word.Word8]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abeZ
                                     = GHC.Base.pure
                                         @f_abeQ $dApplicative_abeS @[GHC.Word.Word8] } in
                                 let {
                                   ds2_abf0
                                     :: f_abeQ (GHC.Word.Word8, [GHC.Word.Word8])
                                        -> f_abeQ [GHC.Word.Word8]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 90 0}]
                                   ds2_abf0
                                     = GHC.Base.fmap
                                         @f_abeQ
                                         (GHC.Base.$p1Applicative @f_abeQ $dApplicative_abeS)
                                         @(GHC.Word.Word8, [GHC.Word.Word8])
                                         @[GHC.Word.Word8]
                                         (\ (p1_abf1 :: (GHC.Word.Word8, [GHC.Word.Word8])) ->
                                            GHC.Types.:
                                              @GHC.Word.Word8
                                              (case p1_abf1 of { (x_abf3, ds_abf4) -> x_abf3 })
                                              (case p1_abf1 of { (ds_abf7, y_abf8) ->
                                               y_abf8
                                               })) } in
                                 \ (ds3_abfa
                                      :: Data.Either.Either
                                           [GHC.Word.Word8]
                                           (f_abeQ (GHC.Word.Word8, [GHC.Word.Word8]))) ->
                                   case ds3_abfa of {
                                     Data.Either.Left x_abfc -> f2_abeZ x_abfc;
                                     Data.Either.Right y_abfe -> ds2_abf0 y_abfe
                                   }) } in
                        let {
                          g_abfg
                            :: p_abeP
                                 (GHC.Word.Word8, [GHC.Word.Word8])
                                 (f_abeQ (GHC.Word.Word8, [GHC.Word.Word8]))
                               -> p_abeP
                                    (Data.Either.Either
                                       [GHC.Word.Word8] (GHC.Word.Word8, [GHC.Word.Word8]))
                                    (Data.Either.Either
                                       [GHC.Word.Word8] (f_abeQ (GHC.Word.Word8, [GHC.Word.Word8])))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abfg
                            = Data.Profunctor.Choice.right'
                                @p_abeP
                                $dChoice_abeR
                                @(GHC.Word.Word8, [GHC.Word.Word8])
                                @(f_abeQ (GHC.Word.Word8, [GHC.Word.Word8]))
                                @[GHC.Word.Word8] } in
                        \ (x_abfh
                             :: p_abeP
                                  (GHC.Word.Word8, [GHC.Word.Word8])
                                  (f_abeQ (GHC.Word.Word8, [GHC.Word.Word8]))) ->
                          f1_abeT (g_abfg x_abfh))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <[GHC.Word.Word8]>_N
                                      <[GHC.Word.Word8]>_N
                                      <GHC.Word.Word8>_N
                                      <GHC.Word.Word8>_N)
                             :: Control.Lens.Type.Prism
                                  [GHC.Word.Word8]
                                  [GHC.Word.Word8]
                                  (GHC.Word.Word8, [GHC.Word.Word8])
                                  (GHC.Word.Word8, [GHC.Word.Word8])
                                ~R# Control.Lens.Cons.Cons
                                      [GHC.Word.Word8]
                                      [GHC.Word.Word8]
                                      GHC.Word.Word8
                                      GHC.Word.Word8)
              ValArg (\ (@(p_abm8 :: * -> * -> *))
                        (@(f_abm9 :: * -> *))
                        ($dChoice_abma :: Data.Profunctor.Choice.Choice p_abm8)
                        ($dApplicative_abmb :: GHC.Base.Applicative f_abm9) ->
                        let {
                          f1_abmc
                            :: p_abm8
                                 (Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                                 (Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (f_abm9
                                       (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                               -> p_abm8
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (f_abm9 Data.ByteString.Lazy.Internal.ByteString)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 536 0}]
                          f1_abmc
                            = Data.Profunctor.Unsafe.dimap
                                @p_abm8
                                (Data.Profunctor.Choice.$p1Choice @p_abm8 $dChoice_abma)
                                @Data.ByteString.Lazy.Internal.ByteString
                                @(Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                                @(Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (f_abm9
                                       (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                                @(f_abm9 Data.ByteString.Lazy.Internal.ByteString)
                                (\ (s1_abmd :: Data.ByteString.Lazy.Internal.ByteString) ->
                                   case s1_abmd of {
                                     Data.ByteString.Lazy.Internal.Empty ->
                                       Data.Either.Left
                                         @Data.ByteString.Lazy.Internal.ByteString
                                         @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                         Data.ByteString.Lazy.Internal.Empty;
                                     Data.ByteString.Lazy.Internal.Chunk bx_abmk bx1_abml bx2_abmm
                                                                         cs_abmn ->
                                       case bx2_abmm of ds1_abmp {
                                         __DEFAULT ->
                                           Data.Either.Right
                                             @Data.ByteString.Lazy.Internal.ByteString
                                             @(GHC.Word.Word8,
                                               Data.ByteString.Lazy.Internal.ByteString)
                                             (case GHC.Prim.readWord8OffAddr#
                                                     @GHC.Prim.RealWorld
                                                     bx_abmk
                                                     0#
                                                     GHC.Prim.realWorld#
                                              of
                                              { (# ipv_abmr, ipv1_abms #) ->
                                              case GHC.Prim.touch#
                                                     @'GHC.Types.Lifted
                                                     @GHC.ForeignPtr.ForeignPtrContents
                                                     bx1_abml
                                                     ipv_abmr
                                              of
                                              { __DEFAULT ->
                                              GHC.Word.W8# ipv1_abms
                                              }
                                              },
                                              Data.ByteString.Lazy.Internal.$WChunk
                                                (Data.ByteString.Internal.Type.$WBS
                                                   (GHC.ForeignPtr.ForeignPtr
                                                      @GHC.Word.Word8
                                                      (GHC.Prim.plusAddr# bx_abmk 1#)
                                                      bx1_abml)
                                                   (GHC.Types.I# (GHC.Prim.-# ds1_abmp 1#)))
                                                cs_abmn);
                                         1# ->
                                           Data.Either.Right
                                             @Data.ByteString.Lazy.Internal.ByteString
                                             @(GHC.Word.Word8,
                                               Data.ByteString.Lazy.Internal.ByteString)
                                             (case GHC.Prim.readWord8OffAddr#
                                                     @GHC.Prim.RealWorld
                                                     bx_abmk
                                                     0#
                                                     GHC.Prim.realWorld#
                                              of
                                              { (# ipv_abmw, ipv1_abmx #) ->
                                              case GHC.Prim.touch#
                                                     @'GHC.Types.Lifted
                                                     @GHC.ForeignPtr.ForeignPtrContents
                                                     bx1_abml
                                                     ipv_abmw
                                              of
                                              { __DEFAULT ->
                                              GHC.Word.W8# ipv1_abmx
                                              }
                                              },
                                              cs_abmn)
                                       }
                                   })
                                (let {
                                   f2_abmA
                                     :: Data.ByteString.Lazy.Internal.ByteString
                                        -> f_abm9 Data.ByteString.Lazy.Internal.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abmA
                                     = GHC.Base.pure
                                         @f_abm9
                                         $dApplicative_abmb
                                         @Data.ByteString.Lazy.Internal.ByteString } in
                                 let {
                                   ds2_abmB
                                     :: f_abm9
                                          (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                        -> f_abm9 Data.ByteString.Lazy.Internal.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 162 0}]
                                   ds2_abmB
                                     = GHC.Base.fmap
                                         @f_abm9
                                         (GHC.Base.$p1Applicative @f_abm9 $dApplicative_abmb)
                                         @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                         @Data.ByteString.Lazy.Internal.ByteString
                                         (\ (p1_abmC
                                               :: (GHC.Word.Word8,
                                                   Data.ByteString.Lazy.Internal.ByteString)) ->
                                            case p1_abmC of { (x_abmE, ds_abmF) ->
                                            case x_abmE of { GHC.Word.W8# x#_abmI ->
                                            Data.ByteString.Lazy.Internal.$WChunk
                                              (Data.ByteString.Internal.Type.$WBS
                                                 (GHC.ForeignPtr.ForeignPtr
                                                    @GHC.Word.Word8
                                                    (GHC.Prim.plusAddr#
                                                       Data.ByteString.singleton1
                                                       (GHC.Prim.word2Int#
                                                          (GHC.Prim.word8ToWord# x#_abmI)))
                                                    GHC.ForeignPtr.FinalPtr)
                                                 (GHC.Types.I# 1#))
                                              ds_abmF
                                            }
                                            }) } in
                                 \ (ds3_abmK
                                      :: Data.Either.Either
                                           Data.ByteString.Lazy.Internal.ByteString
                                           (f_abm9
                                              (GHC.Word.Word8,
                                               Data.ByteString.Lazy.Internal.ByteString))) ->
                                   case ds3_abmK of {
                                     Data.Either.Left x_abmM -> f2_abmA x_abmM;
                                     Data.Either.Right y_abmO -> ds2_abmB y_abmO
                                   }) } in
                        let {
                          g_abmQ
                            :: p_abm8
                                 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                 (f_abm9 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                               -> p_abm8
                                    (Data.Either.Either
                                       Data.ByteString.Lazy.Internal.ByteString
                                       (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                                    (Data.Either.Either
                                       Data.ByteString.Lazy.Internal.ByteString
                                       (f_abm9
                                          (GHC.Word.Word8,
                                           Data.ByteString.Lazy.Internal.ByteString)))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abmQ
                            = Data.Profunctor.Choice.right'
                                @p_abm8
                                $dChoice_abma
                                @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                @(f_abm9
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                                @Data.ByteString.Lazy.Internal.ByteString } in
                        \ (x_abmR
                             :: p_abm8
                                  (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                  (f_abm9
                                     (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))) ->
                          f1_abmc (g_abmQ x_abmR))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <Data.ByteString.Lazy.Internal.ByteString>_N
                                      <Data.ByteString.Lazy.Internal.ByteString>_N
                                      <GHC.Word.Word8>_N
                                      <GHC.Word.Word8>_N)
                             :: Control.Lens.Type.Prism
                                  Data.ByteString.Lazy.Internal.ByteString
                                  Data.ByteString.Lazy.Internal.ByteString
                                  (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                  (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                ~R# Control.Lens.Cons.Cons
                                      Data.ByteString.Lazy.Internal.ByteString
                                      Data.ByteString.Lazy.Internal.ByteString
                                      GHC.Word.Word8
                                      GHC.Word.Word8)
              ValArg (\ (@(p_abmT :: * -> * -> *))
                        (@(f_abmU :: * -> *))
                        ($dChoice_abmV :: Data.Profunctor.Choice.Choice p_abmT)
                        ($dApplicative_abmW :: GHC.Base.Applicative f_abmU) ->
                        let {
                          f1_abmX
                            :: p_abmT
                                 (Data.Either.Either Data.ByteString.Lazy.Internal.ByteString ())
                                 (Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString (f_abmU ()))
                               -> p_abmT
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (f_abmU Data.ByteString.Lazy.Internal.ByteString)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 290 0}]
                          f1_abmX
                            = Data.Profunctor.Unsafe.dimap
                                @p_abmT
                                (Data.Profunctor.Choice.$p1Choice @p_abmT $dChoice_abmV)
                                @Data.ByteString.Lazy.Internal.ByteString
                                @(Data.Either.Either Data.ByteString.Lazy.Internal.ByteString ())
                                @(Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString (f_abmU ()))
                                @(f_abmU Data.ByteString.Lazy.Internal.ByteString)
                                (\ (s_abmY :: Data.ByteString.Lazy.Internal.ByteString) ->
                                   case s_abmY of wild_abmZ {
                                     Data.ByteString.Lazy.Internal.Empty ->
                                       Data.Either.Right
                                         @Data.ByteString.Lazy.Internal.ByteString
                                         @()
                                         GHC.Tuple.Prim.();
                                     Data.ByteString.Lazy.Internal.Chunk ipv_abn0 ipv1_abn1
                                                                         ipv2_abn2 ipv3_abn3 ->
                                       Data.Either.Left
                                         @Data.ByteString.Lazy.Internal.ByteString @() wild_abmZ
                                   })
                                (let {
                                   f2_abn5
                                     :: Data.ByteString.Lazy.Internal.ByteString
                                        -> f_abmU Data.ByteString.Lazy.Internal.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abn5
                                     = GHC.Base.pure
                                         @f_abmU
                                         $dApplicative_abmW
                                         @Data.ByteString.Lazy.Internal.ByteString } in
                                 let {
                                   ds2_abn6
                                     :: f_abmU () -> f_abmU Data.ByteString.Lazy.Internal.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 70 0}]
                                   ds2_abn6
                                     = GHC.Base.fmap
                                         @f_abmU
                                         (GHC.Base.$p1Applicative @f_abmU $dApplicative_abmW)
                                         @()
                                         @Data.ByteString.Lazy.Internal.ByteString
                                         (\ (ds3_abn7 :: ()) ->
                                            case ds3_abn7 of { () ->
                                            Data.ByteString.Lazy.Internal.Empty
                                            }) } in
                                 \ (ds3_abn9
                                      :: Data.Either.Either
                                           Data.ByteString.Lazy.Internal.ByteString (f_abmU ())) ->
                                   case ds3_abn9 of {
                                     Data.Either.Left x_abnb -> f2_abn5 x_abnb;
                                     Data.Either.Right y_abnd -> ds2_abn6 y_abnd
                                   }) } in
                        let {
                          g_abnf
                            :: p_abmT () (f_abmU ())
                               -> p_abmT
                                    (Data.Either.Either Data.ByteString.Lazy.Internal.ByteString ())
                                    (Data.Either.Either
                                       Data.ByteString.Lazy.Internal.ByteString (f_abmU ()))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abnf
                            = Data.Profunctor.Choice.right'
                                @p_abmT
                                $dChoice_abmV
                                @()
                                @(f_abmU ())
                                @Data.ByteString.Lazy.Internal.ByteString } in
                        \ (x_abng :: p_abmT () (f_abmU ())) -> f1_abmX (g_abnf x_abng))
                     `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                      <Data.ByteString.Lazy.Internal.ByteString>_N)
                             :: Control.Lens.Type.Prism'
                                  Data.ByteString.Lazy.Internal.ByteString ()
                                ~R# Control.Lens.Empty.AsEmpty
                                      Data.ByteString.Lazy.Internal.ByteString)
              TyArg Data.Functor.Const.Const
                      Data.ByteString.Lazy.Internal.ByteString
              ValArg Data.Functor.Contravariant.$fContravariantConst
                       @Data.ByteString.Lazy.Internal.ByteString
              ValArg Data.Functor.Const.$fFunctorConst
                       @Data.ByteString.Lazy.Internal.ByteString
    After:  (\ (@(f_abdZ :: * -> *))
               ($dCons_abe0
                  :: Control.Lens.Cons.Cons
                       [GHC.Word.Word8] [GHC.Word.Word8] GHC.Word.Word8 GHC.Word.Word8)
               ($dCons1_abe1
                  :: Control.Lens.Cons.Cons
                       Data.ByteString.Lazy.Internal.ByteString
                       Data.ByteString.Lazy.Internal.ByteString
                       GHC.Word.Word8
                       GHC.Word.Word8)
               ($dAsEmpty_abe2
                  :: Control.Lens.Empty.AsEmpty
                       Data.ByteString.Lazy.Internal.ByteString)
               ($dContravariant_abe3
                  :: Data.Functor.Contravariant.Contravariant f_abdZ)
               ($dFunctor_abe4 :: GHC.Base.Functor f_abdZ) ->
               Data.Profunctor.Unsafe.$fProfunctorFUN_$cdimap
                 @[GHC.Word.Word8]
                 @Data.ByteString.Lazy.Internal.ByteString
                 @(f_abdZ Data.ByteString.Lazy.Internal.ByteString)
                 @(f_abdZ [GHC.Word.Word8])
                 Data.ByteString.Lazy.Internal.packBytes
                 (GHC.Base.fmap
                    @f_abdZ
                    $dFunctor_abe4
                    @Data.ByteString.Lazy.Internal.ByteString
                    @[GHC.Word.Word8]
                    Data.ByteString.Lazy.Internal.unpackBytes))
              @(Data.Functor.Const.Const
                  Data.ByteString.Lazy.Internal.ByteString)
              ((\ (@(p_abeP :: * -> * -> *))
                  (@(f_abeQ :: * -> *))
                  ($dChoice_abeR :: Data.Profunctor.Choice.Choice p_abeP)
                  ($dApplicative_abeS :: GHC.Base.Applicative f_abeQ) ->
                  let {
                    f1_abeT
                      :: p_abeP
                           (Data.Either.Either
                              [GHC.Word.Word8] (GHC.Word.Word8, [GHC.Word.Word8]))
                           (Data.Either.Either
                              [GHC.Word.Word8] (f_abeQ (GHC.Word.Word8, [GHC.Word.Word8])))
                         -> p_abeP [GHC.Word.Word8] (f_abeQ [GHC.Word.Word8])
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 320 0}]
                    f1_abeT
                      = Data.Profunctor.Unsafe.dimap
                          @p_abeP
                          (Data.Profunctor.Choice.$p1Choice @p_abeP $dChoice_abeR)
                          @[GHC.Word.Word8]
                          @(Data.Either.Either
                              [GHC.Word.Word8] (GHC.Word.Word8, [GHC.Word.Word8]))
                          @(Data.Either.Either
                              [GHC.Word.Word8] (f_abeQ (GHC.Word.Word8, [GHC.Word.Word8])))
                          @(f_abeQ [GHC.Word.Word8])
                          (\ (aas_abeU :: [GHC.Word.Word8]) ->
                             case aas_abeU of {
                               [] ->
                                 Data.Either.Left
                                   @[GHC.Word.Word8]
                                   @(GHC.Word.Word8, [GHC.Word.Word8])
                                   (GHC.Types.[] @GHC.Word.Word8);
                               : a1_abeW as_abeX ->
                                 Data.Either.Right
                                   @[GHC.Word.Word8]
                                   @(GHC.Word.Word8, [GHC.Word.Word8])
                                   (a1_abeW, as_abeX)
                             })
                          (let {
                             f2_abeZ :: [GHC.Word.Word8] -> f_abeQ [GHC.Word.Word8]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abeZ
                               = GHC.Base.pure @f_abeQ $dApplicative_abeS @[GHC.Word.Word8] } in
                           let {
                             ds2_abf0
                               :: f_abeQ (GHC.Word.Word8, [GHC.Word.Word8])
                                  -> f_abeQ [GHC.Word.Word8]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 90 0}]
                             ds2_abf0
                               = GHC.Base.fmap
                                   @f_abeQ
                                   (GHC.Base.$p1Applicative @f_abeQ $dApplicative_abeS)
                                   @(GHC.Word.Word8, [GHC.Word.Word8])
                                   @[GHC.Word.Word8]
                                   (\ (p1_abf1 :: (GHC.Word.Word8, [GHC.Word.Word8])) ->
                                      GHC.Types.:
                                        @GHC.Word.Word8
                                        (case p1_abf1 of { (x_abf3, ds_abf4) -> x_abf3 })
                                        (case p1_abf1 of { (ds_abf7, y_abf8) -> y_abf8 })) } in
                           \ (ds3_abfa
                                :: Data.Either.Either
                                     [GHC.Word.Word8]
                                     (f_abeQ (GHC.Word.Word8, [GHC.Word.Word8]))) ->
                             case ds3_abfa of {
                               Data.Either.Left x_abfc -> f2_abeZ x_abfc;
                               Data.Either.Right y_abfe -> ds2_abf0 y_abfe
                             }) } in
                  let {
                    g_abfg
                      :: p_abeP
                           (GHC.Word.Word8, [GHC.Word.Word8])
                           (f_abeQ (GHC.Word.Word8, [GHC.Word.Word8]))
                         -> p_abeP
                              (Data.Either.Either
                                 [GHC.Word.Word8] (GHC.Word.Word8, [GHC.Word.Word8]))
                              (Data.Either.Either
                                 [GHC.Word.Word8] (f_abeQ (GHC.Word.Word8, [GHC.Word.Word8])))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abfg
                      = Data.Profunctor.Choice.right'
                          @p_abeP
                          $dChoice_abeR
                          @(GHC.Word.Word8, [GHC.Word.Word8])
                          @(f_abeQ (GHC.Word.Word8, [GHC.Word.Word8]))
                          @[GHC.Word.Word8] } in
                  \ (x_abfh
                       :: p_abeP
                            (GHC.Word.Word8, [GHC.Word.Word8])
                            (f_abeQ (GHC.Word.Word8, [GHC.Word.Word8]))) ->
                    f1_abeT (g_abfg x_abfh))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <[GHC.Word.Word8]>_N
                                <[GHC.Word.Word8]>_N
                                <GHC.Word.Word8>_N
                                <GHC.Word.Word8>_N)
                       :: Control.Lens.Type.Prism
                            [GHC.Word.Word8]
                            [GHC.Word.Word8]
                            (GHC.Word.Word8, [GHC.Word.Word8])
                            (GHC.Word.Word8, [GHC.Word.Word8])
                          ~R# Control.Lens.Cons.Cons
                                [GHC.Word.Word8] [GHC.Word.Word8] GHC.Word.Word8 GHC.Word.Word8))
              ((\ (@(p_abm8 :: * -> * -> *))
                  (@(f_abm9 :: * -> *))
                  ($dChoice_abma :: Data.Profunctor.Choice.Choice p_abm8)
                  ($dApplicative_abmb :: GHC.Base.Applicative f_abm9) ->
                  let {
                    f1_abmc
                      :: p_abm8
                           (Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString
                              (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                           (Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString
                              (f_abm9
                                 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                         -> p_abm8
                              Data.ByteString.Lazy.Internal.ByteString
                              (f_abm9 Data.ByteString.Lazy.Internal.ByteString)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 536 0}]
                    f1_abmc
                      = Data.Profunctor.Unsafe.dimap
                          @p_abm8
                          (Data.Profunctor.Choice.$p1Choice @p_abm8 $dChoice_abma)
                          @Data.ByteString.Lazy.Internal.ByteString
                          @(Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString
                              (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                          @(Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString
                              (f_abm9
                                 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                          @(f_abm9 Data.ByteString.Lazy.Internal.ByteString)
                          (\ (s1_abmd :: Data.ByteString.Lazy.Internal.ByteString) ->
                             case s1_abmd of {
                               Data.ByteString.Lazy.Internal.Empty ->
                                 Data.Either.Left
                                   @Data.ByteString.Lazy.Internal.ByteString
                                   @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                   Data.ByteString.Lazy.Internal.Empty;
                               Data.ByteString.Lazy.Internal.Chunk bx_abmk bx1_abml bx2_abmm
                                                                   cs_abmn ->
                                 case bx2_abmm of ds1_abmp {
                                   __DEFAULT ->
                                     Data.Either.Right
                                       @Data.ByteString.Lazy.Internal.ByteString
                                       @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                       (case GHC.Prim.readWord8OffAddr#
                                               @GHC.Prim.RealWorld bx_abmk 0# GHC.Prim.realWorld#
                                        of
                                        { (# ipv_abmr, ipv1_abms #) ->
                                        case GHC.Prim.touch#
                                               @'GHC.Types.Lifted
                                               @GHC.ForeignPtr.ForeignPtrContents
                                               bx1_abml
                                               ipv_abmr
                                        of
                                        { __DEFAULT ->
                                        GHC.Word.W8# ipv1_abms
                                        }
                                        },
                                        Data.ByteString.Lazy.Internal.$WChunk
                                          (Data.ByteString.Internal.Type.$WBS
                                             (GHC.ForeignPtr.ForeignPtr
                                                @GHC.Word.Word8
                                                (GHC.Prim.plusAddr# bx_abmk 1#)
                                                bx1_abml)
                                             (GHC.Types.I# (GHC.Prim.-# ds1_abmp 1#)))
                                          cs_abmn);
                                   1# ->
                                     Data.Either.Right
                                       @Data.ByteString.Lazy.Internal.ByteString
                                       @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                       (case GHC.Prim.readWord8OffAddr#
                                               @GHC.Prim.RealWorld bx_abmk 0# GHC.Prim.realWorld#
                                        of
                                        { (# ipv_abmw, ipv1_abmx #) ->
                                        case GHC.Prim.touch#
                                               @'GHC.Types.Lifted
                                               @GHC.ForeignPtr.ForeignPtrContents
                                               bx1_abml
                                               ipv_abmw
                                        of
                                        { __DEFAULT ->
                                        GHC.Word.W8# ipv1_abmx
                                        }
                                        },
                                        cs_abmn)
                                 }
                             })
                          (let {
                             f2_abmA
                               :: Data.ByteString.Lazy.Internal.ByteString
                                  -> f_abm9 Data.ByteString.Lazy.Internal.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abmA
                               = GHC.Base.pure
                                   @f_abm9
                                   $dApplicative_abmb
                                   @Data.ByteString.Lazy.Internal.ByteString } in
                           let {
                             ds2_abmB
                               :: f_abm9
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                  -> f_abm9 Data.ByteString.Lazy.Internal.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 162 0}]
                             ds2_abmB
                               = GHC.Base.fmap
                                   @f_abm9
                                   (GHC.Base.$p1Applicative @f_abm9 $dApplicative_abmb)
                                   @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                   @Data.ByteString.Lazy.Internal.ByteString
                                   (\ (p1_abmC
                                         :: (GHC.Word.Word8,
                                             Data.ByteString.Lazy.Internal.ByteString)) ->
                                      case p1_abmC of { (x_abmE, ds_abmF) ->
                                      case x_abmE of { GHC.Word.W8# x#_abmI ->
                                      Data.ByteString.Lazy.Internal.$WChunk
                                        (Data.ByteString.Internal.Type.$WBS
                                           (GHC.ForeignPtr.ForeignPtr
                                              @GHC.Word.Word8
                                              (GHC.Prim.plusAddr#
                                                 Data.ByteString.singleton1
                                                 (GHC.Prim.word2Int#
                                                    (GHC.Prim.word8ToWord# x#_abmI)))
                                              GHC.ForeignPtr.FinalPtr)
                                           (GHC.Types.I# 1#))
                                        ds_abmF
                                      }
                                      }) } in
                           \ (ds3_abmK
                                :: Data.Either.Either
                                     Data.ByteString.Lazy.Internal.ByteString
                                     (f_abm9
                                        (GHC.Word.Word8,
                                         Data.ByteString.Lazy.Internal.ByteString))) ->
                             case ds3_abmK of {
                               Data.Either.Left x_abmM -> f2_abmA x_abmM;
                               Data.Either.Right y_abmO -> ds2_abmB y_abmO
                             }) } in
                  let {
                    g_abmQ
                      :: p_abm8
                           (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                           (f_abm9 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                         -> p_abm8
                              (Data.Either.Either
                                 Data.ByteString.Lazy.Internal.ByteString
                                 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                              (Data.Either.Either
                                 Data.ByteString.Lazy.Internal.ByteString
                                 (f_abm9
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abmQ
                      = Data.Profunctor.Choice.right'
                          @p_abm8
                          $dChoice_abma
                          @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                          @(f_abm9
                              (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                          @Data.ByteString.Lazy.Internal.ByteString } in
                  \ (x_abmR
                       :: p_abm8
                            (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                            (f_abm9
                               (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))) ->
                    f1_abmc (g_abmQ x_abmR))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <Data.ByteString.Lazy.Internal.ByteString>_N
                                <Data.ByteString.Lazy.Internal.ByteString>_N
                                <GHC.Word.Word8>_N
                                <GHC.Word.Word8>_N)
                       :: Control.Lens.Type.Prism
                            Data.ByteString.Lazy.Internal.ByteString
                            Data.ByteString.Lazy.Internal.ByteString
                            (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                            (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                          ~R# Control.Lens.Cons.Cons
                                Data.ByteString.Lazy.Internal.ByteString
                                Data.ByteString.Lazy.Internal.ByteString
                                GHC.Word.Word8
                                GHC.Word.Word8))
              ((\ (@(p_abmT :: * -> * -> *))
                  (@(f_abmU :: * -> *))
                  ($dChoice_abmV :: Data.Profunctor.Choice.Choice p_abmT)
                  ($dApplicative_abmW :: GHC.Base.Applicative f_abmU) ->
                  let {
                    f1_abmX
                      :: p_abmT
                           (Data.Either.Either Data.ByteString.Lazy.Internal.ByteString ())
                           (Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString (f_abmU ()))
                         -> p_abmT
                              Data.ByteString.Lazy.Internal.ByteString
                              (f_abmU Data.ByteString.Lazy.Internal.ByteString)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 290 0}]
                    f1_abmX
                      = Data.Profunctor.Unsafe.dimap
                          @p_abmT
                          (Data.Profunctor.Choice.$p1Choice @p_abmT $dChoice_abmV)
                          @Data.ByteString.Lazy.Internal.ByteString
                          @(Data.Either.Either Data.ByteString.Lazy.Internal.ByteString ())
                          @(Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString (f_abmU ()))
                          @(f_abmU Data.ByteString.Lazy.Internal.ByteString)
                          (\ (s_abmY :: Data.ByteString.Lazy.Internal.ByteString) ->
                             case s_abmY of wild_abmZ {
                               Data.ByteString.Lazy.Internal.Empty ->
                                 Data.Either.Right
                                   @Data.ByteString.Lazy.Internal.ByteString @() GHC.Tuple.Prim.();
                               Data.ByteString.Lazy.Internal.Chunk ipv_abn0 ipv1_abn1 ipv2_abn2
                                                                   ipv3_abn3 ->
                                 Data.Either.Left
                                   @Data.ByteString.Lazy.Internal.ByteString @() wild_abmZ
                             })
                          (let {
                             f2_abn5
                               :: Data.ByteString.Lazy.Internal.ByteString
                                  -> f_abmU Data.ByteString.Lazy.Internal.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abn5
                               = GHC.Base.pure
                                   @f_abmU
                                   $dApplicative_abmW
                                   @Data.ByteString.Lazy.Internal.ByteString } in
                           let {
                             ds2_abn6
                               :: f_abmU () -> f_abmU Data.ByteString.Lazy.Internal.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 70 0}]
                             ds2_abn6
                               = GHC.Base.fmap
                                   @f_abmU
                                   (GHC.Base.$p1Applicative @f_abmU $dApplicative_abmW)
                                   @()
                                   @Data.ByteString.Lazy.Internal.ByteString
                                   (\ (ds3_abn7 :: ()) ->
                                      case ds3_abn7 of { () ->
                                      Data.ByteString.Lazy.Internal.Empty
                                      }) } in
                           \ (ds3_abn9
                                :: Data.Either.Either
                                     Data.ByteString.Lazy.Internal.ByteString (f_abmU ())) ->
                             case ds3_abn9 of {
                               Data.Either.Left x_abnb -> f2_abn5 x_abnb;
                               Data.Either.Right y_abnd -> ds2_abn6 y_abnd
                             }) } in
                  let {
                    g_abnf
                      :: p_abmT () (f_abmU ())
                         -> p_abmT
                              (Data.Either.Either Data.ByteString.Lazy.Internal.ByteString ())
                              (Data.Either.Either
                                 Data.ByteString.Lazy.Internal.ByteString (f_abmU ()))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abnf
                      = Data.Profunctor.Choice.right'
                          @p_abmT
                          $dChoice_abmV
                          @()
                          @(f_abmU ())
                          @Data.ByteString.Lazy.Internal.ByteString } in
                  \ (x_abng :: p_abmT () (f_abmU ())) -> f1_abmX (g_abnf x_abng))
               `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                <Data.ByteString.Lazy.Internal.ByteString>_N)
                       :: Control.Lens.Type.Prism'
                            Data.ByteString.Lazy.Internal.ByteString ()
                          ~R# Control.Lens.Empty.AsEmpty
                                Data.ByteString.Lazy.Internal.ByteString))
              (Data.Functor.Contravariant.$fContravariantConst
                 @Data.ByteString.Lazy.Internal.ByteString)
              (Data.Functor.Const.$fFunctorConst
                 @Data.ByteString.Lazy.Internal.ByteString)
    Cont:   ApplyToVal nodup hole Control.Lens.Getter.Getting
                                    Data.ByteString.Lazy.Internal.ByteString
                                    [GHC.Word.Word8]
                                    Data.ByteString.Lazy.Internal.ByteString
              ((\ (ds_abdj [Occ=Once1] :: a_abdg) -> ds_abdj)
               `cast` (<a_abdg>_R
                       %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                          <*>_N <a_abdg>_R <a_abdg>_P)
                       :: (a_abdg -> a_abdg)
                          ~R# (a_abdg -> Data.Functor.Const.Const a_abdg a_abdg)))
            ApplyToVal nodup hole [GHC.Word.Word8]
                                  -> Data.Functor.Const.Const
                                       Data.ByteString.Lazy.Internal.ByteString [GHC.Word.Word8]
              s_a8Og
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N
                        <Data.ByteString.Lazy.Internal.ByteString>_R
                        <[GHC.Word.Word8]>_P
                    :: Data.Functor.Const.Const
                         Data.ByteString.Lazy.Internal.ByteString [GHC.Word.Word8]
                       ~R# Data.ByteString.Lazy.Internal.ByteString)
            Stop[RuleArgCtxt] Data.ByteString.Lazy.Internal.ByteString
Rule fired
    Rule: Class op fmap
    Module: (BUILTIN)
    Before: GHC.Base.fmap
              TyArg Data.Functor.Const.Const
                      Data.ByteString.Lazy.Internal.ByteString
              ValArg Data.Functor.Const.$fFunctorConst
                       @Data.ByteString.Lazy.Internal.ByteString
    After:  (Data.Functor.Const.$fFunctorConst2
               @Data.ByteString.Lazy.Internal.ByteString)
            `cast` (forall (a :: <*>_N) (b :: <*>_N).
                    <a -> b>_R
                    %<'GHC.Types.Many>_N ->_R <Data.Functor.Const.Const
                                                 Data.ByteString.Lazy.Internal.ByteString a>_R
                    %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                  <*>_N
                                                  <Data.ByteString.Lazy.Internal.ByteString>_R
                                                  <a>_P
                                              ; Sym (Data.Functor.Const.N:Const[0]
                                                         <*>_N
                                                         <Data.ByteString.Lazy.Internal.ByteString>_R
                                                         <b>_P)
                    :: (forall {a} {b}.
                        (a -> b)
                        -> Data.Functor.Const.Const
                             Data.ByteString.Lazy.Internal.ByteString a
                        -> Data.Functor.Const.Const
                             Data.ByteString.Lazy.Internal.ByteString a)
                       ~R# (forall {a} {b}.
                            (a -> b)
                            -> Data.Functor.Const.Const
                                 Data.ByteString.Lazy.Internal.ByteString a
                            -> Data.Functor.Const.Const
                                 Data.ByteString.Lazy.Internal.ByteString b))
    Cont:   ApplyToTy Data.ByteString.Lazy.Internal.ByteString
            ApplyToTy [GHC.Word.Word8]
            ApplyToVal nodup hole (Data.ByteString.Lazy.Internal.ByteString
                                   -> [GHC.Word.Word8])
                                  -> Data.Functor.Const.Const
                                       Data.ByteString.Lazy.Internal.ByteString
                                       Data.ByteString.Lazy.Internal.ByteString
                                  -> Data.Functor.Const.Const
                                       Data.ByteString.Lazy.Internal.ByteString [GHC.Word.Word8]
              Data.ByteString.Lazy.Internal.unpackBytes
            ApplyToVal nodup hole Data.Functor.Const.Const
                                    Data.ByteString.Lazy.Internal.ByteString
                                    Data.ByteString.Lazy.Internal.ByteString
                                  -> Data.Functor.Const.Const
                                       Data.ByteString.Lazy.Internal.ByteString [GHC.Word.Word8]
              (bc_abny (ab_abnw x_abnz))
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N
                        <Data.ByteString.Lazy.Internal.ByteString>_R
                        <[GHC.Word.Word8]>_P
                    :: Data.Functor.Const.Const
                         Data.ByteString.Lazy.Internal.ByteString [GHC.Word.Word8]
                       ~R# Data.ByteString.Lazy.Internal.ByteString)
            Stop[RuleArgCtxt] Data.ByteString.Lazy.Internal.ByteString
Rule fired
    Rule: Class op ==
    Module: (BUILTIN)
    Before: GHC.Classes.==
              TyArg [GHC.Word.Word8]
              ValArg $dEq_a9db
              ValArg Data.ByteString.Lazy.Internal.unpackBytes
                       (Data.ByteString.Lazy.Internal.packBytes_$spackChunks 32# s_a8Og)
              ValArg s_a8Og
    After:  GHC.Classes.$fEqList_$c==
              @GHC.Word.Word8 GHC.Word.$fEqWord8
              ValArg Data.ByteString.Lazy.Internal.unpackBytes
                       (Data.ByteString.Lazy.Internal.packBytes_$spackChunks 32# s_a8Og)
              ValArg s_a8Og
    Cont:   Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: unpack
    Module: (GHC.Base)
    Before: GHC.CString.unpackCString# ValArg "B -> L -> B"#
    After:  (\ (a_ab5Y :: GHC.Prim.Addr#) ->
               GHC.Base.build
                 @GHC.Types.Char
                 (\ (@b_ab5Z) -> GHC.CString.unpackFoldrCString# @b_ab5Z a_ab5Y))
              "B -> L -> B"#
    Cont:   Stop[BoringCtxt] Test.Tasty.Core.TestName
Rule fired
    Rule: Class op property
    Module: (BUILTIN)
    Before: Test.QuickCheck.Property.property
              TyArg Data.ByteString.Internal.Type.ByteString -> GHC.Types.Bool
              ValArg $dTestable_a98I
    After:  Test.QuickCheck.Property.$fTestableFUN_$cproperty
              @Data.ByteString.Internal.Type.ByteString
              @GHC.Types.Bool
              Test.QuickCheck.Instances.ByteString.$fArbitraryByteString0
              Data.ByteString.Internal.Type.$fShowByteString
              Test.QuickCheck.Property.$fTestableBool
    Cont:   ApplyToVal nodup hole (Data.ByteString.Internal.Type.ByteString
                                   -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              prop_ab6b
            CastIt (Sym (Test.Tasty.QuickCheck.N:QC[0])
                    :: Test.QuickCheck.Property.Property ~R# Test.Tasty.QuickCheck.QC)
            Stop[BoringCtxt] Test.Tasty.QuickCheck.QC
Rule fired
    Rule: Class op propertyForAllShrinkShow
    Module: (BUILTIN)
    Before: Test.QuickCheck.Property.propertyForAllShrinkShow
              TyArg GHC.Types.Bool ValArg Test.QuickCheck.Property.$fTestableBool
    After:  Test.QuickCheck.Property.$fTestableBool1
            `cast` (forall (a :: <*>_N).
                    <Test.QuickCheck.Gen.Gen a>_R
                    %<'GHC.Types.Many>_N ->_R <a -> [a]>_R
                    %<'GHC.Types.Many>_N ->_R <a -> [GHC.Base.String]>_R
                    %<'GHC.Types.Many>_N ->_R <a -> GHC.Types.Bool>_R
                    %<'GHC.Types.Many>_N ->_R Sym (Test.QuickCheck.Gen.N:Gen[0]
                                                       (Test.QuickCheck.Property.N:Prop[0]))
                                              ; Sym (Test.QuickCheck.Property.N:Property[0])
                    :: (forall {a}.
                        Test.QuickCheck.Gen.Gen a
                        -> (a -> [a])
                        -> (a -> [GHC.Base.String])
                        -> (a -> GHC.Types.Bool)
                        -> Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int
                        -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result)
                       ~R# (forall {a}.
                            Test.QuickCheck.Gen.Gen a
                            -> (a -> [a])
                            -> (a -> [GHC.Base.String])
                            -> (a -> GHC.Types.Bool)
                            -> Test.QuickCheck.Property.Property))
    Cont:   ApplyToTy Data.ByteString.Internal.Type.ByteString
            ApplyToVal nodup hole Test.QuickCheck.Gen.Gen
                                    Data.ByteString.Internal.Type.ByteString
                                  -> (Data.ByteString.Internal.Type.ByteString
                                      -> [Data.ByteString.Internal.Type.ByteString])
                                  -> (Data.ByteString.Internal.Type.ByteString -> [GHC.Base.String])
                                  -> (Data.ByteString.Internal.Type.ByteString -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (Test.QuickCheck.Arbitrary.arbitrary @a_ab7T $dArbitrary_ab7V)
            ApplyToVal nodup hole (Data.ByteString.Internal.Type.ByteString
                                   -> [Data.ByteString.Internal.Type.ByteString])
                                  -> (Data.ByteString.Internal.Type.ByteString -> [GHC.Base.String])
                                  -> (Data.ByteString.Internal.Type.ByteString -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (Test.QuickCheck.Arbitrary.shrink @a_ab7T $dArbitrary_ab7V)
            ApplyToVal nodup hole (Data.ByteString.Internal.Type.ByteString
                                   -> [GHC.Base.String])
                                  -> (Data.ByteString.Internal.Type.ByteString -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (let {
                 g_ab7Z [Occ=OnceL1!] :: a_ab7T -> GHC.Base.String
                 [LclId]
                 g_ab7Z = GHC.Show.show @a_ab7T $dShow_ab7W } in
               \ (x_ab80 [Occ=Once1] :: a_ab7T) ->
                 GHC.Types.:
                   @GHC.Base.String (g_ab7Z x_ab80) (GHC.Types.[] @GHC.Base.String))
            ApplyToVal nodup hole (Data.ByteString.Internal.Type.ByteString
                                   -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              f_ab7Y
            CastIt (Sym (Test.Tasty.QuickCheck.N:QC[0])
                    :: Test.QuickCheck.Property.Property ~R# Test.Tasty.QuickCheck.QC)
            Stop[BoringCtxt] Test.Tasty.QuickCheck.QC
Rule fired
    Rule: Class op arbitrary
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.arbitrary
              TyArg Data.ByteString.Internal.Type.ByteString
              ValArg Test.QuickCheck.Instances.ByteString.$fArbitraryByteString0
    After:  Test.QuickCheck.Instances.ByteString.$fArbitraryByteString3
            `cast` (Sym (Test.QuickCheck.Gen.N:Gen[0]
                             <Data.ByteString.Internal.Type.ByteString>_R)
                    :: (Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int -> Data.ByteString.Internal.Type.ByteString)
                       ~R# Test.QuickCheck.Gen.Gen
                             Data.ByteString.Internal.Type.ByteString)
    Cont:   Stop[BoringCtxt] Test.QuickCheck.Gen.Gen
                               Data.ByteString.Internal.Type.ByteString
Rule fired
    Rule: Class op shrink
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.shrink
              TyArg Data.ByteString.Internal.Type.ByteString
              ValArg Test.QuickCheck.Instances.ByteString.$fArbitraryByteString0
    After:  Test.QuickCheck.Instances.ByteString.$fArbitraryByteString0_$cshrink
    Cont:   Stop[BoringCtxt] Data.ByteString.Internal.Type.ByteString
                             -> [Data.ByteString.Internal.Type.ByteString]
Rule fired
    Rule: Class op show
    Module: (BUILTIN)
    Before: GHC.Show.show
              TyArg Data.ByteString.Internal.Type.ByteString
              ValArg Data.ByteString.Internal.Type.$fShowByteString
    After:  Data.ByteString.Internal.Type.$fShowByteString_$cshow
    Cont:   Stop[RhsCtxt(NonRecursive)] Data.ByteString.Internal.Type.ByteString
                                        -> GHC.Base.String
Rule fired
    Rule: Class op reader
    Module: (BUILTIN)
    Before: Control.Monad.Reader.Class.reader
              TyArg Data.ByteString.Lazy.Internal.ByteString
              TyArg (->) Data.ByteString.Lazy.Internal.ByteString
              ValArg Control.Monad.Reader.Class.$fMonadReaderrFUN
                       @Data.ByteString.Lazy.Internal.ByteString
    After:  \ (@a_abdo) ->
              GHC.Base.id @(Data.ByteString.Lazy.Internal.ByteString -> a_abdo)
    Cont:   ApplyToTy Data.ByteString.Internal.Type.ByteString
            ApplyToVal nodup hole (Data.ByteString.Lazy.Internal.ByteString
                                   -> Data.ByteString.Internal.Type.ByteString)
                                  -> Data.ByteString.Lazy.Internal.ByteString
                                  -> Data.ByteString.Internal.Type.ByteString
              ((l_abdi
                  ((\ (ds_abdj [Occ=Once1] :: a_abdg) -> ds_abdj)
                   `cast` (<a_abdg>_R
                           %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                              <*>_N <a_abdg>_R <a_abdg>_P)
                           :: (a_abdg -> a_abdg)
                              ~R# (a_abdg -> Data.Functor.Const.Const a_abdg a_abdg))))
               `cast` (<s_abde>_R
                       %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                     <*>_N <a_abdg>_R <s_abde>_P
                       :: (s_abde -> Data.Functor.Const.Const a_abdg s_abde)
                          ~R# (s_abde -> a_abdg)))
            ApplyToVal nodup hole Data.ByteString.Lazy.Internal.ByteString
                                  -> Data.ByteString.Internal.Type.ByteString
              (Control.Lens.Getter.view
                 @Data.ByteString.Internal.Type.ByteString
                 @((->) Data.ByteString.Internal.Type.ByteString)
                 @Data.ByteString.Lazy.Internal.ByteString
                 (Control.Monad.Reader.Class.$fMonadReaderrFUN
                    @Data.ByteString.Internal.Type.ByteString)
                 (Control.Lens.Cons.Extras.recons
                    @Data.ByteString.Internal.Type.ByteString
                    @GHC.Word.Word8
                    @Data.ByteString.Lazy.Internal.ByteString
                    Control.Lens.Cons.$fConsByteStringByteStringWord8Word80
                    Control.Lens.Cons.$fConsByteStringByteStringWord8Word8
                    Control.Lens.Empty.$fAsEmptyByteString
                    @(Data.Functor.Const.Const
                        Data.ByteString.Lazy.Internal.ByteString)
                    (Data.Functor.Contravariant.$fContravariantConst
                       @Data.ByteString.Lazy.Internal.ByteString)
                    (Data.Functor.Const.$fFunctorConst
                       @Data.ByteString.Lazy.Internal.ByteString))
                 s_a8Oh)
            Stop[RuleArgCtxt] Data.ByteString.Internal.Type.ByteString
Rule fired
    Rule: recons/bs-strict
    Module: (Control.Lens.Cons.Extras)
    Before: Control.Lens.Cons.Extras.recons
              TyArg Data.ByteString.Lazy.Internal.ByteString
              TyArg GHC.Word.Word8
              TyArg Data.ByteString.Internal.Type.ByteString
              ValArg (\ (@(p_abm8 :: * -> * -> *))
                        (@(f_abm9 :: * -> *))
                        ($dChoice_abma :: Data.Profunctor.Choice.Choice p_abm8)
                        ($dApplicative_abmb :: GHC.Base.Applicative f_abm9) ->
                        let {
                          f1_abmc
                            :: p_abm8
                                 (Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                                 (Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (f_abm9
                                       (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                               -> p_abm8
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (f_abm9 Data.ByteString.Lazy.Internal.ByteString)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 536 0}]
                          f1_abmc
                            = Data.Profunctor.Unsafe.dimap
                                @p_abm8
                                (Data.Profunctor.Choice.$p1Choice @p_abm8 $dChoice_abma)
                                @Data.ByteString.Lazy.Internal.ByteString
                                @(Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                                @(Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (f_abm9
                                       (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                                @(f_abm9 Data.ByteString.Lazy.Internal.ByteString)
                                (\ (s1_abmd :: Data.ByteString.Lazy.Internal.ByteString) ->
                                   case s1_abmd of {
                                     Data.ByteString.Lazy.Internal.Empty ->
                                       Data.Either.Left
                                         @Data.ByteString.Lazy.Internal.ByteString
                                         @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                         Data.ByteString.Lazy.Internal.Empty;
                                     Data.ByteString.Lazy.Internal.Chunk bx_abmk bx1_abml bx2_abmm
                                                                         cs_abmn ->
                                       case bx2_abmm of ds1_abmp {
                                         __DEFAULT ->
                                           Data.Either.Right
                                             @Data.ByteString.Lazy.Internal.ByteString
                                             @(GHC.Word.Word8,
                                               Data.ByteString.Lazy.Internal.ByteString)
                                             (case GHC.Prim.readWord8OffAddr#
                                                     @GHC.Prim.RealWorld
                                                     bx_abmk
                                                     0#
                                                     GHC.Prim.realWorld#
                                              of
                                              { (# ipv_abmr, ipv1_abms #) ->
                                              case GHC.Prim.touch#
                                                     @'GHC.Types.Lifted
                                                     @GHC.ForeignPtr.ForeignPtrContents
                                                     bx1_abml
                                                     ipv_abmr
                                              of
                                              { __DEFAULT ->
                                              GHC.Word.W8# ipv1_abms
                                              }
                                              },
                                              Data.ByteString.Lazy.Internal.$WChunk
                                                (Data.ByteString.Internal.Type.$WBS
                                                   (GHC.ForeignPtr.ForeignPtr
                                                      @GHC.Word.Word8
                                                      (GHC.Prim.plusAddr# bx_abmk 1#)
                                                      bx1_abml)
                                                   (GHC.Types.I# (GHC.Prim.-# ds1_abmp 1#)))
                                                cs_abmn);
                                         1# ->
                                           Data.Either.Right
                                             @Data.ByteString.Lazy.Internal.ByteString
                                             @(GHC.Word.Word8,
                                               Data.ByteString.Lazy.Internal.ByteString)
                                             (case GHC.Prim.readWord8OffAddr#
                                                     @GHC.Prim.RealWorld
                                                     bx_abmk
                                                     0#
                                                     GHC.Prim.realWorld#
                                              of
                                              { (# ipv_abmw, ipv1_abmx #) ->
                                              case GHC.Prim.touch#
                                                     @'GHC.Types.Lifted
                                                     @GHC.ForeignPtr.ForeignPtrContents
                                                     bx1_abml
                                                     ipv_abmw
                                              of
                                              { __DEFAULT ->
                                              GHC.Word.W8# ipv1_abmx
                                              }
                                              },
                                              cs_abmn)
                                       }
                                   })
                                (let {
                                   f2_abmA
                                     :: Data.ByteString.Lazy.Internal.ByteString
                                        -> f_abm9 Data.ByteString.Lazy.Internal.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abmA
                                     = GHC.Base.pure
                                         @f_abm9
                                         $dApplicative_abmb
                                         @Data.ByteString.Lazy.Internal.ByteString } in
                                 let {
                                   ds2_abmB
                                     :: f_abm9
                                          (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                        -> f_abm9 Data.ByteString.Lazy.Internal.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 162 0}]
                                   ds2_abmB
                                     = GHC.Base.fmap
                                         @f_abm9
                                         (GHC.Base.$p1Applicative @f_abm9 $dApplicative_abmb)
                                         @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                         @Data.ByteString.Lazy.Internal.ByteString
                                         (\ (p1_abmC
                                               :: (GHC.Word.Word8,
                                                   Data.ByteString.Lazy.Internal.ByteString)) ->
                                            case p1_abmC of { (x_abmE, ds_abmF) ->
                                            case x_abmE of { GHC.Word.W8# x#_abmI ->
                                            Data.ByteString.Lazy.Internal.$WChunk
                                              (Data.ByteString.Internal.Type.$WBS
                                                 (GHC.ForeignPtr.ForeignPtr
                                                    @GHC.Word.Word8
                                                    (GHC.Prim.plusAddr#
                                                       Data.ByteString.singleton1
                                                       (GHC.Prim.word2Int#
                                                          (GHC.Prim.word8ToWord# x#_abmI)))
                                                    GHC.ForeignPtr.FinalPtr)
                                                 (GHC.Types.I# 1#))
                                              ds_abmF
                                            }
                                            }) } in
                                 \ (ds3_abmK
                                      :: Data.Either.Either
                                           Data.ByteString.Lazy.Internal.ByteString
                                           (f_abm9
                                              (GHC.Word.Word8,
                                               Data.ByteString.Lazy.Internal.ByteString))) ->
                                   case ds3_abmK of {
                                     Data.Either.Left x_abmM -> f2_abmA x_abmM;
                                     Data.Either.Right y_abmO -> ds2_abmB y_abmO
                                   }) } in
                        let {
                          g_abmQ
                            :: p_abm8
                                 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                 (f_abm9 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                               -> p_abm8
                                    (Data.Either.Either
                                       Data.ByteString.Lazy.Internal.ByteString
                                       (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                                    (Data.Either.Either
                                       Data.ByteString.Lazy.Internal.ByteString
                                       (f_abm9
                                          (GHC.Word.Word8,
                                           Data.ByteString.Lazy.Internal.ByteString)))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abmQ
                            = Data.Profunctor.Choice.right'
                                @p_abm8
                                $dChoice_abma
                                @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                @(f_abm9
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                                @Data.ByteString.Lazy.Internal.ByteString } in
                        \ (x_abmR
                             :: p_abm8
                                  (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                  (f_abm9
                                     (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))) ->
                          f1_abmc (g_abmQ x_abmR))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <Data.ByteString.Lazy.Internal.ByteString>_N
                                      <Data.ByteString.Lazy.Internal.ByteString>_N
                                      <GHC.Word.Word8>_N
                                      <GHC.Word.Word8>_N)
                             :: Control.Lens.Type.Prism
                                  Data.ByteString.Lazy.Internal.ByteString
                                  Data.ByteString.Lazy.Internal.ByteString
                                  (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                  (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                ~R# Control.Lens.Cons.Cons
                                      Data.ByteString.Lazy.Internal.ByteString
                                      Data.ByteString.Lazy.Internal.ByteString
                                      GHC.Word.Word8
                                      GHC.Word.Word8)
              ValArg (\ (@(p_abj8 :: * -> * -> *))
                        (@(f_abj9 :: * -> *))
                        ($dChoice_abja :: Data.Profunctor.Choice.Choice p_abj8)
                        ($dApplicative_abjb :: GHC.Base.Applicative f_abj9) ->
                        let {
                          f1_abjc
                            :: p_abj8
                                 (Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                                 (Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString
                                    (f_abj9
                                       (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                               -> p_abj8
                                    Data.ByteString.Internal.Type.ByteString
                                    (f_abj9 Data.ByteString.Internal.Type.ByteString)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 612 0}]
                          f1_abjc
                            = Data.Profunctor.Unsafe.dimap
                                @p_abj8
                                (Data.Profunctor.Choice.$p1Choice @p_abj8 $dChoice_abja)
                                @Data.ByteString.Internal.Type.ByteString
                                @(Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                                @(Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString
                                    (f_abj9
                                       (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                                @(f_abj9 Data.ByteString.Internal.Type.ByteString)
                                (\ (s1_abjd :: Data.ByteString.Internal.Type.ByteString) ->
                                   case s1_abjd of wild_abje
                                   { Data.ByteString.Internal.Type.BS bx_abjf bx1_abjg bx2_abjh ->
                                   case GHC.Classes.leInt (GHC.Types.I# bx2_abjh) (GHC.Types.I# 0#)
                                   of {
                                     GHC.Types.False ->
                                       Data.Either.Right
                                         @Data.ByteString.Internal.Type.ByteString
                                         @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                         (case GHC.Prim.readWord8OffAddr#
                                                 @GHC.Prim.RealWorld bx_abjf 0# GHC.Prim.realWorld#
                                          of
                                          { (# ipv_abjm, ipv1_abjn #) ->
                                          case GHC.Prim.touch#
                                                 @'GHC.Types.Lifted
                                                 @GHC.ForeignPtr.ForeignPtrContents
                                                 bx1_abjg
                                                 ipv_abjm
                                          of
                                          { __DEFAULT ->
                                          GHC.Word.W8# ipv1_abjn
                                          }
                                          },
                                          Data.ByteString.Internal.Type.$WBS
                                            (GHC.ForeignPtr.ForeignPtr
                                               @GHC.Word.Word8
                                               (GHC.Prim.plusAddr# bx_abjf 1#)
                                               bx1_abjg)
                                            (GHC.Types.I# (GHC.Prim.-# bx2_abjh 1#)));
                                     GHC.Types.True ->
                                       Data.Either.Left
                                         @Data.ByteString.Internal.Type.ByteString
                                         @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                         wild_abje
                                   }
                                   })
                                (let {
                                   f2_abjr
                                     :: Data.ByteString.Internal.Type.ByteString
                                        -> f_abj9 Data.ByteString.Internal.Type.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abjr
                                     = GHC.Base.pure
                                         @f_abj9
                                         $dApplicative_abjb
                                         @Data.ByteString.Internal.Type.ByteString } in
                                 let {
                                   ds2_abjs
                                     :: f_abj9
                                          (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                        -> f_abj9 Data.ByteString.Internal.Type.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 259 0}]
                                   ds2_abjs
                                     = GHC.Base.fmap
                                         @f_abj9
                                         (GHC.Base.$p1Applicative @f_abj9 $dApplicative_abjb)
                                         @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                         @Data.ByteString.Internal.Type.ByteString
                                         (\ (p1_abjt
                                               :: (GHC.Word.Word8,
                                                   Data.ByteString.Internal.Type.ByteString)) ->
                                            case p1_abjt of { (ds_abjv, y_abjw) ->
                                            case y_abjw of
                                            { Data.ByteString.Internal.Type.BS bx_abjI bx1_abjJ
                                                                               bx2_abjK ->
                                            GHC.Magic.runRW#
                                              @GHC.Types.LiftedRep
                                              @Data.ByteString.Internal.Type.ByteString
                                              (\ (s_abjG [OS=OneShot]
                                                    :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                                                 let {
                                                   x_abjH :: GHC.Prim.Int#
                                                   [LclId,
                                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                            Value=False, ConLike=False,
                                                            WorkFree=False, Expandable=False,
                                                            Guidance=IF_ARGS [] 1 0}]
                                                   x_abjH = GHC.Prim.+# bx2_abjK 1# } in
                                                 case GHC.Prim.<# x_abjH 0# of {
                                                   __DEFAULT ->
                                                     case GHC.Prim.newPinnedByteArray#
                                                            @GHC.Prim.RealWorld x_abjH s_abjG
                                                     of
                                                     { (# ipv_abjP, ipv1_abjQ #) ->
                                                     let {
                                                       ipv2_abjO :: GHC.Prim.Addr#
                                                       [LclId,
                                                        Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                                Value=False, ConLike=False,
                                                                WorkFree=False, Expandable=False,
                                                                Guidance=IF_ARGS [] 1 0}]
                                                       ipv2_abjO
                                                         = GHC.Prim.mutableByteArrayContents#
                                                             @GHC.Prim.RealWorld ipv1_abjQ } in
                                                     let {
                                                       ipv3_abjS
                                                         :: GHC.ForeignPtr.ForeignPtrContents
                                                       [LclId,
                                                        Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                                Value=True, ConLike=True,
                                                                WorkFree=True, Expandable=True,
                                                                Guidance=IF_ARGS [] 10 10}]
                                                       ipv3_abjS
                                                         = GHC.ForeignPtr.PlainPtr ipv1_abjQ } in
                                                     case ds_abjv of { GHC.Word.W8# x1_abla ->
                                                     case GHC.Prim.writeWord8OffAddr#
                                                            @GHC.Prim.RealWorld
                                                            ipv2_abjO
                                                            0#
                                                            x1_abla
                                                            ipv_abjP
                                                     of s2_ablc
                                                     { __DEFAULT ->
                                                     case GHC.Prim.touch#
                                                            @'GHC.Types.Lifted
                                                            @GHC.ForeignPtr.ForeignPtrContents
                                                            ipv3_abjS
                                                            s2_ablc
                                                     of s'_abld
                                                     { __DEFAULT ->
                                                     case {__ffi_static_ccall_unsafe base:memcpy :: Addr#
                                          -> Addr#
                                          -> Word64#
                                          -> State# RealWorld
                                          -> (# State# RealWorld, Addr# #)}_able
                                                            (GHC.Prim.plusAddr# ipv2_abjO 1#)
                                                            bx_abjI
                                                            (GHC.Prim.int64ToWord64#
                                                               (GHC.Prim.intToInt64# bx2_abjK))
                                                            s'_abld
                                                     of
                                                     { (# ds4_ablg, ds5_ablh #) ->
                                                     case GHC.Prim.touch#
                                                            @'GHC.Types.Lifted
                                                            @GHC.ForeignPtr.ForeignPtrContents
                                                            bx1_abjJ
                                                            ds4_ablg
                                                     of s'1_ablj
                                                     { __DEFAULT ->
                                                     case GHC.Prim.touch#
                                                            @'GHC.Types.Lifted
                                                            @GHC.ForeignPtr.ForeignPtrContents
                                                            ipv3_abjS
                                                            s'1_ablj
                                                     of s'2_ablk
                                                     { __DEFAULT ->
                                                     case GHC.Magic.lazy
                                                            @((GHC.Prim.State# GHC.Prim.RealWorld
                                                               -> (# GHC.Prim.State#
                                                                       GHC.Prim.RealWorld,
                                                                     GHC.Prim.Addr# #))
                                                              -> (# GHC.Prim.State#
                                                                      GHC.Prim.RealWorld,
                                                                    GHC.Prim.Addr# #))
                                                            (GHC.Magic.runRW#
                                                               @('GHC.Types.TupleRep
                                                                   '[GHC.Types.ZeroBitRep,
                                                                     'GHC.Types.AddrRep])
                                                               @(# GHC.Prim.State#
                                                                     GHC.Prim.RealWorld,
                                                                   GHC.Prim.Addr# #))
                                                            (\ _ [Occ=Dead] ->
                                                               (# s'2_ablk, ipv2_abjO #))
                                                     of
                                                     { (# ipv6_abln, ipv7_ablo #) ->
                                                     Data.ByteString.Internal.Type.BS
                                                       ipv7_ablo ipv3_abjS x_abjH
                                                     }
                                                     }
                                                     }
                                                     }
                                                     }
                                                     }
                                                     }
                                                     };
                                                   1# ->
                                                     case GHC.ForeignPtr.mallocPlainForeignPtrBytes2
                                                     of wild_00 {
                                                     }
                                                 })
                                            }
                                            }) } in
                                 \ (ds3_ablr
                                      :: Data.Either.Either
                                           Data.ByteString.Internal.Type.ByteString
                                           (f_abj9
                                              (GHC.Word.Word8,
                                               Data.ByteString.Internal.Type.ByteString))) ->
                                   case ds3_ablr of {
                                     Data.Either.Left x_ablt -> f2_abjr x_ablt;
                                     Data.Either.Right y_ablv -> ds2_abjs y_ablv
                                   }) } in
                        let {
                          g_ablx
                            :: p_abj8
                                 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                 (f_abj9 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                               -> p_abj8
                                    (Data.Either.Either
                                       Data.ByteString.Internal.Type.ByteString
                                       (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                                    (Data.Either.Either
                                       Data.ByteString.Internal.Type.ByteString
                                       (f_abj9
                                          (GHC.Word.Word8,
                                           Data.ByteString.Internal.Type.ByteString)))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_ablx
                            = Data.Profunctor.Choice.right'
                                @p_abj8
                                $dChoice_abja
                                @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                @(f_abj9
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                                @Data.ByteString.Internal.Type.ByteString } in
                        \ (x_ably
                             :: p_abj8
                                  (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                  (f_abj9
                                     (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))) ->
                          f1_abjc (g_ablx x_ably))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <Data.ByteString.Internal.Type.ByteString>_N
                                      <Data.ByteString.Internal.Type.ByteString>_N
                                      <GHC.Word.Word8>_N
                                      <GHC.Word.Word8>_N)
                             :: Control.Lens.Type.Prism
                                  Data.ByteString.Internal.Type.ByteString
                                  Data.ByteString.Internal.Type.ByteString
                                  (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                  (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                ~R# Control.Lens.Cons.Cons
                                      Data.ByteString.Internal.Type.ByteString
                                      Data.ByteString.Internal.Type.ByteString
                                      GHC.Word.Word8
                                      GHC.Word.Word8)
              ValArg (\ (@(p_ablF :: * -> * -> *))
                        (@(f_ablG :: * -> *))
                        ($dChoice_ablH :: Data.Profunctor.Choice.Choice p_ablF)
                        ($dApplicative_ablI :: GHC.Base.Applicative f_ablG) ->
                        let {
                          f1_ablJ
                            :: p_ablF
                                 (Data.Either.Either Data.ByteString.Internal.Type.ByteString ())
                                 (Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString (f_ablG ()))
                               -> p_ablF
                                    Data.ByteString.Internal.Type.ByteString
                                    (f_ablG Data.ByteString.Internal.Type.ByteString)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 350 0}]
                          f1_ablJ
                            = Data.Profunctor.Unsafe.dimap
                                @p_ablF
                                (Data.Profunctor.Choice.$p1Choice @p_ablF $dChoice_ablH)
                                @Data.ByteString.Internal.Type.ByteString
                                @(Data.Either.Either Data.ByteString.Internal.Type.ByteString ())
                                @(Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString (f_ablG ()))
                                @(f_ablG Data.ByteString.Internal.Type.ByteString)
                                (\ (s_ablK :: Data.ByteString.Internal.Type.ByteString) ->
                                   case s_ablK of wild_ablL
                                   { Data.ByteString.Internal.Type.BS bx_ablM bx1_ablN bx2_ablO ->
                                   case GHC.Classes.leInt (GHC.Types.I# bx2_ablO) (GHC.Types.I# 0#)
                                   of {
                                     GHC.Types.False ->
                                       Data.Either.Left
                                         @Data.ByteString.Internal.Type.ByteString @() wild_ablL;
                                     GHC.Types.True ->
                                       Data.Either.Right
                                         @Data.ByteString.Internal.Type.ByteString
                                         @()
                                         GHC.Tuple.Prim.()
                                   }
                                   })
                                (let {
                                   f2_ablS
                                     :: Data.ByteString.Internal.Type.ByteString
                                        -> f_ablG Data.ByteString.Internal.Type.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_ablS
                                     = GHC.Base.pure
                                         @f_ablG
                                         $dApplicative_ablI
                                         @Data.ByteString.Internal.Type.ByteString } in
                                 let {
                                   ds2_ablT
                                     :: f_ablG () -> f_ablG Data.ByteString.Internal.Type.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 70 0}]
                                   ds2_ablT
                                     = GHC.Base.fmap
                                         @f_ablG
                                         (GHC.Base.$p1Applicative @f_ablG $dApplicative_ablI)
                                         @()
                                         @Data.ByteString.Internal.Type.ByteString
                                         (\ (ds3_ablU :: ()) ->
                                            case ds3_ablU of { () ->
                                            Data.ByteString.Internal.Type.empty
                                            }) } in
                                 \ (ds3_ablW
                                      :: Data.Either.Either
                                           Data.ByteString.Internal.Type.ByteString (f_ablG ())) ->
                                   case ds3_ablW of {
                                     Data.Either.Left x_ablY -> f2_ablS x_ablY;
                                     Data.Either.Right y_abm0 -> ds2_ablT y_abm0
                                   }) } in
                        let {
                          g_abm2
                            :: p_ablF () (f_ablG ())
                               -> p_ablF
                                    (Data.Either.Either Data.ByteString.Internal.Type.ByteString ())
                                    (Data.Either.Either
                                       Data.ByteString.Internal.Type.ByteString (f_ablG ()))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abm2
                            = Data.Profunctor.Choice.right'
                                @p_ablF
                                $dChoice_ablH
                                @()
                                @(f_ablG ())
                                @Data.ByteString.Internal.Type.ByteString } in
                        \ (x_abm3 :: p_ablF () (f_ablG ())) -> f1_ablJ (g_abm2 x_abm3))
                     `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                      <Data.ByteString.Internal.Type.ByteString>_N)
                             :: Control.Lens.Type.Prism'
                                  Data.ByteString.Internal.Type.ByteString ()
                                ~R# Control.Lens.Empty.AsEmpty
                                      Data.ByteString.Internal.Type.ByteString)
              TyArg Data.Functor.Const.Const
                      Data.ByteString.Internal.Type.ByteString
              ValArg Data.Functor.Contravariant.$fContravariantConst
                       @Data.ByteString.Internal.Type.ByteString
              ValArg Data.Functor.Const.$fFunctorConst
                       @Data.ByteString.Internal.Type.ByteString
    After:  (\ (@(f_abev :: * -> *))
               ($dCons_abew
                  :: Control.Lens.Cons.Cons
                       Data.ByteString.Lazy.Internal.ByteString
                       Data.ByteString.Lazy.Internal.ByteString
                       GHC.Word.Word8
                       GHC.Word.Word8)
               ($dCons1_abex
                  :: Control.Lens.Cons.Cons
                       Data.ByteString.Internal.Type.ByteString
                       Data.ByteString.Internal.Type.ByteString
                       GHC.Word.Word8
                       GHC.Word.Word8)
               ($dAsEmpty_abey
                  :: Control.Lens.Empty.AsEmpty
                       Data.ByteString.Internal.Type.ByteString)
               ($dContravariant_abez
                  :: Data.Functor.Contravariant.Contravariant f_abev)
               ($dFunctor_abeA :: GHC.Base.Functor f_abev) ->
               Data.Profunctor.Unsafe.$fProfunctorFUN_$cdimap
                 @Data.ByteString.Lazy.Internal.ByteString
                 @Data.ByteString.Internal.Type.ByteString
                 @(f_abev Data.ByteString.Internal.Type.ByteString)
                 @(f_abev Data.ByteString.Lazy.Internal.ByteString)
                 Data.ByteString.Lazy.Internal.toStrict
                 (GHC.Base.fmap
                    @f_abev
                    $dFunctor_abeA
                    @Data.ByteString.Internal.Type.ByteString
                    @Data.ByteString.Lazy.Internal.ByteString
                    Data.ByteString.Lazy.Internal.fromStrict))
              @(Data.Functor.Const.Const
                  Data.ByteString.Internal.Type.ByteString)
              ((\ (@(p_abm8 :: * -> * -> *))
                  (@(f_abm9 :: * -> *))
                  ($dChoice_abma :: Data.Profunctor.Choice.Choice p_abm8)
                  ($dApplicative_abmb :: GHC.Base.Applicative f_abm9) ->
                  let {
                    f1_abmc
                      :: p_abm8
                           (Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString
                              (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                           (Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString
                              (f_abm9
                                 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                         -> p_abm8
                              Data.ByteString.Lazy.Internal.ByteString
                              (f_abm9 Data.ByteString.Lazy.Internal.ByteString)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 536 0}]
                    f1_abmc
                      = Data.Profunctor.Unsafe.dimap
                          @p_abm8
                          (Data.Profunctor.Choice.$p1Choice @p_abm8 $dChoice_abma)
                          @Data.ByteString.Lazy.Internal.ByteString
                          @(Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString
                              (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                          @(Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString
                              (f_abm9
                                 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                          @(f_abm9 Data.ByteString.Lazy.Internal.ByteString)
                          (\ (s1_abmd :: Data.ByteString.Lazy.Internal.ByteString) ->
                             case s1_abmd of {
                               Data.ByteString.Lazy.Internal.Empty ->
                                 Data.Either.Left
                                   @Data.ByteString.Lazy.Internal.ByteString
                                   @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                   Data.ByteString.Lazy.Internal.Empty;
                               Data.ByteString.Lazy.Internal.Chunk bx_abmk bx1_abml bx2_abmm
                                                                   cs_abmn ->
                                 case bx2_abmm of ds1_abmp {
                                   __DEFAULT ->
                                     Data.Either.Right
                                       @Data.ByteString.Lazy.Internal.ByteString
                                       @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                       (case GHC.Prim.readWord8OffAddr#
                                               @GHC.Prim.RealWorld bx_abmk 0# GHC.Prim.realWorld#
                                        of
                                        { (# ipv_abmr, ipv1_abms #) ->
                                        case GHC.Prim.touch#
                                               @'GHC.Types.Lifted
                                               @GHC.ForeignPtr.ForeignPtrContents
                                               bx1_abml
                                               ipv_abmr
                                        of
                                        { __DEFAULT ->
                                        GHC.Word.W8# ipv1_abms
                                        }
                                        },
                                        Data.ByteString.Lazy.Internal.$WChunk
                                          (Data.ByteString.Internal.Type.$WBS
                                             (GHC.ForeignPtr.ForeignPtr
                                                @GHC.Word.Word8
                                                (GHC.Prim.plusAddr# bx_abmk 1#)
                                                bx1_abml)
                                             (GHC.Types.I# (GHC.Prim.-# ds1_abmp 1#)))
                                          cs_abmn);
                                   1# ->
                                     Data.Either.Right
                                       @Data.ByteString.Lazy.Internal.ByteString
                                       @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                       (case GHC.Prim.readWord8OffAddr#
                                               @GHC.Prim.RealWorld bx_abmk 0# GHC.Prim.realWorld#
                                        of
                                        { (# ipv_abmw, ipv1_abmx #) ->
                                        case GHC.Prim.touch#
                                               @'GHC.Types.Lifted
                                               @GHC.ForeignPtr.ForeignPtrContents
                                               bx1_abml
                                               ipv_abmw
                                        of
                                        { __DEFAULT ->
                                        GHC.Word.W8# ipv1_abmx
                                        }
                                        },
                                        cs_abmn)
                                 }
                             })
                          (let {
                             f2_abmA
                               :: Data.ByteString.Lazy.Internal.ByteString
                                  -> f_abm9 Data.ByteString.Lazy.Internal.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abmA
                               = GHC.Base.pure
                                   @f_abm9
                                   $dApplicative_abmb
                                   @Data.ByteString.Lazy.Internal.ByteString } in
                           let {
                             ds2_abmB
                               :: f_abm9
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                  -> f_abm9 Data.ByteString.Lazy.Internal.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 162 0}]
                             ds2_abmB
                               = GHC.Base.fmap
                                   @f_abm9
                                   (GHC.Base.$p1Applicative @f_abm9 $dApplicative_abmb)
                                   @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                   @Data.ByteString.Lazy.Internal.ByteString
                                   (\ (p1_abmC
                                         :: (GHC.Word.Word8,
                                             Data.ByteString.Lazy.Internal.ByteString)) ->
                                      case p1_abmC of { (x_abmE, ds_abmF) ->
                                      case x_abmE of { GHC.Word.W8# x#_abmI ->
                                      Data.ByteString.Lazy.Internal.$WChunk
                                        (Data.ByteString.Internal.Type.$WBS
                                           (GHC.ForeignPtr.ForeignPtr
                                              @GHC.Word.Word8
                                              (GHC.Prim.plusAddr#
                                                 Data.ByteString.singleton1
                                                 (GHC.Prim.word2Int#
                                                    (GHC.Prim.word8ToWord# x#_abmI)))
                                              GHC.ForeignPtr.FinalPtr)
                                           (GHC.Types.I# 1#))
                                        ds_abmF
                                      }
                                      }) } in
                           \ (ds3_abmK
                                :: Data.Either.Either
                                     Data.ByteString.Lazy.Internal.ByteString
                                     (f_abm9
                                        (GHC.Word.Word8,
                                         Data.ByteString.Lazy.Internal.ByteString))) ->
                             case ds3_abmK of {
                               Data.Either.Left x_abmM -> f2_abmA x_abmM;
                               Data.Either.Right y_abmO -> ds2_abmB y_abmO
                             }) } in
                  let {
                    g_abmQ
                      :: p_abm8
                           (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                           (f_abm9 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                         -> p_abm8
                              (Data.Either.Either
                                 Data.ByteString.Lazy.Internal.ByteString
                                 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                              (Data.Either.Either
                                 Data.ByteString.Lazy.Internal.ByteString
                                 (f_abm9
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abmQ
                      = Data.Profunctor.Choice.right'
                          @p_abm8
                          $dChoice_abma
                          @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                          @(f_abm9
                              (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                          @Data.ByteString.Lazy.Internal.ByteString } in
                  \ (x_abmR
                       :: p_abm8
                            (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                            (f_abm9
                               (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))) ->
                    f1_abmc (g_abmQ x_abmR))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <Data.ByteString.Lazy.Internal.ByteString>_N
                                <Data.ByteString.Lazy.Internal.ByteString>_N
                                <GHC.Word.Word8>_N
                                <GHC.Word.Word8>_N)
                       :: Control.Lens.Type.Prism
                            Data.ByteString.Lazy.Internal.ByteString
                            Data.ByteString.Lazy.Internal.ByteString
                            (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                            (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                          ~R# Control.Lens.Cons.Cons
                                Data.ByteString.Lazy.Internal.ByteString
                                Data.ByteString.Lazy.Internal.ByteString
                                GHC.Word.Word8
                                GHC.Word.Word8))
              ((\ (@(p_abj8 :: * -> * -> *))
                  (@(f_abj9 :: * -> *))
                  ($dChoice_abja :: Data.Profunctor.Choice.Choice p_abj8)
                  ($dApplicative_abjb :: GHC.Base.Applicative f_abj9) ->
                  let {
                    f1_abjc
                      :: p_abj8
                           (Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString
                              (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                           (Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString
                              (f_abj9
                                 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                         -> p_abj8
                              Data.ByteString.Internal.Type.ByteString
                              (f_abj9 Data.ByteString.Internal.Type.ByteString)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 612 0}]
                    f1_abjc
                      = Data.Profunctor.Unsafe.dimap
                          @p_abj8
                          (Data.Profunctor.Choice.$p1Choice @p_abj8 $dChoice_abja)
                          @Data.ByteString.Internal.Type.ByteString
                          @(Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString
                              (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                          @(Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString
                              (f_abj9
                                 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                          @(f_abj9 Data.ByteString.Internal.Type.ByteString)
                          (\ (s1_abjd :: Data.ByteString.Internal.Type.ByteString) ->
                             case s1_abjd of wild_abje
                             { Data.ByteString.Internal.Type.BS bx_abjf bx1_abjg bx2_abjh ->
                             case GHC.Classes.leInt (GHC.Types.I# bx2_abjh) (GHC.Types.I# 0#)
                             of {
                               GHC.Types.False ->
                                 Data.Either.Right
                                   @Data.ByteString.Internal.Type.ByteString
                                   @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                   (case GHC.Prim.readWord8OffAddr#
                                           @GHC.Prim.RealWorld bx_abjf 0# GHC.Prim.realWorld#
                                    of
                                    { (# ipv_abjm, ipv1_abjn #) ->
                                    case GHC.Prim.touch#
                                           @'GHC.Types.Lifted
                                           @GHC.ForeignPtr.ForeignPtrContents
                                           bx1_abjg
                                           ipv_abjm
                                    of
                                    { __DEFAULT ->
                                    GHC.Word.W8# ipv1_abjn
                                    }
                                    },
                                    Data.ByteString.Internal.Type.$WBS
                                      (GHC.ForeignPtr.ForeignPtr
                                         @GHC.Word.Word8 (GHC.Prim.plusAddr# bx_abjf 1#) bx1_abjg)
                                      (GHC.Types.I# (GHC.Prim.-# bx2_abjh 1#)));
                               GHC.Types.True ->
                                 Data.Either.Left
                                   @Data.ByteString.Internal.Type.ByteString
                                   @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                   wild_abje
                             }
                             })
                          (let {
                             f2_abjr
                               :: Data.ByteString.Internal.Type.ByteString
                                  -> f_abj9 Data.ByteString.Internal.Type.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abjr
                               = GHC.Base.pure
                                   @f_abj9
                                   $dApplicative_abjb
                                   @Data.ByteString.Internal.Type.ByteString } in
                           let {
                             ds2_abjs
                               :: f_abj9
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                  -> f_abj9 Data.ByteString.Internal.Type.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 259 0}]
                             ds2_abjs
                               = GHC.Base.fmap
                                   @f_abj9
                                   (GHC.Base.$p1Applicative @f_abj9 $dApplicative_abjb)
                                   @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                   @Data.ByteString.Internal.Type.ByteString
                                   (\ (p1_abjt
                                         :: (GHC.Word.Word8,
                                             Data.ByteString.Internal.Type.ByteString)) ->
                                      case p1_abjt of { (ds_abjv, y_abjw) ->
                                      case y_abjw of
                                      { Data.ByteString.Internal.Type.BS bx_abjI bx1_abjJ
                                                                         bx2_abjK ->
                                      GHC.Magic.runRW#
                                        @GHC.Types.LiftedRep
                                        @Data.ByteString.Internal.Type.ByteString
                                        (\ (s_abjG [OS=OneShot]
                                              :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                                           let {
                                             x_abjH :: GHC.Prim.Int#
                                             [LclId,
                                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                      Value=False, ConLike=False, WorkFree=False,
                                                      Expandable=False,
                                                      Guidance=IF_ARGS [] 1 0}]
                                             x_abjH = GHC.Prim.+# bx2_abjK 1# } in
                                           case GHC.Prim.<# x_abjH 0# of {
                                             __DEFAULT ->
                                               case GHC.Prim.newPinnedByteArray#
                                                      @GHC.Prim.RealWorld x_abjH s_abjG
                                               of
                                               { (# ipv_abjP, ipv1_abjQ #) ->
                                               let {
                                                 ipv2_abjO :: GHC.Prim.Addr#
                                                 [LclId,
                                                  Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                          Value=False, ConLike=False,
                                                          WorkFree=False, Expandable=False,
                                                          Guidance=IF_ARGS [] 1 0}]
                                                 ipv2_abjO
                                                   = GHC.Prim.mutableByteArrayContents#
                                                       @GHC.Prim.RealWorld ipv1_abjQ } in
                                               let {
                                                 ipv3_abjS :: GHC.ForeignPtr.ForeignPtrContents
                                                 [LclId,
                                                  Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                          Value=True, ConLike=True, WorkFree=True,
                                                          Expandable=True,
                                                          Guidance=IF_ARGS [] 10 10}]
                                                 ipv3_abjS = GHC.ForeignPtr.PlainPtr ipv1_abjQ } in
                                               case ds_abjv of { GHC.Word.W8# x1_abla ->
                                               case GHC.Prim.writeWord8OffAddr#
                                                      @GHC.Prim.RealWorld
                                                      ipv2_abjO
                                                      0#
                                                      x1_abla
                                                      ipv_abjP
                                               of s2_ablc
                                               { __DEFAULT ->
                                               case GHC.Prim.touch#
                                                      @'GHC.Types.Lifted
                                                      @GHC.ForeignPtr.ForeignPtrContents
                                                      ipv3_abjS
                                                      s2_ablc
                                               of s'_abld
                                               { __DEFAULT ->
                                               case {__ffi_static_ccall_unsafe base:memcpy :: Addr#
                                          -> Addr#
                                          -> Word64#
                                          -> State# RealWorld
                                          -> (# State# RealWorld, Addr# #)}_able
                                                      (GHC.Prim.plusAddr# ipv2_abjO 1#)
                                                      bx_abjI
                                                      (GHC.Prim.int64ToWord64#
                                                         (GHC.Prim.intToInt64# bx2_abjK))
                                                      s'_abld
                                               of
                                               { (# ds4_ablg, ds5_ablh #) ->
                                               case GHC.Prim.touch#
                                                      @'GHC.Types.Lifted
                                                      @GHC.ForeignPtr.ForeignPtrContents
                                                      bx1_abjJ
                                                      ds4_ablg
                                               of s'1_ablj
                                               { __DEFAULT ->
                                               case GHC.Prim.touch#
                                                      @'GHC.Types.Lifted
                                                      @GHC.ForeignPtr.ForeignPtrContents
                                                      ipv3_abjS
                                                      s'1_ablj
                                               of s'2_ablk
                                               { __DEFAULT ->
                                               case GHC.Magic.lazy
                                                      @((GHC.Prim.State# GHC.Prim.RealWorld
                                                         -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                               GHC.Prim.Addr# #))
                                                        -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                              GHC.Prim.Addr# #))
                                                      (GHC.Magic.runRW#
                                                         @('GHC.Types.TupleRep
                                                             '[GHC.Types.ZeroBitRep,
                                                               'GHC.Types.AddrRep])
                                                         @(# GHC.Prim.State# GHC.Prim.RealWorld,
                                                             GHC.Prim.Addr# #))
                                                      (\ _ [Occ=Dead] -> (# s'2_ablk, ipv2_abjO #))
                                               of
                                               { (# ipv6_abln, ipv7_ablo #) ->
                                               Data.ByteString.Internal.Type.BS
                                                 ipv7_ablo ipv3_abjS x_abjH
                                               }
                                               }
                                               }
                                               }
                                               }
                                               }
                                               }
                                               };
                                             1# ->
                                               case GHC.ForeignPtr.mallocPlainForeignPtrBytes2
                                               of wild_00 {
                                               }
                                           })
                                      }
                                      }) } in
                           \ (ds3_ablr
                                :: Data.Either.Either
                                     Data.ByteString.Internal.Type.ByteString
                                     (f_abj9
                                        (GHC.Word.Word8,
                                         Data.ByteString.Internal.Type.ByteString))) ->
                             case ds3_ablr of {
                               Data.Either.Left x_ablt -> f2_abjr x_ablt;
                               Data.Either.Right y_ablv -> ds2_abjs y_ablv
                             }) } in
                  let {
                    g_ablx
                      :: p_abj8
                           (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                           (f_abj9 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                         -> p_abj8
                              (Data.Either.Either
                                 Data.ByteString.Internal.Type.ByteString
                                 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                              (Data.Either.Either
                                 Data.ByteString.Internal.Type.ByteString
                                 (f_abj9
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_ablx
                      = Data.Profunctor.Choice.right'
                          @p_abj8
                          $dChoice_abja
                          @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                          @(f_abj9
                              (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                          @Data.ByteString.Internal.Type.ByteString } in
                  \ (x_ably
                       :: p_abj8
                            (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                            (f_abj9
                               (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))) ->
                    f1_abjc (g_ablx x_ably))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <Data.ByteString.Internal.Type.ByteString>_N
                                <Data.ByteString.Internal.Type.ByteString>_N
                                <GHC.Word.Word8>_N
                                <GHC.Word.Word8>_N)
                       :: Control.Lens.Type.Prism
                            Data.ByteString.Internal.Type.ByteString
                            Data.ByteString.Internal.Type.ByteString
                            (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                            (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                          ~R# Control.Lens.Cons.Cons
                                Data.ByteString.Internal.Type.ByteString
                                Data.ByteString.Internal.Type.ByteString
                                GHC.Word.Word8
                                GHC.Word.Word8))
              ((\ (@(p_ablF :: * -> * -> *))
                  (@(f_ablG :: * -> *))
                  ($dChoice_ablH :: Data.Profunctor.Choice.Choice p_ablF)
                  ($dApplicative_ablI :: GHC.Base.Applicative f_ablG) ->
                  let {
                    f1_ablJ
                      :: p_ablF
                           (Data.Either.Either Data.ByteString.Internal.Type.ByteString ())
                           (Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString (f_ablG ()))
                         -> p_ablF
                              Data.ByteString.Internal.Type.ByteString
                              (f_ablG Data.ByteString.Internal.Type.ByteString)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 350 0}]
                    f1_ablJ
                      = Data.Profunctor.Unsafe.dimap
                          @p_ablF
                          (Data.Profunctor.Choice.$p1Choice @p_ablF $dChoice_ablH)
                          @Data.ByteString.Internal.Type.ByteString
                          @(Data.Either.Either Data.ByteString.Internal.Type.ByteString ())
                          @(Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString (f_ablG ()))
                          @(f_ablG Data.ByteString.Internal.Type.ByteString)
                          (\ (s_ablK :: Data.ByteString.Internal.Type.ByteString) ->
                             case s_ablK of wild_ablL
                             { Data.ByteString.Internal.Type.BS bx_ablM bx1_ablN bx2_ablO ->
                             case GHC.Classes.leInt (GHC.Types.I# bx2_ablO) (GHC.Types.I# 0#)
                             of {
                               GHC.Types.False ->
                                 Data.Either.Left
                                   @Data.ByteString.Internal.Type.ByteString @() wild_ablL;
                               GHC.Types.True ->
                                 Data.Either.Right
                                   @Data.ByteString.Internal.Type.ByteString @() GHC.Tuple.Prim.()
                             }
                             })
                          (let {
                             f2_ablS
                               :: Data.ByteString.Internal.Type.ByteString
                                  -> f_ablG Data.ByteString.Internal.Type.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_ablS
                               = GHC.Base.pure
                                   @f_ablG
                                   $dApplicative_ablI
                                   @Data.ByteString.Internal.Type.ByteString } in
                           let {
                             ds2_ablT
                               :: f_ablG () -> f_ablG Data.ByteString.Internal.Type.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 70 0}]
                             ds2_ablT
                               = GHC.Base.fmap
                                   @f_ablG
                                   (GHC.Base.$p1Applicative @f_ablG $dApplicative_ablI)
                                   @()
                                   @Data.ByteString.Internal.Type.ByteString
                                   (\ (ds3_ablU :: ()) ->
                                      case ds3_ablU of { () ->
                                      Data.ByteString.Internal.Type.empty
                                      }) } in
                           \ (ds3_ablW
                                :: Data.Either.Either
                                     Data.ByteString.Internal.Type.ByteString (f_ablG ())) ->
                             case ds3_ablW of {
                               Data.Either.Left x_ablY -> f2_ablS x_ablY;
                               Data.Either.Right y_abm0 -> ds2_ablT y_abm0
                             }) } in
                  let {
                    g_abm2
                      :: p_ablF () (f_ablG ())
                         -> p_ablF
                              (Data.Either.Either Data.ByteString.Internal.Type.ByteString ())
                              (Data.Either.Either
                                 Data.ByteString.Internal.Type.ByteString (f_ablG ()))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abm2
                      = Data.Profunctor.Choice.right'
                          @p_ablF
                          $dChoice_ablH
                          @()
                          @(f_ablG ())
                          @Data.ByteString.Internal.Type.ByteString } in
                  \ (x_abm3 :: p_ablF () (f_ablG ())) -> f1_ablJ (g_abm2 x_abm3))
               `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                <Data.ByteString.Internal.Type.ByteString>_N)
                       :: Control.Lens.Type.Prism'
                            Data.ByteString.Internal.Type.ByteString ()
                          ~R# Control.Lens.Empty.AsEmpty
                                Data.ByteString.Internal.Type.ByteString))
              (Data.Functor.Contravariant.$fContravariantConst
                 @Data.ByteString.Internal.Type.ByteString)
              (Data.Functor.Const.$fFunctorConst
                 @Data.ByteString.Internal.Type.ByteString)
    Cont:   ApplyToVal nodup hole Control.Lens.Getter.Getting
                                    Data.ByteString.Internal.Type.ByteString
                                    Data.ByteString.Lazy.Internal.ByteString
                                    Data.ByteString.Internal.Type.ByteString
              ((\ (ds_abdj [Occ=Once1] :: a_abdg) -> ds_abdj)
               `cast` (<a_abdg>_R
                       %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                          <*>_N <a_abdg>_R <a_abdg>_P)
                       :: (a_abdg -> a_abdg)
                          ~R# (a_abdg -> Data.Functor.Const.Const a_abdg a_abdg)))
            ApplyToVal nodup hole Data.ByteString.Lazy.Internal.ByteString
                                  -> Data.Functor.Const.Const
                                       Data.ByteString.Internal.Type.ByteString
                                       Data.ByteString.Lazy.Internal.ByteString
              (Control.Lens.Getter.view
                 @Data.ByteString.Internal.Type.ByteString
                 @((->) Data.ByteString.Internal.Type.ByteString)
                 @Data.ByteString.Lazy.Internal.ByteString
                 (Control.Monad.Reader.Class.$fMonadReaderrFUN
                    @Data.ByteString.Internal.Type.ByteString)
                 (Control.Lens.Cons.Extras.recons
                    @Data.ByteString.Internal.Type.ByteString
                    @GHC.Word.Word8
                    @Data.ByteString.Lazy.Internal.ByteString
                    Control.Lens.Cons.$fConsByteStringByteStringWord8Word80
                    Control.Lens.Cons.$fConsByteStringByteStringWord8Word8
                    Control.Lens.Empty.$fAsEmptyByteString
                    @(Data.Functor.Const.Const
                        Data.ByteString.Lazy.Internal.ByteString)
                    (Data.Functor.Contravariant.$fContravariantConst
                       @Data.ByteString.Lazy.Internal.ByteString)
                    (Data.Functor.Const.$fFunctorConst
                       @Data.ByteString.Lazy.Internal.ByteString))
                 s_a8Oh)
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N
                        <Data.ByteString.Internal.Type.ByteString>_R
                        <Data.ByteString.Lazy.Internal.ByteString>_P
                    :: Data.Functor.Const.Const
                         Data.ByteString.Internal.Type.ByteString
                         Data.ByteString.Lazy.Internal.ByteString
                       ~R# Data.ByteString.Internal.Type.ByteString)
            Stop[RuleArgCtxt] Data.ByteString.Internal.Type.ByteString
Rule fired
    Rule: Class op fmap
    Module: (BUILTIN)
    Before: GHC.Base.fmap
              TyArg Data.Functor.Const.Const
                      Data.ByteString.Internal.Type.ByteString
              ValArg Data.Functor.Const.$fFunctorConst
                       @Data.ByteString.Internal.Type.ByteString
    After:  (Data.Functor.Const.$fFunctorConst2
               @Data.ByteString.Internal.Type.ByteString)
            `cast` (forall (a :: <*>_N) (b :: <*>_N).
                    <a -> b>_R
                    %<'GHC.Types.Many>_N ->_R <Data.Functor.Const.Const
                                                 Data.ByteString.Internal.Type.ByteString a>_R
                    %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                  <*>_N
                                                  <Data.ByteString.Internal.Type.ByteString>_R
                                                  <a>_P
                                              ; Sym (Data.Functor.Const.N:Const[0]
                                                         <*>_N
                                                         <Data.ByteString.Internal.Type.ByteString>_R
                                                         <b>_P)
                    :: (forall {a} {b}.
                        (a -> b)
                        -> Data.Functor.Const.Const
                             Data.ByteString.Internal.Type.ByteString a
                        -> Data.Functor.Const.Const
                             Data.ByteString.Internal.Type.ByteString a)
                       ~R# (forall {a} {b}.
                            (a -> b)
                            -> Data.Functor.Const.Const
                                 Data.ByteString.Internal.Type.ByteString a
                            -> Data.Functor.Const.Const
                                 Data.ByteString.Internal.Type.ByteString b))
    Cont:   ApplyToTy Data.ByteString.Internal.Type.ByteString
            ApplyToTy Data.ByteString.Lazy.Internal.ByteString
            ApplyToVal nodup hole (Data.ByteString.Internal.Type.ByteString
                                   -> Data.ByteString.Lazy.Internal.ByteString)
                                  -> Data.Functor.Const.Const
                                       Data.ByteString.Internal.Type.ByteString
                                       Data.ByteString.Internal.Type.ByteString
                                  -> Data.Functor.Const.Const
                                       Data.ByteString.Internal.Type.ByteString
                                       Data.ByteString.Lazy.Internal.ByteString
              Data.ByteString.Lazy.Internal.fromStrict
            ApplyToVal nodup hole Data.Functor.Const.Const
                                    Data.ByteString.Internal.Type.ByteString
                                    Data.ByteString.Internal.Type.ByteString
                                  -> Data.Functor.Const.Const
                                       Data.ByteString.Internal.Type.ByteString
                                       Data.ByteString.Lazy.Internal.ByteString
              (bc_abny (ab_abnw x_abnz))
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N
                        <Data.ByteString.Internal.Type.ByteString>_R
                        <Data.ByteString.Lazy.Internal.ByteString>_P
                    :: Data.Functor.Const.Const
                         Data.ByteString.Internal.Type.ByteString
                         Data.ByteString.Lazy.Internal.ByteString
                       ~R# Data.ByteString.Internal.Type.ByteString)
            Stop[RuleArgCtxt] Data.ByteString.Internal.Type.ByteString
Rule fired
    Rule: Class op reader
    Module: (BUILTIN)
    Before: Control.Monad.Reader.Class.reader
              TyArg Data.ByteString.Internal.Type.ByteString
              TyArg (->) Data.ByteString.Internal.Type.ByteString
              ValArg Control.Monad.Reader.Class.$fMonadReaderrFUN
                       @Data.ByteString.Internal.Type.ByteString
    After:  \ (@a_abdo) ->
              GHC.Base.id @(Data.ByteString.Internal.Type.ByteString -> a_abdo)
    Cont:   ApplyToTy Data.ByteString.Lazy.Internal.ByteString
            ApplyToVal nodup hole (Data.ByteString.Internal.Type.ByteString
                                   -> Data.ByteString.Lazy.Internal.ByteString)
                                  -> Data.ByteString.Internal.Type.ByteString
                                  -> Data.ByteString.Lazy.Internal.ByteString
              ((l_abdi
                  ((\ (ds_abdj [Occ=Once1] :: a_abdg) -> ds_abdj)
                   `cast` (<a_abdg>_R
                           %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                              <*>_N <a_abdg>_R <a_abdg>_P)
                           :: (a_abdg -> a_abdg)
                              ~R# (a_abdg -> Data.Functor.Const.Const a_abdg a_abdg))))
               `cast` (<s_abde>_R
                       %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                     <*>_N <a_abdg>_R <s_abde>_P
                       :: (s_abde -> Data.Functor.Const.Const a_abdg s_abde)
                          ~R# (s_abde -> a_abdg)))
            ApplyToVal nodup hole Data.ByteString.Internal.Type.ByteString
                                  -> Data.ByteString.Lazy.Internal.ByteString
              s_a8Oh
            Stop[RuleArgCtxt] Data.ByteString.Lazy.Internal.ByteString
Rule fired
    Rule: recons/bs-lazy
    Module: (Control.Lens.Cons.Extras)
    Before: Control.Lens.Cons.Extras.recons
              TyArg Data.ByteString.Internal.Type.ByteString
              TyArg GHC.Word.Word8
              TyArg Data.ByteString.Lazy.Internal.ByteString
              ValArg (\ (@(p_abj8 :: * -> * -> *))
                        (@(f_abj9 :: * -> *))
                        ($dChoice_abja :: Data.Profunctor.Choice.Choice p_abj8)
                        ($dApplicative_abjb :: GHC.Base.Applicative f_abj9) ->
                        let {
                          f1_abjc
                            :: p_abj8
                                 (Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                                 (Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString
                                    (f_abj9
                                       (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                               -> p_abj8
                                    Data.ByteString.Internal.Type.ByteString
                                    (f_abj9 Data.ByteString.Internal.Type.ByteString)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 612 0}]
                          f1_abjc
                            = Data.Profunctor.Unsafe.dimap
                                @p_abj8
                                (Data.Profunctor.Choice.$p1Choice @p_abj8 $dChoice_abja)
                                @Data.ByteString.Internal.Type.ByteString
                                @(Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                                @(Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString
                                    (f_abj9
                                       (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                                @(f_abj9 Data.ByteString.Internal.Type.ByteString)
                                (\ (s1_abjd :: Data.ByteString.Internal.Type.ByteString) ->
                                   case s1_abjd of wild_abje
                                   { Data.ByteString.Internal.Type.BS bx_abjf bx1_abjg bx2_abjh ->
                                   case GHC.Classes.leInt (GHC.Types.I# bx2_abjh) (GHC.Types.I# 0#)
                                   of {
                                     GHC.Types.False ->
                                       Data.Either.Right
                                         @Data.ByteString.Internal.Type.ByteString
                                         @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                         (case GHC.Prim.readWord8OffAddr#
                                                 @GHC.Prim.RealWorld bx_abjf 0# GHC.Prim.realWorld#
                                          of
                                          { (# ipv_abjm, ipv1_abjn #) ->
                                          case GHC.Prim.touch#
                                                 @'GHC.Types.Lifted
                                                 @GHC.ForeignPtr.ForeignPtrContents
                                                 bx1_abjg
                                                 ipv_abjm
                                          of
                                          { __DEFAULT ->
                                          GHC.Word.W8# ipv1_abjn
                                          }
                                          },
                                          Data.ByteString.Internal.Type.$WBS
                                            (GHC.ForeignPtr.ForeignPtr
                                               @GHC.Word.Word8
                                               (GHC.Prim.plusAddr# bx_abjf 1#)
                                               bx1_abjg)
                                            (GHC.Types.I# (GHC.Prim.-# bx2_abjh 1#)));
                                     GHC.Types.True ->
                                       Data.Either.Left
                                         @Data.ByteString.Internal.Type.ByteString
                                         @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                         wild_abje
                                   }
                                   })
                                (let {
                                   f2_abjr
                                     :: Data.ByteString.Internal.Type.ByteString
                                        -> f_abj9 Data.ByteString.Internal.Type.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abjr
                                     = GHC.Base.pure
                                         @f_abj9
                                         $dApplicative_abjb
                                         @Data.ByteString.Internal.Type.ByteString } in
                                 let {
                                   ds2_abjs
                                     :: f_abj9
                                          (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                        -> f_abj9 Data.ByteString.Internal.Type.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 259 0}]
                                   ds2_abjs
                                     = GHC.Base.fmap
                                         @f_abj9
                                         (GHC.Base.$p1Applicative @f_abj9 $dApplicative_abjb)
                                         @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                         @Data.ByteString.Internal.Type.ByteString
                                         (\ (p1_abjt
                                               :: (GHC.Word.Word8,
                                                   Data.ByteString.Internal.Type.ByteString)) ->
                                            case p1_abjt of { (ds_abjv, y_abjw) ->
                                            case y_abjw of
                                            { Data.ByteString.Internal.Type.BS bx_abjI bx1_abjJ
                                                                               bx2_abjK ->
                                            GHC.Magic.runRW#
                                              @GHC.Types.LiftedRep
                                              @Data.ByteString.Internal.Type.ByteString
                                              (\ (s_abjG [OS=OneShot]
                                                    :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                                                 let {
                                                   x_abjH :: GHC.Prim.Int#
                                                   [LclId,
                                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                            Value=False, ConLike=False,
                                                            WorkFree=False, Expandable=False,
                                                            Guidance=IF_ARGS [] 1 0}]
                                                   x_abjH = GHC.Prim.+# bx2_abjK 1# } in
                                                 case GHC.Prim.<# x_abjH 0# of {
                                                   __DEFAULT ->
                                                     case GHC.Prim.newPinnedByteArray#
                                                            @GHC.Prim.RealWorld x_abjH s_abjG
                                                     of
                                                     { (# ipv_abjP, ipv1_abjQ #) ->
                                                     let {
                                                       ipv2_abjO :: GHC.Prim.Addr#
                                                       [LclId,
                                                        Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                                Value=False, ConLike=False,
                                                                WorkFree=False, Expandable=False,
                                                                Guidance=IF_ARGS [] 1 0}]
                                                       ipv2_abjO
                                                         = GHC.Prim.mutableByteArrayContents#
                                                             @GHC.Prim.RealWorld ipv1_abjQ } in
                                                     let {
                                                       ipv3_abjS
                                                         :: GHC.ForeignPtr.ForeignPtrContents
                                                       [LclId,
                                                        Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                                Value=True, ConLike=True,
                                                                WorkFree=True, Expandable=True,
                                                                Guidance=IF_ARGS [] 10 10}]
                                                       ipv3_abjS
                                                         = GHC.ForeignPtr.PlainPtr ipv1_abjQ } in
                                                     case ds_abjv of { GHC.Word.W8# x1_abla ->
                                                     case GHC.Prim.writeWord8OffAddr#
                                                            @GHC.Prim.RealWorld
                                                            ipv2_abjO
                                                            0#
                                                            x1_abla
                                                            ipv_abjP
                                                     of s2_ablc
                                                     { __DEFAULT ->
                                                     case GHC.Prim.touch#
                                                            @'GHC.Types.Lifted
                                                            @GHC.ForeignPtr.ForeignPtrContents
                                                            ipv3_abjS
                                                            s2_ablc
                                                     of s'_abld
                                                     { __DEFAULT ->
                                                     case {__ffi_static_ccall_unsafe base:memcpy :: Addr#
                                          -> Addr#
                                          -> Word64#
                                          -> State# RealWorld
                                          -> (# State# RealWorld, Addr# #)}_able
                                                            (GHC.Prim.plusAddr# ipv2_abjO 1#)
                                                            bx_abjI
                                                            (GHC.Prim.int64ToWord64#
                                                               (GHC.Prim.intToInt64# bx2_abjK))
                                                            s'_abld
                                                     of
                                                     { (# ds4_ablg, ds5_ablh #) ->
                                                     case GHC.Prim.touch#
                                                            @'GHC.Types.Lifted
                                                            @GHC.ForeignPtr.ForeignPtrContents
                                                            bx1_abjJ
                                                            ds4_ablg
                                                     of s'1_ablj
                                                     { __DEFAULT ->
                                                     case GHC.Prim.touch#
                                                            @'GHC.Types.Lifted
                                                            @GHC.ForeignPtr.ForeignPtrContents
                                                            ipv3_abjS
                                                            s'1_ablj
                                                     of s'2_ablk
                                                     { __DEFAULT ->
                                                     case GHC.Magic.lazy
                                                            @((GHC.Prim.State# GHC.Prim.RealWorld
                                                               -> (# GHC.Prim.State#
                                                                       GHC.Prim.RealWorld,
                                                                     GHC.Prim.Addr# #))
                                                              -> (# GHC.Prim.State#
                                                                      GHC.Prim.RealWorld,
                                                                    GHC.Prim.Addr# #))
                                                            (GHC.Magic.runRW#
                                                               @('GHC.Types.TupleRep
                                                                   '[GHC.Types.ZeroBitRep,
                                                                     'GHC.Types.AddrRep])
                                                               @(# GHC.Prim.State#
                                                                     GHC.Prim.RealWorld,
                                                                   GHC.Prim.Addr# #))
                                                            (\ _ [Occ=Dead] ->
                                                               (# s'2_ablk, ipv2_abjO #))
                                                     of
                                                     { (# ipv6_abln, ipv7_ablo #) ->
                                                     Data.ByteString.Internal.Type.BS
                                                       ipv7_ablo ipv3_abjS x_abjH
                                                     }
                                                     }
                                                     }
                                                     }
                                                     }
                                                     }
                                                     }
                                                     };
                                                   1# ->
                                                     case GHC.ForeignPtr.mallocPlainForeignPtrBytes2
                                                     of wild_00 {
                                                     }
                                                 })
                                            }
                                            }) } in
                                 \ (ds3_ablr
                                      :: Data.Either.Either
                                           Data.ByteString.Internal.Type.ByteString
                                           (f_abj9
                                              (GHC.Word.Word8,
                                               Data.ByteString.Internal.Type.ByteString))) ->
                                   case ds3_ablr of {
                                     Data.Either.Left x_ablt -> f2_abjr x_ablt;
                                     Data.Either.Right y_ablv -> ds2_abjs y_ablv
                                   }) } in
                        let {
                          g_ablx
                            :: p_abj8
                                 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                 (f_abj9 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                               -> p_abj8
                                    (Data.Either.Either
                                       Data.ByteString.Internal.Type.ByteString
                                       (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                                    (Data.Either.Either
                                       Data.ByteString.Internal.Type.ByteString
                                       (f_abj9
                                          (GHC.Word.Word8,
                                           Data.ByteString.Internal.Type.ByteString)))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_ablx
                            = Data.Profunctor.Choice.right'
                                @p_abj8
                                $dChoice_abja
                                @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                @(f_abj9
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                                @Data.ByteString.Internal.Type.ByteString } in
                        \ (x_ably
                             :: p_abj8
                                  (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                  (f_abj9
                                     (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))) ->
                          f1_abjc (g_ablx x_ably))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <Data.ByteString.Internal.Type.ByteString>_N
                                      <Data.ByteString.Internal.Type.ByteString>_N
                                      <GHC.Word.Word8>_N
                                      <GHC.Word.Word8>_N)
                             :: Control.Lens.Type.Prism
                                  Data.ByteString.Internal.Type.ByteString
                                  Data.ByteString.Internal.Type.ByteString
                                  (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                  (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                ~R# Control.Lens.Cons.Cons
                                      Data.ByteString.Internal.Type.ByteString
                                      Data.ByteString.Internal.Type.ByteString
                                      GHC.Word.Word8
                                      GHC.Word.Word8)
              ValArg (\ (@(p_abm8 :: * -> * -> *))
                        (@(f_abm9 :: * -> *))
                        ($dChoice_abma :: Data.Profunctor.Choice.Choice p_abm8)
                        ($dApplicative_abmb :: GHC.Base.Applicative f_abm9) ->
                        let {
                          f1_abmc
                            :: p_abm8
                                 (Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                                 (Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (f_abm9
                                       (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                               -> p_abm8
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (f_abm9 Data.ByteString.Lazy.Internal.ByteString)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 536 0}]
                          f1_abmc
                            = Data.Profunctor.Unsafe.dimap
                                @p_abm8
                                (Data.Profunctor.Choice.$p1Choice @p_abm8 $dChoice_abma)
                                @Data.ByteString.Lazy.Internal.ByteString
                                @(Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                                @(Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (f_abm9
                                       (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                                @(f_abm9 Data.ByteString.Lazy.Internal.ByteString)
                                (\ (s1_abmd :: Data.ByteString.Lazy.Internal.ByteString) ->
                                   case s1_abmd of {
                                     Data.ByteString.Lazy.Internal.Empty ->
                                       Data.Either.Left
                                         @Data.ByteString.Lazy.Internal.ByteString
                                         @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                         Data.ByteString.Lazy.Internal.Empty;
                                     Data.ByteString.Lazy.Internal.Chunk bx_abmk bx1_abml bx2_abmm
                                                                         cs_abmn ->
                                       case bx2_abmm of ds1_abmp {
                                         __DEFAULT ->
                                           Data.Either.Right
                                             @Data.ByteString.Lazy.Internal.ByteString
                                             @(GHC.Word.Word8,
                                               Data.ByteString.Lazy.Internal.ByteString)
                                             (case GHC.Prim.readWord8OffAddr#
                                                     @GHC.Prim.RealWorld
                                                     bx_abmk
                                                     0#
                                                     GHC.Prim.realWorld#
                                              of
                                              { (# ipv_abmr, ipv1_abms #) ->
                                              case GHC.Prim.touch#
                                                     @'GHC.Types.Lifted
                                                     @GHC.ForeignPtr.ForeignPtrContents
                                                     bx1_abml
                                                     ipv_abmr
                                              of
                                              { __DEFAULT ->
                                              GHC.Word.W8# ipv1_abms
                                              }
                                              },
                                              Data.ByteString.Lazy.Internal.$WChunk
                                                (Data.ByteString.Internal.Type.$WBS
                                                   (GHC.ForeignPtr.ForeignPtr
                                                      @GHC.Word.Word8
                                                      (GHC.Prim.plusAddr# bx_abmk 1#)
                                                      bx1_abml)
                                                   (GHC.Types.I# (GHC.Prim.-# ds1_abmp 1#)))
                                                cs_abmn);
                                         1# ->
                                           Data.Either.Right
                                             @Data.ByteString.Lazy.Internal.ByteString
                                             @(GHC.Word.Word8,
                                               Data.ByteString.Lazy.Internal.ByteString)
                                             (case GHC.Prim.readWord8OffAddr#
                                                     @GHC.Prim.RealWorld
                                                     bx_abmk
                                                     0#
                                                     GHC.Prim.realWorld#
                                              of
                                              { (# ipv_abmw, ipv1_abmx #) ->
                                              case GHC.Prim.touch#
                                                     @'GHC.Types.Lifted
                                                     @GHC.ForeignPtr.ForeignPtrContents
                                                     bx1_abml
                                                     ipv_abmw
                                              of
                                              { __DEFAULT ->
                                              GHC.Word.W8# ipv1_abmx
                                              }
                                              },
                                              cs_abmn)
                                       }
                                   })
                                (let {
                                   f2_abmA
                                     :: Data.ByteString.Lazy.Internal.ByteString
                                        -> f_abm9 Data.ByteString.Lazy.Internal.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abmA
                                     = GHC.Base.pure
                                         @f_abm9
                                         $dApplicative_abmb
                                         @Data.ByteString.Lazy.Internal.ByteString } in
                                 let {
                                   ds2_abmB
                                     :: f_abm9
                                          (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                        -> f_abm9 Data.ByteString.Lazy.Internal.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 162 0}]
                                   ds2_abmB
                                     = GHC.Base.fmap
                                         @f_abm9
                                         (GHC.Base.$p1Applicative @f_abm9 $dApplicative_abmb)
                                         @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                         @Data.ByteString.Lazy.Internal.ByteString
                                         (\ (p1_abmC
                                               :: (GHC.Word.Word8,
                                                   Data.ByteString.Lazy.Internal.ByteString)) ->
                                            case p1_abmC of { (x_abmE, ds_abmF) ->
                                            case x_abmE of { GHC.Word.W8# x#_abmI ->
                                            Data.ByteString.Lazy.Internal.$WChunk
                                              (Data.ByteString.Internal.Type.$WBS
                                                 (GHC.ForeignPtr.ForeignPtr
                                                    @GHC.Word.Word8
                                                    (GHC.Prim.plusAddr#
                                                       Data.ByteString.singleton1
                                                       (GHC.Prim.word2Int#
                                                          (GHC.Prim.word8ToWord# x#_abmI)))
                                                    GHC.ForeignPtr.FinalPtr)
                                                 (GHC.Types.I# 1#))
                                              ds_abmF
                                            }
                                            }) } in
                                 \ (ds3_abmK
                                      :: Data.Either.Either
                                           Data.ByteString.Lazy.Internal.ByteString
                                           (f_abm9
                                              (GHC.Word.Word8,
                                               Data.ByteString.Lazy.Internal.ByteString))) ->
                                   case ds3_abmK of {
                                     Data.Either.Left x_abmM -> f2_abmA x_abmM;
                                     Data.Either.Right y_abmO -> ds2_abmB y_abmO
                                   }) } in
                        let {
                          g_abmQ
                            :: p_abm8
                                 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                 (f_abm9 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                               -> p_abm8
                                    (Data.Either.Either
                                       Data.ByteString.Lazy.Internal.ByteString
                                       (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                                    (Data.Either.Either
                                       Data.ByteString.Lazy.Internal.ByteString
                                       (f_abm9
                                          (GHC.Word.Word8,
                                           Data.ByteString.Lazy.Internal.ByteString)))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abmQ
                            = Data.Profunctor.Choice.right'
                                @p_abm8
                                $dChoice_abma
                                @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                @(f_abm9
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                                @Data.ByteString.Lazy.Internal.ByteString } in
                        \ (x_abmR
                             :: p_abm8
                                  (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                  (f_abm9
                                     (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))) ->
                          f1_abmc (g_abmQ x_abmR))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <Data.ByteString.Lazy.Internal.ByteString>_N
                                      <Data.ByteString.Lazy.Internal.ByteString>_N
                                      <GHC.Word.Word8>_N
                                      <GHC.Word.Word8>_N)
                             :: Control.Lens.Type.Prism
                                  Data.ByteString.Lazy.Internal.ByteString
                                  Data.ByteString.Lazy.Internal.ByteString
                                  (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                  (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                ~R# Control.Lens.Cons.Cons
                                      Data.ByteString.Lazy.Internal.ByteString
                                      Data.ByteString.Lazy.Internal.ByteString
                                      GHC.Word.Word8
                                      GHC.Word.Word8)
              ValArg (\ (@(p_abmT :: * -> * -> *))
                        (@(f_abmU :: * -> *))
                        ($dChoice_abmV :: Data.Profunctor.Choice.Choice p_abmT)
                        ($dApplicative_abmW :: GHC.Base.Applicative f_abmU) ->
                        let {
                          f1_abmX
                            :: p_abmT
                                 (Data.Either.Either Data.ByteString.Lazy.Internal.ByteString ())
                                 (Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString (f_abmU ()))
                               -> p_abmT
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (f_abmU Data.ByteString.Lazy.Internal.ByteString)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 290 0}]
                          f1_abmX
                            = Data.Profunctor.Unsafe.dimap
                                @p_abmT
                                (Data.Profunctor.Choice.$p1Choice @p_abmT $dChoice_abmV)
                                @Data.ByteString.Lazy.Internal.ByteString
                                @(Data.Either.Either Data.ByteString.Lazy.Internal.ByteString ())
                                @(Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString (f_abmU ()))
                                @(f_abmU Data.ByteString.Lazy.Internal.ByteString)
                                (\ (s_abmY :: Data.ByteString.Lazy.Internal.ByteString) ->
                                   case s_abmY of wild_abmZ {
                                     Data.ByteString.Lazy.Internal.Empty ->
                                       Data.Either.Right
                                         @Data.ByteString.Lazy.Internal.ByteString
                                         @()
                                         GHC.Tuple.Prim.();
                                     Data.ByteString.Lazy.Internal.Chunk ipv_abn0 ipv1_abn1
                                                                         ipv2_abn2 ipv3_abn3 ->
                                       Data.Either.Left
                                         @Data.ByteString.Lazy.Internal.ByteString @() wild_abmZ
                                   })
                                (let {
                                   f2_abn5
                                     :: Data.ByteString.Lazy.Internal.ByteString
                                        -> f_abmU Data.ByteString.Lazy.Internal.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abn5
                                     = GHC.Base.pure
                                         @f_abmU
                                         $dApplicative_abmW
                                         @Data.ByteString.Lazy.Internal.ByteString } in
                                 let {
                                   ds2_abn6
                                     :: f_abmU () -> f_abmU Data.ByteString.Lazy.Internal.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 70 0}]
                                   ds2_abn6
                                     = GHC.Base.fmap
                                         @f_abmU
                                         (GHC.Base.$p1Applicative @f_abmU $dApplicative_abmW)
                                         @()
                                         @Data.ByteString.Lazy.Internal.ByteString
                                         (\ (ds3_abn7 :: ()) ->
                                            case ds3_abn7 of { () ->
                                            Data.ByteString.Lazy.Internal.Empty
                                            }) } in
                                 \ (ds3_abn9
                                      :: Data.Either.Either
                                           Data.ByteString.Lazy.Internal.ByteString (f_abmU ())) ->
                                   case ds3_abn9 of {
                                     Data.Either.Left x_abnb -> f2_abn5 x_abnb;
                                     Data.Either.Right y_abnd -> ds2_abn6 y_abnd
                                   }) } in
                        let {
                          g_abnf
                            :: p_abmT () (f_abmU ())
                               -> p_abmT
                                    (Data.Either.Either Data.ByteString.Lazy.Internal.ByteString ())
                                    (Data.Either.Either
                                       Data.ByteString.Lazy.Internal.ByteString (f_abmU ()))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abnf
                            = Data.Profunctor.Choice.right'
                                @p_abmT
                                $dChoice_abmV
                                @()
                                @(f_abmU ())
                                @Data.ByteString.Lazy.Internal.ByteString } in
                        \ (x_abng :: p_abmT () (f_abmU ())) -> f1_abmX (g_abnf x_abng))
                     `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                      <Data.ByteString.Lazy.Internal.ByteString>_N)
                             :: Control.Lens.Type.Prism'
                                  Data.ByteString.Lazy.Internal.ByteString ()
                                ~R# Control.Lens.Empty.AsEmpty
                                      Data.ByteString.Lazy.Internal.ByteString)
              TyArg Data.Functor.Const.Const
                      Data.ByteString.Lazy.Internal.ByteString
              ValArg Data.Functor.Contravariant.$fContravariantConst
                       @Data.ByteString.Lazy.Internal.ByteString
              ValArg Data.Functor.Const.$fFunctorConst
                       @Data.ByteString.Lazy.Internal.ByteString
    After:  (\ (@(f_abeH :: * -> *))
               ($dCons_abeI
                  :: Control.Lens.Cons.Cons
                       Data.ByteString.Internal.Type.ByteString
                       Data.ByteString.Internal.Type.ByteString
                       GHC.Word.Word8
                       GHC.Word.Word8)
               ($dCons1_abeJ
                  :: Control.Lens.Cons.Cons
                       Data.ByteString.Lazy.Internal.ByteString
                       Data.ByteString.Lazy.Internal.ByteString
                       GHC.Word.Word8
                       GHC.Word.Word8)
               ($dAsEmpty_abeK
                  :: Control.Lens.Empty.AsEmpty
                       Data.ByteString.Lazy.Internal.ByteString)
               ($dContravariant_abeL
                  :: Data.Functor.Contravariant.Contravariant f_abeH)
               ($dFunctor_abeM :: GHC.Base.Functor f_abeH) ->
               Data.Profunctor.Unsafe.$fProfunctorFUN_$cdimap
                 @Data.ByteString.Internal.Type.ByteString
                 @Data.ByteString.Lazy.Internal.ByteString
                 @(f_abeH Data.ByteString.Lazy.Internal.ByteString)
                 @(f_abeH Data.ByteString.Internal.Type.ByteString)
                 Data.ByteString.Lazy.Internal.fromStrict
                 (GHC.Base.fmap
                    @f_abeH
                    $dFunctor_abeM
                    @Data.ByteString.Lazy.Internal.ByteString
                    @Data.ByteString.Internal.Type.ByteString
                    Data.ByteString.Lazy.Internal.toStrict))
              @(Data.Functor.Const.Const
                  Data.ByteString.Lazy.Internal.ByteString)
              ((\ (@(p_abj8 :: * -> * -> *))
                  (@(f_abj9 :: * -> *))
                  ($dChoice_abja :: Data.Profunctor.Choice.Choice p_abj8)
                  ($dApplicative_abjb :: GHC.Base.Applicative f_abj9) ->
                  let {
                    f1_abjc
                      :: p_abj8
                           (Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString
                              (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                           (Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString
                              (f_abj9
                                 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                         -> p_abj8
                              Data.ByteString.Internal.Type.ByteString
                              (f_abj9 Data.ByteString.Internal.Type.ByteString)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 612 0}]
                    f1_abjc
                      = Data.Profunctor.Unsafe.dimap
                          @p_abj8
                          (Data.Profunctor.Choice.$p1Choice @p_abj8 $dChoice_abja)
                          @Data.ByteString.Internal.Type.ByteString
                          @(Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString
                              (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                          @(Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString
                              (f_abj9
                                 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                          @(f_abj9 Data.ByteString.Internal.Type.ByteString)
                          (\ (s1_abjd :: Data.ByteString.Internal.Type.ByteString) ->
                             case s1_abjd of wild_abje
                             { Data.ByteString.Internal.Type.BS bx_abjf bx1_abjg bx2_abjh ->
                             case GHC.Classes.leInt (GHC.Types.I# bx2_abjh) (GHC.Types.I# 0#)
                             of {
                               GHC.Types.False ->
                                 Data.Either.Right
                                   @Data.ByteString.Internal.Type.ByteString
                                   @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                   (case GHC.Prim.readWord8OffAddr#
                                           @GHC.Prim.RealWorld bx_abjf 0# GHC.Prim.realWorld#
                                    of
                                    { (# ipv_abjm, ipv1_abjn #) ->
                                    case GHC.Prim.touch#
                                           @'GHC.Types.Lifted
                                           @GHC.ForeignPtr.ForeignPtrContents
                                           bx1_abjg
                                           ipv_abjm
                                    of
                                    { __DEFAULT ->
                                    GHC.Word.W8# ipv1_abjn
                                    }
                                    },
                                    Data.ByteString.Internal.Type.$WBS
                                      (GHC.ForeignPtr.ForeignPtr
                                         @GHC.Word.Word8 (GHC.Prim.plusAddr# bx_abjf 1#) bx1_abjg)
                                      (GHC.Types.I# (GHC.Prim.-# bx2_abjh 1#)));
                               GHC.Types.True ->
                                 Data.Either.Left
                                   @Data.ByteString.Internal.Type.ByteString
                                   @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                   wild_abje
                             }
                             })
                          (let {
                             f2_abjr
                               :: Data.ByteString.Internal.Type.ByteString
                                  -> f_abj9 Data.ByteString.Internal.Type.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abjr
                               = GHC.Base.pure
                                   @f_abj9
                                   $dApplicative_abjb
                                   @Data.ByteString.Internal.Type.ByteString } in
                           let {
                             ds2_abjs
                               :: f_abj9
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                  -> f_abj9 Data.ByteString.Internal.Type.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 259 0}]
                             ds2_abjs
                               = GHC.Base.fmap
                                   @f_abj9
                                   (GHC.Base.$p1Applicative @f_abj9 $dApplicative_abjb)
                                   @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                   @Data.ByteString.Internal.Type.ByteString
                                   (\ (p1_abjt
                                         :: (GHC.Word.Word8,
                                             Data.ByteString.Internal.Type.ByteString)) ->
                                      case p1_abjt of { (ds_abjv, y_abjw) ->
                                      case y_abjw of
                                      { Data.ByteString.Internal.Type.BS bx_abjI bx1_abjJ
                                                                         bx2_abjK ->
                                      GHC.Magic.runRW#
                                        @GHC.Types.LiftedRep
                                        @Data.ByteString.Internal.Type.ByteString
                                        (\ (s_abjG [OS=OneShot]
                                              :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                                           let {
                                             x_abjH :: GHC.Prim.Int#
                                             [LclId,
                                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                      Value=False, ConLike=False, WorkFree=False,
                                                      Expandable=False,
                                                      Guidance=IF_ARGS [] 1 0}]
                                             x_abjH = GHC.Prim.+# bx2_abjK 1# } in
                                           case GHC.Prim.<# x_abjH 0# of {
                                             __DEFAULT ->
                                               case GHC.Prim.newPinnedByteArray#
                                                      @GHC.Prim.RealWorld x_abjH s_abjG
                                               of
                                               { (# ipv_abjP, ipv1_abjQ #) ->
                                               let {
                                                 ipv2_abjO :: GHC.Prim.Addr#
                                                 [LclId,
                                                  Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                          Value=False, ConLike=False,
                                                          WorkFree=False, Expandable=False,
                                                          Guidance=IF_ARGS [] 1 0}]
                                                 ipv2_abjO
                                                   = GHC.Prim.mutableByteArrayContents#
                                                       @GHC.Prim.RealWorld ipv1_abjQ } in
                                               let {
                                                 ipv3_abjS :: GHC.ForeignPtr.ForeignPtrContents
                                                 [LclId,
                                                  Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                          Value=True, ConLike=True, WorkFree=True,
                                                          Expandable=True,
                                                          Guidance=IF_ARGS [] 10 10}]
                                                 ipv3_abjS = GHC.ForeignPtr.PlainPtr ipv1_abjQ } in
                                               case ds_abjv of { GHC.Word.W8# x1_abla ->
                                               case GHC.Prim.writeWord8OffAddr#
                                                      @GHC.Prim.RealWorld
                                                      ipv2_abjO
                                                      0#
                                                      x1_abla
                                                      ipv_abjP
                                               of s2_ablc
                                               { __DEFAULT ->
                                               case GHC.Prim.touch#
                                                      @'GHC.Types.Lifted
                                                      @GHC.ForeignPtr.ForeignPtrContents
                                                      ipv3_abjS
                                                      s2_ablc
                                               of s'_abld
                                               { __DEFAULT ->
                                               case {__ffi_static_ccall_unsafe base:memcpy :: Addr#
                                          -> Addr#
                                          -> Word64#
                                          -> State# RealWorld
                                          -> (# State# RealWorld, Addr# #)}_able
                                                      (GHC.Prim.plusAddr# ipv2_abjO 1#)
                                                      bx_abjI
                                                      (GHC.Prim.int64ToWord64#
                                                         (GHC.Prim.intToInt64# bx2_abjK))
                                                      s'_abld
                                               of
                                               { (# ds4_ablg, ds5_ablh #) ->
                                               case GHC.Prim.touch#
                                                      @'GHC.Types.Lifted
                                                      @GHC.ForeignPtr.ForeignPtrContents
                                                      bx1_abjJ
                                                      ds4_ablg
                                               of s'1_ablj
                                               { __DEFAULT ->
                                               case GHC.Prim.touch#
                                                      @'GHC.Types.Lifted
                                                      @GHC.ForeignPtr.ForeignPtrContents
                                                      ipv3_abjS
                                                      s'1_ablj
                                               of s'2_ablk
                                               { __DEFAULT ->
                                               case GHC.Magic.lazy
                                                      @((GHC.Prim.State# GHC.Prim.RealWorld
                                                         -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                               GHC.Prim.Addr# #))
                                                        -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                              GHC.Prim.Addr# #))
                                                      (GHC.Magic.runRW#
                                                         @('GHC.Types.TupleRep
                                                             '[GHC.Types.ZeroBitRep,
                                                               'GHC.Types.AddrRep])
                                                         @(# GHC.Prim.State# GHC.Prim.RealWorld,
                                                             GHC.Prim.Addr# #))
                                                      (\ _ [Occ=Dead] -> (# s'2_ablk, ipv2_abjO #))
                                               of
                                               { (# ipv6_abln, ipv7_ablo #) ->
                                               Data.ByteString.Internal.Type.BS
                                                 ipv7_ablo ipv3_abjS x_abjH
                                               }
                                               }
                                               }
                                               }
                                               }
                                               }
                                               }
                                               };
                                             1# ->
                                               case GHC.ForeignPtr.mallocPlainForeignPtrBytes2
                                               of wild_00 {
                                               }
                                           })
                                      }
                                      }) } in
                           \ (ds3_ablr
                                :: Data.Either.Either
                                     Data.ByteString.Internal.Type.ByteString
                                     (f_abj9
                                        (GHC.Word.Word8,
                                         Data.ByteString.Internal.Type.ByteString))) ->
                             case ds3_ablr of {
                               Data.Either.Left x_ablt -> f2_abjr x_ablt;
                               Data.Either.Right y_ablv -> ds2_abjs y_ablv
                             }) } in
                  let {
                    g_ablx
                      :: p_abj8
                           (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                           (f_abj9 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                         -> p_abj8
                              (Data.Either.Either
                                 Data.ByteString.Internal.Type.ByteString
                                 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                              (Data.Either.Either
                                 Data.ByteString.Internal.Type.ByteString
                                 (f_abj9
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_ablx
                      = Data.Profunctor.Choice.right'
                          @p_abj8
                          $dChoice_abja
                          @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                          @(f_abj9
                              (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                          @Data.ByteString.Internal.Type.ByteString } in
                  \ (x_ably
                       :: p_abj8
                            (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                            (f_abj9
                               (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))) ->
                    f1_abjc (g_ablx x_ably))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <Data.ByteString.Internal.Type.ByteString>_N
                                <Data.ByteString.Internal.Type.ByteString>_N
                                <GHC.Word.Word8>_N
                                <GHC.Word.Word8>_N)
                       :: Control.Lens.Type.Prism
                            Data.ByteString.Internal.Type.ByteString
                            Data.ByteString.Internal.Type.ByteString
                            (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                            (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                          ~R# Control.Lens.Cons.Cons
                                Data.ByteString.Internal.Type.ByteString
                                Data.ByteString.Internal.Type.ByteString
                                GHC.Word.Word8
                                GHC.Word.Word8))
              ((\ (@(p_abm8 :: * -> * -> *))
                  (@(f_abm9 :: * -> *))
                  ($dChoice_abma :: Data.Profunctor.Choice.Choice p_abm8)
                  ($dApplicative_abmb :: GHC.Base.Applicative f_abm9) ->
                  let {
                    f1_abmc
                      :: p_abm8
                           (Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString
                              (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                           (Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString
                              (f_abm9
                                 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                         -> p_abm8
                              Data.ByteString.Lazy.Internal.ByteString
                              (f_abm9 Data.ByteString.Lazy.Internal.ByteString)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 536 0}]
                    f1_abmc
                      = Data.Profunctor.Unsafe.dimap
                          @p_abm8
                          (Data.Profunctor.Choice.$p1Choice @p_abm8 $dChoice_abma)
                          @Data.ByteString.Lazy.Internal.ByteString
                          @(Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString
                              (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                          @(Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString
                              (f_abm9
                                 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                          @(f_abm9 Data.ByteString.Lazy.Internal.ByteString)
                          (\ (s1_abmd :: Data.ByteString.Lazy.Internal.ByteString) ->
                             case s1_abmd of {
                               Data.ByteString.Lazy.Internal.Empty ->
                                 Data.Either.Left
                                   @Data.ByteString.Lazy.Internal.ByteString
                                   @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                   Data.ByteString.Lazy.Internal.Empty;
                               Data.ByteString.Lazy.Internal.Chunk bx_abmk bx1_abml bx2_abmm
                                                                   cs_abmn ->
                                 case bx2_abmm of ds1_abmp {
                                   __DEFAULT ->
                                     Data.Either.Right
                                       @Data.ByteString.Lazy.Internal.ByteString
                                       @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                       (case GHC.Prim.readWord8OffAddr#
                                               @GHC.Prim.RealWorld bx_abmk 0# GHC.Prim.realWorld#
                                        of
                                        { (# ipv_abmr, ipv1_abms #) ->
                                        case GHC.Prim.touch#
                                               @'GHC.Types.Lifted
                                               @GHC.ForeignPtr.ForeignPtrContents
                                               bx1_abml
                                               ipv_abmr
                                        of
                                        { __DEFAULT ->
                                        GHC.Word.W8# ipv1_abms
                                        }
                                        },
                                        Data.ByteString.Lazy.Internal.$WChunk
                                          (Data.ByteString.Internal.Type.$WBS
                                             (GHC.ForeignPtr.ForeignPtr
                                                @GHC.Word.Word8
                                                (GHC.Prim.plusAddr# bx_abmk 1#)
                                                bx1_abml)
                                             (GHC.Types.I# (GHC.Prim.-# ds1_abmp 1#)))
                                          cs_abmn);
                                   1# ->
                                     Data.Either.Right
                                       @Data.ByteString.Lazy.Internal.ByteString
                                       @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                       (case GHC.Prim.readWord8OffAddr#
                                               @GHC.Prim.RealWorld bx_abmk 0# GHC.Prim.realWorld#
                                        of
                                        { (# ipv_abmw, ipv1_abmx #) ->
                                        case GHC.Prim.touch#
                                               @'GHC.Types.Lifted
                                               @GHC.ForeignPtr.ForeignPtrContents
                                               bx1_abml
                                               ipv_abmw
                                        of
                                        { __DEFAULT ->
                                        GHC.Word.W8# ipv1_abmx
                                        }
                                        },
                                        cs_abmn)
                                 }
                             })
                          (let {
                             f2_abmA
                               :: Data.ByteString.Lazy.Internal.ByteString
                                  -> f_abm9 Data.ByteString.Lazy.Internal.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abmA
                               = GHC.Base.pure
                                   @f_abm9
                                   $dApplicative_abmb
                                   @Data.ByteString.Lazy.Internal.ByteString } in
                           let {
                             ds2_abmB
                               :: f_abm9
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                  -> f_abm9 Data.ByteString.Lazy.Internal.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 162 0}]
                             ds2_abmB
                               = GHC.Base.fmap
                                   @f_abm9
                                   (GHC.Base.$p1Applicative @f_abm9 $dApplicative_abmb)
                                   @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                   @Data.ByteString.Lazy.Internal.ByteString
                                   (\ (p1_abmC
                                         :: (GHC.Word.Word8,
                                             Data.ByteString.Lazy.Internal.ByteString)) ->
                                      case p1_abmC of { (x_abmE, ds_abmF) ->
                                      case x_abmE of { GHC.Word.W8# x#_abmI ->
                                      Data.ByteString.Lazy.Internal.$WChunk
                                        (Data.ByteString.Internal.Type.$WBS
                                           (GHC.ForeignPtr.ForeignPtr
                                              @GHC.Word.Word8
                                              (GHC.Prim.plusAddr#
                                                 Data.ByteString.singleton1
                                                 (GHC.Prim.word2Int#
                                                    (GHC.Prim.word8ToWord# x#_abmI)))
                                              GHC.ForeignPtr.FinalPtr)
                                           (GHC.Types.I# 1#))
                                        ds_abmF
                                      }
                                      }) } in
                           \ (ds3_abmK
                                :: Data.Either.Either
                                     Data.ByteString.Lazy.Internal.ByteString
                                     (f_abm9
                                        (GHC.Word.Word8,
                                         Data.ByteString.Lazy.Internal.ByteString))) ->
                             case ds3_abmK of {
                               Data.Either.Left x_abmM -> f2_abmA x_abmM;
                               Data.Either.Right y_abmO -> ds2_abmB y_abmO
                             }) } in
                  let {
                    g_abmQ
                      :: p_abm8
                           (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                           (f_abm9 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                         -> p_abm8
                              (Data.Either.Either
                                 Data.ByteString.Lazy.Internal.ByteString
                                 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                              (Data.Either.Either
                                 Data.ByteString.Lazy.Internal.ByteString
                                 (f_abm9
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abmQ
                      = Data.Profunctor.Choice.right'
                          @p_abm8
                          $dChoice_abma
                          @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                          @(f_abm9
                              (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                          @Data.ByteString.Lazy.Internal.ByteString } in
                  \ (x_abmR
                       :: p_abm8
                            (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                            (f_abm9
                               (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))) ->
                    f1_abmc (g_abmQ x_abmR))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <Data.ByteString.Lazy.Internal.ByteString>_N
                                <Data.ByteString.Lazy.Internal.ByteString>_N
                                <GHC.Word.Word8>_N
                                <GHC.Word.Word8>_N)
                       :: Control.Lens.Type.Prism
                            Data.ByteString.Lazy.Internal.ByteString
                            Data.ByteString.Lazy.Internal.ByteString
                            (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                            (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                          ~R# Control.Lens.Cons.Cons
                                Data.ByteString.Lazy.Internal.ByteString
                                Data.ByteString.Lazy.Internal.ByteString
                                GHC.Word.Word8
                                GHC.Word.Word8))
              ((\ (@(p_abmT :: * -> * -> *))
                  (@(f_abmU :: * -> *))
                  ($dChoice_abmV :: Data.Profunctor.Choice.Choice p_abmT)
                  ($dApplicative_abmW :: GHC.Base.Applicative f_abmU) ->
                  let {
                    f1_abmX
                      :: p_abmT
                           (Data.Either.Either Data.ByteString.Lazy.Internal.ByteString ())
                           (Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString (f_abmU ()))
                         -> p_abmT
                              Data.ByteString.Lazy.Internal.ByteString
                              (f_abmU Data.ByteString.Lazy.Internal.ByteString)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 290 0}]
                    f1_abmX
                      = Data.Profunctor.Unsafe.dimap
                          @p_abmT
                          (Data.Profunctor.Choice.$p1Choice @p_abmT $dChoice_abmV)
                          @Data.ByteString.Lazy.Internal.ByteString
                          @(Data.Either.Either Data.ByteString.Lazy.Internal.ByteString ())
                          @(Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString (f_abmU ()))
                          @(f_abmU Data.ByteString.Lazy.Internal.ByteString)
                          (\ (s_abmY :: Data.ByteString.Lazy.Internal.ByteString) ->
                             case s_abmY of wild_abmZ {
                               Data.ByteString.Lazy.Internal.Empty ->
                                 Data.Either.Right
                                   @Data.ByteString.Lazy.Internal.ByteString @() GHC.Tuple.Prim.();
                               Data.ByteString.Lazy.Internal.Chunk ipv_abn0 ipv1_abn1 ipv2_abn2
                                                                   ipv3_abn3 ->
                                 Data.Either.Left
                                   @Data.ByteString.Lazy.Internal.ByteString @() wild_abmZ
                             })
                          (let {
                             f2_abn5
                               :: Data.ByteString.Lazy.Internal.ByteString
                                  -> f_abmU Data.ByteString.Lazy.Internal.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abn5
                               = GHC.Base.pure
                                   @f_abmU
                                   $dApplicative_abmW
                                   @Data.ByteString.Lazy.Internal.ByteString } in
                           let {
                             ds2_abn6
                               :: f_abmU () -> f_abmU Data.ByteString.Lazy.Internal.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 70 0}]
                             ds2_abn6
                               = GHC.Base.fmap
                                   @f_abmU
                                   (GHC.Base.$p1Applicative @f_abmU $dApplicative_abmW)
                                   @()
                                   @Data.ByteString.Lazy.Internal.ByteString
                                   (\ (ds3_abn7 :: ()) ->
                                      case ds3_abn7 of { () ->
                                      Data.ByteString.Lazy.Internal.Empty
                                      }) } in
                           \ (ds3_abn9
                                :: Data.Either.Either
                                     Data.ByteString.Lazy.Internal.ByteString (f_abmU ())) ->
                             case ds3_abn9 of {
                               Data.Either.Left x_abnb -> f2_abn5 x_abnb;
                               Data.Either.Right y_abnd -> ds2_abn6 y_abnd
                             }) } in
                  let {
                    g_abnf
                      :: p_abmT () (f_abmU ())
                         -> p_abmT
                              (Data.Either.Either Data.ByteString.Lazy.Internal.ByteString ())
                              (Data.Either.Either
                                 Data.ByteString.Lazy.Internal.ByteString (f_abmU ()))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abnf
                      = Data.Profunctor.Choice.right'
                          @p_abmT
                          $dChoice_abmV
                          @()
                          @(f_abmU ())
                          @Data.ByteString.Lazy.Internal.ByteString } in
                  \ (x_abng :: p_abmT () (f_abmU ())) -> f1_abmX (g_abnf x_abng))
               `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                <Data.ByteString.Lazy.Internal.ByteString>_N)
                       :: Control.Lens.Type.Prism'
                            Data.ByteString.Lazy.Internal.ByteString ()
                          ~R# Control.Lens.Empty.AsEmpty
                                Data.ByteString.Lazy.Internal.ByteString))
              (Data.Functor.Contravariant.$fContravariantConst
                 @Data.ByteString.Lazy.Internal.ByteString)
              (Data.Functor.Const.$fFunctorConst
                 @Data.ByteString.Lazy.Internal.ByteString)
    Cont:   ApplyToVal nodup hole Control.Lens.Getter.Getting
                                    Data.ByteString.Lazy.Internal.ByteString
                                    Data.ByteString.Internal.Type.ByteString
                                    Data.ByteString.Lazy.Internal.ByteString
              ((\ (ds_abdj [Occ=Once1] :: a_abdg) -> ds_abdj)
               `cast` (<a_abdg>_R
                       %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                          <*>_N <a_abdg>_R <a_abdg>_P)
                       :: (a_abdg -> a_abdg)
                          ~R# (a_abdg -> Data.Functor.Const.Const a_abdg a_abdg)))
            ApplyToVal nodup hole Data.ByteString.Internal.Type.ByteString
                                  -> Data.Functor.Const.Const
                                       Data.ByteString.Lazy.Internal.ByteString
                                       Data.ByteString.Internal.Type.ByteString
              s_a8Oh
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N
                        <Data.ByteString.Lazy.Internal.ByteString>_R
                        <Data.ByteString.Internal.Type.ByteString>_P
                    :: Data.Functor.Const.Const
                         Data.ByteString.Lazy.Internal.ByteString
                         Data.ByteString.Internal.Type.ByteString
                       ~R# Data.ByteString.Lazy.Internal.ByteString)
            Stop[RuleArgCtxt] Data.ByteString.Lazy.Internal.ByteString
Rule fired
    Rule: Class op fmap
    Module: (BUILTIN)
    Before: GHC.Base.fmap
              TyArg Data.Functor.Const.Const
                      Data.ByteString.Lazy.Internal.ByteString
              ValArg Data.Functor.Const.$fFunctorConst
                       @Data.ByteString.Lazy.Internal.ByteString
    After:  (Data.Functor.Const.$fFunctorConst2
               @Data.ByteString.Lazy.Internal.ByteString)
            `cast` (forall (a :: <*>_N) (b :: <*>_N).
                    <a -> b>_R
                    %<'GHC.Types.Many>_N ->_R <Data.Functor.Const.Const
                                                 Data.ByteString.Lazy.Internal.ByteString a>_R
                    %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                  <*>_N
                                                  <Data.ByteString.Lazy.Internal.ByteString>_R
                                                  <a>_P
                                              ; Sym (Data.Functor.Const.N:Const[0]
                                                         <*>_N
                                                         <Data.ByteString.Lazy.Internal.ByteString>_R
                                                         <b>_P)
                    :: (forall {a} {b}.
                        (a -> b)
                        -> Data.Functor.Const.Const
                             Data.ByteString.Lazy.Internal.ByteString a
                        -> Data.Functor.Const.Const
                             Data.ByteString.Lazy.Internal.ByteString a)
                       ~R# (forall {a} {b}.
                            (a -> b)
                            -> Data.Functor.Const.Const
                                 Data.ByteString.Lazy.Internal.ByteString a
                            -> Data.Functor.Const.Const
                                 Data.ByteString.Lazy.Internal.ByteString b))
    Cont:   ApplyToTy Data.ByteString.Lazy.Internal.ByteString
            ApplyToTy Data.ByteString.Internal.Type.ByteString
            ApplyToVal nodup hole (Data.ByteString.Lazy.Internal.ByteString
                                   -> Data.ByteString.Internal.Type.ByteString)
                                  -> Data.Functor.Const.Const
                                       Data.ByteString.Lazy.Internal.ByteString
                                       Data.ByteString.Lazy.Internal.ByteString
                                  -> Data.Functor.Const.Const
                                       Data.ByteString.Lazy.Internal.ByteString
                                       Data.ByteString.Internal.Type.ByteString
              Data.ByteString.Lazy.Internal.toStrict
            ApplyToVal nodup hole Data.Functor.Const.Const
                                    Data.ByteString.Lazy.Internal.ByteString
                                    Data.ByteString.Lazy.Internal.ByteString
                                  -> Data.Functor.Const.Const
                                       Data.ByteString.Lazy.Internal.ByteString
                                       Data.ByteString.Internal.Type.ByteString
              (bc_abny (ab_abnw x_abnz))
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N
                        <Data.ByteString.Lazy.Internal.ByteString>_R
                        <Data.ByteString.Internal.Type.ByteString>_P
                    :: Data.Functor.Const.Const
                         Data.ByteString.Lazy.Internal.ByteString
                         Data.ByteString.Internal.Type.ByteString
                       ~R# Data.ByteString.Lazy.Internal.ByteString)
            Stop[RuleArgCtxt] Data.ByteString.Lazy.Internal.ByteString
Rule fired
    Rule: Class op ==
    Module: (BUILTIN)
    Before: GHC.Classes.==
              TyArg Data.ByteString.Internal.Type.ByteString
              ValArg Data.ByteString.Internal.Type.$fEqByteString
              ValArg Data.ByteString.Lazy.Internal.toStrict
                       (case s_a8Oh of
                        { Data.ByteString.Internal.Type.BS bx_abqQ bx1_abqR bx2_abqS ->
                        case bx2_abqS of ds1_abqU {
                          __DEFAULT ->
                            Data.ByteString.Lazy.Internal.Chunk
                              bx_abqQ bx1_abqR ds1_abqU Data.ByteString.Lazy.Internal.Empty;
                          0# -> Data.ByteString.Lazy.Internal.Empty
                        }
                        })
              ValArg s_a8Oh
    After:  Data.ByteString.Internal.Type.eq
              ValArg Data.ByteString.Lazy.Internal.toStrict
                       (case s_a8Oh of
                        { Data.ByteString.Internal.Type.BS bx_abqQ bx1_abqR bx2_abqS ->
                        case bx2_abqS of ds1_abqU {
                          __DEFAULT ->
                            Data.ByteString.Lazy.Internal.Chunk
                              bx_abqQ bx1_abqR ds1_abqU Data.ByteString.Lazy.Internal.Empty;
                          0# -> Data.ByteString.Lazy.Internal.Empty
                        }
                        })
              ValArg s_a8Oh
    Cont:   Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: unpack
    Module: (GHC.Base)
    Before: GHC.CString.unpackCString# ValArg "[a] -> List a -> [a]"#
    After:  (\ (a_ab5Y :: GHC.Prim.Addr#) ->
               GHC.Base.build
                 @GHC.Types.Char
                 (\ (@b_ab5Z) -> GHC.CString.unpackFoldrCString# @b_ab5Z a_ab5Y))
              "[a] -> List a -> [a]"#
    Cont:   Stop[BoringCtxt] Test.Tasty.Core.TestName
Rule fired
    Rule: USPEC $fShowList @Int
    Module: (GHC.Show)
    Before: GHC.Show.$fShowList
              TyArg GHC.Types.Int ValArg GHC.Show.$fShowInt
    After:  (\ ($dShow_ab5N :: GHC.Show.Show GHC.Types.Int) ->
               GHC.Show.$fShowList_$s$fShowList)
              GHC.Show.$fShowInt
    Cont:   Stop[RuleArgCtxt, P(A,L,A)] GHC.Show.Show [GHC.Types.Int]
Rule fired
    Rule: Class op property
    Module: (BUILTIN)
    Before: Test.QuickCheck.Property.property
              TyArg [GHC.Types.Int] -> GHC.Types.Bool
              ValArg Test.QuickCheck.Property.$fTestableFUN
                       @[GHC.Types.Int]
                       @GHC.Types.Bool
                       (Test.QuickCheck.Arbitrary.$fArbitraryList
                          @GHC.Types.Int Test.QuickCheck.Arbitrary.$fArbitraryInt)
                       GHC.Show.$fShowList_$s$fShowList
                       Test.QuickCheck.Property.$fTestableBool
    After:  Test.QuickCheck.Property.$fTestableFUN_$cproperty
              @[GHC.Types.Int]
              @GHC.Types.Bool
              (Test.QuickCheck.Arbitrary.$fArbitraryList
                 @GHC.Types.Int Test.QuickCheck.Arbitrary.$fArbitraryInt)
              GHC.Show.$fShowList_$s$fShowList
              Test.QuickCheck.Property.$fTestableBool
    Cont:   ApplyToVal nodup hole ([GHC.Types.Int] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              prop_ab6b
            CastIt (Sym (Test.Tasty.QuickCheck.N:QC[0])
                    :: Test.QuickCheck.Property.Property ~R# Test.Tasty.QuickCheck.QC)
            Stop[BoringCtxt] Test.Tasty.QuickCheck.QC
Rule fired
    Rule: Class op propertyForAllShrinkShow
    Module: (BUILTIN)
    Before: Test.QuickCheck.Property.propertyForAllShrinkShow
              TyArg GHC.Types.Bool ValArg Test.QuickCheck.Property.$fTestableBool
    After:  Test.QuickCheck.Property.$fTestableBool1
            `cast` (forall (a :: <*>_N).
                    <Test.QuickCheck.Gen.Gen a>_R
                    %<'GHC.Types.Many>_N ->_R <a -> [a]>_R
                    %<'GHC.Types.Many>_N ->_R <a -> [GHC.Base.String]>_R
                    %<'GHC.Types.Many>_N ->_R <a -> GHC.Types.Bool>_R
                    %<'GHC.Types.Many>_N ->_R Sym (Test.QuickCheck.Gen.N:Gen[0]
                                                       (Test.QuickCheck.Property.N:Prop[0]))
                                              ; Sym (Test.QuickCheck.Property.N:Property[0])
                    :: (forall {a}.
                        Test.QuickCheck.Gen.Gen a
                        -> (a -> [a])
                        -> (a -> [GHC.Base.String])
                        -> (a -> GHC.Types.Bool)
                        -> Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int
                        -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result)
                       ~R# (forall {a}.
                            Test.QuickCheck.Gen.Gen a
                            -> (a -> [a])
                            -> (a -> [GHC.Base.String])
                            -> (a -> GHC.Types.Bool)
                            -> Test.QuickCheck.Property.Property))
    Cont:   ApplyToTy [GHC.Types.Int]
            ApplyToVal nodup hole Test.QuickCheck.Gen.Gen [GHC.Types.Int]
                                  -> ([GHC.Types.Int] -> [[GHC.Types.Int]])
                                  -> ([GHC.Types.Int] -> [GHC.Base.String])
                                  -> ([GHC.Types.Int] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (Test.QuickCheck.Arbitrary.arbitrary @a_ab7T $dArbitrary_ab7V)
            ApplyToVal nodup hole ([GHC.Types.Int] -> [[GHC.Types.Int]])
                                  -> ([GHC.Types.Int] -> [GHC.Base.String])
                                  -> ([GHC.Types.Int] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (Test.QuickCheck.Arbitrary.shrink @a_ab7T $dArbitrary_ab7V)
            ApplyToVal nodup hole ([GHC.Types.Int] -> [GHC.Base.String])
                                  -> ([GHC.Types.Int] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (let {
                 g_ab7Z [Occ=OnceL1!] :: a_ab7T -> GHC.Base.String
                 [LclId]
                 g_ab7Z = GHC.Show.show @a_ab7T $dShow_ab7W } in
               \ (x_ab80 [Occ=Once1] :: a_ab7T) ->
                 GHC.Types.:
                   @GHC.Base.String (g_ab7Z x_ab80) (GHC.Types.[] @GHC.Base.String))
            ApplyToVal nodup hole ([GHC.Types.Int] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              f_ab7Y
            CastIt (Sym (Test.Tasty.QuickCheck.N:QC[0])
                    :: Test.QuickCheck.Property.Property ~R# Test.Tasty.QuickCheck.QC)
            Stop[BoringCtxt] Test.Tasty.QuickCheck.QC
Rule fired
    Rule: Class op arbitrary
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.arbitrary
              TyArg [GHC.Types.Int] ValArg $dArbitrary_ab7V
    After:  (Test.QuickCheck.Arbitrary.$fArbitraryList1
               @GHC.Types.Int Test.QuickCheck.Arbitrary.$fArbitraryInt)
            `cast` (Sym (Test.QuickCheck.Gen.N:Gen[0] <[GHC.Types.Int]>_R)
                    :: (Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int -> [GHC.Types.Int])
                       ~R# Test.QuickCheck.Gen.Gen [GHC.Types.Int])
    Cont:   Stop[BoringCtxt] Test.QuickCheck.Gen.Gen [GHC.Types.Int]
Rule fired
    Rule: Class op arbitrary
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.arbitrary
              TyArg GHC.Types.Int ValArg Test.QuickCheck.Arbitrary.$fArbitraryInt
    After:  Test.QuickCheck.Arbitrary.$fArbitraryInt_$sarbitrarySizedIntegral
            `cast` (Sym (Test.QuickCheck.Gen.N:Gen[0] <GHC.Types.Int>_R)
                    :: (Test.QuickCheck.Random.QCGen -> GHC.Types.Int -> GHC.Types.Int)
                       ~R# Test.QuickCheck.Gen.Gen GHC.Types.Int)
    Cont:   Stop[BoringCtxt, C(S,C(1,L))] Test.QuickCheck.Gen.Gen
                                            GHC.Types.Int
Rule fired
    Rule: Class op shrink
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.shrink
              TyArg [GHC.Types.Int] ValArg $dArbitrary_ab7V
    After:  Test.QuickCheck.Arbitrary.$fArbitraryList_$cshrink
              @GHC.Types.Int Test.QuickCheck.Arbitrary.$fArbitraryInt
    Cont:   Stop[BoringCtxt] [GHC.Types.Int] -> [[GHC.Types.Int]]
Rule fired
    Rule: Class op shrink
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.shrink
              TyArg GHC.Types.Int ValArg Test.QuickCheck.Arbitrary.$fArbitraryInt
    After:  Test.QuickCheck.Arbitrary.$fArbitrary1IntMap_$sshrinkIntegral
    Cont:   Stop[DiscArgCtxt, C(S,L)] GHC.Types.Int -> [GHC.Types.Int]
Rule fired
    Rule: Class op show
    Module: (BUILTIN)
    Before: GHC.Show.show
              TyArg [GHC.Types.Int] ValArg GHC.Show.$fShowList_$s$fShowList
    After:  GHC.Show.$fShowList_$s$cshow
    Cont:   Stop[RhsCtxt(NonRecursive)] [GHC.Types.Int]
                                        -> GHC.Base.String
Rule fired
    Rule: Class op reader
    Module: (BUILTIN)
    Before: Control.Monad.Reader.Class.reader
              TyArg Main.List GHC.Types.Int
              TyArg (->) (Main.List GHC.Types.Int)
              ValArg Control.Monad.Reader.Class.$fMonadReaderrFUN
                       @(Main.List GHC.Types.Int)
    After:  \ (@a_abdo) ->
              GHC.Base.id @(Main.List GHC.Types.Int -> a_abdo)
    Cont:   ApplyToTy [GHC.Types.Int]
            ApplyToVal nodup hole (Main.List GHC.Types.Int -> [GHC.Types.Int])
                                  -> Main.List GHC.Types.Int -> [GHC.Types.Int]
              ((l_abdi
                  ((\ (ds_abdj [Occ=Once1] :: a_abdg) -> ds_abdj)
                   `cast` (<a_abdg>_R
                           %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                              <*>_N <a_abdg>_R <a_abdg>_P)
                           :: (a_abdg -> a_abdg)
                              ~R# (a_abdg -> Data.Functor.Const.Const a_abdg a_abdg))))
               `cast` (<s_abde>_R
                       %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                     <*>_N <a_abdg>_R <s_abde>_P
                       :: (s_abde -> Data.Functor.Const.Const a_abdg s_abde)
                          ~R# (s_abde -> a_abdg)))
            ApplyToVal nodup hole Main.List GHC.Types.Int -> [GHC.Types.Int]
              (Control.Lens.Getter.view
                 @[GHC.Types.Int]
                 @((->) [GHC.Types.Int])
                 @(Main.List GHC.Types.Int)
                 (Control.Monad.Reader.Class.$fMonadReaderrFUN @[GHC.Types.Int])
                 (Control.Lens.Cons.Extras.recons
                    @[GHC.Types.Int]
                    @GHC.Types.Int
                    @(Main.List GHC.Types.Int)
                    (Control.Lens.Cons.$fConsListListab @GHC.Types.Int @GHC.Types.Int)
                    (Main.$fConsListListab @GHC.Types.Int @GHC.Types.Int)
                    (Main.$fAsEmptyList @GHC.Types.Int)
                    @(Data.Functor.Const.Const (Main.List GHC.Types.Int))
                    (Data.Functor.Contravariant.$fContravariantConst
                       @(Main.List GHC.Types.Int))
                    (Data.Functor.Const.$fFunctorConst @(Main.List GHC.Types.Int)))
                 s_a8Oi)
            Stop[RuleArgCtxt] [GHC.Types.Int]
Rule fired
    Rule: Class op reader
    Module: (BUILTIN)
    Before: Control.Monad.Reader.Class.reader
              TyArg [GHC.Types.Int]
              TyArg (->) [GHC.Types.Int]
              ValArg Control.Monad.Reader.Class.$fMonadReaderrFUN
                       @[GHC.Types.Int]
    After:  \ (@a_abdo) -> GHC.Base.id @([GHC.Types.Int] -> a_abdo)
    Cont:   ApplyToTy (Main.List GHC.Types.Int)
            ApplyToVal nodup hole ([GHC.Types.Int] -> Main.List GHC.Types.Int)
                                  -> [GHC.Types.Int] -> Main.List GHC.Types.Int
              ((l_abdi
                  ((\ (ds_abdj [Occ=Once1] :: a_abdg) -> ds_abdj)
                   `cast` (<a_abdg>_R
                           %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                              <*>_N <a_abdg>_R <a_abdg>_P)
                           :: (a_abdg -> a_abdg)
                              ~R# (a_abdg -> Data.Functor.Const.Const a_abdg a_abdg))))
               `cast` (<s_abde>_R
                       %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                     <*>_N <a_abdg>_R <s_abde>_P
                       :: (s_abde -> Data.Functor.Const.Const a_abdg s_abde)
                          ~R# (s_abde -> a_abdg)))
            ApplyToVal nodup hole [GHC.Types.Int] -> Main.List GHC.Types.Int
              s_a8Oi
            Stop[RuleArgCtxt] Main.List GHC.Types.Int
Rule fired
    Rule: Class op ==
    Module: (BUILTIN)
    Before: GHC.Classes.==
              TyArg [GHC.Types.Int]
              ValArg GHC.Classes.$fEqList_$s$fEqList
              ValArg (Control.Lens.Cons.Extras.recons
                        @(Main.List GHC.Types.Int)
                        @GHC.Types.Int
                        @[GHC.Types.Int]
                        (($c_Cons_a9hU @GHC.Types.Int @GHC.Types.Int)
                         `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                          <Main.List GHC.Types.Int>_N
                                          <Main.List GHC.Types.Int>_N
                                          <GHC.Types.Int>_N
                                          <GHC.Types.Int>_N)
                                 :: Control.Lens.Type.Prism
                                      (Main.List GHC.Types.Int)
                                      (Main.List GHC.Types.Int)
                                      (GHC.Types.Int, Main.List GHC.Types.Int)
                                      (GHC.Types.Int, Main.List GHC.Types.Int)
                                    ~R# Control.Lens.Cons.Cons
                                          (Main.List GHC.Types.Int)
                                          (Main.List GHC.Types.Int)
                                          GHC.Types.Int
                                          GHC.Types.Int))
                        ((\ (@(p_abeP :: * -> * -> *))
                            (@(f_abeQ :: * -> *))
                            ($dChoice_abeR :: Data.Profunctor.Choice.Choice p_abeP)
                            ($dApplicative_abeS :: GHC.Base.Applicative f_abeQ) ->
                            let {
                              f1_abeT
                                :: p_abeP
                                     (Data.Either.Either
                                        [GHC.Types.Int] (GHC.Types.Int, [GHC.Types.Int]))
                                     (Data.Either.Either
                                        [GHC.Types.Int] (f_abeQ (GHC.Types.Int, [GHC.Types.Int])))
                                   -> p_abeP [GHC.Types.Int] (f_abeQ [GHC.Types.Int])
                              [LclId,
                               Unf=Unf{Src=<vanilla>, TopLvl=False,
                                       Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                       Guidance=IF_ARGS [] 320 0}]
                              f1_abeT
                                = Data.Profunctor.Unsafe.dimap
                                    @p_abeP
                                    (Data.Profunctor.Choice.$p1Choice @p_abeP $dChoice_abeR)
                                    @[GHC.Types.Int]
                                    @(Data.Either.Either
                                        [GHC.Types.Int] (GHC.Types.Int, [GHC.Types.Int]))
                                    @(Data.Either.Either
                                        [GHC.Types.Int] (f_abeQ (GHC.Types.Int, [GHC.Types.Int])))
                                    @(f_abeQ [GHC.Types.Int])
                                    (\ (aas_abeU :: [GHC.Types.Int]) ->
                                       case aas_abeU of {
                                         [] ->
                                           Data.Either.Left
                                             @[GHC.Types.Int]
                                             @(GHC.Types.Int, [GHC.Types.Int])
                                             (GHC.Types.[] @GHC.Types.Int);
                                         : a1_abeW as_abeX ->
                                           Data.Either.Right
                                             @[GHC.Types.Int]
                                             @(GHC.Types.Int, [GHC.Types.Int])
                                             (a1_abeW, as_abeX)
                                       })
                                    (let {
                                       f2_abeZ :: [GHC.Types.Int] -> f_abeQ [GHC.Types.Int]
                                       [LclId,
                                        Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                Value=False, ConLike=False, WorkFree=False,
                                                Expandable=True,
                                                Guidance=IF_ARGS [] 20 0}]
                                       f2_abeZ
                                         = GHC.Base.pure
                                             @f_abeQ $dApplicative_abeS @[GHC.Types.Int] } in
                                     let {
                                       ds2_abf0
                                         :: f_abeQ (GHC.Types.Int, [GHC.Types.Int])
                                            -> f_abeQ [GHC.Types.Int]
                                       [LclId,
                                        Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                Value=False, ConLike=False, WorkFree=False,
                                                Expandable=False,
                                                Guidance=IF_ARGS [] 90 0}]
                                       ds2_abf0
                                         = GHC.Base.fmap
                                             @f_abeQ
                                             (GHC.Base.$p1Applicative @f_abeQ $dApplicative_abeS)
                                             @(GHC.Types.Int, [GHC.Types.Int])
                                             @[GHC.Types.Int]
                                             (\ (p1_abf1 :: (GHC.Types.Int, [GHC.Types.Int])) ->
                                                GHC.Types.:
                                                  @GHC.Types.Int
                                                  (case p1_abf1 of { (x_abf3, ds_abf4) -> x_abf3 })
                                                  (case p1_abf1 of { (ds_abf7, y_abf8) ->
                                                   y_abf8
                                                   })) } in
                                     \ (ds3_abfa
                                          :: Data.Either.Either
                                               [GHC.Types.Int]
                                               (f_abeQ (GHC.Types.Int, [GHC.Types.Int]))) ->
                                       case ds3_abfa of {
                                         Data.Either.Left x_abfc -> f2_abeZ x_abfc;
                                         Data.Either.Right y_abfe -> ds2_abf0 y_abfe
                                       }) } in
                            let {
                              g_abfg
                                :: p_abeP
                                     (GHC.Types.Int, [GHC.Types.Int])
                                     (f_abeQ (GHC.Types.Int, [GHC.Types.Int]))
                                   -> p_abeP
                                        (Data.Either.Either
                                           [GHC.Types.Int] (GHC.Types.Int, [GHC.Types.Int]))
                                        (Data.Either.Either
                                           [GHC.Types.Int]
                                           (f_abeQ (GHC.Types.Int, [GHC.Types.Int])))
                              [LclId,
                               Unf=Unf{Src=<vanilla>, TopLvl=False,
                                       Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                       Guidance=IF_ARGS [] 20 0}]
                              g_abfg
                                = Data.Profunctor.Choice.right'
                                    @p_abeP
                                    $dChoice_abeR
                                    @(GHC.Types.Int, [GHC.Types.Int])
                                    @(f_abeQ (GHC.Types.Int, [GHC.Types.Int]))
                                    @[GHC.Types.Int] } in
                            \ (x_abfh
                                 :: p_abeP
                                      (GHC.Types.Int, [GHC.Types.Int])
                                      (f_abeQ (GHC.Types.Int, [GHC.Types.Int]))) ->
                              f1_abeT (g_abfg x_abfh))
                         `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                          <[GHC.Types.Int]>_N
                                          <[GHC.Types.Int]>_N
                                          <GHC.Types.Int>_N
                                          <GHC.Types.Int>_N)
                                 :: Control.Lens.Type.Prism
                                      [GHC.Types.Int]
                                      [GHC.Types.Int]
                                      (GHC.Types.Int, [GHC.Types.Int])
                                      (GHC.Types.Int, [GHC.Types.Int])
                                    ~R# Control.Lens.Cons.Cons
                                          [GHC.Types.Int]
                                          [GHC.Types.Int]
                                          GHC.Types.Int
                                          GHC.Types.Int))
                        ((\ (@(p_abfm :: * -> * -> *))
                            (@(f_abfn :: * -> *))
                            ($dChoice_abfo :: Data.Profunctor.Choice.Choice p_abfm)
                            ($dApplicative_abfp :: GHC.Base.Applicative f_abfn) ->
                            let {
                              f1_abfq
                                :: p_abfm
                                     (Data.Either.Either [GHC.Types.Int] ())
                                     (Data.Either.Either [GHC.Types.Int] (f_abfn ()))
                                   -> p_abfm [GHC.Types.Int] (f_abfn [GHC.Types.Int])
                              [LclId,
                               Unf=Unf{Src=<vanilla>, TopLvl=False,
                                       Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                       Guidance=IF_ARGS [] 290 0}]
                              f1_abfq
                                = Data.Profunctor.Unsafe.dimap
                                    @p_abfm
                                    (Data.Profunctor.Choice.$p1Choice @p_abfm $dChoice_abfo)
                                    @[GHC.Types.Int]
                                    @(Data.Either.Either [GHC.Types.Int] ())
                                    @(Data.Either.Either [GHC.Types.Int] (f_abfn ()))
                                    @(f_abfn [GHC.Types.Int])
                                    (\ (s_abfr :: [GHC.Types.Int]) ->
                                       case s_abfr of wild_abfs {
                                         [] ->
                                           Data.Either.Right @[GHC.Types.Int] @() GHC.Tuple.Prim.();
                                         : ds1_abft ds2_abfu ->
                                           Data.Either.Left @[GHC.Types.Int] @() wild_abfs
                                       })
                                    (let {
                                       f2_abfw :: [GHC.Types.Int] -> f_abfn [GHC.Types.Int]
                                       [LclId,
                                        Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                Value=False, ConLike=False, WorkFree=False,
                                                Expandable=True,
                                                Guidance=IF_ARGS [] 20 0}]
                                       f2_abfw
                                         = GHC.Base.pure
                                             @f_abfn $dApplicative_abfp @[GHC.Types.Int] } in
                                     let {
                                       ds2_abfx :: f_abfn () -> f_abfn [GHC.Types.Int]
                                       [LclId,
                                        Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                Value=False, ConLike=False, WorkFree=False,
                                                Expandable=False,
                                                Guidance=IF_ARGS [] 70 0}]
                                       ds2_abfx
                                         = GHC.Base.fmap
                                             @f_abfn
                                             (GHC.Base.$p1Applicative @f_abfn $dApplicative_abfp)
                                             @()
                                             @[GHC.Types.Int]
                                             (\ (ds3_abfy :: ()) ->
                                                case ds3_abfy of { () ->
                                                GHC.Types.[] @GHC.Types.Int
                                                }) } in
                                     \ (ds3_abfA
                                          :: Data.Either.Either [GHC.Types.Int] (f_abfn ())) ->
                                       case ds3_abfA of {
                                         Data.Either.Left x_abfC -> f2_abfw x_abfC;
                                         Data.Either.Right y_abfE -> ds2_abfx y_abfE
                                       }) } in
                            let {
                              g_abfG
                                :: p_abfm () (f_abfn ())
                                   -> p_abfm
                                        (Data.Either.Either [GHC.Types.Int] ())
                                        (Data.Either.Either [GHC.Types.Int] (f_abfn ()))
                              [LclId,
                               Unf=Unf{Src=<vanilla>, TopLvl=False,
                                       Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                       Guidance=IF_ARGS [] 20 0}]
                              g_abfG
                                = Data.Profunctor.Choice.right'
                                    @p_abfm $dChoice_abfo @() @(f_abfn ()) @[GHC.Types.Int] } in
                            \ (x_abfH :: p_abfm () (f_abfn ())) -> f1_abfq (g_abfG x_abfH))
                         `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0] <[GHC.Types.Int]>_N)
                                 :: Control.Lens.Type.Prism' [GHC.Types.Int] ()
                                    ~R# Control.Lens.Empty.AsEmpty [GHC.Types.Int]))
                        @(Data.Functor.Const.Const [GHC.Types.Int])
                        (Data.Functor.Contravariant.$fContravariantConst @[GHC.Types.Int])
                        (Data.Functor.Const.$fFunctorConst @[GHC.Types.Int])
                        ((\ (ds_abdj :: [GHC.Types.Int]) -> ds_abdj)
                         `cast` (<[GHC.Types.Int]>_R
                                 %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                                    <*>_N
                                                                    <[GHC.Types.Int]>_R
                                                                    <[GHC.Types.Int]>_P)
                                 :: ([GHC.Types.Int] -> [GHC.Types.Int])
                                    ~R# ([GHC.Types.Int]
                                         -> Data.Functor.Const.Const
                                              [GHC.Types.Int] [GHC.Types.Int])))
                        ((Control.Lens.Cons.Extras.recons
                            @[GHC.Types.Int]
                            @GHC.Types.Int
                            @(Main.List GHC.Types.Int)
                            ((\ (@(p_abeP :: * -> * -> *))
                                (@(f_abeQ :: * -> *))
                                ($dChoice_abeR :: Data.Profunctor.Choice.Choice p_abeP)
                                ($dApplicative_abeS :: GHC.Base.Applicative f_abeQ) ->
                                let {
                                  f1_abeT
                                    :: p_abeP
                                         (Data.Either.Either
                                            [GHC.Types.Int] (GHC.Types.Int, [GHC.Types.Int]))
                                         (Data.Either.Either
                                            [GHC.Types.Int]
                                            (f_abeQ (GHC.Types.Int, [GHC.Types.Int])))
                                       -> p_abeP [GHC.Types.Int] (f_abeQ [GHC.Types.Int])
                                  [LclId,
                                   Unf=Unf{Src=<vanilla>, TopLvl=False,
                                           Value=False, ConLike=False, WorkFree=False,
                                           Expandable=False,
                                           Guidance=IF_ARGS [] 320 0}]
                                  f1_abeT
                                    = Data.Profunctor.Unsafe.dimap
                                        @p_abeP
                                        (Data.Profunctor.Choice.$p1Choice @p_abeP $dChoice_abeR)
                                        @[GHC.Types.Int]
                                        @(Data.Either.Either
                                            [GHC.Types.Int] (GHC.Types.Int, [GHC.Types.Int]))
                                        @(Data.Either.Either
                                            [GHC.Types.Int]
                                            (f_abeQ (GHC.Types.Int, [GHC.Types.Int])))
                                        @(f_abeQ [GHC.Types.Int])
                                        (\ (aas_abeU :: [GHC.Types.Int]) ->
                                           case aas_abeU of {
                                             [] ->
                                               Data.Either.Left
                                                 @[GHC.Types.Int]
                                                 @(GHC.Types.Int, [GHC.Types.Int])
                                                 (GHC.Types.[] @GHC.Types.Int);
                                             : a1_abeW as_abeX ->
                                               Data.Either.Right
                                                 @[GHC.Types.Int]
                                                 @(GHC.Types.Int, [GHC.Types.Int])
                                                 (a1_abeW, as_abeX)
                                           })
                                        (let {
                                           f2_abeZ :: [GHC.Types.Int] -> f_abeQ [GHC.Types.Int]
                                           [LclId,
                                            Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                    Value=False, ConLike=False, WorkFree=False,
                                                    Expandable=True,
                                                    Guidance=IF_ARGS [] 20 0}]
                                           f2_abeZ
                                             = GHC.Base.pure
                                                 @f_abeQ $dApplicative_abeS @[GHC.Types.Int] } in
                                         let {
                                           ds2_abf0
                                             :: f_abeQ (GHC.Types.Int, [GHC.Types.Int])
                                                -> f_abeQ [GHC.Types.Int]
                                           [LclId,
                                            Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                    Value=False, ConLike=False, WorkFree=False,
                                                    Expandable=False,
                                                    Guidance=IF_ARGS [] 90 0}]
                                           ds2_abf0
                                             = GHC.Base.fmap
                                                 @f_abeQ
                                                 (GHC.Base.$p1Applicative
                                                    @f_abeQ $dApplicative_abeS)
                                                 @(GHC.Types.Int, [GHC.Types.Int])
                                                 @[GHC.Types.Int]
                                                 (\ (p1_abf1 :: (GHC.Types.Int, [GHC.Types.Int])) ->
                                                    GHC.Types.:
                                                      @GHC.Types.Int
                                                      (case p1_abf1 of { (x_abf3, ds_abf4) ->
                                                       x_abf3
                                                       })
                                                      (case p1_abf1 of { (ds_abf7, y_abf8) ->
                                                       y_abf8
                                                       })) } in
                                         \ (ds3_abfa
                                              :: Data.Either.Either
                                                   [GHC.Types.Int]
                                                   (f_abeQ (GHC.Types.Int, [GHC.Types.Int]))) ->
                                           case ds3_abfa of {
                                             Data.Either.Left x_abfc -> f2_abeZ x_abfc;
                                             Data.Either.Right y_abfe -> ds2_abf0 y_abfe
                                           }) } in
                                let {
                                  g_abfg
                                    :: p_abeP
                                         (GHC.Types.Int, [GHC.Types.Int])
                                         (f_abeQ (GHC.Types.Int, [GHC.Types.Int]))
                                       -> p_abeP
                                            (Data.Either.Either
                                               [GHC.Types.Int] (GHC.Types.Int, [GHC.Types.Int]))
                                            (Data.Either.Either
                                               [GHC.Types.Int]
                                               (f_abeQ (GHC.Types.Int, [GHC.Types.Int])))
                                  [LclId,
                                   Unf=Unf{Src=<vanilla>, TopLvl=False,
                                           Value=False, ConLike=False, WorkFree=False,
                                           Expandable=True,
                                           Guidance=IF_ARGS [] 20 0}]
                                  g_abfg
                                    = Data.Profunctor.Choice.right'
                                        @p_abeP
                                        $dChoice_abeR
                                        @(GHC.Types.Int, [GHC.Types.Int])
                                        @(f_abeQ (GHC.Types.Int, [GHC.Types.Int]))
                                        @[GHC.Types.Int] } in
                                \ (x_abfh
                                     :: p_abeP
                                          (GHC.Types.Int, [GHC.Types.Int])
                                          (f_abeQ (GHC.Types.Int, [GHC.Types.Int]))) ->
                                  f1_abeT (g_abfg x_abfh))
                             `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                              <[GHC.Types.Int]>_N
                                              <[GHC.Types.Int]>_N
                                              <GHC.Types.Int>_N
                                              <GHC.Types.Int>_N)
                                     :: Control.Lens.Type.Prism
                                          [GHC.Types.Int]
                                          [GHC.Types.Int]
                                          (GHC.Types.Int, [GHC.Types.Int])
                                          (GHC.Types.Int, [GHC.Types.Int])
                                        ~R# Control.Lens.Cons.Cons
                                              [GHC.Types.Int]
                                              [GHC.Types.Int]
                                              GHC.Types.Int
                                              GHC.Types.Int))
                            (($c_Cons_a9hU @GHC.Types.Int @GHC.Types.Int)
                             `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                              <Main.List GHC.Types.Int>_N
                                              <Main.List GHC.Types.Int>_N
                                              <GHC.Types.Int>_N
                                              <GHC.Types.Int>_N)
                                     :: Control.Lens.Type.Prism
                                          (Main.List GHC.Types.Int)
                                          (Main.List GHC.Types.Int)
                                          (GHC.Types.Int, Main.List GHC.Types.Int)
                                          (GHC.Types.Int, Main.List GHC.Types.Int)
                                        ~R# Control.Lens.Cons.Cons
                                              (Main.List GHC.Types.Int)
                                              (Main.List GHC.Types.Int)
                                              GHC.Types.Int
                                              GHC.Types.Int))
                            (($c_Empty_a9mT @GHC.Types.Int)
                             `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                              <Main.List GHC.Types.Int>_N)
                                     :: Control.Lens.Type.Prism' (Main.List GHC.Types.Int) ()
                                        ~R# Control.Lens.Empty.AsEmpty (Main.List GHC.Types.Int)))
                            @(Data.Functor.Const.Const (Main.List GHC.Types.Int))
                            (Data.Functor.Contravariant.$fContravariantConst
                               @(Main.List GHC.Types.Int))
                            (Data.Functor.Const.$fFunctorConst @(Main.List GHC.Types.Int))
                            ((\ (ds_abdj :: Main.List GHC.Types.Int) -> ds_abdj)
                             `cast` (<Main.List GHC.Types.Int>_R
                                     %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                                        <*>_N
                                                                        <Main.List GHC.Types.Int>_R
                                                                        <Main.List GHC.Types.Int>_P)
                                     :: (Main.List GHC.Types.Int -> Main.List GHC.Types.Int)
                                        ~R# (Main.List GHC.Types.Int
                                             -> Data.Functor.Const.Const
                                                  (Main.List GHC.Types.Int)
                                                  (Main.List GHC.Types.Int))))
                            s_a8Oi)
                         `cast` (Data.Functor.Const.N:Const[0]
                                     <*>_N <Main.List GHC.Types.Int>_R <[GHC.Types.Int]>_P
                                 :: Data.Functor.Const.Const
                                      (Main.List GHC.Types.Int) [GHC.Types.Int]
                                    ~R# Main.List GHC.Types.Int)))
                     `cast` (Data.Functor.Const.N:Const[0]
                                 <*>_N <[GHC.Types.Int]>_R <Main.List GHC.Types.Int>_P
                             :: Data.Functor.Const.Const
                                  [GHC.Types.Int] (Main.List GHC.Types.Int)
                                ~R# [GHC.Types.Int])
              ValArg s_a8Oi
    After:  GHC.Classes.$fEqList_$s$c==
              ValArg (Control.Lens.Cons.Extras.recons
                        @(Main.List GHC.Types.Int)
                        @GHC.Types.Int
                        @[GHC.Types.Int]
                        (($c_Cons_a9hU @GHC.Types.Int @GHC.Types.Int)
                         `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                          <Main.List GHC.Types.Int>_N
                                          <Main.List GHC.Types.Int>_N
                                          <GHC.Types.Int>_N
                                          <GHC.Types.Int>_N)
                                 :: Control.Lens.Type.Prism
                                      (Main.List GHC.Types.Int)
                                      (Main.List GHC.Types.Int)
                                      (GHC.Types.Int, Main.List GHC.Types.Int)
                                      (GHC.Types.Int, Main.List GHC.Types.Int)
                                    ~R# Control.Lens.Cons.Cons
                                          (Main.List GHC.Types.Int)
                                          (Main.List GHC.Types.Int)
                                          GHC.Types.Int
                                          GHC.Types.Int))
                        ((\ (@(p_abeP :: * -> * -> *))
                            (@(f_abeQ :: * -> *))
                            ($dChoice_abeR :: Data.Profunctor.Choice.Choice p_abeP)
                            ($dApplicative_abeS :: GHC.Base.Applicative f_abeQ) ->
                            let {
                              f1_abeT
                                :: p_abeP
                                     (Data.Either.Either
                                        [GHC.Types.Int] (GHC.Types.Int, [GHC.Types.Int]))
                                     (Data.Either.Either
                                        [GHC.Types.Int] (f_abeQ (GHC.Types.Int, [GHC.Types.Int])))
                                   -> p_abeP [GHC.Types.Int] (f_abeQ [GHC.Types.Int])
                              [LclId,
                               Unf=Unf{Src=<vanilla>, TopLvl=False,
                                       Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                       Guidance=IF_ARGS [] 320 0}]
                              f1_abeT
                                = Data.Profunctor.Unsafe.dimap
                                    @p_abeP
                                    (Data.Profunctor.Choice.$p1Choice @p_abeP $dChoice_abeR)
                                    @[GHC.Types.Int]
                                    @(Data.Either.Either
                                        [GHC.Types.Int] (GHC.Types.Int, [GHC.Types.Int]))
                                    @(Data.Either.Either
                                        [GHC.Types.Int] (f_abeQ (GHC.Types.Int, [GHC.Types.Int])))
                                    @(f_abeQ [GHC.Types.Int])
                                    (\ (aas_abeU :: [GHC.Types.Int]) ->
                                       case aas_abeU of {
                                         [] ->
                                           Data.Either.Left
                                             @[GHC.Types.Int]
                                             @(GHC.Types.Int, [GHC.Types.Int])
                                             (GHC.Types.[] @GHC.Types.Int);
                                         : a1_abeW as_abeX ->
                                           Data.Either.Right
                                             @[GHC.Types.Int]
                                             @(GHC.Types.Int, [GHC.Types.Int])
                                             (a1_abeW, as_abeX)
                                       })
                                    (let {
                                       f2_abeZ :: [GHC.Types.Int] -> f_abeQ [GHC.Types.Int]
                                       [LclId,
                                        Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                Value=False, ConLike=False, WorkFree=False,
                                                Expandable=True,
                                                Guidance=IF_ARGS [] 20 0}]
                                       f2_abeZ
                                         = GHC.Base.pure
                                             @f_abeQ $dApplicative_abeS @[GHC.Types.Int] } in
                                     let {
                                       ds2_abf0
                                         :: f_abeQ (GHC.Types.Int, [GHC.Types.Int])
                                            -> f_abeQ [GHC.Types.Int]
                                       [LclId,
                                        Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                Value=False, ConLike=False, WorkFree=False,
                                                Expandable=False,
                                                Guidance=IF_ARGS [] 90 0}]
                                       ds2_abf0
                                         = GHC.Base.fmap
                                             @f_abeQ
                                             (GHC.Base.$p1Applicative @f_abeQ $dApplicative_abeS)
                                             @(GHC.Types.Int, [GHC.Types.Int])
                                             @[GHC.Types.Int]
                                             (\ (p1_abf1 :: (GHC.Types.Int, [GHC.Types.Int])) ->
                                                GHC.Types.:
                                                  @GHC.Types.Int
                                                  (case p1_abf1 of { (x_abf3, ds_abf4) -> x_abf3 })
                                                  (case p1_abf1 of { (ds_abf7, y_abf8) ->
                                                   y_abf8
                                                   })) } in
                                     \ (ds3_abfa
                                          :: Data.Either.Either
                                               [GHC.Types.Int]
                                               (f_abeQ (GHC.Types.Int, [GHC.Types.Int]))) ->
                                       case ds3_abfa of {
                                         Data.Either.Left x_abfc -> f2_abeZ x_abfc;
                                         Data.Either.Right y_abfe -> ds2_abf0 y_abfe
                                       }) } in
                            let {
                              g_abfg
                                :: p_abeP
                                     (GHC.Types.Int, [GHC.Types.Int])
                                     (f_abeQ (GHC.Types.Int, [GHC.Types.Int]))
                                   -> p_abeP
                                        (Data.Either.Either
                                           [GHC.Types.Int] (GHC.Types.Int, [GHC.Types.Int]))
                                        (Data.Either.Either
                                           [GHC.Types.Int]
                                           (f_abeQ (GHC.Types.Int, [GHC.Types.Int])))
                              [LclId,
                               Unf=Unf{Src=<vanilla>, TopLvl=False,
                                       Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                       Guidance=IF_ARGS [] 20 0}]
                              g_abfg
                                = Data.Profunctor.Choice.right'
                                    @p_abeP
                                    $dChoice_abeR
                                    @(GHC.Types.Int, [GHC.Types.Int])
                                    @(f_abeQ (GHC.Types.Int, [GHC.Types.Int]))
                                    @[GHC.Types.Int] } in
                            \ (x_abfh
                                 :: p_abeP
                                      (GHC.Types.Int, [GHC.Types.Int])
                                      (f_abeQ (GHC.Types.Int, [GHC.Types.Int]))) ->
                              f1_abeT (g_abfg x_abfh))
                         `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                          <[GHC.Types.Int]>_N
                                          <[GHC.Types.Int]>_N
                                          <GHC.Types.Int>_N
                                          <GHC.Types.Int>_N)
                                 :: Control.Lens.Type.Prism
                                      [GHC.Types.Int]
                                      [GHC.Types.Int]
                                      (GHC.Types.Int, [GHC.Types.Int])
                                      (GHC.Types.Int, [GHC.Types.Int])
                                    ~R# Control.Lens.Cons.Cons
                                          [GHC.Types.Int]
                                          [GHC.Types.Int]
                                          GHC.Types.Int
                                          GHC.Types.Int))
                        ((\ (@(p_abfm :: * -> * -> *))
                            (@(f_abfn :: * -> *))
                            ($dChoice_abfo :: Data.Profunctor.Choice.Choice p_abfm)
                            ($dApplicative_abfp :: GHC.Base.Applicative f_abfn) ->
                            let {
                              f1_abfq
                                :: p_abfm
                                     (Data.Either.Either [GHC.Types.Int] ())
                                     (Data.Either.Either [GHC.Types.Int] (f_abfn ()))
                                   -> p_abfm [GHC.Types.Int] (f_abfn [GHC.Types.Int])
                              [LclId,
                               Unf=Unf{Src=<vanilla>, TopLvl=False,
                                       Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                       Guidance=IF_ARGS [] 290 0}]
                              f1_abfq
                                = Data.Profunctor.Unsafe.dimap
                                    @p_abfm
                                    (Data.Profunctor.Choice.$p1Choice @p_abfm $dChoice_abfo)
                                    @[GHC.Types.Int]
                                    @(Data.Either.Either [GHC.Types.Int] ())
                                    @(Data.Either.Either [GHC.Types.Int] (f_abfn ()))
                                    @(f_abfn [GHC.Types.Int])
                                    (\ (s_abfr :: [GHC.Types.Int]) ->
                                       case s_abfr of wild_abfs {
                                         [] ->
                                           Data.Either.Right @[GHC.Types.Int] @() GHC.Tuple.Prim.();
                                         : ds1_abft ds2_abfu ->
                                           Data.Either.Left @[GHC.Types.Int] @() wild_abfs
                                       })
                                    (let {
                                       f2_abfw :: [GHC.Types.Int] -> f_abfn [GHC.Types.Int]
                                       [LclId,
                                        Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                Value=False, ConLike=False, WorkFree=False,
                                                Expandable=True,
                                                Guidance=IF_ARGS [] 20 0}]
                                       f2_abfw
                                         = GHC.Base.pure
                                             @f_abfn $dApplicative_abfp @[GHC.Types.Int] } in
                                     let {
                                       ds2_abfx :: f_abfn () -> f_abfn [GHC.Types.Int]
                                       [LclId,
                                        Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                Value=False, ConLike=False, WorkFree=False,
                                                Expandable=False,
                                                Guidance=IF_ARGS [] 70 0}]
                                       ds2_abfx
                                         = GHC.Base.fmap
                                             @f_abfn
                                             (GHC.Base.$p1Applicative @f_abfn $dApplicative_abfp)
                                             @()
                                             @[GHC.Types.Int]
                                             (\ (ds3_abfy :: ()) ->
                                                case ds3_abfy of { () ->
                                                GHC.Types.[] @GHC.Types.Int
                                                }) } in
                                     \ (ds3_abfA
                                          :: Data.Either.Either [GHC.Types.Int] (f_abfn ())) ->
                                       case ds3_abfA of {
                                         Data.Either.Left x_abfC -> f2_abfw x_abfC;
                                         Data.Either.Right y_abfE -> ds2_abfx y_abfE
                                       }) } in
                            let {
                              g_abfG
                                :: p_abfm () (f_abfn ())
                                   -> p_abfm
                                        (Data.Either.Either [GHC.Types.Int] ())
                                        (Data.Either.Either [GHC.Types.Int] (f_abfn ()))
                              [LclId,
                               Unf=Unf{Src=<vanilla>, TopLvl=False,
                                       Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                       Guidance=IF_ARGS [] 20 0}]
                              g_abfG
                                = Data.Profunctor.Choice.right'
                                    @p_abfm $dChoice_abfo @() @(f_abfn ()) @[GHC.Types.Int] } in
                            \ (x_abfH :: p_abfm () (f_abfn ())) -> f1_abfq (g_abfG x_abfH))
                         `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0] <[GHC.Types.Int]>_N)
                                 :: Control.Lens.Type.Prism' [GHC.Types.Int] ()
                                    ~R# Control.Lens.Empty.AsEmpty [GHC.Types.Int]))
                        @(Data.Functor.Const.Const [GHC.Types.Int])
                        (Data.Functor.Contravariant.$fContravariantConst @[GHC.Types.Int])
                        (Data.Functor.Const.$fFunctorConst @[GHC.Types.Int])
                        ((\ (ds_abdj :: [GHC.Types.Int]) -> ds_abdj)
                         `cast` (<[GHC.Types.Int]>_R
                                 %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                                    <*>_N
                                                                    <[GHC.Types.Int]>_R
                                                                    <[GHC.Types.Int]>_P)
                                 :: ([GHC.Types.Int] -> [GHC.Types.Int])
                                    ~R# ([GHC.Types.Int]
                                         -> Data.Functor.Const.Const
                                              [GHC.Types.Int] [GHC.Types.Int])))
                        ((Control.Lens.Cons.Extras.recons
                            @[GHC.Types.Int]
                            @GHC.Types.Int
                            @(Main.List GHC.Types.Int)
                            ((\ (@(p_abeP :: * -> * -> *))
                                (@(f_abeQ :: * -> *))
                                ($dChoice_abeR :: Data.Profunctor.Choice.Choice p_abeP)
                                ($dApplicative_abeS :: GHC.Base.Applicative f_abeQ) ->
                                let {
                                  f1_abeT
                                    :: p_abeP
                                         (Data.Either.Either
                                            [GHC.Types.Int] (GHC.Types.Int, [GHC.Types.Int]))
                                         (Data.Either.Either
                                            [GHC.Types.Int]
                                            (f_abeQ (GHC.Types.Int, [GHC.Types.Int])))
                                       -> p_abeP [GHC.Types.Int] (f_abeQ [GHC.Types.Int])
                                  [LclId,
                                   Unf=Unf{Src=<vanilla>, TopLvl=False,
                                           Value=False, ConLike=False, WorkFree=False,
                                           Expandable=False,
                                           Guidance=IF_ARGS [] 320 0}]
                                  f1_abeT
                                    = Data.Profunctor.Unsafe.dimap
                                        @p_abeP
                                        (Data.Profunctor.Choice.$p1Choice @p_abeP $dChoice_abeR)
                                        @[GHC.Types.Int]
                                        @(Data.Either.Either
                                            [GHC.Types.Int] (GHC.Types.Int, [GHC.Types.Int]))
                                        @(Data.Either.Either
                                            [GHC.Types.Int]
                                            (f_abeQ (GHC.Types.Int, [GHC.Types.Int])))
                                        @(f_abeQ [GHC.Types.Int])
                                        (\ (aas_abeU :: [GHC.Types.Int]) ->
                                           case aas_abeU of {
                                             [] ->
                                               Data.Either.Left
                                                 @[GHC.Types.Int]
                                                 @(GHC.Types.Int, [GHC.Types.Int])
                                                 (GHC.Types.[] @GHC.Types.Int);
                                             : a1_abeW as_abeX ->
                                               Data.Either.Right
                                                 @[GHC.Types.Int]
                                                 @(GHC.Types.Int, [GHC.Types.Int])
                                                 (a1_abeW, as_abeX)
                                           })
                                        (let {
                                           f2_abeZ :: [GHC.Types.Int] -> f_abeQ [GHC.Types.Int]
                                           [LclId,
                                            Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                    Value=False, ConLike=False, WorkFree=False,
                                                    Expandable=True,
                                                    Guidance=IF_ARGS [] 20 0}]
                                           f2_abeZ
                                             = GHC.Base.pure
                                                 @f_abeQ $dApplicative_abeS @[GHC.Types.Int] } in
                                         let {
                                           ds2_abf0
                                             :: f_abeQ (GHC.Types.Int, [GHC.Types.Int])
                                                -> f_abeQ [GHC.Types.Int]
                                           [LclId,
                                            Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                    Value=False, ConLike=False, WorkFree=False,
                                                    Expandable=False,
                                                    Guidance=IF_ARGS [] 90 0}]
                                           ds2_abf0
                                             = GHC.Base.fmap
                                                 @f_abeQ
                                                 (GHC.Base.$p1Applicative
                                                    @f_abeQ $dApplicative_abeS)
                                                 @(GHC.Types.Int, [GHC.Types.Int])
                                                 @[GHC.Types.Int]
                                                 (\ (p1_abf1 :: (GHC.Types.Int, [GHC.Types.Int])) ->
                                                    GHC.Types.:
                                                      @GHC.Types.Int
                                                      (case p1_abf1 of { (x_abf3, ds_abf4) ->
                                                       x_abf3
                                                       })
                                                      (case p1_abf1 of { (ds_abf7, y_abf8) ->
                                                       y_abf8
                                                       })) } in
                                         \ (ds3_abfa
                                              :: Data.Either.Either
                                                   [GHC.Types.Int]
                                                   (f_abeQ (GHC.Types.Int, [GHC.Types.Int]))) ->
                                           case ds3_abfa of {
                                             Data.Either.Left x_abfc -> f2_abeZ x_abfc;
                                             Data.Either.Right y_abfe -> ds2_abf0 y_abfe
                                           }) } in
                                let {
                                  g_abfg
                                    :: p_abeP
                                         (GHC.Types.Int, [GHC.Types.Int])
                                         (f_abeQ (GHC.Types.Int, [GHC.Types.Int]))
                                       -> p_abeP
                                            (Data.Either.Either
                                               [GHC.Types.Int] (GHC.Types.Int, [GHC.Types.Int]))
                                            (Data.Either.Either
                                               [GHC.Types.Int]
                                               (f_abeQ (GHC.Types.Int, [GHC.Types.Int])))
                                  [LclId,
                                   Unf=Unf{Src=<vanilla>, TopLvl=False,
                                           Value=False, ConLike=False, WorkFree=False,
                                           Expandable=True,
                                           Guidance=IF_ARGS [] 20 0}]
                                  g_abfg
                                    = Data.Profunctor.Choice.right'
                                        @p_abeP
                                        $dChoice_abeR
                                        @(GHC.Types.Int, [GHC.Types.Int])
                                        @(f_abeQ (GHC.Types.Int, [GHC.Types.Int]))
                                        @[GHC.Types.Int] } in
                                \ (x_abfh
                                     :: p_abeP
                                          (GHC.Types.Int, [GHC.Types.Int])
                                          (f_abeQ (GHC.Types.Int, [GHC.Types.Int]))) ->
                                  f1_abeT (g_abfg x_abfh))
                             `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                              <[GHC.Types.Int]>_N
                                              <[GHC.Types.Int]>_N
                                              <GHC.Types.Int>_N
                                              <GHC.Types.Int>_N)
                                     :: Control.Lens.Type.Prism
                                          [GHC.Types.Int]
                                          [GHC.Types.Int]
                                          (GHC.Types.Int, [GHC.Types.Int])
                                          (GHC.Types.Int, [GHC.Types.Int])
                                        ~R# Control.Lens.Cons.Cons
                                              [GHC.Types.Int]
                                              [GHC.Types.Int]
                                              GHC.Types.Int
                                              GHC.Types.Int))
                            (($c_Cons_a9hU @GHC.Types.Int @GHC.Types.Int)
                             `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                              <Main.List GHC.Types.Int>_N
                                              <Main.List GHC.Types.Int>_N
                                              <GHC.Types.Int>_N
                                              <GHC.Types.Int>_N)
                                     :: Control.Lens.Type.Prism
                                          (Main.List GHC.Types.Int)
                                          (Main.List GHC.Types.Int)
                                          (GHC.Types.Int, Main.List GHC.Types.Int)
                                          (GHC.Types.Int, Main.List GHC.Types.Int)
                                        ~R# Control.Lens.Cons.Cons
                                              (Main.List GHC.Types.Int)
                                              (Main.List GHC.Types.Int)
                                              GHC.Types.Int
                                              GHC.Types.Int))
                            (($c_Empty_a9mT @GHC.Types.Int)
                             `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                              <Main.List GHC.Types.Int>_N)
                                     :: Control.Lens.Type.Prism' (Main.List GHC.Types.Int) ()
                                        ~R# Control.Lens.Empty.AsEmpty (Main.List GHC.Types.Int)))
                            @(Data.Functor.Const.Const (Main.List GHC.Types.Int))
                            (Data.Functor.Contravariant.$fContravariantConst
                               @(Main.List GHC.Types.Int))
                            (Data.Functor.Const.$fFunctorConst @(Main.List GHC.Types.Int))
                            ((\ (ds_abdj :: Main.List GHC.Types.Int) -> ds_abdj)
                             `cast` (<Main.List GHC.Types.Int>_R
                                     %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                                        <*>_N
                                                                        <Main.List GHC.Types.Int>_R
                                                                        <Main.List GHC.Types.Int>_P)
                                     :: (Main.List GHC.Types.Int -> Main.List GHC.Types.Int)
                                        ~R# (Main.List GHC.Types.Int
                                             -> Data.Functor.Const.Const
                                                  (Main.List GHC.Types.Int)
                                                  (Main.List GHC.Types.Int))))
                            s_a8Oi)
                         `cast` (Data.Functor.Const.N:Const[0]
                                     <*>_N <Main.List GHC.Types.Int>_R <[GHC.Types.Int]>_P
                                 :: Data.Functor.Const.Const
                                      (Main.List GHC.Types.Int) [GHC.Types.Int]
                                    ~R# Main.List GHC.Types.Int)))
                     `cast` (Data.Functor.Const.N:Const[0]
                                 <*>_N <[GHC.Types.Int]>_R <Main.List GHC.Types.Int>_P
                             :: Data.Functor.Const.Const
                                  [GHC.Types.Int] (Main.List GHC.Types.Int)
                                ~R# [GHC.Types.Int])
              ValArg s_a8Oi
    Cont:   Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: unpack-list
    Module: (GHC.Base)
    Before: GHC.CString.unpackFoldrCString#
              TyArg [GHC.Types.Char]
              ValArg "Properties"#
              ValArg \ (ds_abTz :: GHC.Types.Char)
                       (ds1_abTA :: [GHC.Types.Char]) ->
                       GHC.Types.: @GHC.Types.Char ds_abTz ds1_abTA
              ValArg GHC.Types.[] @GHC.Types.Char
    After:  (\ (a_ab61 :: GHC.Prim.Addr#) ->
               GHC.CString.unpackCString# a_ab61)
              "Properties"#
    Cont:   Stop[RhsCtxt(NonRecursive)] [GHC.Types.Char]
Rule fired
    Rule: unpack-list
    Module: (GHC.Base)
    Before: GHC.CString.unpackFoldrCString#
              TyArg [GHC.Types.Char]
              ValArg "[a] -> [a]"#
              ValArg \ (ds_abTz :: GHC.Types.Char)
                       (ds1_abTA :: [GHC.Types.Char]) ->
                       GHC.Types.: @GHC.Types.Char ds_abTz ds1_abTA
              ValArg GHC.Types.[] @GHC.Types.Char
    After:  (\ (a_ab61 :: GHC.Prim.Addr#) ->
               GHC.CString.unpackCString# a_ab61)
              "[a] -> [a]"#
    Cont:   Stop[BoringCtxt] Test.Tasty.Core.TestName
Rule fired
    Rule: unpack-list
    Module: (GHC.Base)
    Before: GHC.CString.unpackFoldrCString#
              TyArg [GHC.Types.Char]
              ValArg "T -> T"#
              ValArg \ (ds_abTz :: GHC.Types.Char)
                       (ds1_abTA :: [GHC.Types.Char]) ->
                       GHC.Types.: @GHC.Types.Char ds_abTz ds1_abTA
              ValArg GHC.Types.[] @GHC.Types.Char
    After:  (\ (a_ab61 :: GHC.Prim.Addr#) ->
               GHC.CString.unpackCString# a_ab61)
              "T -> T"#
    Cont:   Stop[BoringCtxt] Test.Tasty.Core.TestName
Rule fired
    Rule: unpack-list
    Module: (GHC.Base)
    Before: GHC.CString.unpackFoldrCString#
              TyArg [GHC.Types.Char]
              ValArg "TL -> TL"#
              ValArg \ (ds_abTz :: GHC.Types.Char)
                       (ds1_abTA :: [GHC.Types.Char]) ->
                       GHC.Types.: @GHC.Types.Char ds_abTz ds1_abTA
              ValArg GHC.Types.[] @GHC.Types.Char
    After:  (\ (a_ab61 :: GHC.Prim.Addr#) ->
               GHC.CString.unpackCString# a_ab61)
              "TL -> TL"#
    Cont:   Stop[BoringCtxt] Test.Tasty.Core.TestName
Rule fired
    Rule: unpack-list
    Module: (GHC.Base)
    Before: GHC.CString.unpackFoldrCString#
              TyArg [GHC.Types.Char]
              ValArg "B -> B"#
              ValArg \ (ds_abTz :: GHC.Types.Char)
                       (ds1_abTA :: [GHC.Types.Char]) ->
                       GHC.Types.: @GHC.Types.Char ds_abTz ds1_abTA
              ValArg GHC.Types.[] @GHC.Types.Char
    After:  (\ (a_ab61 :: GHC.Prim.Addr#) ->
               GHC.CString.unpackCString# a_ab61)
              "B -> B"#
    Cont:   Stop[BoringCtxt] Test.Tasty.Core.TestName
Rule fired
    Rule: unpack-list
    Module: (GHC.Base)
    Before: GHC.CString.unpackFoldrCString#
              TyArg [GHC.Types.Char]
              ValArg "L -> L"#
              ValArg \ (ds_abTz :: GHC.Types.Char)
                       (ds1_abTA :: [GHC.Types.Char]) ->
                       GHC.Types.: @GHC.Types.Char ds_abTz ds1_abTA
              ValArg GHC.Types.[] @GHC.Types.Char
    After:  (\ (a_ab61 :: GHC.Prim.Addr#) ->
               GHC.CString.unpackCString# a_ab61)
              "L -> L"#
    Cont:   Stop[BoringCtxt] Test.Tasty.Core.TestName
Rule fired
    Rule: unpack-list
    Module: (GHC.Base)
    Before: GHC.CString.unpackFoldrCString#
              TyArg [GHC.Types.Char]
              ValArg "Str -> T -> Str"#
              ValArg \ (ds_abTz :: GHC.Types.Char)
                       (ds1_abTA :: [GHC.Types.Char]) ->
                       GHC.Types.: @GHC.Types.Char ds_abTz ds1_abTA
              ValArg GHC.Types.[] @GHC.Types.Char
    After:  (\ (a_ab61 :: GHC.Prim.Addr#) ->
               GHC.CString.unpackCString# a_ab61)
              "Str -> T -> Str"#
    Cont:   Stop[BoringCtxt] Test.Tasty.Core.TestName
Rule fired
    Rule: unpack-list
    Module: (GHC.Base)
    Before: GHC.CString.unpackFoldrCString#
              TyArg [GHC.Types.Char]
              ValArg "Str -> TL -> Str"#
              ValArg \ (ds_abTz :: GHC.Types.Char)
                       (ds1_abTA :: [GHC.Types.Char]) ->
                       GHC.Types.: @GHC.Types.Char ds_abTz ds1_abTA
              ValArg GHC.Types.[] @GHC.Types.Char
    After:  (\ (a_ab61 :: GHC.Prim.Addr#) ->
               GHC.CString.unpackCString# a_ab61)
              "Str -> TL -> Str"#
    Cont:   Stop[BoringCtxt] Test.Tasty.Core.TestName
Rule fired
    Rule: LAZY STREAM stream/unstream fusion
    Module: (Data.Text.Internal.Lazy.Fusion)
    Before: Data.Text.Internal.Lazy.Fusion.stream
              ValArg Data.Text.Internal.Lazy.Fusion.unstream
                       (Data.Text.Internal.Fusion.Common.streamList
                          @GHC.Types.Char
                          (GHC.Base.map
                             @GHC.Types.Char @GHC.Types.Char Data.Text.Internal.safe s_a8Od))
    After:  (\ (s_abZ2
                  :: Data.Text.Internal.Fusion.Types.Stream GHC.Types.Char) ->
               s_abZ2)
              (Data.Text.Internal.Fusion.Common.streamList
                 @GHC.Types.Char
                 (GHC.Base.map
                    @GHC.Types.Char @GHC.Types.Char Data.Text.Internal.safe s_a8Od))
    Cont:   StrictArg Data.Text.Internal.Fusion.Common.unstreamList
            StrictArg GHC.Base.eqString
            ApplyToVal nodup hole GHC.Base.String -> GHC.Types.Bool s_a8Od
            Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: unpack-list
    Module: (GHC.Base)
    Before: GHC.CString.unpackFoldrCString#
              TyArg [GHC.Types.Char]
              ValArg "T -> TL -> T"#
              ValArg \ (ds_abTz :: GHC.Types.Char)
                       (ds1_abTA :: [GHC.Types.Char]) ->
                       GHC.Types.: @GHC.Types.Char ds_abTz ds1_abTA
              ValArg GHC.Types.[] @GHC.Types.Char
    After:  (\ (a_ab61 :: GHC.Prim.Addr#) ->
               GHC.CString.unpackCString# a_ab61)
              "T -> TL -> T"#
    Cont:   Stop[BoringCtxt] Test.Tasty.Core.TestName
Rule fired
    Rule: ==#
    Module: (BUILTIN)
    Before: GHC.Prim.==# ValArg ds2_abo6 ValArg 0#
    After:  case ds2_abo6 of wild_00 {
              __DEFAULT -> 0#;
              0# -> 1#
            }
    Cont:   StrictArg GHC.Prim.tagToEnum#
            Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: tagToEnum#
    Module: (BUILTIN)
    Before: GHC.Prim.tagToEnum# TyArg GHC.Types.Bool ValArg 0#
    After:  GHC.Types.False
    Cont:   Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: tagToEnum#
    Module: (BUILTIN)
    Before: GHC.Prim.tagToEnum# TyArg GHC.Types.Bool ValArg 1#
    After:  GHC.Types.True
    Cont:   Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: unpack-list
    Module: (GHC.Base)
    Before: GHC.CString.unpackFoldrCString#
              TyArg [GHC.Types.Char]
              ValArg "[W8] -> B -> [W8]"#
              ValArg \ (ds_abTz :: GHC.Types.Char)
                       (ds1_abTA :: [GHC.Types.Char]) ->
                       GHC.Types.: @GHC.Types.Char ds_abTz ds1_abTA
              ValArg GHC.Types.[] @GHC.Types.Char
    After:  (\ (a_ab61 :: GHC.Prim.Addr#) ->
               GHC.CString.unpackCString# a_ab61)
              "[W8] -> B -> [W8]"#
    Cont:   Stop[BoringCtxt] Test.Tasty.Core.TestName
Rule fired
    Rule: ByteString unpack-list
    Module: (Data.ByteString)
    Before: Data.ByteString.unpackFoldr
              TyArg [GHC.Word.Word8]
              ValArg Data.ByteString.Internal.Type.BS
                       ww1_ac15 (GHC.ForeignPtr.PlainPtr ww2_ac16) ww3_ac17
              ValArg \ (ds_abTz :: GHC.Word.Word8)
                       (ds1_abTA :: [GHC.Word.Word8]) ->
                       GHC.Types.: @GHC.Word.Word8 ds_abTz ds1_abTA
              ValArg GHC.Types.[] @GHC.Word.Word8
    After:  (\ (bs_abqF :: Data.ByteString.Internal.Type.ByteString) ->
               Data.ByteString.Internal.Type.unpackBytes bs_abqF)
              (Data.ByteString.Internal.Type.BS
                 ww1_ac15 (GHC.ForeignPtr.PlainPtr ww2_ac16) ww3_ac17)
    Cont:   StrictArg GHC.Classes.$fEqList_$c==
            ApplyToVal nodup hole [GHC.Word.Word8] -> GHC.Types.Bool s_a8Of
            Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: unpack-list
    Module: (GHC.Base)
    Before: GHC.CString.unpackFoldrCString#
              TyArg [GHC.Types.Char]
              ValArg "[W8] -> L -> [W8]"#
              ValArg \ (ds_abTz :: GHC.Types.Char)
                       (ds1_abTA :: [GHC.Types.Char]) ->
                       GHC.Types.: @GHC.Types.Char ds_abTz ds1_abTA
              ValArg GHC.Types.[] @GHC.Types.Char
    After:  (\ (a_ab61 :: GHC.Prim.Addr#) ->
               GHC.CString.unpackCString# a_ab61)
              "[W8] -> L -> [W8]"#
    Cont:   Stop[BoringCtxt] Test.Tasty.Core.TestName
Rule fired
    Rule: unpack-list
    Module: (GHC.Base)
    Before: GHC.CString.unpackFoldrCString#
              TyArg [GHC.Types.Char]
              ValArg "B -> L -> B"#
              ValArg \ (ds_abTz :: GHC.Types.Char)
                       (ds1_abTA :: [GHC.Types.Char]) ->
                       GHC.Types.: @GHC.Types.Char ds_abTz ds1_abTA
              ValArg GHC.Types.[] @GHC.Types.Char
    After:  (\ (a_ab61 :: GHC.Prim.Addr#) ->
               GHC.CString.unpackCString# a_ab61)
              "B -> L -> B"#
    Cont:   Stop[BoringCtxt] Test.Tasty.Core.TestName
Rule fired
    Rule: /=#
    Module: (BUILTIN)
    Before: GHC.Prim./=# ValArg 0# ValArg 0#
    After:  0#
    Cont:   Select nodup lwild_sc1E
            Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: <#
    Module: (BUILTIN)
    Before: GHC.Prim.<# ValArg 0# ValArg 0#
    After:  0#
    Cont:   Select nodup lwild_ac1H
            Select ok lwild1_abra
            Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: ==#
    Module: (BUILTIN)
    Before: GHC.Prim.==# ValArg 0# ValArg 0#
    After:  1#
    Cont:   Select nodup lwild1_ac1I
            Select ok lwild1_abra
            Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: <=#
    Module: (BUILTIN)
    Before: GHC.Prim.<=# ValArg 0# ValArg 0#
    After:  1#
    Cont:   Select nodup lwild_abTm
            Select ok lwild1_abra
            Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: intToInt64#
    Module: (BUILTIN)
    Before: GHC.Prim.intToInt64# ValArg 0#
    After:  0#Int64
    Cont:   StrictArg GHC.Prim.int64ToWord64#
            StrictArg {__ffi_static_ccall_unsafe bytestring-0.11.5.3:memcmp :: Addr#
                                                         -> Addr#
                                                         -> Word64#
                                                         -> State# RealWorld
                                                         -> (# State# RealWorld, Int32# #)}_abT9
            ApplyToVal nodup hole GHC.Prim.State# GHC.Prim.RealWorld
                                  -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Prim.Int32# #)
              GHC.Prim.realWorld#
            Select nodup wild_abTa
            Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: int64ToWord64#
    Module: (BUILTIN)
    Before: GHC.Prim.int64ToWord64# ValArg 0#Int64
    After:  0#Word64
    Cont:   StrictArg {__ffi_static_ccall_unsafe bytestring-0.11.5.3:memcmp :: Addr#
                                                         -> Addr#
                                                         -> Word64#
                                                         -> State# RealWorld
                                                         -> (# State# RealWorld, Int32# #)}_abT9
            ApplyToVal nodup hole GHC.Prim.State# GHC.Prim.RealWorld
                                  -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Prim.Int32# #)
              GHC.Prim.realWorld#
            Select nodup wild_abTa
            Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: unpack-list
    Module: (GHC.Base)
    Before: GHC.CString.unpackFoldrCString#
              TyArg [GHC.Types.Char]
              ValArg "[a] -> List a -> [a]"#
              ValArg \ (ds_abTz :: GHC.Types.Char)
                       (ds1_abTA :: [GHC.Types.Char]) ->
                       GHC.Types.: @GHC.Types.Char ds_abTz ds1_abTA
              ValArg GHC.Types.[] @GHC.Types.Char
    After:  (\ (a_ab61 :: GHC.Prim.Addr#) ->
               GHC.CString.unpackCString# a_ab61)
              "[a] -> List a -> [a]"#
    Cont:   Stop[BoringCtxt] Test.Tasty.Core.TestName
Rule fired
    Rule: ==#
    Module: (BUILTIN)
    Before: GHC.Prim.==# ValArg bx2_abnX ValArg 0#
    After:  case bx2_abnX of wild_00 {
              __DEFAULT -> 0#;
              0# -> 1#
            }
    Cont:   Select nodup lwild_sc0V
            Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: /=#
    Module: (BUILTIN)
    Before: GHC.Prim./=# ValArg ds1_abqU ValArg ds1_abqU
    After:  0#
    Cont:   Select nodup lwild_sc1E
            Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: <#
    Module: (BUILTIN)
    Before: GHC.Prim.<# ValArg ds1_abqU ValArg ds1_abqU
    After:  0#
    Cont:   Select nodup lwild_ac1H
            Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: ==#
    Module: (BUILTIN)
    Before: GHC.Prim.==# ValArg ds1_abqU ValArg ds1_abqU
    After:  1#
    Cont:   Select nodup lwild1_ac1I
            Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: <=#
    Module: (BUILTIN)
    Before: GHC.Prim.<=# ValArg ds1_abqU ValArg ds1_abqU
    After:  1#
    Cont:   Select nodup lwild_abTm
            Stop[BoringCtxt] GHC.Types.Bool
[2 of 2] Linking /tmp/workdir-concise/concise-0.1.0.1/dist-newstyle/build/x86_64-linux/ghc-9.6.6/concise-0.1.0.1/t/tests/build/tests/tests
