Build profile: -w ghc-9.6.6 -O1
In order, the following will be built (use -v for more details):
 - concise-0.1.0.1 (lib) (first run)
 - concise-0.1.0.1 (test:tests) (first run)
Configuring library for concise-0.1.0.1...
Preprocessing library for concise-0.1.0.1...
Building library for concise-0.1.0.1...
[1 of 1] Compiling Control.Lens.Cons.Extras

src/Control/Lens/Cons/Extras.hs:45:1: warning: [-Wunused-imports]
    The import of ‘Control.Lens’ is redundant
      except perhaps to import instances from ‘Control.Lens’
    To import instances alone, use: import Control.Lens()
   |
45 | import Control.Lens ((#))
   | ^^^^^^^^^^^^^^^^^^^^^^^^^

src/Control/Lens/Cons/Extras.hs:46:1: warning: [-Wunused-imports]
    The import of ‘Control.Lens.Cons’ is redundant
      except perhaps to import instances from ‘Control.Lens.Cons’
    To import instances alone, use: import Control.Lens.Cons()
   |
46 | import Control.Lens.Cons (Cons, cons, uncons)
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

src/Control/Lens/Cons/Extras.hs:47:1: warning: [-Wunused-imports]
    The import of ‘Control.Lens.Empty’ is redundant
      except perhaps to import instances from ‘Control.Lens.Empty’
    To import instances alone, use: import Control.Lens.Empty()
   |
47 | import Control.Lens.Empty (AsEmpty(..))
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

src/Control/Lens/Cons/Extras.hs:48:1: warning: [-Wunused-imports]
    The import of ‘Control.Lens.Fold’ is redundant
      except perhaps to import instances from ‘Control.Lens.Fold’
    To import instances alone, use: import Control.Lens.Fold()
   |
48 | import Control.Lens.Fold (foldrOf, unfolded)
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

src/Control/Lens/Cons/Extras.hs:50:1: warning: [-Wunused-imports]
    The import of ‘Control.Lens.Iso’ is redundant
      except perhaps to import instances from ‘Control.Lens.Iso’
    To import instances alone, use: import Control.Lens.Iso()
   |
50 | import Control.Lens.Iso (lazy, strict)
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Configuring test suite 'tests' for concise-0.1.0.1...
Preprocessing test suite 'tests' for concise-0.1.0.1...
Building test suite 'tests' for concise-0.1.0.1...
[1 of 1] Compiling Main
Rule fired
    Rule: Class op ==
    Module: (BUILTIN)
    Before: GHC.Classes.==
              TyArg Main.List a_a9hH
              ValArg Main.$fEqList @a_a9hH $dEq_a9hI
              ValArg eta_B0
              ValArg eta_B1
    After:  $c==_a9hK @a_a9hH $dEq_a9hI ValArg eta_B0 ValArg eta_B1
    Cont:   Select nodup wild_aaYL
            Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: Class op ==
    Module: (BUILTIN)
    Before: GHC.Classes.==
              TyArg Main.List a_a9hH ValArg $dEq_aaYI ValArg x_aaYJ ValArg y_aaYK
    After:  $c==_a9hK @a_a9hH $dEq_a9hI ValArg x_aaYJ ValArg y_aaYK
    Cont:   Select nodup wild_aaYL
            Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: Class op ==
    Module: (BUILTIN)
    Before: GHC.Classes.==
              TyArg Main.List a_a9hH
              ValArg $dEq_a9i5
              ValArg a2_a8Q6
              ValArg b2_a8Q8
    After:  $c==_a9hK @a_a9hH $dEq_a9hI ValArg a2_a8Q6 ValArg b2_a8Q8
    Cont:   Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: USPEC $fEqList @Int
    Module: (GHC.Classes)
    Before: GHC.Classes.$fEqList
              TyArg GHC.Types.Int ValArg GHC.Classes.$fEqInt
    After:  (\ ($dEq_ab6t :: GHC.Classes.Eq GHC.Types.Int) ->
               GHC.Classes.$fEqList_$s$fEqList)
              GHC.Classes.$fEqInt
    Cont:   Stop[RhsCtxt(NonRecursive)] GHC.Classes.Eq [GHC.Types.Int]
Rule fired
    Rule: USPEC $fEqList @Char
    Module: (GHC.Classes)
    Before: GHC.Classes.$fEqList
              TyArg GHC.Types.Char ValArg GHC.Classes.$fEqChar
    After:  (\ ($dEq_ab6u :: GHC.Classes.Eq GHC.Types.Char) ->
               GHC.Classes.$fEqList_$s$fEqList1)
              GHC.Classes.$fEqChar
    Cont:   Stop[RhsCtxt(NonRecursive)] GHC.Classes.Eq [GHC.Types.Char]
Rule fired
    Rule: USPEC $fShowList @Char
    Module: (GHC.Show)
    Before: GHC.Show.$fShowList
              TyArg GHC.Types.Char ValArg GHC.Show.$fShowChar
    After:  (\ ($dShow_ab6x :: GHC.Show.Show GHC.Types.Char) ->
               GHC.Show.$fShowList_$s$fShowList1)
              GHC.Show.$fShowChar
    Cont:   Stop[RhsCtxt(NonRecursive)] GHC.Show.Show [GHC.Types.Char]
Rule fired
    Rule: unpack
    Module: (GHC.Base)
    Before: GHC.CString.unpackCString# ValArg "Properties"#
    After:  (\ (a_ab6H :: GHC.Prim.Addr#) ->
               GHC.Base.build
                 @GHC.Types.Char
                 (\ (@b_ab6I) -> GHC.CString.unpackFoldrCString# @b_ab6I a_ab6H))
              "Properties"#
    Cont:   Stop[BoringCtxt] Test.Tasty.Core.TestName
Rule fired
    Rule: unpack
    Module: (GHC.Base)
    Before: GHC.CString.unpackCString# ValArg "[a] -> [a]"#
    After:  (\ (a_ab6H :: GHC.Prim.Addr#) ->
               GHC.Base.build
                 @GHC.Types.Char
                 (\ (@b_ab6I) -> GHC.CString.unpackFoldrCString# @b_ab6I a_ab6H))
              "[a] -> [a]"#
    Cont:   Stop[BoringCtxt] Test.Tasty.Core.TestName
Rule fired
    Rule: Class op property
    Module: (BUILTIN)
    Before: Test.QuickCheck.Property.property
              TyArg GHC.Base.String -> GHC.Types.Bool ValArg $dTestable_a91r
    After:  Test.QuickCheck.Property.$fTestableFUN_$cproperty
              @[GHC.Types.Char]
              @GHC.Types.Bool
              $dArbitrary_a9IP
              GHC.Show.$fShowList_$s$fShowList1
              Test.QuickCheck.Property.$fTestableBool
    Cont:   ApplyToVal nodup hole (GHC.Base.String -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              prop_ab6U
            CastIt (Sym (Test.Tasty.QuickCheck.N:QC[0])
                    :: Test.QuickCheck.Property.Property ~R# Test.Tasty.QuickCheck.QC)
            Stop[BoringCtxt] Test.Tasty.QuickCheck.QC
Rule fired
    Rule: Class op propertyForAllShrinkShow
    Module: (BUILTIN)
    Before: Test.QuickCheck.Property.propertyForAllShrinkShow
              TyArg GHC.Types.Bool ValArg Test.QuickCheck.Property.$fTestableBool
    After:  Test.QuickCheck.Property.$fTestableBool1
            `cast` (forall (a :: <*>_N).
                    <Test.QuickCheck.Gen.Gen a>_R
                    %<'GHC.Types.Many>_N ->_R <a -> [a]>_R
                    %<'GHC.Types.Many>_N ->_R <a -> [GHC.Base.String]>_R
                    %<'GHC.Types.Many>_N ->_R <a -> GHC.Types.Bool>_R
                    %<'GHC.Types.Many>_N ->_R Sym (Test.QuickCheck.Gen.N:Gen[0]
                                                       (Test.QuickCheck.Property.N:Prop[0]))
                                              ; Sym (Test.QuickCheck.Property.N:Property[0])
                    :: (forall {a}.
                        Test.QuickCheck.Gen.Gen a
                        -> (a -> [a])
                        -> (a -> [GHC.Base.String])
                        -> (a -> GHC.Types.Bool)
                        -> Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int
                        -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result)
                       ~R# (forall {a}.
                            Test.QuickCheck.Gen.Gen a
                            -> (a -> [a])
                            -> (a -> [GHC.Base.String])
                            -> (a -> GHC.Types.Bool)
                            -> Test.QuickCheck.Property.Property))
    Cont:   ApplyToTy [GHC.Types.Char]
            ApplyToVal nodup hole Test.QuickCheck.Gen.Gen [GHC.Types.Char]
                                  -> ([GHC.Types.Char] -> [[GHC.Types.Char]])
                                  -> ([GHC.Types.Char] -> [GHC.Base.String])
                                  -> ([GHC.Types.Char] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (Test.QuickCheck.Arbitrary.arbitrary @a_ab8C $dArbitrary_ab8E)
            ApplyToVal nodup hole ([GHC.Types.Char] -> [[GHC.Types.Char]])
                                  -> ([GHC.Types.Char] -> [GHC.Base.String])
                                  -> ([GHC.Types.Char] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (Test.QuickCheck.Arbitrary.shrink @a_ab8C $dArbitrary_ab8E)
            ApplyToVal nodup hole ([GHC.Types.Char] -> [GHC.Base.String])
                                  -> ([GHC.Types.Char] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (let {
                 g_ab8I [Occ=OnceL1!] :: a_ab8C -> GHC.Base.String
                 [LclId]
                 g_ab8I = GHC.Show.show @a_ab8C $dShow_ab8F } in
               \ (x_ab8J [Occ=Once1] :: a_ab8C) ->
                 GHC.Types.:
                   @GHC.Base.String (g_ab8I x_ab8J) (GHC.Types.[] @GHC.Base.String))
            ApplyToVal nodup hole ([GHC.Types.Char] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              f_ab8H
            CastIt (Sym (Test.Tasty.QuickCheck.N:QC[0])
                    :: Test.QuickCheck.Property.Property ~R# Test.Tasty.QuickCheck.QC)
            Stop[BoringCtxt] Test.Tasty.QuickCheck.QC
Rule fired
    Rule: Class op arbitrary
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.arbitrary
              TyArg [GHC.Types.Char] ValArg $dArbitrary_a9IP
    After:  (Test.QuickCheck.Arbitrary.$fArbitraryList1
               @GHC.Types.Char Test.QuickCheck.Arbitrary.$fArbitraryChar)
            `cast` (Sym (Test.QuickCheck.Gen.N:Gen[0] <[GHC.Types.Char]>_R)
                    :: (Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int -> [GHC.Types.Char])
                       ~R# Test.QuickCheck.Gen.Gen [GHC.Types.Char])
    Cont:   Stop[BoringCtxt] Test.QuickCheck.Gen.Gen [GHC.Types.Char]
Rule fired
    Rule: Class op arbitrary
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.arbitrary
              TyArg GHC.Types.Char
              ValArg Test.QuickCheck.Arbitrary.$fArbitraryChar
    After:  Test.QuickCheck.Arbitrary.$fArbitraryChar_$carbitrary
    Cont:   Stop[BoringCtxt, C(S,C(1,L))] Test.QuickCheck.Gen.Gen
                                            GHC.Types.Char
Rule fired
    Rule: Class op shrink
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.shrink
              TyArg [GHC.Types.Char] ValArg $dArbitrary_a9IP
    After:  Test.QuickCheck.Arbitrary.$fArbitraryList_$cshrink
              @GHC.Types.Char Test.QuickCheck.Arbitrary.$fArbitraryChar
    Cont:   Stop[BoringCtxt] [GHC.Types.Char] -> [[GHC.Types.Char]]
Rule fired
    Rule: Class op shrink
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.shrink
              TyArg GHC.Types.Char
              ValArg Test.QuickCheck.Arbitrary.$fArbitraryChar
    After:  Test.QuickCheck.Arbitrary.$fArbitraryChar_$cshrink
    Cont:   Stop[DiscArgCtxt, C(S,L)] GHC.Types.Char
                                      -> [GHC.Types.Char]
Rule fired
    Rule: Class op show
    Module: (BUILTIN)
    Before: GHC.Show.show
              TyArg [GHC.Types.Char] ValArg GHC.Show.$fShowList_$s$fShowList1
    After:  GHC.Show.$fShowList_$s$cshow1
    Cont:   Stop[RhsCtxt(NonRecursive)] [GHC.Types.Char]
                                        -> GHC.Base.String
Rule fired
    Rule: Class op reader
    Module: (BUILTIN)
    Before: Control.Monad.Reader.Class.reader
              TyArg [GHC.Types.Char]
              TyArg (->) GHC.Base.String
              ValArg Control.Monad.Reader.Class.$fMonadReaderrFUN
                       @[GHC.Types.Char]
    After:  \ (@a_abe8) -> GHC.Base.id @([GHC.Types.Char] -> a_abe8)
    Cont:   ApplyToTy GHC.Base.String
            ApplyToVal nodup hole ([GHC.Types.Char] -> GHC.Base.String)
                                  -> GHC.Base.String -> GHC.Base.String
              ((l_abe2
                  ((\ (ds_abe3 [Occ=Once1] :: a_abe0) -> ds_abe3)
                   `cast` (<a_abe0>_R
                           %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                              <*>_N <a_abe0>_R <a_abe0>_P)
                           :: (a_abe0 -> a_abe0)
                              ~R# (a_abe0 -> Data.Functor.Const.Const a_abe0 a_abe0))))
               `cast` (<s_abdY>_R
                       %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                     <*>_N <a_abe0>_R <s_abdY>_P
                       :: (s_abdY -> Data.Functor.Const.Const a_abe0 s_abdY)
                          ~R# (s_abdY -> a_abe0)))
            ApplyToVal nodup hole GHC.Base.String -> GHC.Base.String s_a8Jf
            Stop[RuleArgCtxt] GHC.Base.String
Rule fired
    Rule: recons/id
    Module: (Control.Lens.Cons.Extras)
    Before: Control.Lens.Cons.Extras.recons
              TyArg [GHC.Types.Char]
              TyArg GHC.Types.Char
              TyArg GHC.Base.String
              ValArg (\ (@(p_abfz :: * -> * -> *))
                        (@(f_abfA :: * -> *))
                        ($dChoice_abfB :: Data.Profunctor.Choice.Choice p_abfz)
                        ($dApplicative_abfC :: GHC.Base.Applicative f_abfA) ->
                        let {
                          f1_abfD
                            :: p_abfz
                                 (Data.Either.Either
                                    [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                                 (Data.Either.Either
                                    [GHC.Types.Char] (f_abfA (GHC.Types.Char, [GHC.Types.Char])))
                               -> p_abfz [GHC.Types.Char] (f_abfA [GHC.Types.Char])
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 320 0}]
                          f1_abfD
                            = Data.Profunctor.Unsafe.dimap
                                @p_abfz
                                (Data.Profunctor.Choice.$p1Choice @p_abfz $dChoice_abfB)
                                @[GHC.Types.Char]
                                @(Data.Either.Either
                                    [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                                @(Data.Either.Either
                                    [GHC.Types.Char] (f_abfA (GHC.Types.Char, [GHC.Types.Char])))
                                @(f_abfA [GHC.Types.Char])
                                (\ (aas_abfE :: [GHC.Types.Char]) ->
                                   case aas_abfE of {
                                     [] ->
                                       Data.Either.Left
                                         @[GHC.Types.Char]
                                         @(GHC.Types.Char, [GHC.Types.Char])
                                         (GHC.Types.[] @GHC.Types.Char);
                                     : a1_abfG as_abfH ->
                                       Data.Either.Right
                                         @[GHC.Types.Char]
                                         @(GHC.Types.Char, [GHC.Types.Char])
                                         (a1_abfG, as_abfH)
                                   })
                                (let {
                                   f2_abfJ :: [GHC.Types.Char] -> f_abfA [GHC.Types.Char]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abfJ
                                     = GHC.Base.pure
                                         @f_abfA $dApplicative_abfC @[GHC.Types.Char] } in
                                 let {
                                   ds2_abfK
                                     :: f_abfA (GHC.Types.Char, [GHC.Types.Char])
                                        -> f_abfA [GHC.Types.Char]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 90 0}]
                                   ds2_abfK
                                     = GHC.Base.fmap
                                         @f_abfA
                                         (GHC.Base.$p1Applicative @f_abfA $dApplicative_abfC)
                                         @(GHC.Types.Char, [GHC.Types.Char])
                                         @[GHC.Types.Char]
                                         (\ (p1_abfL :: (GHC.Types.Char, [GHC.Types.Char])) ->
                                            GHC.Types.:
                                              @GHC.Types.Char
                                              (case p1_abfL of { (x_abfN, ds_abfO) -> x_abfN })
                                              (case p1_abfL of { (ds_abfR, y_abfS) ->
                                               y_abfS
                                               })) } in
                                 \ (ds3_abfU
                                      :: Data.Either.Either
                                           [GHC.Types.Char]
                                           (f_abfA (GHC.Types.Char, [GHC.Types.Char]))) ->
                                   case ds3_abfU of {
                                     Data.Either.Left x_abfW -> f2_abfJ x_abfW;
                                     Data.Either.Right y_abfY -> ds2_abfK y_abfY
                                   }) } in
                        let {
                          g_abg0
                            :: p_abfz
                                 (GHC.Types.Char, [GHC.Types.Char])
                                 (f_abfA (GHC.Types.Char, [GHC.Types.Char]))
                               -> p_abfz
                                    (Data.Either.Either
                                       [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                                    (Data.Either.Either
                                       [GHC.Types.Char] (f_abfA (GHC.Types.Char, [GHC.Types.Char])))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abg0
                            = Data.Profunctor.Choice.right'
                                @p_abfz
                                $dChoice_abfB
                                @(GHC.Types.Char, [GHC.Types.Char])
                                @(f_abfA (GHC.Types.Char, [GHC.Types.Char]))
                                @[GHC.Types.Char] } in
                        \ (x_abg1
                             :: p_abfz
                                  (GHC.Types.Char, [GHC.Types.Char])
                                  (f_abfA (GHC.Types.Char, [GHC.Types.Char]))) ->
                          f1_abfD (g_abg0 x_abg1))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <[GHC.Types.Char]>_N
                                      <[GHC.Types.Char]>_N
                                      <GHC.Types.Char>_N
                                      <GHC.Types.Char>_N)
                             :: Control.Lens.Type.Prism
                                  [GHC.Types.Char]
                                  [GHC.Types.Char]
                                  (GHC.Types.Char, [GHC.Types.Char])
                                  (GHC.Types.Char, [GHC.Types.Char])
                                ~R# Control.Lens.Cons.Cons
                                      [GHC.Types.Char]
                                      [GHC.Types.Char]
                                      GHC.Types.Char
                                      GHC.Types.Char)
              ValArg (\ (@(p_abfz :: * -> * -> *))
                        (@(f_abfA :: * -> *))
                        ($dChoice_abfB :: Data.Profunctor.Choice.Choice p_abfz)
                        ($dApplicative_abfC :: GHC.Base.Applicative f_abfA) ->
                        let {
                          f1_abfD
                            :: p_abfz
                                 (Data.Either.Either
                                    [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                                 (Data.Either.Either
                                    [GHC.Types.Char] (f_abfA (GHC.Types.Char, [GHC.Types.Char])))
                               -> p_abfz [GHC.Types.Char] (f_abfA [GHC.Types.Char])
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 320 0}]
                          f1_abfD
                            = Data.Profunctor.Unsafe.dimap
                                @p_abfz
                                (Data.Profunctor.Choice.$p1Choice @p_abfz $dChoice_abfB)
                                @[GHC.Types.Char]
                                @(Data.Either.Either
                                    [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                                @(Data.Either.Either
                                    [GHC.Types.Char] (f_abfA (GHC.Types.Char, [GHC.Types.Char])))
                                @(f_abfA [GHC.Types.Char])
                                (\ (aas_abfE :: [GHC.Types.Char]) ->
                                   case aas_abfE of {
                                     [] ->
                                       Data.Either.Left
                                         @[GHC.Types.Char]
                                         @(GHC.Types.Char, [GHC.Types.Char])
                                         (GHC.Types.[] @GHC.Types.Char);
                                     : a1_abfG as_abfH ->
                                       Data.Either.Right
                                         @[GHC.Types.Char]
                                         @(GHC.Types.Char, [GHC.Types.Char])
                                         (a1_abfG, as_abfH)
                                   })
                                (let {
                                   f2_abfJ :: [GHC.Types.Char] -> f_abfA [GHC.Types.Char]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abfJ
                                     = GHC.Base.pure
                                         @f_abfA $dApplicative_abfC @[GHC.Types.Char] } in
                                 let {
                                   ds2_abfK
                                     :: f_abfA (GHC.Types.Char, [GHC.Types.Char])
                                        -> f_abfA [GHC.Types.Char]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 90 0}]
                                   ds2_abfK
                                     = GHC.Base.fmap
                                         @f_abfA
                                         (GHC.Base.$p1Applicative @f_abfA $dApplicative_abfC)
                                         @(GHC.Types.Char, [GHC.Types.Char])
                                         @[GHC.Types.Char]
                                         (\ (p1_abfL :: (GHC.Types.Char, [GHC.Types.Char])) ->
                                            GHC.Types.:
                                              @GHC.Types.Char
                                              (case p1_abfL of { (x_abfN, ds_abfO) -> x_abfN })
                                              (case p1_abfL of { (ds_abfR, y_abfS) ->
                                               y_abfS
                                               })) } in
                                 \ (ds3_abfU
                                      :: Data.Either.Either
                                           [GHC.Types.Char]
                                           (f_abfA (GHC.Types.Char, [GHC.Types.Char]))) ->
                                   case ds3_abfU of {
                                     Data.Either.Left x_abfW -> f2_abfJ x_abfW;
                                     Data.Either.Right y_abfY -> ds2_abfK y_abfY
                                   }) } in
                        let {
                          g_abg0
                            :: p_abfz
                                 (GHC.Types.Char, [GHC.Types.Char])
                                 (f_abfA (GHC.Types.Char, [GHC.Types.Char]))
                               -> p_abfz
                                    (Data.Either.Either
                                       [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                                    (Data.Either.Either
                                       [GHC.Types.Char] (f_abfA (GHC.Types.Char, [GHC.Types.Char])))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abg0
                            = Data.Profunctor.Choice.right'
                                @p_abfz
                                $dChoice_abfB
                                @(GHC.Types.Char, [GHC.Types.Char])
                                @(f_abfA (GHC.Types.Char, [GHC.Types.Char]))
                                @[GHC.Types.Char] } in
                        \ (x_abg1
                             :: p_abfz
                                  (GHC.Types.Char, [GHC.Types.Char])
                                  (f_abfA (GHC.Types.Char, [GHC.Types.Char]))) ->
                          f1_abfD (g_abg0 x_abg1))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <[GHC.Types.Char]>_N
                                      <[GHC.Types.Char]>_N
                                      <GHC.Types.Char>_N
                                      <GHC.Types.Char>_N)
                             :: Control.Lens.Type.Prism
                                  [GHC.Types.Char]
                                  [GHC.Types.Char]
                                  (GHC.Types.Char, [GHC.Types.Char])
                                  (GHC.Types.Char, [GHC.Types.Char])
                                ~R# Control.Lens.Cons.Cons
                                      [GHC.Types.Char]
                                      [GHC.Types.Char]
                                      GHC.Types.Char
                                      GHC.Types.Char)
              ValArg (\ (@(p_abg6 :: * -> * -> *))
                        (@(f_abg7 :: * -> *))
                        ($dChoice_abg8 :: Data.Profunctor.Choice.Choice p_abg6)
                        ($dApplicative_abg9 :: GHC.Base.Applicative f_abg7) ->
                        let {
                          f1_abga
                            :: p_abg6
                                 (Data.Either.Either [GHC.Types.Char] ())
                                 (Data.Either.Either [GHC.Types.Char] (f_abg7 ()))
                               -> p_abg6 [GHC.Types.Char] (f_abg7 [GHC.Types.Char])
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 290 0}]
                          f1_abga
                            = Data.Profunctor.Unsafe.dimap
                                @p_abg6
                                (Data.Profunctor.Choice.$p1Choice @p_abg6 $dChoice_abg8)
                                @[GHC.Types.Char]
                                @(Data.Either.Either [GHC.Types.Char] ())
                                @(Data.Either.Either [GHC.Types.Char] (f_abg7 ()))
                                @(f_abg7 [GHC.Types.Char])
                                (\ (s_abgb :: [GHC.Types.Char]) ->
                                   case s_abgb of wild_abgc {
                                     [] ->
                                       Data.Either.Right @[GHC.Types.Char] @() GHC.Tuple.Prim.();
                                     : ds1_abgd ds2_abge ->
                                       Data.Either.Left @[GHC.Types.Char] @() wild_abgc
                                   })
                                (let {
                                   f2_abgg :: [GHC.Types.Char] -> f_abg7 [GHC.Types.Char]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abgg
                                     = GHC.Base.pure
                                         @f_abg7 $dApplicative_abg9 @[GHC.Types.Char] } in
                                 let {
                                   ds2_abgh :: f_abg7 () -> f_abg7 [GHC.Types.Char]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 70 0}]
                                   ds2_abgh
                                     = GHC.Base.fmap
                                         @f_abg7
                                         (GHC.Base.$p1Applicative @f_abg7 $dApplicative_abg9)
                                         @()
                                         @[GHC.Types.Char]
                                         (\ (ds3_abgi :: ()) ->
                                            case ds3_abgi of { () ->
                                            GHC.Types.[] @GHC.Types.Char
                                            }) } in
                                 \ (ds3_abgk :: Data.Either.Either [GHC.Types.Char] (f_abg7 ())) ->
                                   case ds3_abgk of {
                                     Data.Either.Left x_abgm -> f2_abgg x_abgm;
                                     Data.Either.Right y_abgo -> ds2_abgh y_abgo
                                   }) } in
                        let {
                          g_abgq
                            :: p_abg6 () (f_abg7 ())
                               -> p_abg6
                                    (Data.Either.Either [GHC.Types.Char] ())
                                    (Data.Either.Either [GHC.Types.Char] (f_abg7 ()))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abgq
                            = Data.Profunctor.Choice.right'
                                @p_abg6 $dChoice_abg8 @() @(f_abg7 ()) @[GHC.Types.Char] } in
                        \ (x_abgr :: p_abg6 () (f_abg7 ())) -> f1_abga (g_abgq x_abgr))
                     `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0] <[GHC.Types.Char]>_N)
                             :: Control.Lens.Type.Prism' [GHC.Types.Char] ()
                                ~R# Control.Lens.Empty.AsEmpty [GHC.Types.Char])
              TyArg Data.Functor.Const.Const GHC.Base.String
              ValArg Data.Functor.Contravariant.$fContravariantConst
                       @[GHC.Types.Char]
              ValArg Data.Functor.Const.$fFunctorConst @[GHC.Types.Char]
    After:  (\ (@s1_abf7)
               (@(f_abf8 :: * -> *))
               (@a_abf9)
               ($dCons_abfa
                  :: Control.Lens.Cons.Cons s1_abf7 s1_abf7 a_abf9 a_abf9)
               ($dCons1_abfb
                  :: Control.Lens.Cons.Cons s1_abf7 s1_abf7 a_abf9 a_abf9)
               ($dAsEmpty_abfc :: Control.Lens.Empty.AsEmpty s1_abf7)
               ($dContravariant_abfd
                  :: Data.Functor.Contravariant.Contravariant f_abf8)
               ($dFunctor_abfe :: GHC.Base.Functor f_abf8) ->
               GHC.Base.id @(s1_abf7 -> f_abf8 s1_abf7))
              @[GHC.Types.Char]
              @(Data.Functor.Const.Const GHC.Base.String)
              @GHC.Types.Char
              ((\ (@(p_abfz :: * -> * -> *))
                  (@(f_abfA :: * -> *))
                  ($dChoice_abfB :: Data.Profunctor.Choice.Choice p_abfz)
                  ($dApplicative_abfC :: GHC.Base.Applicative f_abfA) ->
                  let {
                    f1_abfD
                      :: p_abfz
                           (Data.Either.Either
                              [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                           (Data.Either.Either
                              [GHC.Types.Char] (f_abfA (GHC.Types.Char, [GHC.Types.Char])))
                         -> p_abfz [GHC.Types.Char] (f_abfA [GHC.Types.Char])
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 320 0}]
                    f1_abfD
                      = Data.Profunctor.Unsafe.dimap
                          @p_abfz
                          (Data.Profunctor.Choice.$p1Choice @p_abfz $dChoice_abfB)
                          @[GHC.Types.Char]
                          @(Data.Either.Either
                              [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                          @(Data.Either.Either
                              [GHC.Types.Char] (f_abfA (GHC.Types.Char, [GHC.Types.Char])))
                          @(f_abfA [GHC.Types.Char])
                          (\ (aas_abfE :: [GHC.Types.Char]) ->
                             case aas_abfE of {
                               [] ->
                                 Data.Either.Left
                                   @[GHC.Types.Char]
                                   @(GHC.Types.Char, [GHC.Types.Char])
                                   (GHC.Types.[] @GHC.Types.Char);
                               : a1_abfG as_abfH ->
                                 Data.Either.Right
                                   @[GHC.Types.Char]
                                   @(GHC.Types.Char, [GHC.Types.Char])
                                   (a1_abfG, as_abfH)
                             })
                          (let {
                             f2_abfJ :: [GHC.Types.Char] -> f_abfA [GHC.Types.Char]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abfJ
                               = GHC.Base.pure @f_abfA $dApplicative_abfC @[GHC.Types.Char] } in
                           let {
                             ds2_abfK
                               :: f_abfA (GHC.Types.Char, [GHC.Types.Char])
                                  -> f_abfA [GHC.Types.Char]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 90 0}]
                             ds2_abfK
                               = GHC.Base.fmap
                                   @f_abfA
                                   (GHC.Base.$p1Applicative @f_abfA $dApplicative_abfC)
                                   @(GHC.Types.Char, [GHC.Types.Char])
                                   @[GHC.Types.Char]
                                   (\ (p1_abfL :: (GHC.Types.Char, [GHC.Types.Char])) ->
                                      GHC.Types.:
                                        @GHC.Types.Char
                                        (case p1_abfL of { (x_abfN, ds_abfO) -> x_abfN })
                                        (case p1_abfL of { (ds_abfR, y_abfS) -> y_abfS })) } in
                           \ (ds3_abfU
                                :: Data.Either.Either
                                     [GHC.Types.Char]
                                     (f_abfA (GHC.Types.Char, [GHC.Types.Char]))) ->
                             case ds3_abfU of {
                               Data.Either.Left x_abfW -> f2_abfJ x_abfW;
                               Data.Either.Right y_abfY -> ds2_abfK y_abfY
                             }) } in
                  let {
                    g_abg0
                      :: p_abfz
                           (GHC.Types.Char, [GHC.Types.Char])
                           (f_abfA (GHC.Types.Char, [GHC.Types.Char]))
                         -> p_abfz
                              (Data.Either.Either
                                 [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                              (Data.Either.Either
                                 [GHC.Types.Char] (f_abfA (GHC.Types.Char, [GHC.Types.Char])))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abg0
                      = Data.Profunctor.Choice.right'
                          @p_abfz
                          $dChoice_abfB
                          @(GHC.Types.Char, [GHC.Types.Char])
                          @(f_abfA (GHC.Types.Char, [GHC.Types.Char]))
                          @[GHC.Types.Char] } in
                  \ (x_abg1
                       :: p_abfz
                            (GHC.Types.Char, [GHC.Types.Char])
                            (f_abfA (GHC.Types.Char, [GHC.Types.Char]))) ->
                    f1_abfD (g_abg0 x_abg1))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <[GHC.Types.Char]>_N
                                <[GHC.Types.Char]>_N
                                <GHC.Types.Char>_N
                                <GHC.Types.Char>_N)
                       :: Control.Lens.Type.Prism
                            [GHC.Types.Char]
                            [GHC.Types.Char]
                            (GHC.Types.Char, [GHC.Types.Char])
                            (GHC.Types.Char, [GHC.Types.Char])
                          ~R# Control.Lens.Cons.Cons
                                [GHC.Types.Char] [GHC.Types.Char] GHC.Types.Char GHC.Types.Char))
              ((\ (@(p_abfz :: * -> * -> *))
                  (@(f_abfA :: * -> *))
                  ($dChoice_abfB :: Data.Profunctor.Choice.Choice p_abfz)
                  ($dApplicative_abfC :: GHC.Base.Applicative f_abfA) ->
                  let {
                    f1_abfD
                      :: p_abfz
                           (Data.Either.Either
                              [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                           (Data.Either.Either
                              [GHC.Types.Char] (f_abfA (GHC.Types.Char, [GHC.Types.Char])))
                         -> p_abfz [GHC.Types.Char] (f_abfA [GHC.Types.Char])
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 320 0}]
                    f1_abfD
                      = Data.Profunctor.Unsafe.dimap
                          @p_abfz
                          (Data.Profunctor.Choice.$p1Choice @p_abfz $dChoice_abfB)
                          @[GHC.Types.Char]
                          @(Data.Either.Either
                              [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                          @(Data.Either.Either
                              [GHC.Types.Char] (f_abfA (GHC.Types.Char, [GHC.Types.Char])))
                          @(f_abfA [GHC.Types.Char])
                          (\ (aas_abfE :: [GHC.Types.Char]) ->
                             case aas_abfE of {
                               [] ->
                                 Data.Either.Left
                                   @[GHC.Types.Char]
                                   @(GHC.Types.Char, [GHC.Types.Char])
                                   (GHC.Types.[] @GHC.Types.Char);
                               : a1_abfG as_abfH ->
                                 Data.Either.Right
                                   @[GHC.Types.Char]
                                   @(GHC.Types.Char, [GHC.Types.Char])
                                   (a1_abfG, as_abfH)
                             })
                          (let {
                             f2_abfJ :: [GHC.Types.Char] -> f_abfA [GHC.Types.Char]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abfJ
                               = GHC.Base.pure @f_abfA $dApplicative_abfC @[GHC.Types.Char] } in
                           let {
                             ds2_abfK
                               :: f_abfA (GHC.Types.Char, [GHC.Types.Char])
                                  -> f_abfA [GHC.Types.Char]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 90 0}]
                             ds2_abfK
                               = GHC.Base.fmap
                                   @f_abfA
                                   (GHC.Base.$p1Applicative @f_abfA $dApplicative_abfC)
                                   @(GHC.Types.Char, [GHC.Types.Char])
                                   @[GHC.Types.Char]
                                   (\ (p1_abfL :: (GHC.Types.Char, [GHC.Types.Char])) ->
                                      GHC.Types.:
                                        @GHC.Types.Char
                                        (case p1_abfL of { (x_abfN, ds_abfO) -> x_abfN })
                                        (case p1_abfL of { (ds_abfR, y_abfS) -> y_abfS })) } in
                           \ (ds3_abfU
                                :: Data.Either.Either
                                     [GHC.Types.Char]
                                     (f_abfA (GHC.Types.Char, [GHC.Types.Char]))) ->
                             case ds3_abfU of {
                               Data.Either.Left x_abfW -> f2_abfJ x_abfW;
                               Data.Either.Right y_abfY -> ds2_abfK y_abfY
                             }) } in
                  let {
                    g_abg0
                      :: p_abfz
                           (GHC.Types.Char, [GHC.Types.Char])
                           (f_abfA (GHC.Types.Char, [GHC.Types.Char]))
                         -> p_abfz
                              (Data.Either.Either
                                 [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                              (Data.Either.Either
                                 [GHC.Types.Char] (f_abfA (GHC.Types.Char, [GHC.Types.Char])))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abg0
                      = Data.Profunctor.Choice.right'
                          @p_abfz
                          $dChoice_abfB
                          @(GHC.Types.Char, [GHC.Types.Char])
                          @(f_abfA (GHC.Types.Char, [GHC.Types.Char]))
                          @[GHC.Types.Char] } in
                  \ (x_abg1
                       :: p_abfz
                            (GHC.Types.Char, [GHC.Types.Char])
                            (f_abfA (GHC.Types.Char, [GHC.Types.Char]))) ->
                    f1_abfD (g_abg0 x_abg1))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <[GHC.Types.Char]>_N
                                <[GHC.Types.Char]>_N
                                <GHC.Types.Char>_N
                                <GHC.Types.Char>_N)
                       :: Control.Lens.Type.Prism
                            [GHC.Types.Char]
                            [GHC.Types.Char]
                            (GHC.Types.Char, [GHC.Types.Char])
                            (GHC.Types.Char, [GHC.Types.Char])
                          ~R# Control.Lens.Cons.Cons
                                [GHC.Types.Char] [GHC.Types.Char] GHC.Types.Char GHC.Types.Char))
              ((\ (@(p_abg6 :: * -> * -> *))
                  (@(f_abg7 :: * -> *))
                  ($dChoice_abg8 :: Data.Profunctor.Choice.Choice p_abg6)
                  ($dApplicative_abg9 :: GHC.Base.Applicative f_abg7) ->
                  let {
                    f1_abga
                      :: p_abg6
                           (Data.Either.Either [GHC.Types.Char] ())
                           (Data.Either.Either [GHC.Types.Char] (f_abg7 ()))
                         -> p_abg6 [GHC.Types.Char] (f_abg7 [GHC.Types.Char])
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 290 0}]
                    f1_abga
                      = Data.Profunctor.Unsafe.dimap
                          @p_abg6
                          (Data.Profunctor.Choice.$p1Choice @p_abg6 $dChoice_abg8)
                          @[GHC.Types.Char]
                          @(Data.Either.Either [GHC.Types.Char] ())
                          @(Data.Either.Either [GHC.Types.Char] (f_abg7 ()))
                          @(f_abg7 [GHC.Types.Char])
                          (\ (s_abgb :: [GHC.Types.Char]) ->
                             case s_abgb of wild_abgc {
                               [] -> Data.Either.Right @[GHC.Types.Char] @() GHC.Tuple.Prim.();
                               : ds1_abgd ds2_abge ->
                                 Data.Either.Left @[GHC.Types.Char] @() wild_abgc
                             })
                          (let {
                             f2_abgg :: [GHC.Types.Char] -> f_abg7 [GHC.Types.Char]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abgg
                               = GHC.Base.pure @f_abg7 $dApplicative_abg9 @[GHC.Types.Char] } in
                           let {
                             ds2_abgh :: f_abg7 () -> f_abg7 [GHC.Types.Char]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 70 0}]
                             ds2_abgh
                               = GHC.Base.fmap
                                   @f_abg7
                                   (GHC.Base.$p1Applicative @f_abg7 $dApplicative_abg9)
                                   @()
                                   @[GHC.Types.Char]
                                   (\ (ds3_abgi :: ()) ->
                                      case ds3_abgi of { () -> GHC.Types.[] @GHC.Types.Char }) } in
                           \ (ds3_abgk :: Data.Either.Either [GHC.Types.Char] (f_abg7 ())) ->
                             case ds3_abgk of {
                               Data.Either.Left x_abgm -> f2_abgg x_abgm;
                               Data.Either.Right y_abgo -> ds2_abgh y_abgo
                             }) } in
                  let {
                    g_abgq
                      :: p_abg6 () (f_abg7 ())
                         -> p_abg6
                              (Data.Either.Either [GHC.Types.Char] ())
                              (Data.Either.Either [GHC.Types.Char] (f_abg7 ()))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abgq
                      = Data.Profunctor.Choice.right'
                          @p_abg6 $dChoice_abg8 @() @(f_abg7 ()) @[GHC.Types.Char] } in
                  \ (x_abgr :: p_abg6 () (f_abg7 ())) -> f1_abga (g_abgq x_abgr))
               `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0] <[GHC.Types.Char]>_N)
                       :: Control.Lens.Type.Prism' [GHC.Types.Char] ()
                          ~R# Control.Lens.Empty.AsEmpty [GHC.Types.Char]))
              (Data.Functor.Contravariant.$fContravariantConst @[GHC.Types.Char])
              (Data.Functor.Const.$fFunctorConst @[GHC.Types.Char])
    Cont:   ApplyToVal nodup hole Control.Lens.Getter.Getting
                                    GHC.Base.String [GHC.Types.Char] GHC.Base.String
              ((\ (ds_abe3 [Occ=Once1] :: a_abe0) -> ds_abe3)
               `cast` (<a_abe0>_R
                       %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                          <*>_N <a_abe0>_R <a_abe0>_P)
                       :: (a_abe0 -> a_abe0)
                          ~R# (a_abe0 -> Data.Functor.Const.Const a_abe0 a_abe0)))
            ApplyToVal nodup hole [GHC.Types.Char]
                                  -> Data.Functor.Const.Const GHC.Base.String [GHC.Types.Char]
              s_a8Jf
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N <GHC.Base.String>_R <[GHC.Types.Char]>_P
                    :: Data.Functor.Const.Const GHC.Base.String [GHC.Types.Char]
                       ~R# GHC.Base.String)
            Stop[RuleArgCtxt] GHC.Base.String
Rule fired
    Rule: eqString
    Module: (GHC.Base)
    Before: GHC.Classes.==
              TyArg GHC.Base.String
              ValArg GHC.Classes.$fEqList_$s$fEqList1
              ValArg s_a8Jf
              ValArg s_a8Jf
    After:  (\ ($dEq_aaZD :: GHC.Classes.Eq GHC.Base.String) ->
               GHC.Base.eqString)
              GHC.Classes.$fEqList_$s$fEqList1
              ValArg s_a8Jf ValArg s_a8Jf
    Cont:   Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: unpack
    Module: (GHC.Base)
    Before: GHC.CString.unpackCString# ValArg "T -> T"#
    After:  (\ (a_ab6H :: GHC.Prim.Addr#) ->
               GHC.Base.build
                 @GHC.Types.Char
                 (\ (@b_ab6I) -> GHC.CString.unpackFoldrCString# @b_ab6I a_ab6H))
              "T -> T"#
    Cont:   Stop[BoringCtxt] Test.Tasty.Core.TestName
Rule fired
    Rule: Class op property
    Module: (BUILTIN)
    Before: Test.QuickCheck.Property.property
              TyArg Data.Text.Internal.Text -> GHC.Types.Bool
              ValArg $dTestable_a97V
    After:  Test.QuickCheck.Property.$fTestableFUN_$cproperty
              @Data.Text.Internal.Text
              @GHC.Types.Bool
              Test.QuickCheck.Instances.Text.$fArbitraryText0
              Data.Text.Show.$fShowText
              Test.QuickCheck.Property.$fTestableBool
    Cont:   ApplyToVal nodup hole (Data.Text.Internal.Text
                                   -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              prop_ab6U
            CastIt (Sym (Test.Tasty.QuickCheck.N:QC[0])
                    :: Test.QuickCheck.Property.Property ~R# Test.Tasty.QuickCheck.QC)
            Stop[BoringCtxt] Test.Tasty.QuickCheck.QC
Rule fired
    Rule: Class op propertyForAllShrinkShow
    Module: (BUILTIN)
    Before: Test.QuickCheck.Property.propertyForAllShrinkShow
              TyArg GHC.Types.Bool ValArg Test.QuickCheck.Property.$fTestableBool
    After:  Test.QuickCheck.Property.$fTestableBool1
            `cast` (forall (a :: <*>_N).
                    <Test.QuickCheck.Gen.Gen a>_R
                    %<'GHC.Types.Many>_N ->_R <a -> [a]>_R
                    %<'GHC.Types.Many>_N ->_R <a -> [GHC.Base.String]>_R
                    %<'GHC.Types.Many>_N ->_R <a -> GHC.Types.Bool>_R
                    %<'GHC.Types.Many>_N ->_R Sym (Test.QuickCheck.Gen.N:Gen[0]
                                                       (Test.QuickCheck.Property.N:Prop[0]))
                                              ; Sym (Test.QuickCheck.Property.N:Property[0])
                    :: (forall {a}.
                        Test.QuickCheck.Gen.Gen a
                        -> (a -> [a])
                        -> (a -> [GHC.Base.String])
                        -> (a -> GHC.Types.Bool)
                        -> Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int
                        -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result)
                       ~R# (forall {a}.
                            Test.QuickCheck.Gen.Gen a
                            -> (a -> [a])
                            -> (a -> [GHC.Base.String])
                            -> (a -> GHC.Types.Bool)
                            -> Test.QuickCheck.Property.Property))
    Cont:   ApplyToTy Data.Text.Internal.Text
            ApplyToVal nodup hole Test.QuickCheck.Gen.Gen
                                    Data.Text.Internal.Text
                                  -> (Data.Text.Internal.Text -> [Data.Text.Internal.Text])
                                  -> (Data.Text.Internal.Text -> [GHC.Base.String])
                                  -> (Data.Text.Internal.Text -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (Test.QuickCheck.Arbitrary.arbitrary @a_ab8C $dArbitrary_ab8E)
            ApplyToVal nodup hole (Data.Text.Internal.Text
                                   -> [Data.Text.Internal.Text])
                                  -> (Data.Text.Internal.Text -> [GHC.Base.String])
                                  -> (Data.Text.Internal.Text -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (Test.QuickCheck.Arbitrary.shrink @a_ab8C $dArbitrary_ab8E)
            ApplyToVal nodup hole (Data.Text.Internal.Text
                                   -> [GHC.Base.String])
                                  -> (Data.Text.Internal.Text -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (let {
                 g_ab8I [Occ=OnceL1!] :: a_ab8C -> GHC.Base.String
                 [LclId]
                 g_ab8I = GHC.Show.show @a_ab8C $dShow_ab8F } in
               \ (x_ab8J [Occ=Once1] :: a_ab8C) ->
                 GHC.Types.:
                   @GHC.Base.String (g_ab8I x_ab8J) (GHC.Types.[] @GHC.Base.String))
            ApplyToVal nodup hole (Data.Text.Internal.Text -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              f_ab8H
            CastIt (Sym (Test.Tasty.QuickCheck.N:QC[0])
                    :: Test.QuickCheck.Property.Property ~R# Test.Tasty.QuickCheck.QC)
            Stop[BoringCtxt] Test.Tasty.QuickCheck.QC
Rule fired
    Rule: Class op arbitrary
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.arbitrary
              TyArg Data.Text.Internal.Text
              ValArg Test.QuickCheck.Instances.Text.$fArbitraryText0
    After:  Test.QuickCheck.Instances.Text.$fArbitraryText3
            `cast` (Sym (Test.QuickCheck.Gen.N:Gen[0]
                             <Data.Text.Internal.Text>_R)
                    :: (Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int -> Data.Text.Internal.Text)
                       ~R# Test.QuickCheck.Gen.Gen Data.Text.Internal.Text)
    Cont:   Stop[BoringCtxt] Test.QuickCheck.Gen.Gen
                               Data.Text.Internal.Text
Rule fired
    Rule: Class op shrink
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.shrink
              TyArg Data.Text.Internal.Text
              ValArg Test.QuickCheck.Instances.Text.$fArbitraryText0
    After:  Test.QuickCheck.Instances.Text.$fArbitraryText0_$cshrink
    Cont:   Stop[BoringCtxt] Data.Text.Internal.Text
                             -> [Data.Text.Internal.Text]
Rule fired
    Rule: Class op show
    Module: (BUILTIN)
    Before: GHC.Show.show
              TyArg Data.Text.Internal.Text ValArg Data.Text.Show.$fShowText
    After:  Data.Text.Show.$fShowText_$cshow
    Cont:   Stop[RhsCtxt(NonRecursive)] Data.Text.Internal.Text
                                        -> GHC.Base.String
Rule fired
    Rule: Class op reader
    Module: (BUILTIN)
    Before: Control.Monad.Reader.Class.reader
              TyArg Data.Text.Internal.Text
              TyArg (->) Data.Text.Internal.Text
              ValArg Control.Monad.Reader.Class.$fMonadReaderrFUN
                       @Data.Text.Internal.Text
    After:  \ (@a_abe8) ->
              GHC.Base.id @(Data.Text.Internal.Text -> a_abe8)
    Cont:   ApplyToTy Data.Text.Internal.Text
            ApplyToVal nodup hole (Data.Text.Internal.Text
                                   -> Data.Text.Internal.Text)
                                  -> Data.Text.Internal.Text -> Data.Text.Internal.Text
              ((l_abe2
                  ((\ (ds_abe3 [Occ=Once1] :: a_abe0) -> ds_abe3)
                   `cast` (<a_abe0>_R
                           %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                              <*>_N <a_abe0>_R <a_abe0>_P)
                           :: (a_abe0 -> a_abe0)
                              ~R# (a_abe0 -> Data.Functor.Const.Const a_abe0 a_abe0))))
               `cast` (<s_abdY>_R
                       %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                     <*>_N <a_abe0>_R <s_abdY>_P
                       :: (s_abdY -> Data.Functor.Const.Const a_abe0 s_abdY)
                          ~R# (s_abdY -> a_abe0)))
            ApplyToVal nodup hole Data.Text.Internal.Text
                                  -> Data.Text.Internal.Text
              s_a8Jm
            Stop[RuleArgCtxt] Data.Text.Internal.Text
Rule fired
    Rule: recons/id
    Module: (Control.Lens.Cons.Extras)
    Before: Control.Lens.Cons.Extras.recons
              TyArg Data.Text.Internal.Text
              TyArg GHC.Types.Char
              TyArg Data.Text.Internal.Text
              ValArg (\ (@(p_abhA :: * -> * -> *))
                        (@(f_abhB :: * -> *))
                        ($dChoice_abhC :: Data.Profunctor.Choice.Choice p_abhA)
                        ($dApplicative_abhD :: GHC.Base.Applicative f_abhB) ->
                        let {
                          f1_abhE
                            :: p_abhA
                                 (Data.Either.Either
                                    Data.Text.Internal.Text
                                    (GHC.Types.Char, Data.Text.Internal.Text))
                                 (Data.Either.Either
                                    Data.Text.Internal.Text
                                    (f_abhB (GHC.Types.Char, Data.Text.Internal.Text)))
                               -> p_abhA Data.Text.Internal.Text (f_abhB Data.Text.Internal.Text)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 340 0}]
                          f1_abhE
                            = Data.Profunctor.Unsafe.dimap
                                @p_abhA
                                (Data.Profunctor.Choice.$p1Choice @p_abhA $dChoice_abhC)
                                @Data.Text.Internal.Text
                                @(Data.Either.Either
                                    Data.Text.Internal.Text
                                    (GHC.Types.Char, Data.Text.Internal.Text))
                                @(Data.Either.Either
                                    Data.Text.Internal.Text
                                    (f_abhB (GHC.Types.Char, Data.Text.Internal.Text)))
                                @(f_abhB Data.Text.Internal.Text)
                                (\ (s1_abhF :: Data.Text.Internal.Text) ->
                                   case Data.Text.uncons s1_abhF of {
                                     GHC.Maybe.Nothing ->
                                       Data.Either.Left
                                         @Data.Text.Internal.Text
                                         @(GHC.Types.Char, Data.Text.Internal.Text)
                                         s1_abhF;
                                     GHC.Maybe.Just x_abhI ->
                                       Data.Either.Right
                                         @Data.Text.Internal.Text
                                         @(GHC.Types.Char, Data.Text.Internal.Text)
                                         x_abhI
                                   })
                                (let {
                                   f2_abhK
                                     :: Data.Text.Internal.Text -> f_abhB Data.Text.Internal.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abhK
                                     = GHC.Base.pure
                                         @f_abhB $dApplicative_abhD @Data.Text.Internal.Text } in
                                 let {
                                   ds2_abhL
                                     :: f_abhB (GHC.Types.Char, Data.Text.Internal.Text)
                                        -> f_abhB Data.Text.Internal.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 100 0}]
                                   ds2_abhL
                                     = GHC.Base.fmap
                                         @f_abhB
                                         (GHC.Base.$p1Applicative @f_abhB $dApplicative_abhD)
                                         @(GHC.Types.Char, Data.Text.Internal.Text)
                                         @Data.Text.Internal.Text
                                         (\ (p1_abhM
                                               :: (GHC.Types.Char, Data.Text.Internal.Text)) ->
                                            case p1_abhM of { (x_abhO, ds_abhP) ->
                                            Data.Text.cons x_abhO ds_abhP
                                            }) } in
                                 \ (ds3_abhR
                                      :: Data.Either.Either
                                           Data.Text.Internal.Text
                                           (f_abhB (GHC.Types.Char, Data.Text.Internal.Text))) ->
                                   case ds3_abhR of {
                                     Data.Either.Left x_abhT -> f2_abhK x_abhT;
                                     Data.Either.Right y_abhV -> ds2_abhL y_abhV
                                   }) } in
                        let {
                          g_abhX
                            :: p_abhA
                                 (GHC.Types.Char, Data.Text.Internal.Text)
                                 (f_abhB (GHC.Types.Char, Data.Text.Internal.Text))
                               -> p_abhA
                                    (Data.Either.Either
                                       Data.Text.Internal.Text
                                       (GHC.Types.Char, Data.Text.Internal.Text))
                                    (Data.Either.Either
                                       Data.Text.Internal.Text
                                       (f_abhB (GHC.Types.Char, Data.Text.Internal.Text)))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abhX
                            = Data.Profunctor.Choice.right'
                                @p_abhA
                                $dChoice_abhC
                                @(GHC.Types.Char, Data.Text.Internal.Text)
                                @(f_abhB (GHC.Types.Char, Data.Text.Internal.Text))
                                @Data.Text.Internal.Text } in
                        \ (x_abhY
                             :: p_abhA
                                  (GHC.Types.Char, Data.Text.Internal.Text)
                                  (f_abhB (GHC.Types.Char, Data.Text.Internal.Text))) ->
                          f1_abhE (g_abhX x_abhY))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <Data.Text.Internal.Text>_N
                                      <Data.Text.Internal.Text>_N
                                      <GHC.Types.Char>_N
                                      <GHC.Types.Char>_N)
                             :: Control.Lens.Type.Prism
                                  Data.Text.Internal.Text
                                  Data.Text.Internal.Text
                                  (GHC.Types.Char, Data.Text.Internal.Text)
                                  (GHC.Types.Char, Data.Text.Internal.Text)
                                ~R# Control.Lens.Cons.Cons
                                      Data.Text.Internal.Text
                                      Data.Text.Internal.Text
                                      GHC.Types.Char
                                      GHC.Types.Char)
              ValArg (\ (@(p_abhA :: * -> * -> *))
                        (@(f_abhB :: * -> *))
                        ($dChoice_abhC :: Data.Profunctor.Choice.Choice p_abhA)
                        ($dApplicative_abhD :: GHC.Base.Applicative f_abhB) ->
                        let {
                          f1_abhE
                            :: p_abhA
                                 (Data.Either.Either
                                    Data.Text.Internal.Text
                                    (GHC.Types.Char, Data.Text.Internal.Text))
                                 (Data.Either.Either
                                    Data.Text.Internal.Text
                                    (f_abhB (GHC.Types.Char, Data.Text.Internal.Text)))
                               -> p_abhA Data.Text.Internal.Text (f_abhB Data.Text.Internal.Text)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 340 0}]
                          f1_abhE
                            = Data.Profunctor.Unsafe.dimap
                                @p_abhA
                                (Data.Profunctor.Choice.$p1Choice @p_abhA $dChoice_abhC)
                                @Data.Text.Internal.Text
                                @(Data.Either.Either
                                    Data.Text.Internal.Text
                                    (GHC.Types.Char, Data.Text.Internal.Text))
                                @(Data.Either.Either
                                    Data.Text.Internal.Text
                                    (f_abhB (GHC.Types.Char, Data.Text.Internal.Text)))
                                @(f_abhB Data.Text.Internal.Text)
                                (\ (s1_abhF :: Data.Text.Internal.Text) ->
                                   case Data.Text.uncons s1_abhF of {
                                     GHC.Maybe.Nothing ->
                                       Data.Either.Left
                                         @Data.Text.Internal.Text
                                         @(GHC.Types.Char, Data.Text.Internal.Text)
                                         s1_abhF;
                                     GHC.Maybe.Just x_abhI ->
                                       Data.Either.Right
                                         @Data.Text.Internal.Text
                                         @(GHC.Types.Char, Data.Text.Internal.Text)
                                         x_abhI
                                   })
                                (let {
                                   f2_abhK
                                     :: Data.Text.Internal.Text -> f_abhB Data.Text.Internal.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abhK
                                     = GHC.Base.pure
                                         @f_abhB $dApplicative_abhD @Data.Text.Internal.Text } in
                                 let {
                                   ds2_abhL
                                     :: f_abhB (GHC.Types.Char, Data.Text.Internal.Text)
                                        -> f_abhB Data.Text.Internal.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 100 0}]
                                   ds2_abhL
                                     = GHC.Base.fmap
                                         @f_abhB
                                         (GHC.Base.$p1Applicative @f_abhB $dApplicative_abhD)
                                         @(GHC.Types.Char, Data.Text.Internal.Text)
                                         @Data.Text.Internal.Text
                                         (\ (p1_abhM
                                               :: (GHC.Types.Char, Data.Text.Internal.Text)) ->
                                            case p1_abhM of { (x_abhO, ds_abhP) ->
                                            Data.Text.cons x_abhO ds_abhP
                                            }) } in
                                 \ (ds3_abhR
                                      :: Data.Either.Either
                                           Data.Text.Internal.Text
                                           (f_abhB (GHC.Types.Char, Data.Text.Internal.Text))) ->
                                   case ds3_abhR of {
                                     Data.Either.Left x_abhT -> f2_abhK x_abhT;
                                     Data.Either.Right y_abhV -> ds2_abhL y_abhV
                                   }) } in
                        let {
                          g_abhX
                            :: p_abhA
                                 (GHC.Types.Char, Data.Text.Internal.Text)
                                 (f_abhB (GHC.Types.Char, Data.Text.Internal.Text))
                               -> p_abhA
                                    (Data.Either.Either
                                       Data.Text.Internal.Text
                                       (GHC.Types.Char, Data.Text.Internal.Text))
                                    (Data.Either.Either
                                       Data.Text.Internal.Text
                                       (f_abhB (GHC.Types.Char, Data.Text.Internal.Text)))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abhX
                            = Data.Profunctor.Choice.right'
                                @p_abhA
                                $dChoice_abhC
                                @(GHC.Types.Char, Data.Text.Internal.Text)
                                @(f_abhB (GHC.Types.Char, Data.Text.Internal.Text))
                                @Data.Text.Internal.Text } in
                        \ (x_abhY
                             :: p_abhA
                                  (GHC.Types.Char, Data.Text.Internal.Text)
                                  (f_abhB (GHC.Types.Char, Data.Text.Internal.Text))) ->
                          f1_abhE (g_abhX x_abhY))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <Data.Text.Internal.Text>_N
                                      <Data.Text.Internal.Text>_N
                                      <GHC.Types.Char>_N
                                      <GHC.Types.Char>_N)
                             :: Control.Lens.Type.Prism
                                  Data.Text.Internal.Text
                                  Data.Text.Internal.Text
                                  (GHC.Types.Char, Data.Text.Internal.Text)
                                  (GHC.Types.Char, Data.Text.Internal.Text)
                                ~R# Control.Lens.Cons.Cons
                                      Data.Text.Internal.Text
                                      Data.Text.Internal.Text
                                      GHC.Types.Char
                                      GHC.Types.Char)
              ValArg (\ (@(p_abhZ :: * -> * -> *))
                        (@(f_abi0 :: * -> *))
                        ($dChoice_abi1 :: Data.Profunctor.Choice.Choice p_abhZ)
                        ($dApplicative_abi2 :: GHC.Base.Applicative f_abi0) ->
                        let {
                          f1_abi3
                            :: p_abhZ
                                 (Data.Either.Either Data.Text.Internal.Text ())
                                 (Data.Either.Either Data.Text.Internal.Text (f_abi0 ()))
                               -> p_abhZ Data.Text.Internal.Text (f_abi0 Data.Text.Internal.Text)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 310 0}]
                          f1_abi3
                            = Data.Profunctor.Unsafe.dimap
                                @p_abhZ
                                (Data.Profunctor.Choice.$p1Choice @p_abhZ $dChoice_abi1)
                                @Data.Text.Internal.Text
                                @(Data.Either.Either Data.Text.Internal.Text ())
                                @(Data.Either.Either Data.Text.Internal.Text (f_abi0 ()))
                                @(f_abi0 Data.Text.Internal.Text)
                                (\ (s_abi4 :: Data.Text.Internal.Text) ->
                                   case Data.Text.null s_abi4 of {
                                     GHC.Types.False ->
                                       Data.Either.Left @Data.Text.Internal.Text @() s_abi4;
                                     GHC.Types.True ->
                                       Data.Either.Right
                                         @Data.Text.Internal.Text @() GHC.Tuple.Prim.()
                                   })
                                (let {
                                   f2_abi7
                                     :: Data.Text.Internal.Text -> f_abi0 Data.Text.Internal.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abi7
                                     = GHC.Base.pure
                                         @f_abi0 $dApplicative_abi2 @Data.Text.Internal.Text } in
                                 let {
                                   ds2_abi8 :: f_abi0 () -> f_abi0 Data.Text.Internal.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 70 0}]
                                   ds2_abi8
                                     = GHC.Base.fmap
                                         @f_abi0
                                         (GHC.Base.$p1Applicative @f_abi0 $dApplicative_abi2)
                                         @()
                                         @Data.Text.Internal.Text
                                         (\ (ds3_abi9 :: ()) ->
                                            case ds3_abi9 of { () ->
                                            Data.Text.Internal.empty
                                            }) } in
                                 \ (ds3_abib
                                      :: Data.Either.Either Data.Text.Internal.Text (f_abi0 ())) ->
                                   case ds3_abib of {
                                     Data.Either.Left x_abid -> f2_abi7 x_abid;
                                     Data.Either.Right y_abif -> ds2_abi8 y_abif
                                   }) } in
                        let {
                          g_abih
                            :: p_abhZ () (f_abi0 ())
                               -> p_abhZ
                                    (Data.Either.Either Data.Text.Internal.Text ())
                                    (Data.Either.Either Data.Text.Internal.Text (f_abi0 ()))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abih
                            = Data.Profunctor.Choice.right'
                                @p_abhZ
                                $dChoice_abi1
                                @()
                                @(f_abi0 ())
                                @Data.Text.Internal.Text } in
                        \ (x_abii :: p_abhZ () (f_abi0 ())) -> f1_abi3 (g_abih x_abii))
                     `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                      <Data.Text.Internal.Text>_N)
                             :: Control.Lens.Type.Prism' Data.Text.Internal.Text ()
                                ~R# Control.Lens.Empty.AsEmpty Data.Text.Internal.Text)
              TyArg Data.Functor.Const.Const Data.Text.Internal.Text
              ValArg Data.Functor.Contravariant.$fContravariantConst
                       @Data.Text.Internal.Text
              ValArg Data.Functor.Const.$fFunctorConst @Data.Text.Internal.Text
    After:  (\ (@s1_abf7)
               (@(f_abf8 :: * -> *))
               (@a_abf9)
               ($dCons_abfa
                  :: Control.Lens.Cons.Cons s1_abf7 s1_abf7 a_abf9 a_abf9)
               ($dCons1_abfb
                  :: Control.Lens.Cons.Cons s1_abf7 s1_abf7 a_abf9 a_abf9)
               ($dAsEmpty_abfc :: Control.Lens.Empty.AsEmpty s1_abf7)
               ($dContravariant_abfd
                  :: Data.Functor.Contravariant.Contravariant f_abf8)
               ($dFunctor_abfe :: GHC.Base.Functor f_abf8) ->
               GHC.Base.id @(s1_abf7 -> f_abf8 s1_abf7))
              @Data.Text.Internal.Text
              @(Data.Functor.Const.Const Data.Text.Internal.Text)
              @GHC.Types.Char
              ((\ (@(p_abhA :: * -> * -> *))
                  (@(f_abhB :: * -> *))
                  ($dChoice_abhC :: Data.Profunctor.Choice.Choice p_abhA)
                  ($dApplicative_abhD :: GHC.Base.Applicative f_abhB) ->
                  let {
                    f1_abhE
                      :: p_abhA
                           (Data.Either.Either
                              Data.Text.Internal.Text (GHC.Types.Char, Data.Text.Internal.Text))
                           (Data.Either.Either
                              Data.Text.Internal.Text
                              (f_abhB (GHC.Types.Char, Data.Text.Internal.Text)))
                         -> p_abhA Data.Text.Internal.Text (f_abhB Data.Text.Internal.Text)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 340 0}]
                    f1_abhE
                      = Data.Profunctor.Unsafe.dimap
                          @p_abhA
                          (Data.Profunctor.Choice.$p1Choice @p_abhA $dChoice_abhC)
                          @Data.Text.Internal.Text
                          @(Data.Either.Either
                              Data.Text.Internal.Text (GHC.Types.Char, Data.Text.Internal.Text))
                          @(Data.Either.Either
                              Data.Text.Internal.Text
                              (f_abhB (GHC.Types.Char, Data.Text.Internal.Text)))
                          @(f_abhB Data.Text.Internal.Text)
                          (\ (s1_abhF :: Data.Text.Internal.Text) ->
                             case Data.Text.uncons s1_abhF of {
                               GHC.Maybe.Nothing ->
                                 Data.Either.Left
                                   @Data.Text.Internal.Text
                                   @(GHC.Types.Char, Data.Text.Internal.Text)
                                   s1_abhF;
                               GHC.Maybe.Just x_abhI ->
                                 Data.Either.Right
                                   @Data.Text.Internal.Text
                                   @(GHC.Types.Char, Data.Text.Internal.Text)
                                   x_abhI
                             })
                          (let {
                             f2_abhK
                               :: Data.Text.Internal.Text -> f_abhB Data.Text.Internal.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abhK
                               = GHC.Base.pure
                                   @f_abhB $dApplicative_abhD @Data.Text.Internal.Text } in
                           let {
                             ds2_abhL
                               :: f_abhB (GHC.Types.Char, Data.Text.Internal.Text)
                                  -> f_abhB Data.Text.Internal.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 100 0}]
                             ds2_abhL
                               = GHC.Base.fmap
                                   @f_abhB
                                   (GHC.Base.$p1Applicative @f_abhB $dApplicative_abhD)
                                   @(GHC.Types.Char, Data.Text.Internal.Text)
                                   @Data.Text.Internal.Text
                                   (\ (p1_abhM :: (GHC.Types.Char, Data.Text.Internal.Text)) ->
                                      case p1_abhM of { (x_abhO, ds_abhP) ->
                                      Data.Text.cons x_abhO ds_abhP
                                      }) } in
                           \ (ds3_abhR
                                :: Data.Either.Either
                                     Data.Text.Internal.Text
                                     (f_abhB (GHC.Types.Char, Data.Text.Internal.Text))) ->
                             case ds3_abhR of {
                               Data.Either.Left x_abhT -> f2_abhK x_abhT;
                               Data.Either.Right y_abhV -> ds2_abhL y_abhV
                             }) } in
                  let {
                    g_abhX
                      :: p_abhA
                           (GHC.Types.Char, Data.Text.Internal.Text)
                           (f_abhB (GHC.Types.Char, Data.Text.Internal.Text))
                         -> p_abhA
                              (Data.Either.Either
                                 Data.Text.Internal.Text (GHC.Types.Char, Data.Text.Internal.Text))
                              (Data.Either.Either
                                 Data.Text.Internal.Text
                                 (f_abhB (GHC.Types.Char, Data.Text.Internal.Text)))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abhX
                      = Data.Profunctor.Choice.right'
                          @p_abhA
                          $dChoice_abhC
                          @(GHC.Types.Char, Data.Text.Internal.Text)
                          @(f_abhB (GHC.Types.Char, Data.Text.Internal.Text))
                          @Data.Text.Internal.Text } in
                  \ (x_abhY
                       :: p_abhA
                            (GHC.Types.Char, Data.Text.Internal.Text)
                            (f_abhB (GHC.Types.Char, Data.Text.Internal.Text))) ->
                    f1_abhE (g_abhX x_abhY))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <Data.Text.Internal.Text>_N
                                <Data.Text.Internal.Text>_N
                                <GHC.Types.Char>_N
                                <GHC.Types.Char>_N)
                       :: Control.Lens.Type.Prism
                            Data.Text.Internal.Text
                            Data.Text.Internal.Text
                            (GHC.Types.Char, Data.Text.Internal.Text)
                            (GHC.Types.Char, Data.Text.Internal.Text)
                          ~R# Control.Lens.Cons.Cons
                                Data.Text.Internal.Text
                                Data.Text.Internal.Text
                                GHC.Types.Char
                                GHC.Types.Char))
              ((\ (@(p_abhA :: * -> * -> *))
                  (@(f_abhB :: * -> *))
                  ($dChoice_abhC :: Data.Profunctor.Choice.Choice p_abhA)
                  ($dApplicative_abhD :: GHC.Base.Applicative f_abhB) ->
                  let {
                    f1_abhE
                      :: p_abhA
                           (Data.Either.Either
                              Data.Text.Internal.Text (GHC.Types.Char, Data.Text.Internal.Text))
                           (Data.Either.Either
                              Data.Text.Internal.Text
                              (f_abhB (GHC.Types.Char, Data.Text.Internal.Text)))
                         -> p_abhA Data.Text.Internal.Text (f_abhB Data.Text.Internal.Text)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 340 0}]
                    f1_abhE
                      = Data.Profunctor.Unsafe.dimap
                          @p_abhA
                          (Data.Profunctor.Choice.$p1Choice @p_abhA $dChoice_abhC)
                          @Data.Text.Internal.Text
                          @(Data.Either.Either
                              Data.Text.Internal.Text (GHC.Types.Char, Data.Text.Internal.Text))
                          @(Data.Either.Either
                              Data.Text.Internal.Text
                              (f_abhB (GHC.Types.Char, Data.Text.Internal.Text)))
                          @(f_abhB Data.Text.Internal.Text)
                          (\ (s1_abhF :: Data.Text.Internal.Text) ->
                             case Data.Text.uncons s1_abhF of {
                               GHC.Maybe.Nothing ->
                                 Data.Either.Left
                                   @Data.Text.Internal.Text
                                   @(GHC.Types.Char, Data.Text.Internal.Text)
                                   s1_abhF;
                               GHC.Maybe.Just x_abhI ->
                                 Data.Either.Right
                                   @Data.Text.Internal.Text
                                   @(GHC.Types.Char, Data.Text.Internal.Text)
                                   x_abhI
                             })
                          (let {
                             f2_abhK
                               :: Data.Text.Internal.Text -> f_abhB Data.Text.Internal.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abhK
                               = GHC.Base.pure
                                   @f_abhB $dApplicative_abhD @Data.Text.Internal.Text } in
                           let {
                             ds2_abhL
                               :: f_abhB (GHC.Types.Char, Data.Text.Internal.Text)
                                  -> f_abhB Data.Text.Internal.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 100 0}]
                             ds2_abhL
                               = GHC.Base.fmap
                                   @f_abhB
                                   (GHC.Base.$p1Applicative @f_abhB $dApplicative_abhD)
                                   @(GHC.Types.Char, Data.Text.Internal.Text)
                                   @Data.Text.Internal.Text
                                   (\ (p1_abhM :: (GHC.Types.Char, Data.Text.Internal.Text)) ->
                                      case p1_abhM of { (x_abhO, ds_abhP) ->
                                      Data.Text.cons x_abhO ds_abhP
                                      }) } in
                           \ (ds3_abhR
                                :: Data.Either.Either
                                     Data.Text.Internal.Text
                                     (f_abhB (GHC.Types.Char, Data.Text.Internal.Text))) ->
                             case ds3_abhR of {
                               Data.Either.Left x_abhT -> f2_abhK x_abhT;
                               Data.Either.Right y_abhV -> ds2_abhL y_abhV
                             }) } in
                  let {
                    g_abhX
                      :: p_abhA
                           (GHC.Types.Char, Data.Text.Internal.Text)
                           (f_abhB (GHC.Types.Char, Data.Text.Internal.Text))
                         -> p_abhA
                              (Data.Either.Either
                                 Data.Text.Internal.Text (GHC.Types.Char, Data.Text.Internal.Text))
                              (Data.Either.Either
                                 Data.Text.Internal.Text
                                 (f_abhB (GHC.Types.Char, Data.Text.Internal.Text)))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abhX
                      = Data.Profunctor.Choice.right'
                          @p_abhA
                          $dChoice_abhC
                          @(GHC.Types.Char, Data.Text.Internal.Text)
                          @(f_abhB (GHC.Types.Char, Data.Text.Internal.Text))
                          @Data.Text.Internal.Text } in
                  \ (x_abhY
                       :: p_abhA
                            (GHC.Types.Char, Data.Text.Internal.Text)
                            (f_abhB (GHC.Types.Char, Data.Text.Internal.Text))) ->
                    f1_abhE (g_abhX x_abhY))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <Data.Text.Internal.Text>_N
                                <Data.Text.Internal.Text>_N
                                <GHC.Types.Char>_N
                                <GHC.Types.Char>_N)
                       :: Control.Lens.Type.Prism
                            Data.Text.Internal.Text
                            Data.Text.Internal.Text
                            (GHC.Types.Char, Data.Text.Internal.Text)
                            (GHC.Types.Char, Data.Text.Internal.Text)
                          ~R# Control.Lens.Cons.Cons
                                Data.Text.Internal.Text
                                Data.Text.Internal.Text
                                GHC.Types.Char
                                GHC.Types.Char))
              ((\ (@(p_abhZ :: * -> * -> *))
                  (@(f_abi0 :: * -> *))
                  ($dChoice_abi1 :: Data.Profunctor.Choice.Choice p_abhZ)
                  ($dApplicative_abi2 :: GHC.Base.Applicative f_abi0) ->
                  let {
                    f1_abi3
                      :: p_abhZ
                           (Data.Either.Either Data.Text.Internal.Text ())
                           (Data.Either.Either Data.Text.Internal.Text (f_abi0 ()))
                         -> p_abhZ Data.Text.Internal.Text (f_abi0 Data.Text.Internal.Text)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 310 0}]
                    f1_abi3
                      = Data.Profunctor.Unsafe.dimap
                          @p_abhZ
                          (Data.Profunctor.Choice.$p1Choice @p_abhZ $dChoice_abi1)
                          @Data.Text.Internal.Text
                          @(Data.Either.Either Data.Text.Internal.Text ())
                          @(Data.Either.Either Data.Text.Internal.Text (f_abi0 ()))
                          @(f_abi0 Data.Text.Internal.Text)
                          (\ (s_abi4 :: Data.Text.Internal.Text) ->
                             case Data.Text.null s_abi4 of {
                               GHC.Types.False ->
                                 Data.Either.Left @Data.Text.Internal.Text @() s_abi4;
                               GHC.Types.True ->
                                 Data.Either.Right @Data.Text.Internal.Text @() GHC.Tuple.Prim.()
                             })
                          (let {
                             f2_abi7
                               :: Data.Text.Internal.Text -> f_abi0 Data.Text.Internal.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abi7
                               = GHC.Base.pure
                                   @f_abi0 $dApplicative_abi2 @Data.Text.Internal.Text } in
                           let {
                             ds2_abi8 :: f_abi0 () -> f_abi0 Data.Text.Internal.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 70 0}]
                             ds2_abi8
                               = GHC.Base.fmap
                                   @f_abi0
                                   (GHC.Base.$p1Applicative @f_abi0 $dApplicative_abi2)
                                   @()
                                   @Data.Text.Internal.Text
                                   (\ (ds3_abi9 :: ()) ->
                                      case ds3_abi9 of { () -> Data.Text.Internal.empty }) } in
                           \ (ds3_abib
                                :: Data.Either.Either Data.Text.Internal.Text (f_abi0 ())) ->
                             case ds3_abib of {
                               Data.Either.Left x_abid -> f2_abi7 x_abid;
                               Data.Either.Right y_abif -> ds2_abi8 y_abif
                             }) } in
                  let {
                    g_abih
                      :: p_abhZ () (f_abi0 ())
                         -> p_abhZ
                              (Data.Either.Either Data.Text.Internal.Text ())
                              (Data.Either.Either Data.Text.Internal.Text (f_abi0 ()))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abih
                      = Data.Profunctor.Choice.right'
                          @p_abhZ
                          $dChoice_abi1
                          @()
                          @(f_abi0 ())
                          @Data.Text.Internal.Text } in
                  \ (x_abii :: p_abhZ () (f_abi0 ())) -> f1_abi3 (g_abih x_abii))
               `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                <Data.Text.Internal.Text>_N)
                       :: Control.Lens.Type.Prism' Data.Text.Internal.Text ()
                          ~R# Control.Lens.Empty.AsEmpty Data.Text.Internal.Text))
              (Data.Functor.Contravariant.$fContravariantConst
                 @Data.Text.Internal.Text)
              (Data.Functor.Const.$fFunctorConst @Data.Text.Internal.Text)
    Cont:   ApplyToVal nodup hole Control.Lens.Getter.Getting
                                    Data.Text.Internal.Text
                                    Data.Text.Internal.Text
                                    Data.Text.Internal.Text
              ((\ (ds_abe3 [Occ=Once1] :: a_abe0) -> ds_abe3)
               `cast` (<a_abe0>_R
                       %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                          <*>_N <a_abe0>_R <a_abe0>_P)
                       :: (a_abe0 -> a_abe0)
                          ~R# (a_abe0 -> Data.Functor.Const.Const a_abe0 a_abe0)))
            ApplyToVal nodup hole Data.Text.Internal.Text
                                  -> Data.Functor.Const.Const
                                       Data.Text.Internal.Text Data.Text.Internal.Text
              s_a8Jm
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N <Data.Text.Internal.Text>_R <Data.Text.Internal.Text>_P
                    :: Data.Functor.Const.Const
                         Data.Text.Internal.Text Data.Text.Internal.Text
                       ~R# Data.Text.Internal.Text)
            Stop[RuleArgCtxt] Data.Text.Internal.Text
Rule fired
    Rule: Class op ==
    Module: (BUILTIN)
    Before: GHC.Classes.==
              TyArg Data.Text.Internal.Text
              ValArg Data.Text.$fEqText
              ValArg s_a8Jm
              ValArg s_a8Jm
    After:  Data.Text.$fEqText_$c== ValArg s_a8Jm ValArg s_a8Jm
    Cont:   Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: unpack
    Module: (GHC.Base)
    Before: GHC.CString.unpackCString# ValArg "TL -> TL"#
    After:  (\ (a_ab6H :: GHC.Prim.Addr#) ->
               GHC.Base.build
                 @GHC.Types.Char
                 (\ (@b_ab6I) -> GHC.CString.unpackFoldrCString# @b_ab6I a_ab6H))
              "TL -> TL"#
    Cont:   Stop[BoringCtxt] Test.Tasty.Core.TestName
Rule fired
    Rule: Class op property
    Module: (BUILTIN)
    Before: Test.QuickCheck.Property.property
              TyArg Data.Text.Internal.Lazy.Text -> GHC.Types.Bool
              ValArg Test.QuickCheck.Property.$fTestableFUN
                       @Data.Text.Internal.Lazy.Text
                       @GHC.Types.Bool
                       Test.QuickCheck.Instances.Text.$fArbitraryText
                       Data.Text.Lazy.$fShowText
                       Test.QuickCheck.Property.$fTestableBool
    After:  Test.QuickCheck.Property.$fTestableFUN_$cproperty
              @Data.Text.Internal.Lazy.Text
              @GHC.Types.Bool
              Test.QuickCheck.Instances.Text.$fArbitraryText
              Data.Text.Lazy.$fShowText
              Test.QuickCheck.Property.$fTestableBool
    Cont:   ApplyToVal nodup hole (Data.Text.Internal.Lazy.Text
                                   -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              prop_ab6U
            CastIt (Sym (Test.Tasty.QuickCheck.N:QC[0])
                    :: Test.QuickCheck.Property.Property ~R# Test.Tasty.QuickCheck.QC)
            Stop[BoringCtxt] Test.Tasty.QuickCheck.QC
Rule fired
    Rule: Class op propertyForAllShrinkShow
    Module: (BUILTIN)
    Before: Test.QuickCheck.Property.propertyForAllShrinkShow
              TyArg GHC.Types.Bool ValArg Test.QuickCheck.Property.$fTestableBool
    After:  Test.QuickCheck.Property.$fTestableBool1
            `cast` (forall (a :: <*>_N).
                    <Test.QuickCheck.Gen.Gen a>_R
                    %<'GHC.Types.Many>_N ->_R <a -> [a]>_R
                    %<'GHC.Types.Many>_N ->_R <a -> [GHC.Base.String]>_R
                    %<'GHC.Types.Many>_N ->_R <a -> GHC.Types.Bool>_R
                    %<'GHC.Types.Many>_N ->_R Sym (Test.QuickCheck.Gen.N:Gen[0]
                                                       (Test.QuickCheck.Property.N:Prop[0]))
                                              ; Sym (Test.QuickCheck.Property.N:Property[0])
                    :: (forall {a}.
                        Test.QuickCheck.Gen.Gen a
                        -> (a -> [a])
                        -> (a -> [GHC.Base.String])
                        -> (a -> GHC.Types.Bool)
                        -> Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int
                        -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result)
                       ~R# (forall {a}.
                            Test.QuickCheck.Gen.Gen a
                            -> (a -> [a])
                            -> (a -> [GHC.Base.String])
                            -> (a -> GHC.Types.Bool)
                            -> Test.QuickCheck.Property.Property))
    Cont:   ApplyToTy Data.Text.Internal.Lazy.Text
            ApplyToVal nodup hole Test.QuickCheck.Gen.Gen
                                    Data.Text.Internal.Lazy.Text
                                  -> (Data.Text.Internal.Lazy.Text
                                      -> [Data.Text.Internal.Lazy.Text])
                                  -> (Data.Text.Internal.Lazy.Text -> [GHC.Base.String])
                                  -> (Data.Text.Internal.Lazy.Text -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (Test.QuickCheck.Arbitrary.arbitrary @a_ab8C $dArbitrary_ab8E)
            ApplyToVal nodup hole (Data.Text.Internal.Lazy.Text
                                   -> [Data.Text.Internal.Lazy.Text])
                                  -> (Data.Text.Internal.Lazy.Text -> [GHC.Base.String])
                                  -> (Data.Text.Internal.Lazy.Text -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (Test.QuickCheck.Arbitrary.shrink @a_ab8C $dArbitrary_ab8E)
            ApplyToVal nodup hole (Data.Text.Internal.Lazy.Text
                                   -> [GHC.Base.String])
                                  -> (Data.Text.Internal.Lazy.Text -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (let {
                 g_ab8I [Occ=OnceL1!] :: a_ab8C -> GHC.Base.String
                 [LclId]
                 g_ab8I = GHC.Show.show @a_ab8C $dShow_ab8F } in
               \ (x_ab8J [Occ=Once1] :: a_ab8C) ->
                 GHC.Types.:
                   @GHC.Base.String (g_ab8I x_ab8J) (GHC.Types.[] @GHC.Base.String))
            ApplyToVal nodup hole (Data.Text.Internal.Lazy.Text
                                   -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              f_ab8H
            CastIt (Sym (Test.Tasty.QuickCheck.N:QC[0])
                    :: Test.QuickCheck.Property.Property ~R# Test.Tasty.QuickCheck.QC)
            Stop[BoringCtxt] Test.Tasty.QuickCheck.QC
Rule fired
    Rule: Class op arbitrary
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.arbitrary
              TyArg Data.Text.Internal.Lazy.Text
              ValArg Test.QuickCheck.Instances.Text.$fArbitraryText
    After:  Test.QuickCheck.Instances.Text.$fArbitraryText2
            `cast` (Sym (Test.QuickCheck.Gen.N:Gen[0]
                             <Data.Text.Internal.Lazy.Text>_R)
                    :: (Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int -> Data.Text.Internal.Lazy.Text)
                       ~R# Test.QuickCheck.Gen.Gen Data.Text.Internal.Lazy.Text)
    Cont:   Stop[BoringCtxt] Test.QuickCheck.Gen.Gen
                               Data.Text.Internal.Lazy.Text
Rule fired
    Rule: Class op shrink
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.shrink
              TyArg Data.Text.Internal.Lazy.Text
              ValArg Test.QuickCheck.Instances.Text.$fArbitraryText
    After:  Test.QuickCheck.Instances.Text.$fArbitraryText_$cshrink
    Cont:   Stop[BoringCtxt] Data.Text.Internal.Lazy.Text
                             -> [Data.Text.Internal.Lazy.Text]
Rule fired
    Rule: Class op show
    Module: (BUILTIN)
    Before: GHC.Show.show
              TyArg Data.Text.Internal.Lazy.Text ValArg Data.Text.Lazy.$fShowText
    After:  Data.Text.Lazy.$fShowText_$cshow
    Cont:   Stop[RhsCtxt(NonRecursive)] Data.Text.Internal.Lazy.Text
                                        -> GHC.Base.String
Rule fired
    Rule: Class op reader
    Module: (BUILTIN)
    Before: Control.Monad.Reader.Class.reader
              TyArg Data.Text.Internal.Lazy.Text
              TyArg (->) Data.Text.Internal.Lazy.Text
              ValArg Control.Monad.Reader.Class.$fMonadReaderrFUN
                       @Data.Text.Internal.Lazy.Text
    After:  \ (@a_abe8) ->
              GHC.Base.id @(Data.Text.Internal.Lazy.Text -> a_abe8)
    Cont:   ApplyToTy Data.Text.Internal.Lazy.Text
            ApplyToVal nodup hole (Data.Text.Internal.Lazy.Text
                                   -> Data.Text.Internal.Lazy.Text)
                                  -> Data.Text.Internal.Lazy.Text -> Data.Text.Internal.Lazy.Text
              ((l_abe2
                  ((\ (ds_abe3 [Occ=Once1] :: a_abe0) -> ds_abe3)
                   `cast` (<a_abe0>_R
                           %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                              <*>_N <a_abe0>_R <a_abe0>_P)
                           :: (a_abe0 -> a_abe0)
                              ~R# (a_abe0 -> Data.Functor.Const.Const a_abe0 a_abe0))))
               `cast` (<s_abdY>_R
                       %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                     <*>_N <a_abe0>_R <s_abdY>_P
                       :: (s_abdY -> Data.Functor.Const.Const a_abe0 s_abdY)
                          ~R# (s_abdY -> a_abe0)))
            ApplyToVal nodup hole Data.Text.Internal.Lazy.Text
                                  -> Data.Text.Internal.Lazy.Text
              s_a8Jn
            Stop[RuleArgCtxt] Data.Text.Internal.Lazy.Text
Rule fired
    Rule: recons/id
    Module: (Control.Lens.Cons.Extras)
    Before: Control.Lens.Cons.Extras.recons
              TyArg Data.Text.Internal.Lazy.Text
              TyArg GHC.Types.Char
              TyArg Data.Text.Internal.Lazy.Text
              ValArg (\ (@(p_abip :: * -> * -> *))
                        (@(f_abiq :: * -> *))
                        ($dChoice_abir :: Data.Profunctor.Choice.Choice p_abip)
                        ($dApplicative_abis :: GHC.Base.Applicative f_abiq) ->
                        let {
                          f1_abit
                            :: p_abip
                                 (Data.Either.Either
                                    Data.Text.Internal.Lazy.Text
                                    (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                                 (Data.Either.Either
                                    Data.Text.Internal.Lazy.Text
                                    (f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                               -> p_abip
                                    Data.Text.Internal.Lazy.Text
                                    (f_abiq Data.Text.Internal.Lazy.Text)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 639 0}]
                          f1_abit
                            = Data.Profunctor.Unsafe.dimap
                                @p_abip
                                (Data.Profunctor.Choice.$p1Choice @p_abip $dChoice_abir)
                                @Data.Text.Internal.Lazy.Text
                                @(Data.Either.Either
                                    Data.Text.Internal.Lazy.Text
                                    (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                                @(Data.Either.Either
                                    Data.Text.Internal.Lazy.Text
                                    (f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                                @(f_abiq Data.Text.Internal.Lazy.Text)
                                (\ (s1_abiu :: Data.Text.Internal.Lazy.Text) ->
                                   case s1_abiu of {
                                     Data.Text.Internal.Lazy.Empty ->
                                       Data.Either.Left
                                         @Data.Text.Internal.Lazy.Text
                                         @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                         Data.Text.Internal.Lazy.Empty;
                                     Data.Text.Internal.Lazy.Chunk bx_abiB bx1_abiC bx2_abiD
                                                                   ts_abiE ->
                                       Data.Either.Right
                                         @Data.Text.Internal.Lazy.Text
                                         @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                         (case GHC.Prim.indexWord8Array# bx_abiB bx1_abiC of r#_abiG
                                          { __DEFAULT ->
                                          let {
                                            c#_abiH :: GHC.Prim.Int#
                                            [LclId,
                                             Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                     Value=False, ConLike=False, WorkFree=False,
                                                     Expandable=False,
                                                     Guidance=IF_ARGS [] 4 0}]
                                            c#_abiH
                                              = GHC.Prim.word2Int#
                                                  (GHC.Prim.clz8#
                                                     (GHC.Prim.and#
                                                        (GHC.Prim.not#
                                                           (GHC.Prim.word8ToWord# r#_abiG))
                                                        255##)) } in
                                          case GHC.Prim.xorI# c#_abiH (GHC.Prim.<=# c#_abiH 0#) of {
                                            __DEFAULT ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abiB (GHC.Prim.+# bx1_abiC 1#)
                                              of r#1_abiJ
                                              { __DEFAULT ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abiB (GHC.Prim.+# bx1_abiC 2#)
                                              of r#2_abiK
                                              { __DEFAULT ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abiB (GHC.Prim.+# bx1_abiC 3#)
                                              of r#3_abiL
                                              { __DEFAULT ->
                                              GHC.Types.C#
                                                (GHC.Prim.chr#
                                                   (GHC.Prim.-#
                                                      (GHC.Prim.+#
                                                         (GHC.Prim.+#
                                                            (GHC.Prim.+#
                                                               (GHC.Prim.uncheckedIShiftL#
                                                                  (GHC.Prim.-#
                                                                     (GHC.Prim.word2Int#
                                                                        (GHC.Prim.word8ToWord#
                                                                           r#_abiG))
                                                                     240#)
                                                                  18#)
                                                               (GHC.Prim.uncheckedIShiftL#
                                                                  (GHC.Prim.-#
                                                                     (GHC.Prim.word2Int#
                                                                        (GHC.Prim.word8ToWord#
                                                                           r#1_abiJ))
                                                                     128#)
                                                                  12#))
                                                            (GHC.Prim.uncheckedIShiftL#
                                                               (GHC.Prim.-#
                                                                  (GHC.Prim.word2Int#
                                                                     (GHC.Prim.word8ToWord#
                                                                        r#2_abiK))
                                                                  128#)
                                                               6#))
                                                         (GHC.Prim.word2Int#
                                                            (GHC.Prim.word8ToWord# r#3_abiL)))
                                                      128#))
                                              }
                                              }
                                              };
                                            1# ->
                                              GHC.Types.C#
                                                (GHC.Prim.chr#
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.word8ToWord# r#_abiG)));
                                            2# ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abiB (GHC.Prim.+# bx1_abiC 1#)
                                              of r#1_abiM
                                              { __DEFAULT ->
                                              GHC.Types.C#
                                                (GHC.Prim.chr#
                                                   (GHC.Prim.-#
                                                      (GHC.Prim.+#
                                                         (GHC.Prim.uncheckedIShiftL#
                                                            (GHC.Prim.-#
                                                               (GHC.Prim.word2Int#
                                                                  (GHC.Prim.word8ToWord# r#_abiG))
                                                               192#)
                                                            6#)
                                                         (GHC.Prim.word2Int#
                                                            (GHC.Prim.word8ToWord# r#1_abiM)))
                                                      128#))
                                              };
                                            3# ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abiB (GHC.Prim.+# bx1_abiC 1#)
                                              of r#1_abiN
                                              { __DEFAULT ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abiB (GHC.Prim.+# bx1_abiC 2#)
                                              of r#2_abiO
                                              { __DEFAULT ->
                                              GHC.Types.C#
                                                (GHC.Prim.chr#
                                                   (GHC.Prim.-#
                                                      (GHC.Prim.+#
                                                         (GHC.Prim.+#
                                                            (GHC.Prim.uncheckedIShiftL#
                                                               (GHC.Prim.-#
                                                                  (GHC.Prim.word2Int#
                                                                     (GHC.Prim.word8ToWord#
                                                                        r#_abiG))
                                                                  224#)
                                                               12#)
                                                            (GHC.Prim.uncheckedIShiftL#
                                                               (GHC.Prim.-#
                                                                  (GHC.Prim.word2Int#
                                                                     (GHC.Prim.word8ToWord#
                                                                        r#1_abiN))
                                                                  128#)
                                                               6#))
                                                         (GHC.Prim.word2Int#
                                                            (GHC.Prim.word8ToWord# r#2_abiO)))
                                                      128#))
                                              }
                                              }
                                          }
                                          },
                                          case Data.Text.compareLength
                                                 (Data.Text.Internal.Text bx_abiB bx1_abiC bx2_abiD)
                                                 (GHC.Types.I# 1#)
                                          of {
                                            __DEFAULT ->
                                              case GHC.Prim.indexWord8Array# bx_abiB bx1_abiC
                                              of r#_abiQ
                                              { __DEFAULT ->
                                              let {
                                                c#_abiR :: GHC.Prim.Int#
                                                [LclId,
                                                 Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                         Value=False, ConLike=False, WorkFree=False,
                                                         Expandable=False,
                                                         Guidance=IF_ARGS [] 4 0}]
                                                c#_abiR
                                                  = GHC.Prim.word2Int#
                                                      (GHC.Prim.clz8#
                                                         (GHC.Prim.and#
                                                            (GHC.Prim.not#
                                                               (GHC.Prim.word8ToWord# r#_abiQ))
                                                            255##)) } in
                                              let {
                                                y_abiS :: GHC.Prim.Int#
                                                [LclId,
                                                 Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                         Value=False, ConLike=False, WorkFree=False,
                                                         Expandable=False,
                                                         Guidance=IF_ARGS [] 2 0}]
                                                y_abiS
                                                  = GHC.Prim.xorI#
                                                      c#_abiR (GHC.Prim.<=# c#_abiR 0#) } in
                                              Data.Text.Internal.Lazy.$WChunk
                                                (Data.Text.Internal.$WText
                                                   (Data.Text.Array.ByteArray bx_abiB)
                                                   (GHC.Types.I# (GHC.Prim.+# bx1_abiC y_abiS))
                                                   (GHC.Types.I# (GHC.Prim.-# bx2_abiD y_abiS)))
                                                ts_abiE
                                              };
                                            GHC.Types.EQ -> ts_abiE
                                          })
                                   })
                                (let {
                                   f2_abiU
                                     :: Data.Text.Internal.Lazy.Text
                                        -> f_abiq Data.Text.Internal.Lazy.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abiU
                                     = GHC.Base.pure
                                         @f_abiq
                                         $dApplicative_abis
                                         @Data.Text.Internal.Lazy.Text } in
                                 let {
                                   ds2_abiV
                                     :: f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                        -> f_abiq Data.Text.Internal.Lazy.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 100 0}]
                                   ds2_abiV
                                     = GHC.Base.fmap
                                         @f_abiq
                                         (GHC.Base.$p1Applicative @f_abiq $dApplicative_abis)
                                         @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                         @Data.Text.Internal.Lazy.Text
                                         (\ (p1_abiW
                                               :: (GHC.Types.Char, Data.Text.Internal.Lazy.Text)) ->
                                            case p1_abiW of { (x_abiY, ds_abiZ) ->
                                            Data.Text.Lazy.cons x_abiY ds_abiZ
                                            }) } in
                                 \ (ds3_abj1
                                      :: Data.Either.Either
                                           Data.Text.Internal.Lazy.Text
                                           (f_abiq
                                              (GHC.Types.Char, Data.Text.Internal.Lazy.Text))) ->
                                   case ds3_abj1 of {
                                     Data.Either.Left x_abj3 -> f2_abiU x_abj3;
                                     Data.Either.Right y_abj5 -> ds2_abiV y_abj5
                                   }) } in
                        let {
                          g_abj7
                            :: p_abip
                                 (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                 (f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                               -> p_abip
                                    (Data.Either.Either
                                       Data.Text.Internal.Lazy.Text
                                       (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                                    (Data.Either.Either
                                       Data.Text.Internal.Lazy.Text
                                       (f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abj7
                            = Data.Profunctor.Choice.right'
                                @p_abip
                                $dChoice_abir
                                @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                @(f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                                @Data.Text.Internal.Lazy.Text } in
                        \ (x_abj8
                             :: p_abip
                                  (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                  (f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text))) ->
                          f1_abit (g_abj7 x_abj8))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <Data.Text.Internal.Lazy.Text>_N
                                      <Data.Text.Internal.Lazy.Text>_N
                                      <GHC.Types.Char>_N
                                      <GHC.Types.Char>_N)
                             :: Control.Lens.Type.Prism
                                  Data.Text.Internal.Lazy.Text
                                  Data.Text.Internal.Lazy.Text
                                  (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                  (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                ~R# Control.Lens.Cons.Cons
                                      Data.Text.Internal.Lazy.Text
                                      Data.Text.Internal.Lazy.Text
                                      GHC.Types.Char
                                      GHC.Types.Char)
              ValArg (\ (@(p_abip :: * -> * -> *))
                        (@(f_abiq :: * -> *))
                        ($dChoice_abir :: Data.Profunctor.Choice.Choice p_abip)
                        ($dApplicative_abis :: GHC.Base.Applicative f_abiq) ->
                        let {
                          f1_abit
                            :: p_abip
                                 (Data.Either.Either
                                    Data.Text.Internal.Lazy.Text
                                    (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                                 (Data.Either.Either
                                    Data.Text.Internal.Lazy.Text
                                    (f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                               -> p_abip
                                    Data.Text.Internal.Lazy.Text
                                    (f_abiq Data.Text.Internal.Lazy.Text)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 639 0}]
                          f1_abit
                            = Data.Profunctor.Unsafe.dimap
                                @p_abip
                                (Data.Profunctor.Choice.$p1Choice @p_abip $dChoice_abir)
                                @Data.Text.Internal.Lazy.Text
                                @(Data.Either.Either
                                    Data.Text.Internal.Lazy.Text
                                    (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                                @(Data.Either.Either
                                    Data.Text.Internal.Lazy.Text
                                    (f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                                @(f_abiq Data.Text.Internal.Lazy.Text)
                                (\ (s1_abiu :: Data.Text.Internal.Lazy.Text) ->
                                   case s1_abiu of {
                                     Data.Text.Internal.Lazy.Empty ->
                                       Data.Either.Left
                                         @Data.Text.Internal.Lazy.Text
                                         @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                         Data.Text.Internal.Lazy.Empty;
                                     Data.Text.Internal.Lazy.Chunk bx_abiB bx1_abiC bx2_abiD
                                                                   ts_abiE ->
                                       Data.Either.Right
                                         @Data.Text.Internal.Lazy.Text
                                         @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                         (case GHC.Prim.indexWord8Array# bx_abiB bx1_abiC of r#_abiG
                                          { __DEFAULT ->
                                          let {
                                            c#_abiH :: GHC.Prim.Int#
                                            [LclId,
                                             Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                     Value=False, ConLike=False, WorkFree=False,
                                                     Expandable=False,
                                                     Guidance=IF_ARGS [] 4 0}]
                                            c#_abiH
                                              = GHC.Prim.word2Int#
                                                  (GHC.Prim.clz8#
                                                     (GHC.Prim.and#
                                                        (GHC.Prim.not#
                                                           (GHC.Prim.word8ToWord# r#_abiG))
                                                        255##)) } in
                                          case GHC.Prim.xorI# c#_abiH (GHC.Prim.<=# c#_abiH 0#) of {
                                            __DEFAULT ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abiB (GHC.Prim.+# bx1_abiC 1#)
                                              of r#1_abiJ
                                              { __DEFAULT ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abiB (GHC.Prim.+# bx1_abiC 2#)
                                              of r#2_abiK
                                              { __DEFAULT ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abiB (GHC.Prim.+# bx1_abiC 3#)
                                              of r#3_abiL
                                              { __DEFAULT ->
                                              GHC.Types.C#
                                                (GHC.Prim.chr#
                                                   (GHC.Prim.-#
                                                      (GHC.Prim.+#
                                                         (GHC.Prim.+#
                                                            (GHC.Prim.+#
                                                               (GHC.Prim.uncheckedIShiftL#
                                                                  (GHC.Prim.-#
                                                                     (GHC.Prim.word2Int#
                                                                        (GHC.Prim.word8ToWord#
                                                                           r#_abiG))
                                                                     240#)
                                                                  18#)
                                                               (GHC.Prim.uncheckedIShiftL#
                                                                  (GHC.Prim.-#
                                                                     (GHC.Prim.word2Int#
                                                                        (GHC.Prim.word8ToWord#
                                                                           r#1_abiJ))
                                                                     128#)
                                                                  12#))
                                                            (GHC.Prim.uncheckedIShiftL#
                                                               (GHC.Prim.-#
                                                                  (GHC.Prim.word2Int#
                                                                     (GHC.Prim.word8ToWord#
                                                                        r#2_abiK))
                                                                  128#)
                                                               6#))
                                                         (GHC.Prim.word2Int#
                                                            (GHC.Prim.word8ToWord# r#3_abiL)))
                                                      128#))
                                              }
                                              }
                                              };
                                            1# ->
                                              GHC.Types.C#
                                                (GHC.Prim.chr#
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.word8ToWord# r#_abiG)));
                                            2# ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abiB (GHC.Prim.+# bx1_abiC 1#)
                                              of r#1_abiM
                                              { __DEFAULT ->
                                              GHC.Types.C#
                                                (GHC.Prim.chr#
                                                   (GHC.Prim.-#
                                                      (GHC.Prim.+#
                                                         (GHC.Prim.uncheckedIShiftL#
                                                            (GHC.Prim.-#
                                                               (GHC.Prim.word2Int#
                                                                  (GHC.Prim.word8ToWord# r#_abiG))
                                                               192#)
                                                            6#)
                                                         (GHC.Prim.word2Int#
                                                            (GHC.Prim.word8ToWord# r#1_abiM)))
                                                      128#))
                                              };
                                            3# ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abiB (GHC.Prim.+# bx1_abiC 1#)
                                              of r#1_abiN
                                              { __DEFAULT ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abiB (GHC.Prim.+# bx1_abiC 2#)
                                              of r#2_abiO
                                              { __DEFAULT ->
                                              GHC.Types.C#
                                                (GHC.Prim.chr#
                                                   (GHC.Prim.-#
                                                      (GHC.Prim.+#
                                                         (GHC.Prim.+#
                                                            (GHC.Prim.uncheckedIShiftL#
                                                               (GHC.Prim.-#
                                                                  (GHC.Prim.word2Int#
                                                                     (GHC.Prim.word8ToWord#
                                                                        r#_abiG))
                                                                  224#)
                                                               12#)
                                                            (GHC.Prim.uncheckedIShiftL#
                                                               (GHC.Prim.-#
                                                                  (GHC.Prim.word2Int#
                                                                     (GHC.Prim.word8ToWord#
                                                                        r#1_abiN))
                                                                  128#)
                                                               6#))
                                                         (GHC.Prim.word2Int#
                                                            (GHC.Prim.word8ToWord# r#2_abiO)))
                                                      128#))
                                              }
                                              }
                                          }
                                          },
                                          case Data.Text.compareLength
                                                 (Data.Text.Internal.Text bx_abiB bx1_abiC bx2_abiD)
                                                 (GHC.Types.I# 1#)
                                          of {
                                            __DEFAULT ->
                                              case GHC.Prim.indexWord8Array# bx_abiB bx1_abiC
                                              of r#_abiQ
                                              { __DEFAULT ->
                                              let {
                                                c#_abiR :: GHC.Prim.Int#
                                                [LclId,
                                                 Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                         Value=False, ConLike=False, WorkFree=False,
                                                         Expandable=False,
                                                         Guidance=IF_ARGS [] 4 0}]
                                                c#_abiR
                                                  = GHC.Prim.word2Int#
                                                      (GHC.Prim.clz8#
                                                         (GHC.Prim.and#
                                                            (GHC.Prim.not#
                                                               (GHC.Prim.word8ToWord# r#_abiQ))
                                                            255##)) } in
                                              let {
                                                y_abiS :: GHC.Prim.Int#
                                                [LclId,
                                                 Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                         Value=False, ConLike=False, WorkFree=False,
                                                         Expandable=False,
                                                         Guidance=IF_ARGS [] 2 0}]
                                                y_abiS
                                                  = GHC.Prim.xorI#
                                                      c#_abiR (GHC.Prim.<=# c#_abiR 0#) } in
                                              Data.Text.Internal.Lazy.$WChunk
                                                (Data.Text.Internal.$WText
                                                   (Data.Text.Array.ByteArray bx_abiB)
                                                   (GHC.Types.I# (GHC.Prim.+# bx1_abiC y_abiS))
                                                   (GHC.Types.I# (GHC.Prim.-# bx2_abiD y_abiS)))
                                                ts_abiE
                                              };
                                            GHC.Types.EQ -> ts_abiE
                                          })
                                   })
                                (let {
                                   f2_abiU
                                     :: Data.Text.Internal.Lazy.Text
                                        -> f_abiq Data.Text.Internal.Lazy.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abiU
                                     = GHC.Base.pure
                                         @f_abiq
                                         $dApplicative_abis
                                         @Data.Text.Internal.Lazy.Text } in
                                 let {
                                   ds2_abiV
                                     :: f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                        -> f_abiq Data.Text.Internal.Lazy.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 100 0}]
                                   ds2_abiV
                                     = GHC.Base.fmap
                                         @f_abiq
                                         (GHC.Base.$p1Applicative @f_abiq $dApplicative_abis)
                                         @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                         @Data.Text.Internal.Lazy.Text
                                         (\ (p1_abiW
                                               :: (GHC.Types.Char, Data.Text.Internal.Lazy.Text)) ->
                                            case p1_abiW of { (x_abiY, ds_abiZ) ->
                                            Data.Text.Lazy.cons x_abiY ds_abiZ
                                            }) } in
                                 \ (ds3_abj1
                                      :: Data.Either.Either
                                           Data.Text.Internal.Lazy.Text
                                           (f_abiq
                                              (GHC.Types.Char, Data.Text.Internal.Lazy.Text))) ->
                                   case ds3_abj1 of {
                                     Data.Either.Left x_abj3 -> f2_abiU x_abj3;
                                     Data.Either.Right y_abj5 -> ds2_abiV y_abj5
                                   }) } in
                        let {
                          g_abj7
                            :: p_abip
                                 (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                 (f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                               -> p_abip
                                    (Data.Either.Either
                                       Data.Text.Internal.Lazy.Text
                                       (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                                    (Data.Either.Either
                                       Data.Text.Internal.Lazy.Text
                                       (f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abj7
                            = Data.Profunctor.Choice.right'
                                @p_abip
                                $dChoice_abir
                                @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                @(f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                                @Data.Text.Internal.Lazy.Text } in
                        \ (x_abj8
                             :: p_abip
                                  (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                  (f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text))) ->
                          f1_abit (g_abj7 x_abj8))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <Data.Text.Internal.Lazy.Text>_N
                                      <Data.Text.Internal.Lazy.Text>_N
                                      <GHC.Types.Char>_N
                                      <GHC.Types.Char>_N)
                             :: Control.Lens.Type.Prism
                                  Data.Text.Internal.Lazy.Text
                                  Data.Text.Internal.Lazy.Text
                                  (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                  (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                ~R# Control.Lens.Cons.Cons
                                      Data.Text.Internal.Lazy.Text
                                      Data.Text.Internal.Lazy.Text
                                      GHC.Types.Char
                                      GHC.Types.Char)
              ValArg (\ (@(p_abjb :: * -> * -> *))
                        (@(f_abjc :: * -> *))
                        ($dChoice_abjd :: Data.Profunctor.Choice.Choice p_abjb)
                        ($dApplicative_abje :: GHC.Base.Applicative f_abjc) ->
                        let {
                          f1_abjf
                            :: p_abjb
                                 (Data.Either.Either Data.Text.Internal.Lazy.Text ())
                                 (Data.Either.Either Data.Text.Internal.Lazy.Text (f_abjc ()))
                               -> p_abjb
                                    Data.Text.Internal.Lazy.Text
                                    (f_abjc Data.Text.Internal.Lazy.Text)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 310 0}]
                          f1_abjf
                            = Data.Profunctor.Unsafe.dimap
                                @p_abjb
                                (Data.Profunctor.Choice.$p1Choice @p_abjb $dChoice_abjd)
                                @Data.Text.Internal.Lazy.Text
                                @(Data.Either.Either Data.Text.Internal.Lazy.Text ())
                                @(Data.Either.Either Data.Text.Internal.Lazy.Text (f_abjc ()))
                                @(f_abjc Data.Text.Internal.Lazy.Text)
                                (\ (s_abjg :: Data.Text.Internal.Lazy.Text) ->
                                   case Data.Text.Lazy.null s_abjg of {
                                     GHC.Types.False ->
                                       Data.Either.Left @Data.Text.Internal.Lazy.Text @() s_abjg;
                                     GHC.Types.True ->
                                       Data.Either.Right
                                         @Data.Text.Internal.Lazy.Text @() GHC.Tuple.Prim.()
                                   })
                                (let {
                                   f2_abjj
                                     :: Data.Text.Internal.Lazy.Text
                                        -> f_abjc Data.Text.Internal.Lazy.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abjj
                                     = GHC.Base.pure
                                         @f_abjc
                                         $dApplicative_abje
                                         @Data.Text.Internal.Lazy.Text } in
                                 let {
                                   ds2_abjk :: f_abjc () -> f_abjc Data.Text.Internal.Lazy.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 70 0}]
                                   ds2_abjk
                                     = GHC.Base.fmap
                                         @f_abjc
                                         (GHC.Base.$p1Applicative @f_abjc $dApplicative_abje)
                                         @()
                                         @Data.Text.Internal.Lazy.Text
                                         (\ (ds3_abjl :: ()) ->
                                            case ds3_abjl of { () ->
                                            Data.Text.Internal.Lazy.empty
                                            }) } in
                                 \ (ds3_abjn
                                      :: Data.Either.Either
                                           Data.Text.Internal.Lazy.Text (f_abjc ())) ->
                                   case ds3_abjn of {
                                     Data.Either.Left x_abjp -> f2_abjj x_abjp;
                                     Data.Either.Right y_abjr -> ds2_abjk y_abjr
                                   }) } in
                        let {
                          g_abjt
                            :: p_abjb () (f_abjc ())
                               -> p_abjb
                                    (Data.Either.Either Data.Text.Internal.Lazy.Text ())
                                    (Data.Either.Either Data.Text.Internal.Lazy.Text (f_abjc ()))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abjt
                            = Data.Profunctor.Choice.right'
                                @p_abjb
                                $dChoice_abjd
                                @()
                                @(f_abjc ())
                                @Data.Text.Internal.Lazy.Text } in
                        \ (x_abju :: p_abjb () (f_abjc ())) -> f1_abjf (g_abjt x_abju))
                     `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                      <Data.Text.Internal.Lazy.Text>_N)
                             :: Control.Lens.Type.Prism' Data.Text.Internal.Lazy.Text ()
                                ~R# Control.Lens.Empty.AsEmpty Data.Text.Internal.Lazy.Text)
              TyArg Data.Functor.Const.Const Data.Text.Internal.Lazy.Text
              ValArg Data.Functor.Contravariant.$fContravariantConst
                       @Data.Text.Internal.Lazy.Text
              ValArg Data.Functor.Const.$fFunctorConst
                       @Data.Text.Internal.Lazy.Text
    After:  (\ (@s1_abf7)
               (@(f_abf8 :: * -> *))
               (@a_abf9)
               ($dCons_abfa
                  :: Control.Lens.Cons.Cons s1_abf7 s1_abf7 a_abf9 a_abf9)
               ($dCons1_abfb
                  :: Control.Lens.Cons.Cons s1_abf7 s1_abf7 a_abf9 a_abf9)
               ($dAsEmpty_abfc :: Control.Lens.Empty.AsEmpty s1_abf7)
               ($dContravariant_abfd
                  :: Data.Functor.Contravariant.Contravariant f_abf8)
               ($dFunctor_abfe :: GHC.Base.Functor f_abf8) ->
               GHC.Base.id @(s1_abf7 -> f_abf8 s1_abf7))
              @Data.Text.Internal.Lazy.Text
              @(Data.Functor.Const.Const Data.Text.Internal.Lazy.Text)
              @GHC.Types.Char
              ((\ (@(p_abip :: * -> * -> *))
                  (@(f_abiq :: * -> *))
                  ($dChoice_abir :: Data.Profunctor.Choice.Choice p_abip)
                  ($dApplicative_abis :: GHC.Base.Applicative f_abiq) ->
                  let {
                    f1_abit
                      :: p_abip
                           (Data.Either.Either
                              Data.Text.Internal.Lazy.Text
                              (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                           (Data.Either.Either
                              Data.Text.Internal.Lazy.Text
                              (f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                         -> p_abip
                              Data.Text.Internal.Lazy.Text (f_abiq Data.Text.Internal.Lazy.Text)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 639 0}]
                    f1_abit
                      = Data.Profunctor.Unsafe.dimap
                          @p_abip
                          (Data.Profunctor.Choice.$p1Choice @p_abip $dChoice_abir)
                          @Data.Text.Internal.Lazy.Text
                          @(Data.Either.Either
                              Data.Text.Internal.Lazy.Text
                              (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                          @(Data.Either.Either
                              Data.Text.Internal.Lazy.Text
                              (f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                          @(f_abiq Data.Text.Internal.Lazy.Text)
                          (\ (s1_abiu :: Data.Text.Internal.Lazy.Text) ->
                             case s1_abiu of {
                               Data.Text.Internal.Lazy.Empty ->
                                 Data.Either.Left
                                   @Data.Text.Internal.Lazy.Text
                                   @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                   Data.Text.Internal.Lazy.Empty;
                               Data.Text.Internal.Lazy.Chunk bx_abiB bx1_abiC bx2_abiD ts_abiE ->
                                 Data.Either.Right
                                   @Data.Text.Internal.Lazy.Text
                                   @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                   (case GHC.Prim.indexWord8Array# bx_abiB bx1_abiC of r#_abiG
                                    { __DEFAULT ->
                                    let {
                                      c#_abiH :: GHC.Prim.Int#
                                      [LclId,
                                       Unf=Unf{Src=<vanilla>, TopLvl=False,
                                               Value=False, ConLike=False, WorkFree=False,
                                               Expandable=False,
                                               Guidance=IF_ARGS [] 4 0}]
                                      c#_abiH
                                        = GHC.Prim.word2Int#
                                            (GHC.Prim.clz8#
                                               (GHC.Prim.and#
                                                  (GHC.Prim.not# (GHC.Prim.word8ToWord# r#_abiG))
                                                  255##)) } in
                                    case GHC.Prim.xorI# c#_abiH (GHC.Prim.<=# c#_abiH 0#) of {
                                      __DEFAULT ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abiB (GHC.Prim.+# bx1_abiC 1#)
                                        of r#1_abiJ
                                        { __DEFAULT ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abiB (GHC.Prim.+# bx1_abiC 2#)
                                        of r#2_abiK
                                        { __DEFAULT ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abiB (GHC.Prim.+# bx1_abiC 3#)
                                        of r#3_abiL
                                        { __DEFAULT ->
                                        GHC.Types.C#
                                          (GHC.Prim.chr#
                                             (GHC.Prim.-#
                                                (GHC.Prim.+#
                                                   (GHC.Prim.+#
                                                      (GHC.Prim.+#
                                                         (GHC.Prim.uncheckedIShiftL#
                                                            (GHC.Prim.-#
                                                               (GHC.Prim.word2Int#
                                                                  (GHC.Prim.word8ToWord# r#_abiG))
                                                               240#)
                                                            18#)
                                                         (GHC.Prim.uncheckedIShiftL#
                                                            (GHC.Prim.-#
                                                               (GHC.Prim.word2Int#
                                                                  (GHC.Prim.word8ToWord# r#1_abiJ))
                                                               128#)
                                                            12#))
                                                      (GHC.Prim.uncheckedIShiftL#
                                                         (GHC.Prim.-#
                                                            (GHC.Prim.word2Int#
                                                               (GHC.Prim.word8ToWord# r#2_abiK))
                                                            128#)
                                                         6#))
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.word8ToWord# r#3_abiL)))
                                                128#))
                                        }
                                        }
                                        };
                                      1# ->
                                        GHC.Types.C#
                                          (GHC.Prim.chr#
                                             (GHC.Prim.word2Int# (GHC.Prim.word8ToWord# r#_abiG)));
                                      2# ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abiB (GHC.Prim.+# bx1_abiC 1#)
                                        of r#1_abiM
                                        { __DEFAULT ->
                                        GHC.Types.C#
                                          (GHC.Prim.chr#
                                             (GHC.Prim.-#
                                                (GHC.Prim.+#
                                                   (GHC.Prim.uncheckedIShiftL#
                                                      (GHC.Prim.-#
                                                         (GHC.Prim.word2Int#
                                                            (GHC.Prim.word8ToWord# r#_abiG))
                                                         192#)
                                                      6#)
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.word8ToWord# r#1_abiM)))
                                                128#))
                                        };
                                      3# ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abiB (GHC.Prim.+# bx1_abiC 1#)
                                        of r#1_abiN
                                        { __DEFAULT ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abiB (GHC.Prim.+# bx1_abiC 2#)
                                        of r#2_abiO
                                        { __DEFAULT ->
                                        GHC.Types.C#
                                          (GHC.Prim.chr#
                                             (GHC.Prim.-#
                                                (GHC.Prim.+#
                                                   (GHC.Prim.+#
                                                      (GHC.Prim.uncheckedIShiftL#
                                                         (GHC.Prim.-#
                                                            (GHC.Prim.word2Int#
                                                               (GHC.Prim.word8ToWord# r#_abiG))
                                                            224#)
                                                         12#)
                                                      (GHC.Prim.uncheckedIShiftL#
                                                         (GHC.Prim.-#
                                                            (GHC.Prim.word2Int#
                                                               (GHC.Prim.word8ToWord# r#1_abiN))
                                                            128#)
                                                         6#))
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.word8ToWord# r#2_abiO)))
                                                128#))
                                        }
                                        }
                                    }
                                    },
                                    case Data.Text.compareLength
                                           (Data.Text.Internal.Text bx_abiB bx1_abiC bx2_abiD)
                                           (GHC.Types.I# 1#)
                                    of {
                                      __DEFAULT ->
                                        case GHC.Prim.indexWord8Array# bx_abiB bx1_abiC of r#_abiQ
                                        { __DEFAULT ->
                                        let {
                                          c#_abiR :: GHC.Prim.Int#
                                          [LclId,
                                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                   Value=False, ConLike=False, WorkFree=False,
                                                   Expandable=False,
                                                   Guidance=IF_ARGS [] 4 0}]
                                          c#_abiR
                                            = GHC.Prim.word2Int#
                                                (GHC.Prim.clz8#
                                                   (GHC.Prim.and#
                                                      (GHC.Prim.not#
                                                         (GHC.Prim.word8ToWord# r#_abiQ))
                                                      255##)) } in
                                        let {
                                          y_abiS :: GHC.Prim.Int#
                                          [LclId,
                                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                   Value=False, ConLike=False, WorkFree=False,
                                                   Expandable=False,
                                                   Guidance=IF_ARGS [] 2 0}]
                                          y_abiS
                                            = GHC.Prim.xorI# c#_abiR (GHC.Prim.<=# c#_abiR 0#) } in
                                        Data.Text.Internal.Lazy.$WChunk
                                          (Data.Text.Internal.$WText
                                             (Data.Text.Array.ByteArray bx_abiB)
                                             (GHC.Types.I# (GHC.Prim.+# bx1_abiC y_abiS))
                                             (GHC.Types.I# (GHC.Prim.-# bx2_abiD y_abiS)))
                                          ts_abiE
                                        };
                                      GHC.Types.EQ -> ts_abiE
                                    })
                             })
                          (let {
                             f2_abiU
                               :: Data.Text.Internal.Lazy.Text
                                  -> f_abiq Data.Text.Internal.Lazy.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abiU
                               = GHC.Base.pure
                                   @f_abiq $dApplicative_abis @Data.Text.Internal.Lazy.Text } in
                           let {
                             ds2_abiV
                               :: f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                  -> f_abiq Data.Text.Internal.Lazy.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 100 0}]
                             ds2_abiV
                               = GHC.Base.fmap
                                   @f_abiq
                                   (GHC.Base.$p1Applicative @f_abiq $dApplicative_abis)
                                   @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                   @Data.Text.Internal.Lazy.Text
                                   (\ (p1_abiW :: (GHC.Types.Char, Data.Text.Internal.Lazy.Text)) ->
                                      case p1_abiW of { (x_abiY, ds_abiZ) ->
                                      Data.Text.Lazy.cons x_abiY ds_abiZ
                                      }) } in
                           \ (ds3_abj1
                                :: Data.Either.Either
                                     Data.Text.Internal.Lazy.Text
                                     (f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text))) ->
                             case ds3_abj1 of {
                               Data.Either.Left x_abj3 -> f2_abiU x_abj3;
                               Data.Either.Right y_abj5 -> ds2_abiV y_abj5
                             }) } in
                  let {
                    g_abj7
                      :: p_abip
                           (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                           (f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                         -> p_abip
                              (Data.Either.Either
                                 Data.Text.Internal.Lazy.Text
                                 (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                              (Data.Either.Either
                                 Data.Text.Internal.Lazy.Text
                                 (f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abj7
                      = Data.Profunctor.Choice.right'
                          @p_abip
                          $dChoice_abir
                          @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                          @(f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                          @Data.Text.Internal.Lazy.Text } in
                  \ (x_abj8
                       :: p_abip
                            (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                            (f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text))) ->
                    f1_abit (g_abj7 x_abj8))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <Data.Text.Internal.Lazy.Text>_N
                                <Data.Text.Internal.Lazy.Text>_N
                                <GHC.Types.Char>_N
                                <GHC.Types.Char>_N)
                       :: Control.Lens.Type.Prism
                            Data.Text.Internal.Lazy.Text
                            Data.Text.Internal.Lazy.Text
                            (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                            (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                          ~R# Control.Lens.Cons.Cons
                                Data.Text.Internal.Lazy.Text
                                Data.Text.Internal.Lazy.Text
                                GHC.Types.Char
                                GHC.Types.Char))
              ((\ (@(p_abip :: * -> * -> *))
                  (@(f_abiq :: * -> *))
                  ($dChoice_abir :: Data.Profunctor.Choice.Choice p_abip)
                  ($dApplicative_abis :: GHC.Base.Applicative f_abiq) ->
                  let {
                    f1_abit
                      :: p_abip
                           (Data.Either.Either
                              Data.Text.Internal.Lazy.Text
                              (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                           (Data.Either.Either
                              Data.Text.Internal.Lazy.Text
                              (f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                         -> p_abip
                              Data.Text.Internal.Lazy.Text (f_abiq Data.Text.Internal.Lazy.Text)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 639 0}]
                    f1_abit
                      = Data.Profunctor.Unsafe.dimap
                          @p_abip
                          (Data.Profunctor.Choice.$p1Choice @p_abip $dChoice_abir)
                          @Data.Text.Internal.Lazy.Text
                          @(Data.Either.Either
                              Data.Text.Internal.Lazy.Text
                              (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                          @(Data.Either.Either
                              Data.Text.Internal.Lazy.Text
                              (f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                          @(f_abiq Data.Text.Internal.Lazy.Text)
                          (\ (s1_abiu :: Data.Text.Internal.Lazy.Text) ->
                             case s1_abiu of {
                               Data.Text.Internal.Lazy.Empty ->
                                 Data.Either.Left
                                   @Data.Text.Internal.Lazy.Text
                                   @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                   Data.Text.Internal.Lazy.Empty;
                               Data.Text.Internal.Lazy.Chunk bx_abiB bx1_abiC bx2_abiD ts_abiE ->
                                 Data.Either.Right
                                   @Data.Text.Internal.Lazy.Text
                                   @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                   (case GHC.Prim.indexWord8Array# bx_abiB bx1_abiC of r#_abiG
                                    { __DEFAULT ->
                                    let {
                                      c#_abiH :: GHC.Prim.Int#
                                      [LclId,
                                       Unf=Unf{Src=<vanilla>, TopLvl=False,
                                               Value=False, ConLike=False, WorkFree=False,
                                               Expandable=False,
                                               Guidance=IF_ARGS [] 4 0}]
                                      c#_abiH
                                        = GHC.Prim.word2Int#
                                            (GHC.Prim.clz8#
                                               (GHC.Prim.and#
                                                  (GHC.Prim.not# (GHC.Prim.word8ToWord# r#_abiG))
                                                  255##)) } in
                                    case GHC.Prim.xorI# c#_abiH (GHC.Prim.<=# c#_abiH 0#) of {
                                      __DEFAULT ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abiB (GHC.Prim.+# bx1_abiC 1#)
                                        of r#1_abiJ
                                        { __DEFAULT ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abiB (GHC.Prim.+# bx1_abiC 2#)
                                        of r#2_abiK
                                        { __DEFAULT ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abiB (GHC.Prim.+# bx1_abiC 3#)
                                        of r#3_abiL
                                        { __DEFAULT ->
                                        GHC.Types.C#
                                          (GHC.Prim.chr#
                                             (GHC.Prim.-#
                                                (GHC.Prim.+#
                                                   (GHC.Prim.+#
                                                      (GHC.Prim.+#
                                                         (GHC.Prim.uncheckedIShiftL#
                                                            (GHC.Prim.-#
                                                               (GHC.Prim.word2Int#
                                                                  (GHC.Prim.word8ToWord# r#_abiG))
                                                               240#)
                                                            18#)
                                                         (GHC.Prim.uncheckedIShiftL#
                                                            (GHC.Prim.-#
                                                               (GHC.Prim.word2Int#
                                                                  (GHC.Prim.word8ToWord# r#1_abiJ))
                                                               128#)
                                                            12#))
                                                      (GHC.Prim.uncheckedIShiftL#
                                                         (GHC.Prim.-#
                                                            (GHC.Prim.word2Int#
                                                               (GHC.Prim.word8ToWord# r#2_abiK))
                                                            128#)
                                                         6#))
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.word8ToWord# r#3_abiL)))
                                                128#))
                                        }
                                        }
                                        };
                                      1# ->
                                        GHC.Types.C#
                                          (GHC.Prim.chr#
                                             (GHC.Prim.word2Int# (GHC.Prim.word8ToWord# r#_abiG)));
                                      2# ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abiB (GHC.Prim.+# bx1_abiC 1#)
                                        of r#1_abiM
                                        { __DEFAULT ->
                                        GHC.Types.C#
                                          (GHC.Prim.chr#
                                             (GHC.Prim.-#
                                                (GHC.Prim.+#
                                                   (GHC.Prim.uncheckedIShiftL#
                                                      (GHC.Prim.-#
                                                         (GHC.Prim.word2Int#
                                                            (GHC.Prim.word8ToWord# r#_abiG))
                                                         192#)
                                                      6#)
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.word8ToWord# r#1_abiM)))
                                                128#))
                                        };
                                      3# ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abiB (GHC.Prim.+# bx1_abiC 1#)
                                        of r#1_abiN
                                        { __DEFAULT ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abiB (GHC.Prim.+# bx1_abiC 2#)
                                        of r#2_abiO
                                        { __DEFAULT ->
                                        GHC.Types.C#
                                          (GHC.Prim.chr#
                                             (GHC.Prim.-#
                                                (GHC.Prim.+#
                                                   (GHC.Prim.+#
                                                      (GHC.Prim.uncheckedIShiftL#
                                                         (GHC.Prim.-#
                                                            (GHC.Prim.word2Int#
                                                               (GHC.Prim.word8ToWord# r#_abiG))
                                                            224#)
                                                         12#)
                                                      (GHC.Prim.uncheckedIShiftL#
                                                         (GHC.Prim.-#
                                                            (GHC.Prim.word2Int#
                                                               (GHC.Prim.word8ToWord# r#1_abiN))
                                                            128#)
                                                         6#))
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.word8ToWord# r#2_abiO)))
                                                128#))
                                        }
                                        }
                                    }
                                    },
                                    case Data.Text.compareLength
                                           (Data.Text.Internal.Text bx_abiB bx1_abiC bx2_abiD)
                                           (GHC.Types.I# 1#)
                                    of {
                                      __DEFAULT ->
                                        case GHC.Prim.indexWord8Array# bx_abiB bx1_abiC of r#_abiQ
                                        { __DEFAULT ->
                                        let {
                                          c#_abiR :: GHC.Prim.Int#
                                          [LclId,
                                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                   Value=False, ConLike=False, WorkFree=False,
                                                   Expandable=False,
                                                   Guidance=IF_ARGS [] 4 0}]
                                          c#_abiR
                                            = GHC.Prim.word2Int#
                                                (GHC.Prim.clz8#
                                                   (GHC.Prim.and#
                                                      (GHC.Prim.not#
                                                         (GHC.Prim.word8ToWord# r#_abiQ))
                                                      255##)) } in
                                        let {
                                          y_abiS :: GHC.Prim.Int#
                                          [LclId,
                                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                   Value=False, ConLike=False, WorkFree=False,
                                                   Expandable=False,
                                                   Guidance=IF_ARGS [] 2 0}]
                                          y_abiS
                                            = GHC.Prim.xorI# c#_abiR (GHC.Prim.<=# c#_abiR 0#) } in
                                        Data.Text.Internal.Lazy.$WChunk
                                          (Data.Text.Internal.$WText
                                             (Data.Text.Array.ByteArray bx_abiB)
                                             (GHC.Types.I# (GHC.Prim.+# bx1_abiC y_abiS))
                                             (GHC.Types.I# (GHC.Prim.-# bx2_abiD y_abiS)))
                                          ts_abiE
                                        };
                                      GHC.Types.EQ -> ts_abiE
                                    })
                             })
                          (let {
                             f2_abiU
                               :: Data.Text.Internal.Lazy.Text
                                  -> f_abiq Data.Text.Internal.Lazy.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abiU
                               = GHC.Base.pure
                                   @f_abiq $dApplicative_abis @Data.Text.Internal.Lazy.Text } in
                           let {
                             ds2_abiV
                               :: f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                  -> f_abiq Data.Text.Internal.Lazy.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 100 0}]
                             ds2_abiV
                               = GHC.Base.fmap
                                   @f_abiq
                                   (GHC.Base.$p1Applicative @f_abiq $dApplicative_abis)
                                   @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                   @Data.Text.Internal.Lazy.Text
                                   (\ (p1_abiW :: (GHC.Types.Char, Data.Text.Internal.Lazy.Text)) ->
                                      case p1_abiW of { (x_abiY, ds_abiZ) ->
                                      Data.Text.Lazy.cons x_abiY ds_abiZ
                                      }) } in
                           \ (ds3_abj1
                                :: Data.Either.Either
                                     Data.Text.Internal.Lazy.Text
                                     (f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text))) ->
                             case ds3_abj1 of {
                               Data.Either.Left x_abj3 -> f2_abiU x_abj3;
                               Data.Either.Right y_abj5 -> ds2_abiV y_abj5
                             }) } in
                  let {
                    g_abj7
                      :: p_abip
                           (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                           (f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                         -> p_abip
                              (Data.Either.Either
                                 Data.Text.Internal.Lazy.Text
                                 (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                              (Data.Either.Either
                                 Data.Text.Internal.Lazy.Text
                                 (f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abj7
                      = Data.Profunctor.Choice.right'
                          @p_abip
                          $dChoice_abir
                          @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                          @(f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                          @Data.Text.Internal.Lazy.Text } in
                  \ (x_abj8
                       :: p_abip
                            (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                            (f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text))) ->
                    f1_abit (g_abj7 x_abj8))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <Data.Text.Internal.Lazy.Text>_N
                                <Data.Text.Internal.Lazy.Text>_N
                                <GHC.Types.Char>_N
                                <GHC.Types.Char>_N)
                       :: Control.Lens.Type.Prism
                            Data.Text.Internal.Lazy.Text
                            Data.Text.Internal.Lazy.Text
                            (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                            (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                          ~R# Control.Lens.Cons.Cons
                                Data.Text.Internal.Lazy.Text
                                Data.Text.Internal.Lazy.Text
                                GHC.Types.Char
                                GHC.Types.Char))
              ((\ (@(p_abjb :: * -> * -> *))
                  (@(f_abjc :: * -> *))
                  ($dChoice_abjd :: Data.Profunctor.Choice.Choice p_abjb)
                  ($dApplicative_abje :: GHC.Base.Applicative f_abjc) ->
                  let {
                    f1_abjf
                      :: p_abjb
                           (Data.Either.Either Data.Text.Internal.Lazy.Text ())
                           (Data.Either.Either Data.Text.Internal.Lazy.Text (f_abjc ()))
                         -> p_abjb
                              Data.Text.Internal.Lazy.Text (f_abjc Data.Text.Internal.Lazy.Text)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 310 0}]
                    f1_abjf
                      = Data.Profunctor.Unsafe.dimap
                          @p_abjb
                          (Data.Profunctor.Choice.$p1Choice @p_abjb $dChoice_abjd)
                          @Data.Text.Internal.Lazy.Text
                          @(Data.Either.Either Data.Text.Internal.Lazy.Text ())
                          @(Data.Either.Either Data.Text.Internal.Lazy.Text (f_abjc ()))
                          @(f_abjc Data.Text.Internal.Lazy.Text)
                          (\ (s_abjg :: Data.Text.Internal.Lazy.Text) ->
                             case Data.Text.Lazy.null s_abjg of {
                               GHC.Types.False ->
                                 Data.Either.Left @Data.Text.Internal.Lazy.Text @() s_abjg;
                               GHC.Types.True ->
                                 Data.Either.Right
                                   @Data.Text.Internal.Lazy.Text @() GHC.Tuple.Prim.()
                             })
                          (let {
                             f2_abjj
                               :: Data.Text.Internal.Lazy.Text
                                  -> f_abjc Data.Text.Internal.Lazy.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abjj
                               = GHC.Base.pure
                                   @f_abjc $dApplicative_abje @Data.Text.Internal.Lazy.Text } in
                           let {
                             ds2_abjk :: f_abjc () -> f_abjc Data.Text.Internal.Lazy.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 70 0}]
                             ds2_abjk
                               = GHC.Base.fmap
                                   @f_abjc
                                   (GHC.Base.$p1Applicative @f_abjc $dApplicative_abje)
                                   @()
                                   @Data.Text.Internal.Lazy.Text
                                   (\ (ds3_abjl :: ()) ->
                                      case ds3_abjl of { () -> Data.Text.Internal.Lazy.empty }) } in
                           \ (ds3_abjn
                                :: Data.Either.Either Data.Text.Internal.Lazy.Text (f_abjc ())) ->
                             case ds3_abjn of {
                               Data.Either.Left x_abjp -> f2_abjj x_abjp;
                               Data.Either.Right y_abjr -> ds2_abjk y_abjr
                             }) } in
                  let {
                    g_abjt
                      :: p_abjb () (f_abjc ())
                         -> p_abjb
                              (Data.Either.Either Data.Text.Internal.Lazy.Text ())
                              (Data.Either.Either Data.Text.Internal.Lazy.Text (f_abjc ()))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abjt
                      = Data.Profunctor.Choice.right'
                          @p_abjb
                          $dChoice_abjd
                          @()
                          @(f_abjc ())
                          @Data.Text.Internal.Lazy.Text } in
                  \ (x_abju :: p_abjb () (f_abjc ())) -> f1_abjf (g_abjt x_abju))
               `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                <Data.Text.Internal.Lazy.Text>_N)
                       :: Control.Lens.Type.Prism' Data.Text.Internal.Lazy.Text ()
                          ~R# Control.Lens.Empty.AsEmpty Data.Text.Internal.Lazy.Text))
              (Data.Functor.Contravariant.$fContravariantConst
                 @Data.Text.Internal.Lazy.Text)
              (Data.Functor.Const.$fFunctorConst @Data.Text.Internal.Lazy.Text)
    Cont:   ApplyToVal nodup hole Control.Lens.Getter.Getting
                                    Data.Text.Internal.Lazy.Text
                                    Data.Text.Internal.Lazy.Text
                                    Data.Text.Internal.Lazy.Text
              ((\ (ds_abe3 [Occ=Once1] :: a_abe0) -> ds_abe3)
               `cast` (<a_abe0>_R
                       %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                          <*>_N <a_abe0>_R <a_abe0>_P)
                       :: (a_abe0 -> a_abe0)
                          ~R# (a_abe0 -> Data.Functor.Const.Const a_abe0 a_abe0)))
            ApplyToVal nodup hole Data.Text.Internal.Lazy.Text
                                  -> Data.Functor.Const.Const
                                       Data.Text.Internal.Lazy.Text Data.Text.Internal.Lazy.Text
              s_a8Jn
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N
                        <Data.Text.Internal.Lazy.Text>_R
                        <Data.Text.Internal.Lazy.Text>_P
                    :: Data.Functor.Const.Const
                         Data.Text.Internal.Lazy.Text Data.Text.Internal.Lazy.Text
                       ~R# Data.Text.Internal.Lazy.Text)
            Stop[RuleArgCtxt] Data.Text.Internal.Lazy.Text
Rule fired
    Rule: Class op ==
    Module: (BUILTIN)
    Before: GHC.Classes.==
              TyArg Data.Text.Internal.Lazy.Text
              ValArg Data.Text.Lazy.$fEqText
              ValArg s_a8Jn
              ValArg s_a8Jn
    After:  Data.Text.Internal.Lazy.equal ValArg s_a8Jn ValArg s_a8Jn
    Cont:   Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: unpack
    Module: (GHC.Base)
    Before: GHC.CString.unpackCString# ValArg "B -> B"#
    After:  (\ (a_ab6H :: GHC.Prim.Addr#) ->
               GHC.Base.build
                 @GHC.Types.Char
                 (\ (@b_ab6I) -> GHC.CString.unpackFoldrCString# @b_ab6I a_ab6H))
              "B -> B"#
    Cont:   Stop[BoringCtxt] Test.Tasty.Core.TestName
Rule fired
    Rule: Class op property
    Module: (BUILTIN)
    Before: Test.QuickCheck.Property.property
              TyArg Data.ByteString.Internal.Type.ByteString -> GHC.Types.Bool
              ValArg $dTestable_a998
    After:  Test.QuickCheck.Property.$fTestableFUN_$cproperty
              @Data.ByteString.Internal.Type.ByteString
              @GHC.Types.Bool
              Test.QuickCheck.Instances.ByteString.$fArbitraryByteString0
              Data.ByteString.Internal.Type.$fShowByteString
              Test.QuickCheck.Property.$fTestableBool
    Cont:   ApplyToVal nodup hole (Data.ByteString.Internal.Type.ByteString
                                   -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              prop_ab6U
            CastIt (Sym (Test.Tasty.QuickCheck.N:QC[0])
                    :: Test.QuickCheck.Property.Property ~R# Test.Tasty.QuickCheck.QC)
            Stop[BoringCtxt] Test.Tasty.QuickCheck.QC
Rule fired
    Rule: Class op propertyForAllShrinkShow
    Module: (BUILTIN)
    Before: Test.QuickCheck.Property.propertyForAllShrinkShow
              TyArg GHC.Types.Bool ValArg Test.QuickCheck.Property.$fTestableBool
    After:  Test.QuickCheck.Property.$fTestableBool1
            `cast` (forall (a :: <*>_N).
                    <Test.QuickCheck.Gen.Gen a>_R
                    %<'GHC.Types.Many>_N ->_R <a -> [a]>_R
                    %<'GHC.Types.Many>_N ->_R <a -> [GHC.Base.String]>_R
                    %<'GHC.Types.Many>_N ->_R <a -> GHC.Types.Bool>_R
                    %<'GHC.Types.Many>_N ->_R Sym (Test.QuickCheck.Gen.N:Gen[0]
                                                       (Test.QuickCheck.Property.N:Prop[0]))
                                              ; Sym (Test.QuickCheck.Property.N:Property[0])
                    :: (forall {a}.
                        Test.QuickCheck.Gen.Gen a
                        -> (a -> [a])
                        -> (a -> [GHC.Base.String])
                        -> (a -> GHC.Types.Bool)
                        -> Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int
                        -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result)
                       ~R# (forall {a}.
                            Test.QuickCheck.Gen.Gen a
                            -> (a -> [a])
                            -> (a -> [GHC.Base.String])
                            -> (a -> GHC.Types.Bool)
                            -> Test.QuickCheck.Property.Property))
    Cont:   ApplyToTy Data.ByteString.Internal.Type.ByteString
            ApplyToVal nodup hole Test.QuickCheck.Gen.Gen
                                    Data.ByteString.Internal.Type.ByteString
                                  -> (Data.ByteString.Internal.Type.ByteString
                                      -> [Data.ByteString.Internal.Type.ByteString])
                                  -> (Data.ByteString.Internal.Type.ByteString -> [GHC.Base.String])
                                  -> (Data.ByteString.Internal.Type.ByteString -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (Test.QuickCheck.Arbitrary.arbitrary @a_ab8C $dArbitrary_ab8E)
            ApplyToVal nodup hole (Data.ByteString.Internal.Type.ByteString
                                   -> [Data.ByteString.Internal.Type.ByteString])
                                  -> (Data.ByteString.Internal.Type.ByteString -> [GHC.Base.String])
                                  -> (Data.ByteString.Internal.Type.ByteString -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (Test.QuickCheck.Arbitrary.shrink @a_ab8C $dArbitrary_ab8E)
            ApplyToVal nodup hole (Data.ByteString.Internal.Type.ByteString
                                   -> [GHC.Base.String])
                                  -> (Data.ByteString.Internal.Type.ByteString -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (let {
                 g_ab8I [Occ=OnceL1!] :: a_ab8C -> GHC.Base.String
                 [LclId]
                 g_ab8I = GHC.Show.show @a_ab8C $dShow_ab8F } in
               \ (x_ab8J [Occ=Once1] :: a_ab8C) ->
                 GHC.Types.:
                   @GHC.Base.String (g_ab8I x_ab8J) (GHC.Types.[] @GHC.Base.String))
            ApplyToVal nodup hole (Data.ByteString.Internal.Type.ByteString
                                   -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              f_ab8H
            CastIt (Sym (Test.Tasty.QuickCheck.N:QC[0])
                    :: Test.QuickCheck.Property.Property ~R# Test.Tasty.QuickCheck.QC)
            Stop[BoringCtxt] Test.Tasty.QuickCheck.QC
Rule fired
    Rule: Class op arbitrary
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.arbitrary
              TyArg Data.ByteString.Internal.Type.ByteString
              ValArg Test.QuickCheck.Instances.ByteString.$fArbitraryByteString0
    After:  Test.QuickCheck.Instances.ByteString.$fArbitraryByteString3
            `cast` (Sym (Test.QuickCheck.Gen.N:Gen[0]
                             <Data.ByteString.Internal.Type.ByteString>_R)
                    :: (Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int -> Data.ByteString.Internal.Type.ByteString)
                       ~R# Test.QuickCheck.Gen.Gen
                             Data.ByteString.Internal.Type.ByteString)
    Cont:   Stop[BoringCtxt] Test.QuickCheck.Gen.Gen
                               Data.ByteString.Internal.Type.ByteString
Rule fired
    Rule: Class op shrink
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.shrink
              TyArg Data.ByteString.Internal.Type.ByteString
              ValArg Test.QuickCheck.Instances.ByteString.$fArbitraryByteString0
    After:  Test.QuickCheck.Instances.ByteString.$fArbitraryByteString0_$cshrink
    Cont:   Stop[BoringCtxt] Data.ByteString.Internal.Type.ByteString
                             -> [Data.ByteString.Internal.Type.ByteString]
Rule fired
    Rule: Class op show
    Module: (BUILTIN)
    Before: GHC.Show.show
              TyArg Data.ByteString.Internal.Type.ByteString
              ValArg Data.ByteString.Internal.Type.$fShowByteString
    After:  Data.ByteString.Internal.Type.$fShowByteString_$cshow
    Cont:   Stop[RhsCtxt(NonRecursive)] Data.ByteString.Internal.Type.ByteString
                                        -> GHC.Base.String
Rule fired
    Rule: Class op reader
    Module: (BUILTIN)
    Before: Control.Monad.Reader.Class.reader
              TyArg Data.ByteString.Internal.Type.ByteString
              TyArg (->) Data.ByteString.Internal.Type.ByteString
              ValArg Control.Monad.Reader.Class.$fMonadReaderrFUN
                       @Data.ByteString.Internal.Type.ByteString
    After:  \ (@a_abe8) ->
              GHC.Base.id @(Data.ByteString.Internal.Type.ByteString -> a_abe8)
    Cont:   ApplyToTy Data.ByteString.Internal.Type.ByteString
            ApplyToVal nodup hole (Data.ByteString.Internal.Type.ByteString
                                   -> Data.ByteString.Internal.Type.ByteString)
                                  -> Data.ByteString.Internal.Type.ByteString
                                  -> Data.ByteString.Internal.Type.ByteString
              ((l_abe2
                  ((\ (ds_abe3 [Occ=Once1] :: a_abe0) -> ds_abe3)
                   `cast` (<a_abe0>_R
                           %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                              <*>_N <a_abe0>_R <a_abe0>_P)
                           :: (a_abe0 -> a_abe0)
                              ~R# (a_abe0 -> Data.Functor.Const.Const a_abe0 a_abe0))))
               `cast` (<s_abdY>_R
                       %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                     <*>_N <a_abe0>_R <s_abdY>_P
                       :: (s_abdY -> Data.Functor.Const.Const a_abe0 s_abdY)
                          ~R# (s_abdY -> a_abe0)))
            ApplyToVal nodup hole Data.ByteString.Internal.Type.ByteString
                                  -> Data.ByteString.Internal.Type.ByteString
              s_a8JV
            Stop[RuleArgCtxt] Data.ByteString.Internal.Type.ByteString
Rule fired
    Rule: recons/id
    Module: (Control.Lens.Cons.Extras)
    Before: Control.Lens.Cons.Extras.recons
              TyArg Data.ByteString.Internal.Type.ByteString
              TyArg GHC.Word.Word8
              TyArg Data.ByteString.Internal.Type.ByteString
              ValArg (\ (@(p_abjT :: * -> * -> *))
                        (@(f_abjU :: * -> *))
                        ($dChoice_abjV :: Data.Profunctor.Choice.Choice p_abjT)
                        ($dApplicative_abjW :: GHC.Base.Applicative f_abjU) ->
                        let {
                          f1_abjX
                            :: p_abjT
                                 (Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                                 (Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString
                                    (f_abjU
                                       (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                               -> p_abjT
                                    Data.ByteString.Internal.Type.ByteString
                                    (f_abjU Data.ByteString.Internal.Type.ByteString)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 612 0}]
                          f1_abjX
                            = Data.Profunctor.Unsafe.dimap
                                @p_abjT
                                (Data.Profunctor.Choice.$p1Choice @p_abjT $dChoice_abjV)
                                @Data.ByteString.Internal.Type.ByteString
                                @(Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                                @(Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString
                                    (f_abjU
                                       (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                                @(f_abjU Data.ByteString.Internal.Type.ByteString)
                                (\ (s1_abjY :: Data.ByteString.Internal.Type.ByteString) ->
                                   case s1_abjY of wild_abjZ
                                   { Data.ByteString.Internal.Type.BS bx_abk0 bx1_abk1 bx2_abk2 ->
                                   case GHC.Classes.leInt (GHC.Types.I# bx2_abk2) (GHC.Types.I# 0#)
                                   of {
                                     GHC.Types.False ->
                                       Data.Either.Right
                                         @Data.ByteString.Internal.Type.ByteString
                                         @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                         (case GHC.Prim.readWord8OffAddr#
                                                 @GHC.Prim.RealWorld bx_abk0 0# GHC.Prim.realWorld#
                                          of
                                          { (# ipv_abk7, ipv1_abk8 #) ->
                                          case GHC.Prim.touch#
                                                 @'GHC.Types.Lifted
                                                 @GHC.ForeignPtr.ForeignPtrContents
                                                 bx1_abk1
                                                 ipv_abk7
                                          of
                                          { __DEFAULT ->
                                          GHC.Word.W8# ipv1_abk8
                                          }
                                          },
                                          Data.ByteString.Internal.Type.$WBS
                                            (GHC.ForeignPtr.ForeignPtr
                                               @GHC.Word.Word8
                                               (GHC.Prim.plusAddr# bx_abk0 1#)
                                               bx1_abk1)
                                            (GHC.Types.I# (GHC.Prim.-# bx2_abk2 1#)));
                                     GHC.Types.True ->
                                       Data.Either.Left
                                         @Data.ByteString.Internal.Type.ByteString
                                         @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                         wild_abjZ
                                   }
                                   })
                                (let {
                                   f2_abkc
                                     :: Data.ByteString.Internal.Type.ByteString
                                        -> f_abjU Data.ByteString.Internal.Type.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abkc
                                     = GHC.Base.pure
                                         @f_abjU
                                         $dApplicative_abjW
                                         @Data.ByteString.Internal.Type.ByteString } in
                                 let {
                                   ds2_abkd
                                     :: f_abjU
                                          (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                        -> f_abjU Data.ByteString.Internal.Type.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 259 0}]
                                   ds2_abkd
                                     = GHC.Base.fmap
                                         @f_abjU
                                         (GHC.Base.$p1Applicative @f_abjU $dApplicative_abjW)
                                         @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                         @Data.ByteString.Internal.Type.ByteString
                                         (\ (p1_abke
                                               :: (GHC.Word.Word8,
                                                   Data.ByteString.Internal.Type.ByteString)) ->
                                            case p1_abke of { (ds_abkg, y_abkh) ->
                                            case y_abkh of
                                            { Data.ByteString.Internal.Type.BS bx_abkt bx1_abku
                                                                               bx2_abkv ->
                                            GHC.Magic.runRW#
                                              @GHC.Types.LiftedRep
                                              @Data.ByteString.Internal.Type.ByteString
                                              (\ (s_abkr [OS=OneShot]
                                                    :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                                                 let {
                                                   x_abks :: GHC.Prim.Int#
                                                   [LclId,
                                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                            Value=False, ConLike=False,
                                                            WorkFree=False, Expandable=False,
                                                            Guidance=IF_ARGS [] 1 0}]
                                                   x_abks = GHC.Prim.+# bx2_abkv 1# } in
                                                 case GHC.Prim.<# x_abks 0# of {
                                                   __DEFAULT ->
                                                     case GHC.Prim.newPinnedByteArray#
                                                            @GHC.Prim.RealWorld x_abks s_abkr
                                                     of
                                                     { (# ipv_abkA, ipv1_abkB #) ->
                                                     let {
                                                       ipv2_abkz :: GHC.Prim.Addr#
                                                       [LclId,
                                                        Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                                Value=False, ConLike=False,
                                                                WorkFree=False, Expandable=False,
                                                                Guidance=IF_ARGS [] 1 0}]
                                                       ipv2_abkz
                                                         = GHC.Prim.mutableByteArrayContents#
                                                             @GHC.Prim.RealWorld ipv1_abkB } in
                                                     let {
                                                       ipv3_abkD
                                                         :: GHC.ForeignPtr.ForeignPtrContents
                                                       [LclId,
                                                        Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                                Value=True, ConLike=True,
                                                                WorkFree=True, Expandable=True,
                                                                Guidance=IF_ARGS [] 10 10}]
                                                       ipv3_abkD
                                                         = GHC.ForeignPtr.PlainPtr ipv1_abkB } in
                                                     case ds_abkg of { GHC.Word.W8# x1_ablV ->
                                                     case GHC.Prim.writeWord8OffAddr#
                                                            @GHC.Prim.RealWorld
                                                            ipv2_abkz
                                                            0#
                                                            x1_ablV
                                                            ipv_abkA
                                                     of s2_ablX
                                                     { __DEFAULT ->
                                                     case GHC.Prim.touch#
                                                            @'GHC.Types.Lifted
                                                            @GHC.ForeignPtr.ForeignPtrContents
                                                            ipv3_abkD
                                                            s2_ablX
                                                     of s'_ablY
                                                     { __DEFAULT ->
                                                     case {__ffi_static_ccall_unsafe base:memcpy :: Addr#
                                          -> Addr#
                                          -> Word64#
                                          -> State# RealWorld
                                          -> (# State# RealWorld, Addr# #)}_ablZ
                                                            (GHC.Prim.plusAddr# ipv2_abkz 1#)
                                                            bx_abkt
                                                            (GHC.Prim.int64ToWord64#
                                                               (GHC.Prim.intToInt64# bx2_abkv))
                                                            s'_ablY
                                                     of
                                                     { (# ds4_abm1, ds5_abm2 #) ->
                                                     case GHC.Prim.touch#
                                                            @'GHC.Types.Lifted
                                                            @GHC.ForeignPtr.ForeignPtrContents
                                                            bx1_abku
                                                            ds4_abm1
                                                     of s'1_abm4
                                                     { __DEFAULT ->
                                                     case GHC.Prim.touch#
                                                            @'GHC.Types.Lifted
                                                            @GHC.ForeignPtr.ForeignPtrContents
                                                            ipv3_abkD
                                                            s'1_abm4
                                                     of s'2_abm5
                                                     { __DEFAULT ->
                                                     case GHC.Magic.lazy
                                                            @((GHC.Prim.State# GHC.Prim.RealWorld
                                                               -> (# GHC.Prim.State#
                                                                       GHC.Prim.RealWorld,
                                                                     GHC.Prim.Addr# #))
                                                              -> (# GHC.Prim.State#
                                                                      GHC.Prim.RealWorld,
                                                                    GHC.Prim.Addr# #))
                                                            (GHC.Magic.runRW#
                                                               @('GHC.Types.TupleRep
                                                                   '[GHC.Types.ZeroBitRep,
                                                                     'GHC.Types.AddrRep])
                                                               @(# GHC.Prim.State#
                                                                     GHC.Prim.RealWorld,
                                                                   GHC.Prim.Addr# #))
                                                            (\ _ [Occ=Dead] ->
                                                               (# s'2_abm5, ipv2_abkz #))
                                                     of
                                                     { (# ipv6_abm8, ipv7_abm9 #) ->
                                                     Data.ByteString.Internal.Type.BS
                                                       ipv7_abm9 ipv3_abkD x_abks
                                                     }
                                                     }
                                                     }
                                                     }
                                                     }
                                                     }
                                                     }
                                                     };
                                                   1# ->
                                                     case GHC.ForeignPtr.mallocPlainForeignPtrBytes2
                                                     of wild_00 {
                                                     }
                                                 })
                                            }
                                            }) } in
                                 \ (ds3_abmc
                                      :: Data.Either.Either
                                           Data.ByteString.Internal.Type.ByteString
                                           (f_abjU
                                              (GHC.Word.Word8,
                                               Data.ByteString.Internal.Type.ByteString))) ->
                                   case ds3_abmc of {
                                     Data.Either.Left x_abme -> f2_abkc x_abme;
                                     Data.Either.Right y_abmg -> ds2_abkd y_abmg
                                   }) } in
                        let {
                          g_abmi
                            :: p_abjT
                                 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                 (f_abjU (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                               -> p_abjT
                                    (Data.Either.Either
                                       Data.ByteString.Internal.Type.ByteString
                                       (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                                    (Data.Either.Either
                                       Data.ByteString.Internal.Type.ByteString
                                       (f_abjU
                                          (GHC.Word.Word8,
                                           Data.ByteString.Internal.Type.ByteString)))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abmi
                            = Data.Profunctor.Choice.right'
                                @p_abjT
                                $dChoice_abjV
                                @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                @(f_abjU
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                                @Data.ByteString.Internal.Type.ByteString } in
                        \ (x_abmj
                             :: p_abjT
                                  (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                  (f_abjU
                                     (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))) ->
                          f1_abjX (g_abmi x_abmj))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <Data.ByteString.Internal.Type.ByteString>_N
                                      <Data.ByteString.Internal.Type.ByteString>_N
                                      <GHC.Word.Word8>_N
                                      <GHC.Word.Word8>_N)
                             :: Control.Lens.Type.Prism
                                  Data.ByteString.Internal.Type.ByteString
                                  Data.ByteString.Internal.Type.ByteString
                                  (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                  (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                ~R# Control.Lens.Cons.Cons
                                      Data.ByteString.Internal.Type.ByteString
                                      Data.ByteString.Internal.Type.ByteString
                                      GHC.Word.Word8
                                      GHC.Word.Word8)
              ValArg (\ (@(p_abjT :: * -> * -> *))
                        (@(f_abjU :: * -> *))
                        ($dChoice_abjV :: Data.Profunctor.Choice.Choice p_abjT)
                        ($dApplicative_abjW :: GHC.Base.Applicative f_abjU) ->
                        let {
                          f1_abjX
                            :: p_abjT
                                 (Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                                 (Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString
                                    (f_abjU
                                       (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                               -> p_abjT
                                    Data.ByteString.Internal.Type.ByteString
                                    (f_abjU Data.ByteString.Internal.Type.ByteString)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 612 0}]
                          f1_abjX
                            = Data.Profunctor.Unsafe.dimap
                                @p_abjT
                                (Data.Profunctor.Choice.$p1Choice @p_abjT $dChoice_abjV)
                                @Data.ByteString.Internal.Type.ByteString
                                @(Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                                @(Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString
                                    (f_abjU
                                       (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                                @(f_abjU Data.ByteString.Internal.Type.ByteString)
                                (\ (s1_abjY :: Data.ByteString.Internal.Type.ByteString) ->
                                   case s1_abjY of wild_abjZ
                                   { Data.ByteString.Internal.Type.BS bx_abk0 bx1_abk1 bx2_abk2 ->
                                   case GHC.Classes.leInt (GHC.Types.I# bx2_abk2) (GHC.Types.I# 0#)
                                   of {
                                     GHC.Types.False ->
                                       Data.Either.Right
                                         @Data.ByteString.Internal.Type.ByteString
                                         @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                         (case GHC.Prim.readWord8OffAddr#
                                                 @GHC.Prim.RealWorld bx_abk0 0# GHC.Prim.realWorld#
                                          of
                                          { (# ipv_abk7, ipv1_abk8 #) ->
                                          case GHC.Prim.touch#
                                                 @'GHC.Types.Lifted
                                                 @GHC.ForeignPtr.ForeignPtrContents
                                                 bx1_abk1
                                                 ipv_abk7
                                          of
                                          { __DEFAULT ->
                                          GHC.Word.W8# ipv1_abk8
                                          }
                                          },
                                          Data.ByteString.Internal.Type.$WBS
                                            (GHC.ForeignPtr.ForeignPtr
                                               @GHC.Word.Word8
                                               (GHC.Prim.plusAddr# bx_abk0 1#)
                                               bx1_abk1)
                                            (GHC.Types.I# (GHC.Prim.-# bx2_abk2 1#)));
                                     GHC.Types.True ->
                                       Data.Either.Left
                                         @Data.ByteString.Internal.Type.ByteString
                                         @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                         wild_abjZ
                                   }
                                   })
                                (let {
                                   f2_abkc
                                     :: Data.ByteString.Internal.Type.ByteString
                                        -> f_abjU Data.ByteString.Internal.Type.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abkc
                                     = GHC.Base.pure
                                         @f_abjU
                                         $dApplicative_abjW
                                         @Data.ByteString.Internal.Type.ByteString } in
                                 let {
                                   ds2_abkd
                                     :: f_abjU
                                          (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                        -> f_abjU Data.ByteString.Internal.Type.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 259 0}]
                                   ds2_abkd
                                     = GHC.Base.fmap
                                         @f_abjU
                                         (GHC.Base.$p1Applicative @f_abjU $dApplicative_abjW)
                                         @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                         @Data.ByteString.Internal.Type.ByteString
                                         (\ (p1_abke
                                               :: (GHC.Word.Word8,
                                                   Data.ByteString.Internal.Type.ByteString)) ->
                                            case p1_abke of { (ds_abkg, y_abkh) ->
                                            case y_abkh of
                                            { Data.ByteString.Internal.Type.BS bx_abkt bx1_abku
                                                                               bx2_abkv ->
                                            GHC.Magic.runRW#
                                              @GHC.Types.LiftedRep
                                              @Data.ByteString.Internal.Type.ByteString
                                              (\ (s_abkr [OS=OneShot]
                                                    :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                                                 let {
                                                   x_abks :: GHC.Prim.Int#
                                                   [LclId,
                                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                            Value=False, ConLike=False,
                                                            WorkFree=False, Expandable=False,
                                                            Guidance=IF_ARGS [] 1 0}]
                                                   x_abks = GHC.Prim.+# bx2_abkv 1# } in
                                                 case GHC.Prim.<# x_abks 0# of {
                                                   __DEFAULT ->
                                                     case GHC.Prim.newPinnedByteArray#
                                                            @GHC.Prim.RealWorld x_abks s_abkr
                                                     of
                                                     { (# ipv_abkA, ipv1_abkB #) ->
                                                     let {
                                                       ipv2_abkz :: GHC.Prim.Addr#
                                                       [LclId,
                                                        Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                                Value=False, ConLike=False,
                                                                WorkFree=False, Expandable=False,
                                                                Guidance=IF_ARGS [] 1 0}]
                                                       ipv2_abkz
                                                         = GHC.Prim.mutableByteArrayContents#
                                                             @GHC.Prim.RealWorld ipv1_abkB } in
                                                     let {
                                                       ipv3_abkD
                                                         :: GHC.ForeignPtr.ForeignPtrContents
                                                       [LclId,
                                                        Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                                Value=True, ConLike=True,
                                                                WorkFree=True, Expandable=True,
                                                                Guidance=IF_ARGS [] 10 10}]
                                                       ipv3_abkD
                                                         = GHC.ForeignPtr.PlainPtr ipv1_abkB } in
                                                     case ds_abkg of { GHC.Word.W8# x1_ablV ->
                                                     case GHC.Prim.writeWord8OffAddr#
                                                            @GHC.Prim.RealWorld
                                                            ipv2_abkz
                                                            0#
                                                            x1_ablV
                                                            ipv_abkA
                                                     of s2_ablX
                                                     { __DEFAULT ->
                                                     case GHC.Prim.touch#
                                                            @'GHC.Types.Lifted
                                                            @GHC.ForeignPtr.ForeignPtrContents
                                                            ipv3_abkD
                                                            s2_ablX
                                                     of s'_ablY
                                                     { __DEFAULT ->
                                                     case {__ffi_static_ccall_unsafe base:memcpy :: Addr#
                                          -> Addr#
                                          -> Word64#
                                          -> State# RealWorld
                                          -> (# State# RealWorld, Addr# #)}_ablZ
                                                            (GHC.Prim.plusAddr# ipv2_abkz 1#)
                                                            bx_abkt
                                                            (GHC.Prim.int64ToWord64#
                                                               (GHC.Prim.intToInt64# bx2_abkv))
                                                            s'_ablY
                                                     of
                                                     { (# ds4_abm1, ds5_abm2 #) ->
                                                     case GHC.Prim.touch#
                                                            @'GHC.Types.Lifted
                                                            @GHC.ForeignPtr.ForeignPtrContents
                                                            bx1_abku
                                                            ds4_abm1
                                                     of s'1_abm4
                                                     { __DEFAULT ->
                                                     case GHC.Prim.touch#
                                                            @'GHC.Types.Lifted
                                                            @GHC.ForeignPtr.ForeignPtrContents
                                                            ipv3_abkD
                                                            s'1_abm4
                                                     of s'2_abm5
                                                     { __DEFAULT ->
                                                     case GHC.Magic.lazy
                                                            @((GHC.Prim.State# GHC.Prim.RealWorld
                                                               -> (# GHC.Prim.State#
                                                                       GHC.Prim.RealWorld,
                                                                     GHC.Prim.Addr# #))
                                                              -> (# GHC.Prim.State#
                                                                      GHC.Prim.RealWorld,
                                                                    GHC.Prim.Addr# #))
                                                            (GHC.Magic.runRW#
                                                               @('GHC.Types.TupleRep
                                                                   '[GHC.Types.ZeroBitRep,
                                                                     'GHC.Types.AddrRep])
                                                               @(# GHC.Prim.State#
                                                                     GHC.Prim.RealWorld,
                                                                   GHC.Prim.Addr# #))
                                                            (\ _ [Occ=Dead] ->
                                                               (# s'2_abm5, ipv2_abkz #))
                                                     of
                                                     { (# ipv6_abm8, ipv7_abm9 #) ->
                                                     Data.ByteString.Internal.Type.BS
                                                       ipv7_abm9 ipv3_abkD x_abks
                                                     }
                                                     }
                                                     }
                                                     }
                                                     }
                                                     }
                                                     }
                                                     };
                                                   1# ->
                                                     case GHC.ForeignPtr.mallocPlainForeignPtrBytes2
                                                     of wild_00 {
                                                     }
                                                 })
                                            }
                                            }) } in
                                 \ (ds3_abmc
                                      :: Data.Either.Either
                                           Data.ByteString.Internal.Type.ByteString
                                           (f_abjU
                                              (GHC.Word.Word8,
                                               Data.ByteString.Internal.Type.ByteString))) ->
                                   case ds3_abmc of {
                                     Data.Either.Left x_abme -> f2_abkc x_abme;
                                     Data.Either.Right y_abmg -> ds2_abkd y_abmg
                                   }) } in
                        let {
                          g_abmi
                            :: p_abjT
                                 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                 (f_abjU (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                               -> p_abjT
                                    (Data.Either.Either
                                       Data.ByteString.Internal.Type.ByteString
                                       (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                                    (Data.Either.Either
                                       Data.ByteString.Internal.Type.ByteString
                                       (f_abjU
                                          (GHC.Word.Word8,
                                           Data.ByteString.Internal.Type.ByteString)))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abmi
                            = Data.Profunctor.Choice.right'
                                @p_abjT
                                $dChoice_abjV
                                @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                @(f_abjU
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                                @Data.ByteString.Internal.Type.ByteString } in
                        \ (x_abmj
                             :: p_abjT
                                  (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                  (f_abjU
                                     (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))) ->
                          f1_abjX (g_abmi x_abmj))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <Data.ByteString.Internal.Type.ByteString>_N
                                      <Data.ByteString.Internal.Type.ByteString>_N
                                      <GHC.Word.Word8>_N
                                      <GHC.Word.Word8>_N)
                             :: Control.Lens.Type.Prism
                                  Data.ByteString.Internal.Type.ByteString
                                  Data.ByteString.Internal.Type.ByteString
                                  (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                  (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                ~R# Control.Lens.Cons.Cons
                                      Data.ByteString.Internal.Type.ByteString
                                      Data.ByteString.Internal.Type.ByteString
                                      GHC.Word.Word8
                                      GHC.Word.Word8)
              ValArg (\ (@(p_abmq :: * -> * -> *))
                        (@(f_abmr :: * -> *))
                        ($dChoice_abms :: Data.Profunctor.Choice.Choice p_abmq)
                        ($dApplicative_abmt :: GHC.Base.Applicative f_abmr) ->
                        let {
                          f1_abmu
                            :: p_abmq
                                 (Data.Either.Either Data.ByteString.Internal.Type.ByteString ())
                                 (Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString (f_abmr ()))
                               -> p_abmq
                                    Data.ByteString.Internal.Type.ByteString
                                    (f_abmr Data.ByteString.Internal.Type.ByteString)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 350 0}]
                          f1_abmu
                            = Data.Profunctor.Unsafe.dimap
                                @p_abmq
                                (Data.Profunctor.Choice.$p1Choice @p_abmq $dChoice_abms)
                                @Data.ByteString.Internal.Type.ByteString
                                @(Data.Either.Either Data.ByteString.Internal.Type.ByteString ())
                                @(Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString (f_abmr ()))
                                @(f_abmr Data.ByteString.Internal.Type.ByteString)
                                (\ (s_abmv :: Data.ByteString.Internal.Type.ByteString) ->
                                   case s_abmv of wild_abmw
                                   { Data.ByteString.Internal.Type.BS bx_abmx bx1_abmy bx2_abmz ->
                                   case GHC.Classes.leInt (GHC.Types.I# bx2_abmz) (GHC.Types.I# 0#)
                                   of {
                                     GHC.Types.False ->
                                       Data.Either.Left
                                         @Data.ByteString.Internal.Type.ByteString @() wild_abmw;
                                     GHC.Types.True ->
                                       Data.Either.Right
                                         @Data.ByteString.Internal.Type.ByteString
                                         @()
                                         GHC.Tuple.Prim.()
                                   }
                                   })
                                (let {
                                   f2_abmD
                                     :: Data.ByteString.Internal.Type.ByteString
                                        -> f_abmr Data.ByteString.Internal.Type.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abmD
                                     = GHC.Base.pure
                                         @f_abmr
                                         $dApplicative_abmt
                                         @Data.ByteString.Internal.Type.ByteString } in
                                 let {
                                   ds2_abmE
                                     :: f_abmr () -> f_abmr Data.ByteString.Internal.Type.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 70 0}]
                                   ds2_abmE
                                     = GHC.Base.fmap
                                         @f_abmr
                                         (GHC.Base.$p1Applicative @f_abmr $dApplicative_abmt)
                                         @()
                                         @Data.ByteString.Internal.Type.ByteString
                                         (\ (ds3_abmF :: ()) ->
                                            case ds3_abmF of { () ->
                                            Data.ByteString.Internal.Type.empty
                                            }) } in
                                 \ (ds3_abmH
                                      :: Data.Either.Either
                                           Data.ByteString.Internal.Type.ByteString (f_abmr ())) ->
                                   case ds3_abmH of {
                                     Data.Either.Left x_abmJ -> f2_abmD x_abmJ;
                                     Data.Either.Right y_abmL -> ds2_abmE y_abmL
                                   }) } in
                        let {
                          g_abmN
                            :: p_abmq () (f_abmr ())
                               -> p_abmq
                                    (Data.Either.Either Data.ByteString.Internal.Type.ByteString ())
                                    (Data.Either.Either
                                       Data.ByteString.Internal.Type.ByteString (f_abmr ()))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abmN
                            = Data.Profunctor.Choice.right'
                                @p_abmq
                                $dChoice_abms
                                @()
                                @(f_abmr ())
                                @Data.ByteString.Internal.Type.ByteString } in
                        \ (x_abmO :: p_abmq () (f_abmr ())) -> f1_abmu (g_abmN x_abmO))
                     `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                      <Data.ByteString.Internal.Type.ByteString>_N)
                             :: Control.Lens.Type.Prism'
                                  Data.ByteString.Internal.Type.ByteString ()
                                ~R# Control.Lens.Empty.AsEmpty
                                      Data.ByteString.Internal.Type.ByteString)
              TyArg Data.Functor.Const.Const
                      Data.ByteString.Internal.Type.ByteString
              ValArg Data.Functor.Contravariant.$fContravariantConst
                       @Data.ByteString.Internal.Type.ByteString
              ValArg Data.Functor.Const.$fFunctorConst
                       @Data.ByteString.Internal.Type.ByteString
    After:  (\ (@s1_abf7)
               (@(f_abf8 :: * -> *))
               (@a_abf9)
               ($dCons_abfa
                  :: Control.Lens.Cons.Cons s1_abf7 s1_abf7 a_abf9 a_abf9)
               ($dCons1_abfb
                  :: Control.Lens.Cons.Cons s1_abf7 s1_abf7 a_abf9 a_abf9)
               ($dAsEmpty_abfc :: Control.Lens.Empty.AsEmpty s1_abf7)
               ($dContravariant_abfd
                  :: Data.Functor.Contravariant.Contravariant f_abf8)
               ($dFunctor_abfe :: GHC.Base.Functor f_abf8) ->
               GHC.Base.id @(s1_abf7 -> f_abf8 s1_abf7))
              @Data.ByteString.Internal.Type.ByteString
              @(Data.Functor.Const.Const
                  Data.ByteString.Internal.Type.ByteString)
              @GHC.Word.Word8
              ((\ (@(p_abjT :: * -> * -> *))
                  (@(f_abjU :: * -> *))
                  ($dChoice_abjV :: Data.Profunctor.Choice.Choice p_abjT)
                  ($dApplicative_abjW :: GHC.Base.Applicative f_abjU) ->
                  let {
                    f1_abjX
                      :: p_abjT
                           (Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString
                              (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                           (Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString
                              (f_abjU
                                 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                         -> p_abjT
                              Data.ByteString.Internal.Type.ByteString
                              (f_abjU Data.ByteString.Internal.Type.ByteString)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 612 0}]
                    f1_abjX
                      = Data.Profunctor.Unsafe.dimap
                          @p_abjT
                          (Data.Profunctor.Choice.$p1Choice @p_abjT $dChoice_abjV)
                          @Data.ByteString.Internal.Type.ByteString
                          @(Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString
                              (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                          @(Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString
                              (f_abjU
                                 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                          @(f_abjU Data.ByteString.Internal.Type.ByteString)
                          (\ (s1_abjY :: Data.ByteString.Internal.Type.ByteString) ->
                             case s1_abjY of wild_abjZ
                             { Data.ByteString.Internal.Type.BS bx_abk0 bx1_abk1 bx2_abk2 ->
                             case GHC.Classes.leInt (GHC.Types.I# bx2_abk2) (GHC.Types.I# 0#)
                             of {
                               GHC.Types.False ->
                                 Data.Either.Right
                                   @Data.ByteString.Internal.Type.ByteString
                                   @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                   (case GHC.Prim.readWord8OffAddr#
                                           @GHC.Prim.RealWorld bx_abk0 0# GHC.Prim.realWorld#
                                    of
                                    { (# ipv_abk7, ipv1_abk8 #) ->
                                    case GHC.Prim.touch#
                                           @'GHC.Types.Lifted
                                           @GHC.ForeignPtr.ForeignPtrContents
                                           bx1_abk1
                                           ipv_abk7
                                    of
                                    { __DEFAULT ->
                                    GHC.Word.W8# ipv1_abk8
                                    }
                                    },
                                    Data.ByteString.Internal.Type.$WBS
                                      (GHC.ForeignPtr.ForeignPtr
                                         @GHC.Word.Word8 (GHC.Prim.plusAddr# bx_abk0 1#) bx1_abk1)
                                      (GHC.Types.I# (GHC.Prim.-# bx2_abk2 1#)));
                               GHC.Types.True ->
                                 Data.Either.Left
                                   @Data.ByteString.Internal.Type.ByteString
                                   @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                   wild_abjZ
                             }
                             })
                          (let {
                             f2_abkc
                               :: Data.ByteString.Internal.Type.ByteString
                                  -> f_abjU Data.ByteString.Internal.Type.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abkc
                               = GHC.Base.pure
                                   @f_abjU
                                   $dApplicative_abjW
                                   @Data.ByteString.Internal.Type.ByteString } in
                           let {
                             ds2_abkd
                               :: f_abjU
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                  -> f_abjU Data.ByteString.Internal.Type.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 259 0}]
                             ds2_abkd
                               = GHC.Base.fmap
                                   @f_abjU
                                   (GHC.Base.$p1Applicative @f_abjU $dApplicative_abjW)
                                   @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                   @Data.ByteString.Internal.Type.ByteString
                                   (\ (p1_abke
                                         :: (GHC.Word.Word8,
                                             Data.ByteString.Internal.Type.ByteString)) ->
                                      case p1_abke of { (ds_abkg, y_abkh) ->
                                      case y_abkh of
                                      { Data.ByteString.Internal.Type.BS bx_abkt bx1_abku
                                                                         bx2_abkv ->
                                      GHC.Magic.runRW#
                                        @GHC.Types.LiftedRep
                                        @Data.ByteString.Internal.Type.ByteString
                                        (\ (s_abkr [OS=OneShot]
                                              :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                                           let {
                                             x_abks :: GHC.Prim.Int#
                                             [LclId,
                                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                      Value=False, ConLike=False, WorkFree=False,
                                                      Expandable=False,
                                                      Guidance=IF_ARGS [] 1 0}]
                                             x_abks = GHC.Prim.+# bx2_abkv 1# } in
                                           case GHC.Prim.<# x_abks 0# of {
                                             __DEFAULT ->
                                               case GHC.Prim.newPinnedByteArray#
                                                      @GHC.Prim.RealWorld x_abks s_abkr
                                               of
                                               { (# ipv_abkA, ipv1_abkB #) ->
                                               let {
                                                 ipv2_abkz :: GHC.Prim.Addr#
                                                 [LclId,
                                                  Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                          Value=False, ConLike=False,
                                                          WorkFree=False, Expandable=False,
                                                          Guidance=IF_ARGS [] 1 0}]
                                                 ipv2_abkz
                                                   = GHC.Prim.mutableByteArrayContents#
                                                       @GHC.Prim.RealWorld ipv1_abkB } in
                                               let {
                                                 ipv3_abkD :: GHC.ForeignPtr.ForeignPtrContents
                                                 [LclId,
                                                  Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                          Value=True, ConLike=True, WorkFree=True,
                                                          Expandable=True,
                                                          Guidance=IF_ARGS [] 10 10}]
                                                 ipv3_abkD = GHC.ForeignPtr.PlainPtr ipv1_abkB } in
                                               case ds_abkg of { GHC.Word.W8# x1_ablV ->
                                               case GHC.Prim.writeWord8OffAddr#
                                                      @GHC.Prim.RealWorld
                                                      ipv2_abkz
                                                      0#
                                                      x1_ablV
                                                      ipv_abkA
                                               of s2_ablX
                                               { __DEFAULT ->
                                               case GHC.Prim.touch#
                                                      @'GHC.Types.Lifted
                                                      @GHC.ForeignPtr.ForeignPtrContents
                                                      ipv3_abkD
                                                      s2_ablX
                                               of s'_ablY
                                               { __DEFAULT ->
                                               case {__ffi_static_ccall_unsafe base:memcpy :: Addr#
                                          -> Addr#
                                          -> Word64#
                                          -> State# RealWorld
                                          -> (# State# RealWorld, Addr# #)}_ablZ
                                                      (GHC.Prim.plusAddr# ipv2_abkz 1#)
                                                      bx_abkt
                                                      (GHC.Prim.int64ToWord64#
                                                         (GHC.Prim.intToInt64# bx2_abkv))
                                                      s'_ablY
                                               of
                                               { (# ds4_abm1, ds5_abm2 #) ->
                                               case GHC.Prim.touch#
                                                      @'GHC.Types.Lifted
                                                      @GHC.ForeignPtr.ForeignPtrContents
                                                      bx1_abku
                                                      ds4_abm1
                                               of s'1_abm4
                                               { __DEFAULT ->
                                               case GHC.Prim.touch#
                                                      @'GHC.Types.Lifted
                                                      @GHC.ForeignPtr.ForeignPtrContents
                                                      ipv3_abkD
                                                      s'1_abm4
                                               of s'2_abm5
                                               { __DEFAULT ->
                                               case GHC.Magic.lazy
                                                      @((GHC.Prim.State# GHC.Prim.RealWorld
                                                         -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                               GHC.Prim.Addr# #))
                                                        -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                              GHC.Prim.Addr# #))
                                                      (GHC.Magic.runRW#
                                                         @('GHC.Types.TupleRep
                                                             '[GHC.Types.ZeroBitRep,
                                                               'GHC.Types.AddrRep])
                                                         @(# GHC.Prim.State# GHC.Prim.RealWorld,
                                                             GHC.Prim.Addr# #))
                                                      (\ _ [Occ=Dead] -> (# s'2_abm5, ipv2_abkz #))
                                               of
                                               { (# ipv6_abm8, ipv7_abm9 #) ->
                                               Data.ByteString.Internal.Type.BS
                                                 ipv7_abm9 ipv3_abkD x_abks
                                               }
                                               }
                                               }
                                               }
                                               }
                                               }
                                               }
                                               };
                                             1# ->
                                               case GHC.ForeignPtr.mallocPlainForeignPtrBytes2
                                               of wild_00 {
                                               }
                                           })
                                      }
                                      }) } in
                           \ (ds3_abmc
                                :: Data.Either.Either
                                     Data.ByteString.Internal.Type.ByteString
                                     (f_abjU
                                        (GHC.Word.Word8,
                                         Data.ByteString.Internal.Type.ByteString))) ->
                             case ds3_abmc of {
                               Data.Either.Left x_abme -> f2_abkc x_abme;
                               Data.Either.Right y_abmg -> ds2_abkd y_abmg
                             }) } in
                  let {
                    g_abmi
                      :: p_abjT
                           (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                           (f_abjU (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                         -> p_abjT
                              (Data.Either.Either
                                 Data.ByteString.Internal.Type.ByteString
                                 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                              (Data.Either.Either
                                 Data.ByteString.Internal.Type.ByteString
                                 (f_abjU
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abmi
                      = Data.Profunctor.Choice.right'
                          @p_abjT
                          $dChoice_abjV
                          @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                          @(f_abjU
                              (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                          @Data.ByteString.Internal.Type.ByteString } in
                  \ (x_abmj
                       :: p_abjT
                            (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                            (f_abjU
                               (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))) ->
                    f1_abjX (g_abmi x_abmj))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <Data.ByteString.Internal.Type.ByteString>_N
                                <Data.ByteString.Internal.Type.ByteString>_N
                                <GHC.Word.Word8>_N
                                <GHC.Word.Word8>_N)
                       :: Control.Lens.Type.Prism
                            Data.ByteString.Internal.Type.ByteString
                            Data.ByteString.Internal.Type.ByteString
                            (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                            (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                          ~R# Control.Lens.Cons.Cons
                                Data.ByteString.Internal.Type.ByteString
                                Data.ByteString.Internal.Type.ByteString
                                GHC.Word.Word8
                                GHC.Word.Word8))
              ((\ (@(p_abjT :: * -> * -> *))
                  (@(f_abjU :: * -> *))
                  ($dChoice_abjV :: Data.Profunctor.Choice.Choice p_abjT)
                  ($dApplicative_abjW :: GHC.Base.Applicative f_abjU) ->
                  let {
                    f1_abjX
                      :: p_abjT
                           (Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString
                              (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                           (Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString
                              (f_abjU
                                 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                         -> p_abjT
                              Data.ByteString.Internal.Type.ByteString
                              (f_abjU Data.ByteString.Internal.Type.ByteString)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 612 0}]
                    f1_abjX
                      = Data.Profunctor.Unsafe.dimap
                          @p_abjT
                          (Data.Profunctor.Choice.$p1Choice @p_abjT $dChoice_abjV)
                          @Data.ByteString.Internal.Type.ByteString
                          @(Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString
                              (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                          @(Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString
                              (f_abjU
                                 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                          @(f_abjU Data.ByteString.Internal.Type.ByteString)
                          (\ (s1_abjY :: Data.ByteString.Internal.Type.ByteString) ->
                             case s1_abjY of wild_abjZ
                             { Data.ByteString.Internal.Type.BS bx_abk0 bx1_abk1 bx2_abk2 ->
                             case GHC.Classes.leInt (GHC.Types.I# bx2_abk2) (GHC.Types.I# 0#)
                             of {
                               GHC.Types.False ->
                                 Data.Either.Right
                                   @Data.ByteString.Internal.Type.ByteString
                                   @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                   (case GHC.Prim.readWord8OffAddr#
                                           @GHC.Prim.RealWorld bx_abk0 0# GHC.Prim.realWorld#
                                    of
                                    { (# ipv_abk7, ipv1_abk8 #) ->
                                    case GHC.Prim.touch#
                                           @'GHC.Types.Lifted
                                           @GHC.ForeignPtr.ForeignPtrContents
                                           bx1_abk1
                                           ipv_abk7
                                    of
                                    { __DEFAULT ->
                                    GHC.Word.W8# ipv1_abk8
                                    }
                                    },
                                    Data.ByteString.Internal.Type.$WBS
                                      (GHC.ForeignPtr.ForeignPtr
                                         @GHC.Word.Word8 (GHC.Prim.plusAddr# bx_abk0 1#) bx1_abk1)
                                      (GHC.Types.I# (GHC.Prim.-# bx2_abk2 1#)));
                               GHC.Types.True ->
                                 Data.Either.Left
                                   @Data.ByteString.Internal.Type.ByteString
                                   @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                   wild_abjZ
                             }
                             })
                          (let {
                             f2_abkc
                               :: Data.ByteString.Internal.Type.ByteString
                                  -> f_abjU Data.ByteString.Internal.Type.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abkc
                               = GHC.Base.pure
                                   @f_abjU
                                   $dApplicative_abjW
                                   @Data.ByteString.Internal.Type.ByteString } in
                           let {
                             ds2_abkd
                               :: f_abjU
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                  -> f_abjU Data.ByteString.Internal.Type.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 259 0}]
                             ds2_abkd
                               = GHC.Base.fmap
                                   @f_abjU
                                   (GHC.Base.$p1Applicative @f_abjU $dApplicative_abjW)
                                   @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                   @Data.ByteString.Internal.Type.ByteString
                                   (\ (p1_abke
                                         :: (GHC.Word.Word8,
                                             Data.ByteString.Internal.Type.ByteString)) ->
                                      case p1_abke of { (ds_abkg, y_abkh) ->
                                      case y_abkh of
                                      { Data.ByteString.Internal.Type.BS bx_abkt bx1_abku
                                                                         bx2_abkv ->
                                      GHC.Magic.runRW#
                                        @GHC.Types.LiftedRep
                                        @Data.ByteString.Internal.Type.ByteString
                                        (\ (s_abkr [OS=OneShot]
                                              :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                                           let {
                                             x_abks :: GHC.Prim.Int#
                                             [LclId,
                                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                      Value=False, ConLike=False, WorkFree=False,
                                                      Expandable=False,
                                                      Guidance=IF_ARGS [] 1 0}]
                                             x_abks = GHC.Prim.+# bx2_abkv 1# } in
                                           case GHC.Prim.<# x_abks 0# of {
                                             __DEFAULT ->
                                               case GHC.Prim.newPinnedByteArray#
                                                      @GHC.Prim.RealWorld x_abks s_abkr
                                               of
                                               { (# ipv_abkA, ipv1_abkB #) ->
                                               let {
                                                 ipv2_abkz :: GHC.Prim.Addr#
                                                 [LclId,
                                                  Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                          Value=False, ConLike=False,
                                                          WorkFree=False, Expandable=False,
                                                          Guidance=IF_ARGS [] 1 0}]
                                                 ipv2_abkz
                                                   = GHC.Prim.mutableByteArrayContents#
                                                       @GHC.Prim.RealWorld ipv1_abkB } in
                                               let {
                                                 ipv3_abkD :: GHC.ForeignPtr.ForeignPtrContents
                                                 [LclId,
                                                  Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                          Value=True, ConLike=True, WorkFree=True,
                                                          Expandable=True,
                                                          Guidance=IF_ARGS [] 10 10}]
                                                 ipv3_abkD = GHC.ForeignPtr.PlainPtr ipv1_abkB } in
                                               case ds_abkg of { GHC.Word.W8# x1_ablV ->
                                               case GHC.Prim.writeWord8OffAddr#
                                                      @GHC.Prim.RealWorld
                                                      ipv2_abkz
                                                      0#
                                                      x1_ablV
                                                      ipv_abkA
                                               of s2_ablX
                                               { __DEFAULT ->
                                               case GHC.Prim.touch#
                                                      @'GHC.Types.Lifted
                                                      @GHC.ForeignPtr.ForeignPtrContents
                                                      ipv3_abkD
                                                      s2_ablX
                                               of s'_ablY
                                               { __DEFAULT ->
                                               case {__ffi_static_ccall_unsafe base:memcpy :: Addr#
                                          -> Addr#
                                          -> Word64#
                                          -> State# RealWorld
                                          -> (# State# RealWorld, Addr# #)}_ablZ
                                                      (GHC.Prim.plusAddr# ipv2_abkz 1#)
                                                      bx_abkt
                                                      (GHC.Prim.int64ToWord64#
                                                         (GHC.Prim.intToInt64# bx2_abkv))
                                                      s'_ablY
                                               of
                                               { (# ds4_abm1, ds5_abm2 #) ->
                                               case GHC.Prim.touch#
                                                      @'GHC.Types.Lifted
                                                      @GHC.ForeignPtr.ForeignPtrContents
                                                      bx1_abku
                                                      ds4_abm1
                                               of s'1_abm4
                                               { __DEFAULT ->
                                               case GHC.Prim.touch#
                                                      @'GHC.Types.Lifted
                                                      @GHC.ForeignPtr.ForeignPtrContents
                                                      ipv3_abkD
                                                      s'1_abm4
                                               of s'2_abm5
                                               { __DEFAULT ->
                                               case GHC.Magic.lazy
                                                      @((GHC.Prim.State# GHC.Prim.RealWorld
                                                         -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                               GHC.Prim.Addr# #))
                                                        -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                              GHC.Prim.Addr# #))
                                                      (GHC.Magic.runRW#
                                                         @('GHC.Types.TupleRep
                                                             '[GHC.Types.ZeroBitRep,
                                                               'GHC.Types.AddrRep])
                                                         @(# GHC.Prim.State# GHC.Prim.RealWorld,
                                                             GHC.Prim.Addr# #))
                                                      (\ _ [Occ=Dead] -> (# s'2_abm5, ipv2_abkz #))
                                               of
                                               { (# ipv6_abm8, ipv7_abm9 #) ->
                                               Data.ByteString.Internal.Type.BS
                                                 ipv7_abm9 ipv3_abkD x_abks
                                               }
                                               }
                                               }
                                               }
                                               }
                                               }
                                               }
                                               };
                                             1# ->
                                               case GHC.ForeignPtr.mallocPlainForeignPtrBytes2
                                               of wild_00 {
                                               }
                                           })
                                      }
                                      }) } in
                           \ (ds3_abmc
                                :: Data.Either.Either
                                     Data.ByteString.Internal.Type.ByteString
                                     (f_abjU
                                        (GHC.Word.Word8,
                                         Data.ByteString.Internal.Type.ByteString))) ->
                             case ds3_abmc of {
                               Data.Either.Left x_abme -> f2_abkc x_abme;
                               Data.Either.Right y_abmg -> ds2_abkd y_abmg
                             }) } in
                  let {
                    g_abmi
                      :: p_abjT
                           (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                           (f_abjU (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                         -> p_abjT
                              (Data.Either.Either
                                 Data.ByteString.Internal.Type.ByteString
                                 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                              (Data.Either.Either
                                 Data.ByteString.Internal.Type.ByteString
                                 (f_abjU
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abmi
                      = Data.Profunctor.Choice.right'
                          @p_abjT
                          $dChoice_abjV
                          @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                          @(f_abjU
                              (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                          @Data.ByteString.Internal.Type.ByteString } in
                  \ (x_abmj
                       :: p_abjT
                            (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                            (f_abjU
                               (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))) ->
                    f1_abjX (g_abmi x_abmj))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <Data.ByteString.Internal.Type.ByteString>_N
                                <Data.ByteString.Internal.Type.ByteString>_N
                                <GHC.Word.Word8>_N
                                <GHC.Word.Word8>_N)
                       :: Control.Lens.Type.Prism
                            Data.ByteString.Internal.Type.ByteString
                            Data.ByteString.Internal.Type.ByteString
                            (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                            (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                          ~R# Control.Lens.Cons.Cons
                                Data.ByteString.Internal.Type.ByteString
                                Data.ByteString.Internal.Type.ByteString
                                GHC.Word.Word8
                                GHC.Word.Word8))
              ((\ (@(p_abmq :: * -> * -> *))
                  (@(f_abmr :: * -> *))
                  ($dChoice_abms :: Data.Profunctor.Choice.Choice p_abmq)
                  ($dApplicative_abmt :: GHC.Base.Applicative f_abmr) ->
                  let {
                    f1_abmu
                      :: p_abmq
                           (Data.Either.Either Data.ByteString.Internal.Type.ByteString ())
                           (Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString (f_abmr ()))
                         -> p_abmq
                              Data.ByteString.Internal.Type.ByteString
                              (f_abmr Data.ByteString.Internal.Type.ByteString)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 350 0}]
                    f1_abmu
                      = Data.Profunctor.Unsafe.dimap
                          @p_abmq
                          (Data.Profunctor.Choice.$p1Choice @p_abmq $dChoice_abms)
                          @Data.ByteString.Internal.Type.ByteString
                          @(Data.Either.Either Data.ByteString.Internal.Type.ByteString ())
                          @(Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString (f_abmr ()))
                          @(f_abmr Data.ByteString.Internal.Type.ByteString)
                          (\ (s_abmv :: Data.ByteString.Internal.Type.ByteString) ->
                             case s_abmv of wild_abmw
                             { Data.ByteString.Internal.Type.BS bx_abmx bx1_abmy bx2_abmz ->
                             case GHC.Classes.leInt (GHC.Types.I# bx2_abmz) (GHC.Types.I# 0#)
                             of {
                               GHC.Types.False ->
                                 Data.Either.Left
                                   @Data.ByteString.Internal.Type.ByteString @() wild_abmw;
                               GHC.Types.True ->
                                 Data.Either.Right
                                   @Data.ByteString.Internal.Type.ByteString @() GHC.Tuple.Prim.()
                             }
                             })
                          (let {
                             f2_abmD
                               :: Data.ByteString.Internal.Type.ByteString
                                  -> f_abmr Data.ByteString.Internal.Type.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abmD
                               = GHC.Base.pure
                                   @f_abmr
                                   $dApplicative_abmt
                                   @Data.ByteString.Internal.Type.ByteString } in
                           let {
                             ds2_abmE
                               :: f_abmr () -> f_abmr Data.ByteString.Internal.Type.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 70 0}]
                             ds2_abmE
                               = GHC.Base.fmap
                                   @f_abmr
                                   (GHC.Base.$p1Applicative @f_abmr $dApplicative_abmt)
                                   @()
                                   @Data.ByteString.Internal.Type.ByteString
                                   (\ (ds3_abmF :: ()) ->
                                      case ds3_abmF of { () ->
                                      Data.ByteString.Internal.Type.empty
                                      }) } in
                           \ (ds3_abmH
                                :: Data.Either.Either
                                     Data.ByteString.Internal.Type.ByteString (f_abmr ())) ->
                             case ds3_abmH of {
                               Data.Either.Left x_abmJ -> f2_abmD x_abmJ;
                               Data.Either.Right y_abmL -> ds2_abmE y_abmL
                             }) } in
                  let {
                    g_abmN
                      :: p_abmq () (f_abmr ())
                         -> p_abmq
                              (Data.Either.Either Data.ByteString.Internal.Type.ByteString ())
                              (Data.Either.Either
                                 Data.ByteString.Internal.Type.ByteString (f_abmr ()))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abmN
                      = Data.Profunctor.Choice.right'
                          @p_abmq
                          $dChoice_abms
                          @()
                          @(f_abmr ())
                          @Data.ByteString.Internal.Type.ByteString } in
                  \ (x_abmO :: p_abmq () (f_abmr ())) -> f1_abmu (g_abmN x_abmO))
               `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                <Data.ByteString.Internal.Type.ByteString>_N)
                       :: Control.Lens.Type.Prism'
                            Data.ByteString.Internal.Type.ByteString ()
                          ~R# Control.Lens.Empty.AsEmpty
                                Data.ByteString.Internal.Type.ByteString))
              (Data.Functor.Contravariant.$fContravariantConst
                 @Data.ByteString.Internal.Type.ByteString)
              (Data.Functor.Const.$fFunctorConst
                 @Data.ByteString.Internal.Type.ByteString)
    Cont:   ApplyToVal nodup hole Control.Lens.Getter.Getting
                                    Data.ByteString.Internal.Type.ByteString
                                    Data.ByteString.Internal.Type.ByteString
                                    Data.ByteString.Internal.Type.ByteString
              ((\ (ds_abe3 [Occ=Once1] :: a_abe0) -> ds_abe3)
               `cast` (<a_abe0>_R
                       %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                          <*>_N <a_abe0>_R <a_abe0>_P)
                       :: (a_abe0 -> a_abe0)
                          ~R# (a_abe0 -> Data.Functor.Const.Const a_abe0 a_abe0)))
            ApplyToVal nodup hole Data.ByteString.Internal.Type.ByteString
                                  -> Data.Functor.Const.Const
                                       Data.ByteString.Internal.Type.ByteString
                                       Data.ByteString.Internal.Type.ByteString
              s_a8JV
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N
                        <Data.ByteString.Internal.Type.ByteString>_R
                        <Data.ByteString.Internal.Type.ByteString>_P
                    :: Data.Functor.Const.Const
                         Data.ByteString.Internal.Type.ByteString
                         Data.ByteString.Internal.Type.ByteString
                       ~R# Data.ByteString.Internal.Type.ByteString)
            Stop[RuleArgCtxt] Data.ByteString.Internal.Type.ByteString
Rule fired
    Rule: Class op ==
    Module: (BUILTIN)
    Before: GHC.Classes.==
              TyArg Data.ByteString.Internal.Type.ByteString
              ValArg Data.ByteString.Internal.Type.$fEqByteString
              ValArg s_a8JV
              ValArg s_a8JV
    After:  Data.ByteString.Internal.Type.eq
              ValArg s_a8JV ValArg s_a8JV
    Cont:   Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: unpack
    Module: (GHC.Base)
    Before: GHC.CString.unpackCString# ValArg "L -> L"#
    After:  (\ (a_ab6H :: GHC.Prim.Addr#) ->
               GHC.Base.build
                 @GHC.Types.Char
                 (\ (@b_ab6I) -> GHC.CString.unpackFoldrCString# @b_ab6I a_ab6H))
              "L -> L"#
    Cont:   Stop[BoringCtxt] Test.Tasty.Core.TestName
Rule fired
    Rule: Class op property
    Module: (BUILTIN)
    Before: Test.QuickCheck.Property.property
              TyArg Data.ByteString.Lazy.Internal.ByteString -> GHC.Types.Bool
              ValArg Test.QuickCheck.Property.$fTestableFUN
                       @Data.ByteString.Lazy.Internal.ByteString
                       @GHC.Types.Bool
                       Test.QuickCheck.Instances.ByteString.$fArbitraryByteString
                       Data.ByteString.Lazy.Internal.$fShowByteString
                       Test.QuickCheck.Property.$fTestableBool
    After:  Test.QuickCheck.Property.$fTestableFUN_$cproperty
              @Data.ByteString.Lazy.Internal.ByteString
              @GHC.Types.Bool
              Test.QuickCheck.Instances.ByteString.$fArbitraryByteString
              Data.ByteString.Lazy.Internal.$fShowByteString
              Test.QuickCheck.Property.$fTestableBool
    Cont:   ApplyToVal nodup hole (Data.ByteString.Lazy.Internal.ByteString
                                   -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              prop_ab6U
            CastIt (Sym (Test.Tasty.QuickCheck.N:QC[0])
                    :: Test.QuickCheck.Property.Property ~R# Test.Tasty.QuickCheck.QC)
            Stop[BoringCtxt] Test.Tasty.QuickCheck.QC
Rule fired
    Rule: Class op propertyForAllShrinkShow
    Module: (BUILTIN)
    Before: Test.QuickCheck.Property.propertyForAllShrinkShow
              TyArg GHC.Types.Bool ValArg Test.QuickCheck.Property.$fTestableBool
    After:  Test.QuickCheck.Property.$fTestableBool1
            `cast` (forall (a :: <*>_N).
                    <Test.QuickCheck.Gen.Gen a>_R
                    %<'GHC.Types.Many>_N ->_R <a -> [a]>_R
                    %<'GHC.Types.Many>_N ->_R <a -> [GHC.Base.String]>_R
                    %<'GHC.Types.Many>_N ->_R <a -> GHC.Types.Bool>_R
                    %<'GHC.Types.Many>_N ->_R Sym (Test.QuickCheck.Gen.N:Gen[0]
                                                       (Test.QuickCheck.Property.N:Prop[0]))
                                              ; Sym (Test.QuickCheck.Property.N:Property[0])
                    :: (forall {a}.
                        Test.QuickCheck.Gen.Gen a
                        -> (a -> [a])
                        -> (a -> [GHC.Base.String])
                        -> (a -> GHC.Types.Bool)
                        -> Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int
                        -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result)
                       ~R# (forall {a}.
                            Test.QuickCheck.Gen.Gen a
                            -> (a -> [a])
                            -> (a -> [GHC.Base.String])
                            -> (a -> GHC.Types.Bool)
                            -> Test.QuickCheck.Property.Property))
    Cont:   ApplyToTy Data.ByteString.Lazy.Internal.ByteString
            ApplyToVal nodup hole Test.QuickCheck.Gen.Gen
                                    Data.ByteString.Lazy.Internal.ByteString
                                  -> (Data.ByteString.Lazy.Internal.ByteString
                                      -> [Data.ByteString.Lazy.Internal.ByteString])
                                  -> (Data.ByteString.Lazy.Internal.ByteString -> [GHC.Base.String])
                                  -> (Data.ByteString.Lazy.Internal.ByteString -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (Test.QuickCheck.Arbitrary.arbitrary @a_ab8C $dArbitrary_ab8E)
            ApplyToVal nodup hole (Data.ByteString.Lazy.Internal.ByteString
                                   -> [Data.ByteString.Lazy.Internal.ByteString])
                                  -> (Data.ByteString.Lazy.Internal.ByteString -> [GHC.Base.String])
                                  -> (Data.ByteString.Lazy.Internal.ByteString -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (Test.QuickCheck.Arbitrary.shrink @a_ab8C $dArbitrary_ab8E)
            ApplyToVal nodup hole (Data.ByteString.Lazy.Internal.ByteString
                                   -> [GHC.Base.String])
                                  -> (Data.ByteString.Lazy.Internal.ByteString -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (let {
                 g_ab8I [Occ=OnceL1!] :: a_ab8C -> GHC.Base.String
                 [LclId]
                 g_ab8I = GHC.Show.show @a_ab8C $dShow_ab8F } in
               \ (x_ab8J [Occ=Once1] :: a_ab8C) ->
                 GHC.Types.:
                   @GHC.Base.String (g_ab8I x_ab8J) (GHC.Types.[] @GHC.Base.String))
            ApplyToVal nodup hole (Data.ByteString.Lazy.Internal.ByteString
                                   -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              f_ab8H
            CastIt (Sym (Test.Tasty.QuickCheck.N:QC[0])
                    :: Test.QuickCheck.Property.Property ~R# Test.Tasty.QuickCheck.QC)
            Stop[BoringCtxt] Test.Tasty.QuickCheck.QC
Rule fired
    Rule: Class op arbitrary
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.arbitrary
              TyArg Data.ByteString.Lazy.Internal.ByteString
              ValArg Test.QuickCheck.Instances.ByteString.$fArbitraryByteString
    After:  Test.QuickCheck.Instances.ByteString.$fArbitraryByteString1
            `cast` (Sym (Test.QuickCheck.Gen.N:Gen[0]
                             <Data.ByteString.Lazy.Internal.ByteString>_R)
                    :: (Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int -> Data.ByteString.Lazy.Internal.ByteString)
                       ~R# Test.QuickCheck.Gen.Gen
                             Data.ByteString.Lazy.Internal.ByteString)
    Cont:   Stop[BoringCtxt] Test.QuickCheck.Gen.Gen
                               Data.ByteString.Lazy.Internal.ByteString
Rule fired
    Rule: Class op shrink
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.shrink
              TyArg Data.ByteString.Lazy.Internal.ByteString
              ValArg Test.QuickCheck.Instances.ByteString.$fArbitraryByteString
    After:  Test.QuickCheck.Instances.ByteString.$fArbitraryByteString_$cshrink
    Cont:   Stop[BoringCtxt] Data.ByteString.Lazy.Internal.ByteString
                             -> [Data.ByteString.Lazy.Internal.ByteString]
Rule fired
    Rule: Class op show
    Module: (BUILTIN)
    Before: GHC.Show.show
              TyArg Data.ByteString.Lazy.Internal.ByteString
              ValArg Data.ByteString.Lazy.Internal.$fShowByteString
    After:  Data.ByteString.Lazy.Internal.$fShowByteString_$cshow
    Cont:   Stop[RhsCtxt(NonRecursive)] Data.ByteString.Lazy.Internal.ByteString
                                        -> GHC.Base.String
Rule fired
    Rule: Class op reader
    Module: (BUILTIN)
    Before: Control.Monad.Reader.Class.reader
              TyArg Data.ByteString.Lazy.Internal.ByteString
              TyArg (->) Data.ByteString.Lazy.Internal.ByteString
              ValArg Control.Monad.Reader.Class.$fMonadReaderrFUN
                       @Data.ByteString.Lazy.Internal.ByteString
    After:  \ (@a_abe8) ->
              GHC.Base.id @(Data.ByteString.Lazy.Internal.ByteString -> a_abe8)
    Cont:   ApplyToTy Data.ByteString.Lazy.Internal.ByteString
            ApplyToVal nodup hole (Data.ByteString.Lazy.Internal.ByteString
                                   -> Data.ByteString.Lazy.Internal.ByteString)
                                  -> Data.ByteString.Lazy.Internal.ByteString
                                  -> Data.ByteString.Lazy.Internal.ByteString
              ((l_abe2
                  ((\ (ds_abe3 [Occ=Once1] :: a_abe0) -> ds_abe3)
                   `cast` (<a_abe0>_R
                           %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                              <*>_N <a_abe0>_R <a_abe0>_P)
                           :: (a_abe0 -> a_abe0)
                              ~R# (a_abe0 -> Data.Functor.Const.Const a_abe0 a_abe0))))
               `cast` (<s_abdY>_R
                       %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                     <*>_N <a_abe0>_R <s_abdY>_P
                       :: (s_abdY -> Data.Functor.Const.Const a_abe0 s_abdY)
                          ~R# (s_abdY -> a_abe0)))
            ApplyToVal nodup hole Data.ByteString.Lazy.Internal.ByteString
                                  -> Data.ByteString.Lazy.Internal.ByteString
              s_a8MY
            Stop[RuleArgCtxt] Data.ByteString.Lazy.Internal.ByteString
Rule fired
    Rule: recons/id
    Module: (Control.Lens.Cons.Extras)
    Before: Control.Lens.Cons.Extras.recons
              TyArg Data.ByteString.Lazy.Internal.ByteString
              TyArg GHC.Word.Word8
              TyArg Data.ByteString.Lazy.Internal.ByteString
              ValArg (\ (@(p_abmT :: * -> * -> *))
                        (@(f_abmU :: * -> *))
                        ($dChoice_abmV :: Data.Profunctor.Choice.Choice p_abmT)
                        ($dApplicative_abmW :: GHC.Base.Applicative f_abmU) ->
                        let {
                          f1_abmX
                            :: p_abmT
                                 (Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                                 (Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (f_abmU
                                       (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                               -> p_abmT
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (f_abmU Data.ByteString.Lazy.Internal.ByteString)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 536 0}]
                          f1_abmX
                            = Data.Profunctor.Unsafe.dimap
                                @p_abmT
                                (Data.Profunctor.Choice.$p1Choice @p_abmT $dChoice_abmV)
                                @Data.ByteString.Lazy.Internal.ByteString
                                @(Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                                @(Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (f_abmU
                                       (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                                @(f_abmU Data.ByteString.Lazy.Internal.ByteString)
                                (\ (s1_abmY :: Data.ByteString.Lazy.Internal.ByteString) ->
                                   case s1_abmY of {
                                     Data.ByteString.Lazy.Internal.Empty ->
                                       Data.Either.Left
                                         @Data.ByteString.Lazy.Internal.ByteString
                                         @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                         Data.ByteString.Lazy.Internal.Empty;
                                     Data.ByteString.Lazy.Internal.Chunk bx_abn5 bx1_abn6 bx2_abn7
                                                                         cs_abn8 ->
                                       case bx2_abn7 of ds1_abna {
                                         __DEFAULT ->
                                           Data.Either.Right
                                             @Data.ByteString.Lazy.Internal.ByteString
                                             @(GHC.Word.Word8,
                                               Data.ByteString.Lazy.Internal.ByteString)
                                             (case GHC.Prim.readWord8OffAddr#
                                                     @GHC.Prim.RealWorld
                                                     bx_abn5
                                                     0#
                                                     GHC.Prim.realWorld#
                                              of
                                              { (# ipv_abnc, ipv1_abnd #) ->
                                              case GHC.Prim.touch#
                                                     @'GHC.Types.Lifted
                                                     @GHC.ForeignPtr.ForeignPtrContents
                                                     bx1_abn6
                                                     ipv_abnc
                                              of
                                              { __DEFAULT ->
                                              GHC.Word.W8# ipv1_abnd
                                              }
                                              },
                                              Data.ByteString.Lazy.Internal.$WChunk
                                                (Data.ByteString.Internal.Type.$WBS
                                                   (GHC.ForeignPtr.ForeignPtr
                                                      @GHC.Word.Word8
                                                      (GHC.Prim.plusAddr# bx_abn5 1#)
                                                      bx1_abn6)
                                                   (GHC.Types.I# (GHC.Prim.-# ds1_abna 1#)))
                                                cs_abn8);
                                         1# ->
                                           Data.Either.Right
                                             @Data.ByteString.Lazy.Internal.ByteString
                                             @(GHC.Word.Word8,
                                               Data.ByteString.Lazy.Internal.ByteString)
                                             (case GHC.Prim.readWord8OffAddr#
                                                     @GHC.Prim.RealWorld
                                                     bx_abn5
                                                     0#
                                                     GHC.Prim.realWorld#
                                              of
                                              { (# ipv_abnh, ipv1_abni #) ->
                                              case GHC.Prim.touch#
                                                     @'GHC.Types.Lifted
                                                     @GHC.ForeignPtr.ForeignPtrContents
                                                     bx1_abn6
                                                     ipv_abnh
                                              of
                                              { __DEFAULT ->
                                              GHC.Word.W8# ipv1_abni
                                              }
                                              },
                                              cs_abn8)
                                       }
                                   })
                                (let {
                                   f2_abnl
                                     :: Data.ByteString.Lazy.Internal.ByteString
                                        -> f_abmU Data.ByteString.Lazy.Internal.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abnl
                                     = GHC.Base.pure
                                         @f_abmU
                                         $dApplicative_abmW
                                         @Data.ByteString.Lazy.Internal.ByteString } in
                                 let {
                                   ds2_abnm
                                     :: f_abmU
                                          (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                        -> f_abmU Data.ByteString.Lazy.Internal.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 162 0}]
                                   ds2_abnm
                                     = GHC.Base.fmap
                                         @f_abmU
                                         (GHC.Base.$p1Applicative @f_abmU $dApplicative_abmW)
                                         @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                         @Data.ByteString.Lazy.Internal.ByteString
                                         (\ (p1_abnn
                                               :: (GHC.Word.Word8,
                                                   Data.ByteString.Lazy.Internal.ByteString)) ->
                                            case p1_abnn of { (x_abnp, ds_abnq) ->
                                            case x_abnp of { GHC.Word.W8# x#_abnt ->
                                            Data.ByteString.Lazy.Internal.$WChunk
                                              (Data.ByteString.Internal.Type.$WBS
                                                 (GHC.ForeignPtr.ForeignPtr
                                                    @GHC.Word.Word8
                                                    (GHC.Prim.plusAddr#
                                                       Data.ByteString.singleton1
                                                       (GHC.Prim.word2Int#
                                                          (GHC.Prim.word8ToWord# x#_abnt)))
                                                    GHC.ForeignPtr.FinalPtr)
                                                 (GHC.Types.I# 1#))
                                              ds_abnq
                                            }
                                            }) } in
                                 \ (ds3_abnv
                                      :: Data.Either.Either
                                           Data.ByteString.Lazy.Internal.ByteString
                                           (f_abmU
                                              (GHC.Word.Word8,
                                               Data.ByteString.Lazy.Internal.ByteString))) ->
                                   case ds3_abnv of {
                                     Data.Either.Left x_abnx -> f2_abnl x_abnx;
                                     Data.Either.Right y_abnz -> ds2_abnm y_abnz
                                   }) } in
                        let {
                          g_abnB
                            :: p_abmT
                                 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                 (f_abmU (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                               -> p_abmT
                                    (Data.Either.Either
                                       Data.ByteString.Lazy.Internal.ByteString
                                       (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                                    (Data.Either.Either
                                       Data.ByteString.Lazy.Internal.ByteString
                                       (f_abmU
                                          (GHC.Word.Word8,
                                           Data.ByteString.Lazy.Internal.ByteString)))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abnB
                            = Data.Profunctor.Choice.right'
                                @p_abmT
                                $dChoice_abmV
                                @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                @(f_abmU
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                                @Data.ByteString.Lazy.Internal.ByteString } in
                        \ (x_abnC
                             :: p_abmT
                                  (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                  (f_abmU
                                     (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))) ->
                          f1_abmX (g_abnB x_abnC))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <Data.ByteString.Lazy.Internal.ByteString>_N
                                      <Data.ByteString.Lazy.Internal.ByteString>_N
                                      <GHC.Word.Word8>_N
                                      <GHC.Word.Word8>_N)
                             :: Control.Lens.Type.Prism
                                  Data.ByteString.Lazy.Internal.ByteString
                                  Data.ByteString.Lazy.Internal.ByteString
                                  (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                  (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                ~R# Control.Lens.Cons.Cons
                                      Data.ByteString.Lazy.Internal.ByteString
                                      Data.ByteString.Lazy.Internal.ByteString
                                      GHC.Word.Word8
                                      GHC.Word.Word8)
              ValArg (\ (@(p_abmT :: * -> * -> *))
                        (@(f_abmU :: * -> *))
                        ($dChoice_abmV :: Data.Profunctor.Choice.Choice p_abmT)
                        ($dApplicative_abmW :: GHC.Base.Applicative f_abmU) ->
                        let {
                          f1_abmX
                            :: p_abmT
                                 (Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                                 (Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (f_abmU
                                       (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                               -> p_abmT
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (f_abmU Data.ByteString.Lazy.Internal.ByteString)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 536 0}]
                          f1_abmX
                            = Data.Profunctor.Unsafe.dimap
                                @p_abmT
                                (Data.Profunctor.Choice.$p1Choice @p_abmT $dChoice_abmV)
                                @Data.ByteString.Lazy.Internal.ByteString
                                @(Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                                @(Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (f_abmU
                                       (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                                @(f_abmU Data.ByteString.Lazy.Internal.ByteString)
                                (\ (s1_abmY :: Data.ByteString.Lazy.Internal.ByteString) ->
                                   case s1_abmY of {
                                     Data.ByteString.Lazy.Internal.Empty ->
                                       Data.Either.Left
                                         @Data.ByteString.Lazy.Internal.ByteString
                                         @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                         Data.ByteString.Lazy.Internal.Empty;
                                     Data.ByteString.Lazy.Internal.Chunk bx_abn5 bx1_abn6 bx2_abn7
                                                                         cs_abn8 ->
                                       case bx2_abn7 of ds1_abna {
                                         __DEFAULT ->
                                           Data.Either.Right
                                             @Data.ByteString.Lazy.Internal.ByteString
                                             @(GHC.Word.Word8,
                                               Data.ByteString.Lazy.Internal.ByteString)
                                             (case GHC.Prim.readWord8OffAddr#
                                                     @GHC.Prim.RealWorld
                                                     bx_abn5
                                                     0#
                                                     GHC.Prim.realWorld#
                                              of
                                              { (# ipv_abnc, ipv1_abnd #) ->
                                              case GHC.Prim.touch#
                                                     @'GHC.Types.Lifted
                                                     @GHC.ForeignPtr.ForeignPtrContents
                                                     bx1_abn6
                                                     ipv_abnc
                                              of
                                              { __DEFAULT ->
                                              GHC.Word.W8# ipv1_abnd
                                              }
                                              },
                                              Data.ByteString.Lazy.Internal.$WChunk
                                                (Data.ByteString.Internal.Type.$WBS
                                                   (GHC.ForeignPtr.ForeignPtr
                                                      @GHC.Word.Word8
                                                      (GHC.Prim.plusAddr# bx_abn5 1#)
                                                      bx1_abn6)
                                                   (GHC.Types.I# (GHC.Prim.-# ds1_abna 1#)))
                                                cs_abn8);
                                         1# ->
                                           Data.Either.Right
                                             @Data.ByteString.Lazy.Internal.ByteString
                                             @(GHC.Word.Word8,
                                               Data.ByteString.Lazy.Internal.ByteString)
                                             (case GHC.Prim.readWord8OffAddr#
                                                     @GHC.Prim.RealWorld
                                                     bx_abn5
                                                     0#
                                                     GHC.Prim.realWorld#
                                              of
                                              { (# ipv_abnh, ipv1_abni #) ->
                                              case GHC.Prim.touch#
                                                     @'GHC.Types.Lifted
                                                     @GHC.ForeignPtr.ForeignPtrContents
                                                     bx1_abn6
                                                     ipv_abnh
                                              of
                                              { __DEFAULT ->
                                              GHC.Word.W8# ipv1_abni
                                              }
                                              },
                                              cs_abn8)
                                       }
                                   })
                                (let {
                                   f2_abnl
                                     :: Data.ByteString.Lazy.Internal.ByteString
                                        -> f_abmU Data.ByteString.Lazy.Internal.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abnl
                                     = GHC.Base.pure
                                         @f_abmU
                                         $dApplicative_abmW
                                         @Data.ByteString.Lazy.Internal.ByteString } in
                                 let {
                                   ds2_abnm
                                     :: f_abmU
                                          (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                        -> f_abmU Data.ByteString.Lazy.Internal.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 162 0}]
                                   ds2_abnm
                                     = GHC.Base.fmap
                                         @f_abmU
                                         (GHC.Base.$p1Applicative @f_abmU $dApplicative_abmW)
                                         @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                         @Data.ByteString.Lazy.Internal.ByteString
                                         (\ (p1_abnn
                                               :: (GHC.Word.Word8,
                                                   Data.ByteString.Lazy.Internal.ByteString)) ->
                                            case p1_abnn of { (x_abnp, ds_abnq) ->
                                            case x_abnp of { GHC.Word.W8# x#_abnt ->
                                            Data.ByteString.Lazy.Internal.$WChunk
                                              (Data.ByteString.Internal.Type.$WBS
                                                 (GHC.ForeignPtr.ForeignPtr
                                                    @GHC.Word.Word8
                                                    (GHC.Prim.plusAddr#
                                                       Data.ByteString.singleton1
                                                       (GHC.Prim.word2Int#
                                                          (GHC.Prim.word8ToWord# x#_abnt)))
                                                    GHC.ForeignPtr.FinalPtr)
                                                 (GHC.Types.I# 1#))
                                              ds_abnq
                                            }
                                            }) } in
                                 \ (ds3_abnv
                                      :: Data.Either.Either
                                           Data.ByteString.Lazy.Internal.ByteString
                                           (f_abmU
                                              (GHC.Word.Word8,
                                               Data.ByteString.Lazy.Internal.ByteString))) ->
                                   case ds3_abnv of {
                                     Data.Either.Left x_abnx -> f2_abnl x_abnx;
                                     Data.Either.Right y_abnz -> ds2_abnm y_abnz
                                   }) } in
                        let {
                          g_abnB
                            :: p_abmT
                                 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                 (f_abmU (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                               -> p_abmT
                                    (Data.Either.Either
                                       Data.ByteString.Lazy.Internal.ByteString
                                       (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                                    (Data.Either.Either
                                       Data.ByteString.Lazy.Internal.ByteString
                                       (f_abmU
                                          (GHC.Word.Word8,
                                           Data.ByteString.Lazy.Internal.ByteString)))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abnB
                            = Data.Profunctor.Choice.right'
                                @p_abmT
                                $dChoice_abmV
                                @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                @(f_abmU
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                                @Data.ByteString.Lazy.Internal.ByteString } in
                        \ (x_abnC
                             :: p_abmT
                                  (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                  (f_abmU
                                     (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))) ->
                          f1_abmX (g_abnB x_abnC))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <Data.ByteString.Lazy.Internal.ByteString>_N
                                      <Data.ByteString.Lazy.Internal.ByteString>_N
                                      <GHC.Word.Word8>_N
                                      <GHC.Word.Word8>_N)
                             :: Control.Lens.Type.Prism
                                  Data.ByteString.Lazy.Internal.ByteString
                                  Data.ByteString.Lazy.Internal.ByteString
                                  (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                  (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                ~R# Control.Lens.Cons.Cons
                                      Data.ByteString.Lazy.Internal.ByteString
                                      Data.ByteString.Lazy.Internal.ByteString
                                      GHC.Word.Word8
                                      GHC.Word.Word8)
              ValArg (\ (@(p_abnE :: * -> * -> *))
                        (@(f_abnF :: * -> *))
                        ($dChoice_abnG :: Data.Profunctor.Choice.Choice p_abnE)
                        ($dApplicative_abnH :: GHC.Base.Applicative f_abnF) ->
                        let {
                          f1_abnI
                            :: p_abnE
                                 (Data.Either.Either Data.ByteString.Lazy.Internal.ByteString ())
                                 (Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString (f_abnF ()))
                               -> p_abnE
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (f_abnF Data.ByteString.Lazy.Internal.ByteString)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 290 0}]
                          f1_abnI
                            = Data.Profunctor.Unsafe.dimap
                                @p_abnE
                                (Data.Profunctor.Choice.$p1Choice @p_abnE $dChoice_abnG)
                                @Data.ByteString.Lazy.Internal.ByteString
                                @(Data.Either.Either Data.ByteString.Lazy.Internal.ByteString ())
                                @(Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString (f_abnF ()))
                                @(f_abnF Data.ByteString.Lazy.Internal.ByteString)
                                (\ (s_abnJ :: Data.ByteString.Lazy.Internal.ByteString) ->
                                   case s_abnJ of wild_abnK {
                                     Data.ByteString.Lazy.Internal.Empty ->
                                       Data.Either.Right
                                         @Data.ByteString.Lazy.Internal.ByteString
                                         @()
                                         GHC.Tuple.Prim.();
                                     Data.ByteString.Lazy.Internal.Chunk ipv_abnL ipv1_abnM
                                                                         ipv2_abnN ipv3_abnO ->
                                       Data.Either.Left
                                         @Data.ByteString.Lazy.Internal.ByteString @() wild_abnK
                                   })
                                (let {
                                   f2_abnQ
                                     :: Data.ByteString.Lazy.Internal.ByteString
                                        -> f_abnF Data.ByteString.Lazy.Internal.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abnQ
                                     = GHC.Base.pure
                                         @f_abnF
                                         $dApplicative_abnH
                                         @Data.ByteString.Lazy.Internal.ByteString } in
                                 let {
                                   ds2_abnR
                                     :: f_abnF () -> f_abnF Data.ByteString.Lazy.Internal.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 70 0}]
                                   ds2_abnR
                                     = GHC.Base.fmap
                                         @f_abnF
                                         (GHC.Base.$p1Applicative @f_abnF $dApplicative_abnH)
                                         @()
                                         @Data.ByteString.Lazy.Internal.ByteString
                                         (\ (ds3_abnS :: ()) ->
                                            case ds3_abnS of { () ->
                                            Data.ByteString.Lazy.Internal.Empty
                                            }) } in
                                 \ (ds3_abnU
                                      :: Data.Either.Either
                                           Data.ByteString.Lazy.Internal.ByteString (f_abnF ())) ->
                                   case ds3_abnU of {
                                     Data.Either.Left x_abnW -> f2_abnQ x_abnW;
                                     Data.Either.Right y_abnY -> ds2_abnR y_abnY
                                   }) } in
                        let {
                          g_abo0
                            :: p_abnE () (f_abnF ())
                               -> p_abnE
                                    (Data.Either.Either Data.ByteString.Lazy.Internal.ByteString ())
                                    (Data.Either.Either
                                       Data.ByteString.Lazy.Internal.ByteString (f_abnF ()))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abo0
                            = Data.Profunctor.Choice.right'
                                @p_abnE
                                $dChoice_abnG
                                @()
                                @(f_abnF ())
                                @Data.ByteString.Lazy.Internal.ByteString } in
                        \ (x_abo1 :: p_abnE () (f_abnF ())) -> f1_abnI (g_abo0 x_abo1))
                     `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                      <Data.ByteString.Lazy.Internal.ByteString>_N)
                             :: Control.Lens.Type.Prism'
                                  Data.ByteString.Lazy.Internal.ByteString ()
                                ~R# Control.Lens.Empty.AsEmpty
                                      Data.ByteString.Lazy.Internal.ByteString)
              TyArg Data.Functor.Const.Const
                      Data.ByteString.Lazy.Internal.ByteString
              ValArg Data.Functor.Contravariant.$fContravariantConst
                       @Data.ByteString.Lazy.Internal.ByteString
              ValArg Data.Functor.Const.$fFunctorConst
                       @Data.ByteString.Lazy.Internal.ByteString
    After:  (\ (@s1_abf7)
               (@(f_abf8 :: * -> *))
               (@a_abf9)
               ($dCons_abfa
                  :: Control.Lens.Cons.Cons s1_abf7 s1_abf7 a_abf9 a_abf9)
               ($dCons1_abfb
                  :: Control.Lens.Cons.Cons s1_abf7 s1_abf7 a_abf9 a_abf9)
               ($dAsEmpty_abfc :: Control.Lens.Empty.AsEmpty s1_abf7)
               ($dContravariant_abfd
                  :: Data.Functor.Contravariant.Contravariant f_abf8)
               ($dFunctor_abfe :: GHC.Base.Functor f_abf8) ->
               GHC.Base.id @(s1_abf7 -> f_abf8 s1_abf7))
              @Data.ByteString.Lazy.Internal.ByteString
              @(Data.Functor.Const.Const
                  Data.ByteString.Lazy.Internal.ByteString)
              @GHC.Word.Word8
              ((\ (@(p_abmT :: * -> * -> *))
                  (@(f_abmU :: * -> *))
                  ($dChoice_abmV :: Data.Profunctor.Choice.Choice p_abmT)
                  ($dApplicative_abmW :: GHC.Base.Applicative f_abmU) ->
                  let {
                    f1_abmX
                      :: p_abmT
                           (Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString
                              (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                           (Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString
                              (f_abmU
                                 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                         -> p_abmT
                              Data.ByteString.Lazy.Internal.ByteString
                              (f_abmU Data.ByteString.Lazy.Internal.ByteString)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 536 0}]
                    f1_abmX
                      = Data.Profunctor.Unsafe.dimap
                          @p_abmT
                          (Data.Profunctor.Choice.$p1Choice @p_abmT $dChoice_abmV)
                          @Data.ByteString.Lazy.Internal.ByteString
                          @(Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString
                              (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                          @(Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString
                              (f_abmU
                                 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                          @(f_abmU Data.ByteString.Lazy.Internal.ByteString)
                          (\ (s1_abmY :: Data.ByteString.Lazy.Internal.ByteString) ->
                             case s1_abmY of {
                               Data.ByteString.Lazy.Internal.Empty ->
                                 Data.Either.Left
                                   @Data.ByteString.Lazy.Internal.ByteString
                                   @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                   Data.ByteString.Lazy.Internal.Empty;
                               Data.ByteString.Lazy.Internal.Chunk bx_abn5 bx1_abn6 bx2_abn7
                                                                   cs_abn8 ->
                                 case bx2_abn7 of ds1_abna {
                                   __DEFAULT ->
                                     Data.Either.Right
                                       @Data.ByteString.Lazy.Internal.ByteString
                                       @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                       (case GHC.Prim.readWord8OffAddr#
                                               @GHC.Prim.RealWorld bx_abn5 0# GHC.Prim.realWorld#
                                        of
                                        { (# ipv_abnc, ipv1_abnd #) ->
                                        case GHC.Prim.touch#
                                               @'GHC.Types.Lifted
                                               @GHC.ForeignPtr.ForeignPtrContents
                                               bx1_abn6
                                               ipv_abnc
                                        of
                                        { __DEFAULT ->
                                        GHC.Word.W8# ipv1_abnd
                                        }
                                        },
                                        Data.ByteString.Lazy.Internal.$WChunk
                                          (Data.ByteString.Internal.Type.$WBS
                                             (GHC.ForeignPtr.ForeignPtr
                                                @GHC.Word.Word8
                                                (GHC.Prim.plusAddr# bx_abn5 1#)
                                                bx1_abn6)
                                             (GHC.Types.I# (GHC.Prim.-# ds1_abna 1#)))
                                          cs_abn8);
                                   1# ->
                                     Data.Either.Right
                                       @Data.ByteString.Lazy.Internal.ByteString
                                       @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                       (case GHC.Prim.readWord8OffAddr#
                                               @GHC.Prim.RealWorld bx_abn5 0# GHC.Prim.realWorld#
                                        of
                                        { (# ipv_abnh, ipv1_abni #) ->
                                        case GHC.Prim.touch#
                                               @'GHC.Types.Lifted
                                               @GHC.ForeignPtr.ForeignPtrContents
                                               bx1_abn6
                                               ipv_abnh
                                        of
                                        { __DEFAULT ->
                                        GHC.Word.W8# ipv1_abni
                                        }
                                        },
                                        cs_abn8)
                                 }
                             })
                          (let {
                             f2_abnl
                               :: Data.ByteString.Lazy.Internal.ByteString
                                  -> f_abmU Data.ByteString.Lazy.Internal.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abnl
                               = GHC.Base.pure
                                   @f_abmU
                                   $dApplicative_abmW
                                   @Data.ByteString.Lazy.Internal.ByteString } in
                           let {
                             ds2_abnm
                               :: f_abmU
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                  -> f_abmU Data.ByteString.Lazy.Internal.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 162 0}]
                             ds2_abnm
                               = GHC.Base.fmap
                                   @f_abmU
                                   (GHC.Base.$p1Applicative @f_abmU $dApplicative_abmW)
                                   @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                   @Data.ByteString.Lazy.Internal.ByteString
                                   (\ (p1_abnn
                                         :: (GHC.Word.Word8,
                                             Data.ByteString.Lazy.Internal.ByteString)) ->
                                      case p1_abnn of { (x_abnp, ds_abnq) ->
                                      case x_abnp of { GHC.Word.W8# x#_abnt ->
                                      Data.ByteString.Lazy.Internal.$WChunk
                                        (Data.ByteString.Internal.Type.$WBS
                                           (GHC.ForeignPtr.ForeignPtr
                                              @GHC.Word.Word8
                                              (GHC.Prim.plusAddr#
                                                 Data.ByteString.singleton1
                                                 (GHC.Prim.word2Int#
                                                    (GHC.Prim.word8ToWord# x#_abnt)))
                                              GHC.ForeignPtr.FinalPtr)
                                           (GHC.Types.I# 1#))
                                        ds_abnq
                                      }
                                      }) } in
                           \ (ds3_abnv
                                :: Data.Either.Either
                                     Data.ByteString.Lazy.Internal.ByteString
                                     (f_abmU
                                        (GHC.Word.Word8,
                                         Data.ByteString.Lazy.Internal.ByteString))) ->
                             case ds3_abnv of {
                               Data.Either.Left x_abnx -> f2_abnl x_abnx;
                               Data.Either.Right y_abnz -> ds2_abnm y_abnz
                             }) } in
                  let {
                    g_abnB
                      :: p_abmT
                           (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                           (f_abmU (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                         -> p_abmT
                              (Data.Either.Either
                                 Data.ByteString.Lazy.Internal.ByteString
                                 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                              (Data.Either.Either
                                 Data.ByteString.Lazy.Internal.ByteString
                                 (f_abmU
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abnB
                      = Data.Profunctor.Choice.right'
                          @p_abmT
                          $dChoice_abmV
                          @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                          @(f_abmU
                              (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                          @Data.ByteString.Lazy.Internal.ByteString } in
                  \ (x_abnC
                       :: p_abmT
                            (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                            (f_abmU
                               (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))) ->
                    f1_abmX (g_abnB x_abnC))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <Data.ByteString.Lazy.Internal.ByteString>_N
                                <Data.ByteString.Lazy.Internal.ByteString>_N
                                <GHC.Word.Word8>_N
                                <GHC.Word.Word8>_N)
                       :: Control.Lens.Type.Prism
                            Data.ByteString.Lazy.Internal.ByteString
                            Data.ByteString.Lazy.Internal.ByteString
                            (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                            (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                          ~R# Control.Lens.Cons.Cons
                                Data.ByteString.Lazy.Internal.ByteString
                                Data.ByteString.Lazy.Internal.ByteString
                                GHC.Word.Word8
                                GHC.Word.Word8))
              ((\ (@(p_abmT :: * -> * -> *))
                  (@(f_abmU :: * -> *))
                  ($dChoice_abmV :: Data.Profunctor.Choice.Choice p_abmT)
                  ($dApplicative_abmW :: GHC.Base.Applicative f_abmU) ->
                  let {
                    f1_abmX
                      :: p_abmT
                           (Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString
                              (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                           (Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString
                              (f_abmU
                                 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                         -> p_abmT
                              Data.ByteString.Lazy.Internal.ByteString
                              (f_abmU Data.ByteString.Lazy.Internal.ByteString)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 536 0}]
                    f1_abmX
                      = Data.Profunctor.Unsafe.dimap
                          @p_abmT
                          (Data.Profunctor.Choice.$p1Choice @p_abmT $dChoice_abmV)
                          @Data.ByteString.Lazy.Internal.ByteString
                          @(Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString
                              (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                          @(Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString
                              (f_abmU
                                 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                          @(f_abmU Data.ByteString.Lazy.Internal.ByteString)
                          (\ (s1_abmY :: Data.ByteString.Lazy.Internal.ByteString) ->
                             case s1_abmY of {
                               Data.ByteString.Lazy.Internal.Empty ->
                                 Data.Either.Left
                                   @Data.ByteString.Lazy.Internal.ByteString
                                   @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                   Data.ByteString.Lazy.Internal.Empty;
                               Data.ByteString.Lazy.Internal.Chunk bx_abn5 bx1_abn6 bx2_abn7
                                                                   cs_abn8 ->
                                 case bx2_abn7 of ds1_abna {
                                   __DEFAULT ->
                                     Data.Either.Right
                                       @Data.ByteString.Lazy.Internal.ByteString
                                       @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                       (case GHC.Prim.readWord8OffAddr#
                                               @GHC.Prim.RealWorld bx_abn5 0# GHC.Prim.realWorld#
                                        of
                                        { (# ipv_abnc, ipv1_abnd #) ->
                                        case GHC.Prim.touch#
                                               @'GHC.Types.Lifted
                                               @GHC.ForeignPtr.ForeignPtrContents
                                               bx1_abn6
                                               ipv_abnc
                                        of
                                        { __DEFAULT ->
                                        GHC.Word.W8# ipv1_abnd
                                        }
                                        },
                                        Data.ByteString.Lazy.Internal.$WChunk
                                          (Data.ByteString.Internal.Type.$WBS
                                             (GHC.ForeignPtr.ForeignPtr
                                                @GHC.Word.Word8
                                                (GHC.Prim.plusAddr# bx_abn5 1#)
                                                bx1_abn6)
                                             (GHC.Types.I# (GHC.Prim.-# ds1_abna 1#)))
                                          cs_abn8);
                                   1# ->
                                     Data.Either.Right
                                       @Data.ByteString.Lazy.Internal.ByteString
                                       @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                       (case GHC.Prim.readWord8OffAddr#
                                               @GHC.Prim.RealWorld bx_abn5 0# GHC.Prim.realWorld#
                                        of
                                        { (# ipv_abnh, ipv1_abni #) ->
                                        case GHC.Prim.touch#
                                               @'GHC.Types.Lifted
                                               @GHC.ForeignPtr.ForeignPtrContents
                                               bx1_abn6
                                               ipv_abnh
                                        of
                                        { __DEFAULT ->
                                        GHC.Word.W8# ipv1_abni
                                        }
                                        },
                                        cs_abn8)
                                 }
                             })
                          (let {
                             f2_abnl
                               :: Data.ByteString.Lazy.Internal.ByteString
                                  -> f_abmU Data.ByteString.Lazy.Internal.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abnl
                               = GHC.Base.pure
                                   @f_abmU
                                   $dApplicative_abmW
                                   @Data.ByteString.Lazy.Internal.ByteString } in
                           let {
                             ds2_abnm
                               :: f_abmU
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                  -> f_abmU Data.ByteString.Lazy.Internal.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 162 0}]
                             ds2_abnm
                               = GHC.Base.fmap
                                   @f_abmU
                                   (GHC.Base.$p1Applicative @f_abmU $dApplicative_abmW)
                                   @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                   @Data.ByteString.Lazy.Internal.ByteString
                                   (\ (p1_abnn
                                         :: (GHC.Word.Word8,
                                             Data.ByteString.Lazy.Internal.ByteString)) ->
                                      case p1_abnn of { (x_abnp, ds_abnq) ->
                                      case x_abnp of { GHC.Word.W8# x#_abnt ->
                                      Data.ByteString.Lazy.Internal.$WChunk
                                        (Data.ByteString.Internal.Type.$WBS
                                           (GHC.ForeignPtr.ForeignPtr
                                              @GHC.Word.Word8
                                              (GHC.Prim.plusAddr#
                                                 Data.ByteString.singleton1
                                                 (GHC.Prim.word2Int#
                                                    (GHC.Prim.word8ToWord# x#_abnt)))
                                              GHC.ForeignPtr.FinalPtr)
                                           (GHC.Types.I# 1#))
                                        ds_abnq
                                      }
                                      }) } in
                           \ (ds3_abnv
                                :: Data.Either.Either
                                     Data.ByteString.Lazy.Internal.ByteString
                                     (f_abmU
                                        (GHC.Word.Word8,
                                         Data.ByteString.Lazy.Internal.ByteString))) ->
                             case ds3_abnv of {
                               Data.Either.Left x_abnx -> f2_abnl x_abnx;
                               Data.Either.Right y_abnz -> ds2_abnm y_abnz
                             }) } in
                  let {
                    g_abnB
                      :: p_abmT
                           (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                           (f_abmU (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                         -> p_abmT
                              (Data.Either.Either
                                 Data.ByteString.Lazy.Internal.ByteString
                                 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                              (Data.Either.Either
                                 Data.ByteString.Lazy.Internal.ByteString
                                 (f_abmU
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abnB
                      = Data.Profunctor.Choice.right'
                          @p_abmT
                          $dChoice_abmV
                          @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                          @(f_abmU
                              (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                          @Data.ByteString.Lazy.Internal.ByteString } in
                  \ (x_abnC
                       :: p_abmT
                            (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                            (f_abmU
                               (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))) ->
                    f1_abmX (g_abnB x_abnC))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <Data.ByteString.Lazy.Internal.ByteString>_N
                                <Data.ByteString.Lazy.Internal.ByteString>_N
                                <GHC.Word.Word8>_N
                                <GHC.Word.Word8>_N)
                       :: Control.Lens.Type.Prism
                            Data.ByteString.Lazy.Internal.ByteString
                            Data.ByteString.Lazy.Internal.ByteString
                            (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                            (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                          ~R# Control.Lens.Cons.Cons
                                Data.ByteString.Lazy.Internal.ByteString
                                Data.ByteString.Lazy.Internal.ByteString
                                GHC.Word.Word8
                                GHC.Word.Word8))
              ((\ (@(p_abnE :: * -> * -> *))
                  (@(f_abnF :: * -> *))
                  ($dChoice_abnG :: Data.Profunctor.Choice.Choice p_abnE)
                  ($dApplicative_abnH :: GHC.Base.Applicative f_abnF) ->
                  let {
                    f1_abnI
                      :: p_abnE
                           (Data.Either.Either Data.ByteString.Lazy.Internal.ByteString ())
                           (Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString (f_abnF ()))
                         -> p_abnE
                              Data.ByteString.Lazy.Internal.ByteString
                              (f_abnF Data.ByteString.Lazy.Internal.ByteString)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 290 0}]
                    f1_abnI
                      = Data.Profunctor.Unsafe.dimap
                          @p_abnE
                          (Data.Profunctor.Choice.$p1Choice @p_abnE $dChoice_abnG)
                          @Data.ByteString.Lazy.Internal.ByteString
                          @(Data.Either.Either Data.ByteString.Lazy.Internal.ByteString ())
                          @(Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString (f_abnF ()))
                          @(f_abnF Data.ByteString.Lazy.Internal.ByteString)
                          (\ (s_abnJ :: Data.ByteString.Lazy.Internal.ByteString) ->
                             case s_abnJ of wild_abnK {
                               Data.ByteString.Lazy.Internal.Empty ->
                                 Data.Either.Right
                                   @Data.ByteString.Lazy.Internal.ByteString @() GHC.Tuple.Prim.();
                               Data.ByteString.Lazy.Internal.Chunk ipv_abnL ipv1_abnM ipv2_abnN
                                                                   ipv3_abnO ->
                                 Data.Either.Left
                                   @Data.ByteString.Lazy.Internal.ByteString @() wild_abnK
                             })
                          (let {
                             f2_abnQ
                               :: Data.ByteString.Lazy.Internal.ByteString
                                  -> f_abnF Data.ByteString.Lazy.Internal.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abnQ
                               = GHC.Base.pure
                                   @f_abnF
                                   $dApplicative_abnH
                                   @Data.ByteString.Lazy.Internal.ByteString } in
                           let {
                             ds2_abnR
                               :: f_abnF () -> f_abnF Data.ByteString.Lazy.Internal.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 70 0}]
                             ds2_abnR
                               = GHC.Base.fmap
                                   @f_abnF
                                   (GHC.Base.$p1Applicative @f_abnF $dApplicative_abnH)
                                   @()
                                   @Data.ByteString.Lazy.Internal.ByteString
                                   (\ (ds3_abnS :: ()) ->
                                      case ds3_abnS of { () ->
                                      Data.ByteString.Lazy.Internal.Empty
                                      }) } in
                           \ (ds3_abnU
                                :: Data.Either.Either
                                     Data.ByteString.Lazy.Internal.ByteString (f_abnF ())) ->
                             case ds3_abnU of {
                               Data.Either.Left x_abnW -> f2_abnQ x_abnW;
                               Data.Either.Right y_abnY -> ds2_abnR y_abnY
                             }) } in
                  let {
                    g_abo0
                      :: p_abnE () (f_abnF ())
                         -> p_abnE
                              (Data.Either.Either Data.ByteString.Lazy.Internal.ByteString ())
                              (Data.Either.Either
                                 Data.ByteString.Lazy.Internal.ByteString (f_abnF ()))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abo0
                      = Data.Profunctor.Choice.right'
                          @p_abnE
                          $dChoice_abnG
                          @()
                          @(f_abnF ())
                          @Data.ByteString.Lazy.Internal.ByteString } in
                  \ (x_abo1 :: p_abnE () (f_abnF ())) -> f1_abnI (g_abo0 x_abo1))
               `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                <Data.ByteString.Lazy.Internal.ByteString>_N)
                       :: Control.Lens.Type.Prism'
                            Data.ByteString.Lazy.Internal.ByteString ()
                          ~R# Control.Lens.Empty.AsEmpty
                                Data.ByteString.Lazy.Internal.ByteString))
              (Data.Functor.Contravariant.$fContravariantConst
                 @Data.ByteString.Lazy.Internal.ByteString)
              (Data.Functor.Const.$fFunctorConst
                 @Data.ByteString.Lazy.Internal.ByteString)
    Cont:   ApplyToVal nodup hole Control.Lens.Getter.Getting
                                    Data.ByteString.Lazy.Internal.ByteString
                                    Data.ByteString.Lazy.Internal.ByteString
                                    Data.ByteString.Lazy.Internal.ByteString
              ((\ (ds_abe3 [Occ=Once1] :: a_abe0) -> ds_abe3)
               `cast` (<a_abe0>_R
                       %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                          <*>_N <a_abe0>_R <a_abe0>_P)
                       :: (a_abe0 -> a_abe0)
                          ~R# (a_abe0 -> Data.Functor.Const.Const a_abe0 a_abe0)))
            ApplyToVal nodup hole Data.ByteString.Lazy.Internal.ByteString
                                  -> Data.Functor.Const.Const
                                       Data.ByteString.Lazy.Internal.ByteString
                                       Data.ByteString.Lazy.Internal.ByteString
              s_a8MY
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N
                        <Data.ByteString.Lazy.Internal.ByteString>_R
                        <Data.ByteString.Lazy.Internal.ByteString>_P
                    :: Data.Functor.Const.Const
                         Data.ByteString.Lazy.Internal.ByteString
                         Data.ByteString.Lazy.Internal.ByteString
                       ~R# Data.ByteString.Lazy.Internal.ByteString)
            Stop[RuleArgCtxt] Data.ByteString.Lazy.Internal.ByteString
Rule fired
    Rule: Class op ==
    Module: (BUILTIN)
    Before: GHC.Classes.==
              TyArg Data.ByteString.Lazy.Internal.ByteString
              ValArg Data.ByteString.Lazy.Internal.$fEqByteString
              ValArg s_a8MY
              ValArg s_a8MY
    After:  Data.ByteString.Lazy.Internal.eq
              ValArg s_a8MY ValArg s_a8MY
    Cont:   Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: unpack
    Module: (GHC.Base)
    Before: GHC.CString.unpackCString# ValArg "Str -> T -> Str"#
    After:  (\ (a_ab6H :: GHC.Prim.Addr#) ->
               GHC.Base.build
                 @GHC.Types.Char
                 (\ (@b_ab6I) -> GHC.CString.unpackFoldrCString# @b_ab6I a_ab6H))
              "Str -> T -> Str"#
    Cont:   Stop[BoringCtxt] Test.Tasty.Core.TestName
Rule fired
    Rule: Class op property
    Module: (BUILTIN)
    Before: Test.QuickCheck.Property.property
              TyArg GHC.Base.String -> GHC.Types.Bool ValArg $dTestable_a91r
    After:  Test.QuickCheck.Property.$fTestableFUN_$cproperty
              @[GHC.Types.Char]
              @GHC.Types.Bool
              $dArbitrary_a9IP
              GHC.Show.$fShowList_$s$fShowList1
              Test.QuickCheck.Property.$fTestableBool
    Cont:   ApplyToVal nodup hole (GHC.Base.String -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              prop_ab6U
            CastIt (Sym (Test.Tasty.QuickCheck.N:QC[0])
                    :: Test.QuickCheck.Property.Property ~R# Test.Tasty.QuickCheck.QC)
            Stop[BoringCtxt] Test.Tasty.QuickCheck.QC
Rule fired
    Rule: Class op propertyForAllShrinkShow
    Module: (BUILTIN)
    Before: Test.QuickCheck.Property.propertyForAllShrinkShow
              TyArg GHC.Types.Bool ValArg Test.QuickCheck.Property.$fTestableBool
    After:  Test.QuickCheck.Property.$fTestableBool1
            `cast` (forall (a :: <*>_N).
                    <Test.QuickCheck.Gen.Gen a>_R
                    %<'GHC.Types.Many>_N ->_R <a -> [a]>_R
                    %<'GHC.Types.Many>_N ->_R <a -> [GHC.Base.String]>_R
                    %<'GHC.Types.Many>_N ->_R <a -> GHC.Types.Bool>_R
                    %<'GHC.Types.Many>_N ->_R Sym (Test.QuickCheck.Gen.N:Gen[0]
                                                       (Test.QuickCheck.Property.N:Prop[0]))
                                              ; Sym (Test.QuickCheck.Property.N:Property[0])
                    :: (forall {a}.
                        Test.QuickCheck.Gen.Gen a
                        -> (a -> [a])
                        -> (a -> [GHC.Base.String])
                        -> (a -> GHC.Types.Bool)
                        -> Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int
                        -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result)
                       ~R# (forall {a}.
                            Test.QuickCheck.Gen.Gen a
                            -> (a -> [a])
                            -> (a -> [GHC.Base.String])
                            -> (a -> GHC.Types.Bool)
                            -> Test.QuickCheck.Property.Property))
    Cont:   ApplyToTy [GHC.Types.Char]
            ApplyToVal nodup hole Test.QuickCheck.Gen.Gen [GHC.Types.Char]
                                  -> ([GHC.Types.Char] -> [[GHC.Types.Char]])
                                  -> ([GHC.Types.Char] -> [GHC.Base.String])
                                  -> ([GHC.Types.Char] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (Test.QuickCheck.Arbitrary.arbitrary @a_ab8C $dArbitrary_ab8E)
            ApplyToVal nodup hole ([GHC.Types.Char] -> [[GHC.Types.Char]])
                                  -> ([GHC.Types.Char] -> [GHC.Base.String])
                                  -> ([GHC.Types.Char] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (Test.QuickCheck.Arbitrary.shrink @a_ab8C $dArbitrary_ab8E)
            ApplyToVal nodup hole ([GHC.Types.Char] -> [GHC.Base.String])
                                  -> ([GHC.Types.Char] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (let {
                 g_ab8I [Occ=OnceL1!] :: a_ab8C -> GHC.Base.String
                 [LclId]
                 g_ab8I = GHC.Show.show @a_ab8C $dShow_ab8F } in
               \ (x_ab8J [Occ=Once1] :: a_ab8C) ->
                 GHC.Types.:
                   @GHC.Base.String (g_ab8I x_ab8J) (GHC.Types.[] @GHC.Base.String))
            ApplyToVal nodup hole ([GHC.Types.Char] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              f_ab8H
            CastIt (Sym (Test.Tasty.QuickCheck.N:QC[0])
                    :: Test.QuickCheck.Property.Property ~R# Test.Tasty.QuickCheck.QC)
            Stop[BoringCtxt] Test.Tasty.QuickCheck.QC
Rule fired
    Rule: Class op arbitrary
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.arbitrary
              TyArg [GHC.Types.Char] ValArg $dArbitrary_a9IP
    After:  (Test.QuickCheck.Arbitrary.$fArbitraryList1
               @GHC.Types.Char Test.QuickCheck.Arbitrary.$fArbitraryChar)
            `cast` (Sym (Test.QuickCheck.Gen.N:Gen[0] <[GHC.Types.Char]>_R)
                    :: (Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int -> [GHC.Types.Char])
                       ~R# Test.QuickCheck.Gen.Gen [GHC.Types.Char])
    Cont:   Stop[BoringCtxt] Test.QuickCheck.Gen.Gen [GHC.Types.Char]
Rule fired
    Rule: Class op arbitrary
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.arbitrary
              TyArg GHC.Types.Char
              ValArg Test.QuickCheck.Arbitrary.$fArbitraryChar
    After:  Test.QuickCheck.Arbitrary.$fArbitraryChar_$carbitrary
    Cont:   Stop[BoringCtxt, C(S,C(1,L))] Test.QuickCheck.Gen.Gen
                                            GHC.Types.Char
Rule fired
    Rule: Class op shrink
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.shrink
              TyArg [GHC.Types.Char] ValArg $dArbitrary_a9IP
    After:  Test.QuickCheck.Arbitrary.$fArbitraryList_$cshrink
              @GHC.Types.Char Test.QuickCheck.Arbitrary.$fArbitraryChar
    Cont:   Stop[BoringCtxt] [GHC.Types.Char] -> [[GHC.Types.Char]]
Rule fired
    Rule: Class op shrink
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.shrink
              TyArg GHC.Types.Char
              ValArg Test.QuickCheck.Arbitrary.$fArbitraryChar
    After:  Test.QuickCheck.Arbitrary.$fArbitraryChar_$cshrink
    Cont:   Stop[DiscArgCtxt, C(S,L)] GHC.Types.Char
                                      -> [GHC.Types.Char]
Rule fired
    Rule: Class op show
    Module: (BUILTIN)
    Before: GHC.Show.show
              TyArg [GHC.Types.Char] ValArg GHC.Show.$fShowList_$s$fShowList1
    After:  GHC.Show.$fShowList_$s$cshow1
    Cont:   Stop[RhsCtxt(NonRecursive)] [GHC.Types.Char]
                                        -> GHC.Base.String
Rule fired
    Rule: Class op reader
    Module: (BUILTIN)
    Before: Control.Monad.Reader.Class.reader
              TyArg Data.Text.Internal.Text
              TyArg (->) Data.Text.Internal.Text
              ValArg Control.Monad.Reader.Class.$fMonadReaderrFUN
                       @Data.Text.Internal.Text
    After:  \ (@a_abe8) ->
              GHC.Base.id @(Data.Text.Internal.Text -> a_abe8)
    Cont:   ApplyToTy GHC.Base.String
            ApplyToVal nodup hole (Data.Text.Internal.Text -> GHC.Base.String)
                                  -> Data.Text.Internal.Text -> GHC.Base.String
              ((l_abe2
                  ((\ (ds_abe3 [Occ=Once1] :: a_abe0) -> ds_abe3)
                   `cast` (<a_abe0>_R
                           %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                              <*>_N <a_abe0>_R <a_abe0>_P)
                           :: (a_abe0 -> a_abe0)
                              ~R# (a_abe0 -> Data.Functor.Const.Const a_abe0 a_abe0))))
               `cast` (<s_abdY>_R
                       %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                     <*>_N <a_abe0>_R <s_abdY>_P
                       :: (s_abdY -> Data.Functor.Const.Const a_abe0 s_abdY)
                          ~R# (s_abdY -> a_abe0)))
            ApplyToVal nodup hole Data.Text.Internal.Text -> GHC.Base.String
              (Control.Lens.Getter.view
                 @[GHC.Types.Char]
                 @((->) GHC.Base.String)
                 @Data.Text.Internal.Text
                 (Control.Monad.Reader.Class.$fMonadReaderrFUN @[GHC.Types.Char])
                 (Control.Lens.Cons.Extras.recons
                    @[GHC.Types.Char]
                    @GHC.Types.Char
                    @Data.Text.Internal.Text
                    (Control.Lens.Cons.$fConsListListab
                       @GHC.Types.Char @GHC.Types.Char)
                    Control.Lens.Cons.$fConsTextTextCharChar0
                    Control.Lens.Empty.$fAsEmptyText0
                    @(Data.Functor.Const.Const Data.Text.Internal.Text)
                    (Data.Functor.Contravariant.$fContravariantConst
                       @Data.Text.Internal.Text)
                    (Data.Functor.Const.$fFunctorConst @Data.Text.Internal.Text))
                 s_a8OC)
            Stop[RuleArgCtxt] GHC.Base.String
Rule fired
    Rule: recons/text-string
    Module: (Control.Lens.Cons.Extras)
    Before: Control.Lens.Cons.Extras.recons
              TyArg Data.Text.Internal.Text
              TyArg GHC.Types.Char
              TyArg GHC.Base.String
              ValArg (\ (@(p_abhA :: * -> * -> *))
                        (@(f_abhB :: * -> *))
                        ($dChoice_abhC :: Data.Profunctor.Choice.Choice p_abhA)
                        ($dApplicative_abhD :: GHC.Base.Applicative f_abhB) ->
                        let {
                          f1_abhE
                            :: p_abhA
                                 (Data.Either.Either
                                    Data.Text.Internal.Text
                                    (GHC.Types.Char, Data.Text.Internal.Text))
                                 (Data.Either.Either
                                    Data.Text.Internal.Text
                                    (f_abhB (GHC.Types.Char, Data.Text.Internal.Text)))
                               -> p_abhA Data.Text.Internal.Text (f_abhB Data.Text.Internal.Text)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 340 0}]
                          f1_abhE
                            = Data.Profunctor.Unsafe.dimap
                                @p_abhA
                                (Data.Profunctor.Choice.$p1Choice @p_abhA $dChoice_abhC)
                                @Data.Text.Internal.Text
                                @(Data.Either.Either
                                    Data.Text.Internal.Text
                                    (GHC.Types.Char, Data.Text.Internal.Text))
                                @(Data.Either.Either
                                    Data.Text.Internal.Text
                                    (f_abhB (GHC.Types.Char, Data.Text.Internal.Text)))
                                @(f_abhB Data.Text.Internal.Text)
                                (\ (s1_abhF :: Data.Text.Internal.Text) ->
                                   case Data.Text.uncons s1_abhF of {
                                     GHC.Maybe.Nothing ->
                                       Data.Either.Left
                                         @Data.Text.Internal.Text
                                         @(GHC.Types.Char, Data.Text.Internal.Text)
                                         s1_abhF;
                                     GHC.Maybe.Just x_abhI ->
                                       Data.Either.Right
                                         @Data.Text.Internal.Text
                                         @(GHC.Types.Char, Data.Text.Internal.Text)
                                         x_abhI
                                   })
                                (let {
                                   f2_abhK
                                     :: Data.Text.Internal.Text -> f_abhB Data.Text.Internal.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abhK
                                     = GHC.Base.pure
                                         @f_abhB $dApplicative_abhD @Data.Text.Internal.Text } in
                                 let {
                                   ds2_abhL
                                     :: f_abhB (GHC.Types.Char, Data.Text.Internal.Text)
                                        -> f_abhB Data.Text.Internal.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 100 0}]
                                   ds2_abhL
                                     = GHC.Base.fmap
                                         @f_abhB
                                         (GHC.Base.$p1Applicative @f_abhB $dApplicative_abhD)
                                         @(GHC.Types.Char, Data.Text.Internal.Text)
                                         @Data.Text.Internal.Text
                                         (\ (p1_abhM
                                               :: (GHC.Types.Char, Data.Text.Internal.Text)) ->
                                            case p1_abhM of { (x_abhO, ds_abhP) ->
                                            Data.Text.cons x_abhO ds_abhP
                                            }) } in
                                 \ (ds3_abhR
                                      :: Data.Either.Either
                                           Data.Text.Internal.Text
                                           (f_abhB (GHC.Types.Char, Data.Text.Internal.Text))) ->
                                   case ds3_abhR of {
                                     Data.Either.Left x_abhT -> f2_abhK x_abhT;
                                     Data.Either.Right y_abhV -> ds2_abhL y_abhV
                                   }) } in
                        let {
                          g_abhX
                            :: p_abhA
                                 (GHC.Types.Char, Data.Text.Internal.Text)
                                 (f_abhB (GHC.Types.Char, Data.Text.Internal.Text))
                               -> p_abhA
                                    (Data.Either.Either
                                       Data.Text.Internal.Text
                                       (GHC.Types.Char, Data.Text.Internal.Text))
                                    (Data.Either.Either
                                       Data.Text.Internal.Text
                                       (f_abhB (GHC.Types.Char, Data.Text.Internal.Text)))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abhX
                            = Data.Profunctor.Choice.right'
                                @p_abhA
                                $dChoice_abhC
                                @(GHC.Types.Char, Data.Text.Internal.Text)
                                @(f_abhB (GHC.Types.Char, Data.Text.Internal.Text))
                                @Data.Text.Internal.Text } in
                        \ (x_abhY
                             :: p_abhA
                                  (GHC.Types.Char, Data.Text.Internal.Text)
                                  (f_abhB (GHC.Types.Char, Data.Text.Internal.Text))) ->
                          f1_abhE (g_abhX x_abhY))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <Data.Text.Internal.Text>_N
                                      <Data.Text.Internal.Text>_N
                                      <GHC.Types.Char>_N
                                      <GHC.Types.Char>_N)
                             :: Control.Lens.Type.Prism
                                  Data.Text.Internal.Text
                                  Data.Text.Internal.Text
                                  (GHC.Types.Char, Data.Text.Internal.Text)
                                  (GHC.Types.Char, Data.Text.Internal.Text)
                                ~R# Control.Lens.Cons.Cons
                                      Data.Text.Internal.Text
                                      Data.Text.Internal.Text
                                      GHC.Types.Char
                                      GHC.Types.Char)
              ValArg (\ (@(p_abfz :: * -> * -> *))
                        (@(f_abfA :: * -> *))
                        ($dChoice_abfB :: Data.Profunctor.Choice.Choice p_abfz)
                        ($dApplicative_abfC :: GHC.Base.Applicative f_abfA) ->
                        let {
                          f1_abfD
                            :: p_abfz
                                 (Data.Either.Either
                                    [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                                 (Data.Either.Either
                                    [GHC.Types.Char] (f_abfA (GHC.Types.Char, [GHC.Types.Char])))
                               -> p_abfz [GHC.Types.Char] (f_abfA [GHC.Types.Char])
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 320 0}]
                          f1_abfD
                            = Data.Profunctor.Unsafe.dimap
                                @p_abfz
                                (Data.Profunctor.Choice.$p1Choice @p_abfz $dChoice_abfB)
                                @[GHC.Types.Char]
                                @(Data.Either.Either
                                    [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                                @(Data.Either.Either
                                    [GHC.Types.Char] (f_abfA (GHC.Types.Char, [GHC.Types.Char])))
                                @(f_abfA [GHC.Types.Char])
                                (\ (aas_abfE :: [GHC.Types.Char]) ->
                                   case aas_abfE of {
                                     [] ->
                                       Data.Either.Left
                                         @[GHC.Types.Char]
                                         @(GHC.Types.Char, [GHC.Types.Char])
                                         (GHC.Types.[] @GHC.Types.Char);
                                     : a1_abfG as_abfH ->
                                       Data.Either.Right
                                         @[GHC.Types.Char]
                                         @(GHC.Types.Char, [GHC.Types.Char])
                                         (a1_abfG, as_abfH)
                                   })
                                (let {
                                   f2_abfJ :: [GHC.Types.Char] -> f_abfA [GHC.Types.Char]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abfJ
                                     = GHC.Base.pure
                                         @f_abfA $dApplicative_abfC @[GHC.Types.Char] } in
                                 let {
                                   ds2_abfK
                                     :: f_abfA (GHC.Types.Char, [GHC.Types.Char])
                                        -> f_abfA [GHC.Types.Char]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 90 0}]
                                   ds2_abfK
                                     = GHC.Base.fmap
                                         @f_abfA
                                         (GHC.Base.$p1Applicative @f_abfA $dApplicative_abfC)
                                         @(GHC.Types.Char, [GHC.Types.Char])
                                         @[GHC.Types.Char]
                                         (\ (p1_abfL :: (GHC.Types.Char, [GHC.Types.Char])) ->
                                            GHC.Types.:
                                              @GHC.Types.Char
                                              (case p1_abfL of { (x_abfN, ds_abfO) -> x_abfN })
                                              (case p1_abfL of { (ds_abfR, y_abfS) ->
                                               y_abfS
                                               })) } in
                                 \ (ds3_abfU
                                      :: Data.Either.Either
                                           [GHC.Types.Char]
                                           (f_abfA (GHC.Types.Char, [GHC.Types.Char]))) ->
                                   case ds3_abfU of {
                                     Data.Either.Left x_abfW -> f2_abfJ x_abfW;
                                     Data.Either.Right y_abfY -> ds2_abfK y_abfY
                                   }) } in
                        let {
                          g_abg0
                            :: p_abfz
                                 (GHC.Types.Char, [GHC.Types.Char])
                                 (f_abfA (GHC.Types.Char, [GHC.Types.Char]))
                               -> p_abfz
                                    (Data.Either.Either
                                       [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                                    (Data.Either.Either
                                       [GHC.Types.Char] (f_abfA (GHC.Types.Char, [GHC.Types.Char])))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abg0
                            = Data.Profunctor.Choice.right'
                                @p_abfz
                                $dChoice_abfB
                                @(GHC.Types.Char, [GHC.Types.Char])
                                @(f_abfA (GHC.Types.Char, [GHC.Types.Char]))
                                @[GHC.Types.Char] } in
                        \ (x_abg1
                             :: p_abfz
                                  (GHC.Types.Char, [GHC.Types.Char])
                                  (f_abfA (GHC.Types.Char, [GHC.Types.Char]))) ->
                          f1_abfD (g_abg0 x_abg1))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <[GHC.Types.Char]>_N
                                      <[GHC.Types.Char]>_N
                                      <GHC.Types.Char>_N
                                      <GHC.Types.Char>_N)
                             :: Control.Lens.Type.Prism
                                  [GHC.Types.Char]
                                  [GHC.Types.Char]
                                  (GHC.Types.Char, [GHC.Types.Char])
                                  (GHC.Types.Char, [GHC.Types.Char])
                                ~R# Control.Lens.Cons.Cons
                                      [GHC.Types.Char]
                                      [GHC.Types.Char]
                                      GHC.Types.Char
                                      GHC.Types.Char)
              ValArg (\ (@(p_abg6 :: * -> * -> *))
                        (@(f_abg7 :: * -> *))
                        ($dChoice_abg8 :: Data.Profunctor.Choice.Choice p_abg6)
                        ($dApplicative_abg9 :: GHC.Base.Applicative f_abg7) ->
                        let {
                          f1_abga
                            :: p_abg6
                                 (Data.Either.Either [GHC.Types.Char] ())
                                 (Data.Either.Either [GHC.Types.Char] (f_abg7 ()))
                               -> p_abg6 [GHC.Types.Char] (f_abg7 [GHC.Types.Char])
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 290 0}]
                          f1_abga
                            = Data.Profunctor.Unsafe.dimap
                                @p_abg6
                                (Data.Profunctor.Choice.$p1Choice @p_abg6 $dChoice_abg8)
                                @[GHC.Types.Char]
                                @(Data.Either.Either [GHC.Types.Char] ())
                                @(Data.Either.Either [GHC.Types.Char] (f_abg7 ()))
                                @(f_abg7 [GHC.Types.Char])
                                (\ (s_abgb :: [GHC.Types.Char]) ->
                                   case s_abgb of wild_abgc {
                                     [] ->
                                       Data.Either.Right @[GHC.Types.Char] @() GHC.Tuple.Prim.();
                                     : ds1_abgd ds2_abge ->
                                       Data.Either.Left @[GHC.Types.Char] @() wild_abgc
                                   })
                                (let {
                                   f2_abgg :: [GHC.Types.Char] -> f_abg7 [GHC.Types.Char]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abgg
                                     = GHC.Base.pure
                                         @f_abg7 $dApplicative_abg9 @[GHC.Types.Char] } in
                                 let {
                                   ds2_abgh :: f_abg7 () -> f_abg7 [GHC.Types.Char]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 70 0}]
                                   ds2_abgh
                                     = GHC.Base.fmap
                                         @f_abg7
                                         (GHC.Base.$p1Applicative @f_abg7 $dApplicative_abg9)
                                         @()
                                         @[GHC.Types.Char]
                                         (\ (ds3_abgi :: ()) ->
                                            case ds3_abgi of { () ->
                                            GHC.Types.[] @GHC.Types.Char
                                            }) } in
                                 \ (ds3_abgk :: Data.Either.Either [GHC.Types.Char] (f_abg7 ())) ->
                                   case ds3_abgk of {
                                     Data.Either.Left x_abgm -> f2_abgg x_abgm;
                                     Data.Either.Right y_abgo -> ds2_abgh y_abgo
                                   }) } in
                        let {
                          g_abgq
                            :: p_abg6 () (f_abg7 ())
                               -> p_abg6
                                    (Data.Either.Either [GHC.Types.Char] ())
                                    (Data.Either.Either [GHC.Types.Char] (f_abg7 ()))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abgq
                            = Data.Profunctor.Choice.right'
                                @p_abg6 $dChoice_abg8 @() @(f_abg7 ()) @[GHC.Types.Char] } in
                        \ (x_abgr :: p_abg6 () (f_abg7 ())) -> f1_abga (g_abgq x_abgr))
                     `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0] <[GHC.Types.Char]>_N)
                             :: Control.Lens.Type.Prism' [GHC.Types.Char] ()
                                ~R# Control.Lens.Empty.AsEmpty [GHC.Types.Char])
              TyArg Data.Functor.Const.Const GHC.Base.String
              ValArg Data.Functor.Contravariant.$fContravariantConst
                       @[GHC.Types.Char]
              ValArg Data.Functor.Const.$fFunctorConst @[GHC.Types.Char]
    After:  (\ (@(f_abeb :: * -> *))
               ($dCons_abec
                  :: Control.Lens.Cons.Cons
                       Data.Text.Internal.Text
                       Data.Text.Internal.Text
                       GHC.Types.Char
                       GHC.Types.Char)
               ($dCons1_abed
                  :: Control.Lens.Cons.Cons
                       GHC.Base.String GHC.Base.String GHC.Types.Char GHC.Types.Char)
               ($dAsEmpty_abee :: Control.Lens.Empty.AsEmpty GHC.Base.String)
               ($dContravariant_abef
                  :: Data.Functor.Contravariant.Contravariant f_abeb)
               ($dFunctor_abeg :: GHC.Base.Functor f_abeb) ->
               Data.Profunctor.Unsafe.$fProfunctorFUN_$cdimap
                 @Data.Text.Internal.Text
                 @GHC.Base.String
                 @(f_abeb GHC.Base.String)
                 @(f_abeb Data.Text.Internal.Text)
                 Data.Text.Show.unpack
                 (GHC.Base.fmap
                    @f_abeb
                    $dFunctor_abeg
                    @GHC.Base.String
                    @Data.Text.Internal.Text
                    Data.Text.Internal.pack))
              @(Data.Functor.Const.Const GHC.Base.String)
              ((\ (@(p_abhA :: * -> * -> *))
                  (@(f_abhB :: * -> *))
                  ($dChoice_abhC :: Data.Profunctor.Choice.Choice p_abhA)
                  ($dApplicative_abhD :: GHC.Base.Applicative f_abhB) ->
                  let {
                    f1_abhE
                      :: p_abhA
                           (Data.Either.Either
                              Data.Text.Internal.Text (GHC.Types.Char, Data.Text.Internal.Text))
                           (Data.Either.Either
                              Data.Text.Internal.Text
                              (f_abhB (GHC.Types.Char, Data.Text.Internal.Text)))
                         -> p_abhA Data.Text.Internal.Text (f_abhB Data.Text.Internal.Text)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 340 0}]
                    f1_abhE
                      = Data.Profunctor.Unsafe.dimap
                          @p_abhA
                          (Data.Profunctor.Choice.$p1Choice @p_abhA $dChoice_abhC)
                          @Data.Text.Internal.Text
                          @(Data.Either.Either
                              Data.Text.Internal.Text (GHC.Types.Char, Data.Text.Internal.Text))
                          @(Data.Either.Either
                              Data.Text.Internal.Text
                              (f_abhB (GHC.Types.Char, Data.Text.Internal.Text)))
                          @(f_abhB Data.Text.Internal.Text)
                          (\ (s1_abhF :: Data.Text.Internal.Text) ->
                             case Data.Text.uncons s1_abhF of {
                               GHC.Maybe.Nothing ->
                                 Data.Either.Left
                                   @Data.Text.Internal.Text
                                   @(GHC.Types.Char, Data.Text.Internal.Text)
                                   s1_abhF;
                               GHC.Maybe.Just x_abhI ->
                                 Data.Either.Right
                                   @Data.Text.Internal.Text
                                   @(GHC.Types.Char, Data.Text.Internal.Text)
                                   x_abhI
                             })
                          (let {
                             f2_abhK
                               :: Data.Text.Internal.Text -> f_abhB Data.Text.Internal.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abhK
                               = GHC.Base.pure
                                   @f_abhB $dApplicative_abhD @Data.Text.Internal.Text } in
                           let {
                             ds2_abhL
                               :: f_abhB (GHC.Types.Char, Data.Text.Internal.Text)
                                  -> f_abhB Data.Text.Internal.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 100 0}]
                             ds2_abhL
                               = GHC.Base.fmap
                                   @f_abhB
                                   (GHC.Base.$p1Applicative @f_abhB $dApplicative_abhD)
                                   @(GHC.Types.Char, Data.Text.Internal.Text)
                                   @Data.Text.Internal.Text
                                   (\ (p1_abhM :: (GHC.Types.Char, Data.Text.Internal.Text)) ->
                                      case p1_abhM of { (x_abhO, ds_abhP) ->
                                      Data.Text.cons x_abhO ds_abhP
                                      }) } in
                           \ (ds3_abhR
                                :: Data.Either.Either
                                     Data.Text.Internal.Text
                                     (f_abhB (GHC.Types.Char, Data.Text.Internal.Text))) ->
                             case ds3_abhR of {
                               Data.Either.Left x_abhT -> f2_abhK x_abhT;
                               Data.Either.Right y_abhV -> ds2_abhL y_abhV
                             }) } in
                  let {
                    g_abhX
                      :: p_abhA
                           (GHC.Types.Char, Data.Text.Internal.Text)
                           (f_abhB (GHC.Types.Char, Data.Text.Internal.Text))
                         -> p_abhA
                              (Data.Either.Either
                                 Data.Text.Internal.Text (GHC.Types.Char, Data.Text.Internal.Text))
                              (Data.Either.Either
                                 Data.Text.Internal.Text
                                 (f_abhB (GHC.Types.Char, Data.Text.Internal.Text)))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abhX
                      = Data.Profunctor.Choice.right'
                          @p_abhA
                          $dChoice_abhC
                          @(GHC.Types.Char, Data.Text.Internal.Text)
                          @(f_abhB (GHC.Types.Char, Data.Text.Internal.Text))
                          @Data.Text.Internal.Text } in
                  \ (x_abhY
                       :: p_abhA
                            (GHC.Types.Char, Data.Text.Internal.Text)
                            (f_abhB (GHC.Types.Char, Data.Text.Internal.Text))) ->
                    f1_abhE (g_abhX x_abhY))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <Data.Text.Internal.Text>_N
                                <Data.Text.Internal.Text>_N
                                <GHC.Types.Char>_N
                                <GHC.Types.Char>_N)
                       :: Control.Lens.Type.Prism
                            Data.Text.Internal.Text
                            Data.Text.Internal.Text
                            (GHC.Types.Char, Data.Text.Internal.Text)
                            (GHC.Types.Char, Data.Text.Internal.Text)
                          ~R# Control.Lens.Cons.Cons
                                Data.Text.Internal.Text
                                Data.Text.Internal.Text
                                GHC.Types.Char
                                GHC.Types.Char))
              ((\ (@(p_abfz :: * -> * -> *))
                  (@(f_abfA :: * -> *))
                  ($dChoice_abfB :: Data.Profunctor.Choice.Choice p_abfz)
                  ($dApplicative_abfC :: GHC.Base.Applicative f_abfA) ->
                  let {
                    f1_abfD
                      :: p_abfz
                           (Data.Either.Either
                              [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                           (Data.Either.Either
                              [GHC.Types.Char] (f_abfA (GHC.Types.Char, [GHC.Types.Char])))
                         -> p_abfz [GHC.Types.Char] (f_abfA [GHC.Types.Char])
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 320 0}]
                    f1_abfD
                      = Data.Profunctor.Unsafe.dimap
                          @p_abfz
                          (Data.Profunctor.Choice.$p1Choice @p_abfz $dChoice_abfB)
                          @[GHC.Types.Char]
                          @(Data.Either.Either
                              [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                          @(Data.Either.Either
                              [GHC.Types.Char] (f_abfA (GHC.Types.Char, [GHC.Types.Char])))
                          @(f_abfA [GHC.Types.Char])
                          (\ (aas_abfE :: [GHC.Types.Char]) ->
                             case aas_abfE of {
                               [] ->
                                 Data.Either.Left
                                   @[GHC.Types.Char]
                                   @(GHC.Types.Char, [GHC.Types.Char])
                                   (GHC.Types.[] @GHC.Types.Char);
                               : a1_abfG as_abfH ->
                                 Data.Either.Right
                                   @[GHC.Types.Char]
                                   @(GHC.Types.Char, [GHC.Types.Char])
                                   (a1_abfG, as_abfH)
                             })
                          (let {
                             f2_abfJ :: [GHC.Types.Char] -> f_abfA [GHC.Types.Char]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abfJ
                               = GHC.Base.pure @f_abfA $dApplicative_abfC @[GHC.Types.Char] } in
                           let {
                             ds2_abfK
                               :: f_abfA (GHC.Types.Char, [GHC.Types.Char])
                                  -> f_abfA [GHC.Types.Char]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 90 0}]
                             ds2_abfK
                               = GHC.Base.fmap
                                   @f_abfA
                                   (GHC.Base.$p1Applicative @f_abfA $dApplicative_abfC)
                                   @(GHC.Types.Char, [GHC.Types.Char])
                                   @[GHC.Types.Char]
                                   (\ (p1_abfL :: (GHC.Types.Char, [GHC.Types.Char])) ->
                                      GHC.Types.:
                                        @GHC.Types.Char
                                        (case p1_abfL of { (x_abfN, ds_abfO) -> x_abfN })
                                        (case p1_abfL of { (ds_abfR, y_abfS) -> y_abfS })) } in
                           \ (ds3_abfU
                                :: Data.Either.Either
                                     [GHC.Types.Char]
                                     (f_abfA (GHC.Types.Char, [GHC.Types.Char]))) ->
                             case ds3_abfU of {
                               Data.Either.Left x_abfW -> f2_abfJ x_abfW;
                               Data.Either.Right y_abfY -> ds2_abfK y_abfY
                             }) } in
                  let {
                    g_abg0
                      :: p_abfz
                           (GHC.Types.Char, [GHC.Types.Char])
                           (f_abfA (GHC.Types.Char, [GHC.Types.Char]))
                         -> p_abfz
                              (Data.Either.Either
                                 [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                              (Data.Either.Either
                                 [GHC.Types.Char] (f_abfA (GHC.Types.Char, [GHC.Types.Char])))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abg0
                      = Data.Profunctor.Choice.right'
                          @p_abfz
                          $dChoice_abfB
                          @(GHC.Types.Char, [GHC.Types.Char])
                          @(f_abfA (GHC.Types.Char, [GHC.Types.Char]))
                          @[GHC.Types.Char] } in
                  \ (x_abg1
                       :: p_abfz
                            (GHC.Types.Char, [GHC.Types.Char])
                            (f_abfA (GHC.Types.Char, [GHC.Types.Char]))) ->
                    f1_abfD (g_abg0 x_abg1))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <[GHC.Types.Char]>_N
                                <[GHC.Types.Char]>_N
                                <GHC.Types.Char>_N
                                <GHC.Types.Char>_N)
                       :: Control.Lens.Type.Prism
                            [GHC.Types.Char]
                            [GHC.Types.Char]
                            (GHC.Types.Char, [GHC.Types.Char])
                            (GHC.Types.Char, [GHC.Types.Char])
                          ~R# Control.Lens.Cons.Cons
                                [GHC.Types.Char] [GHC.Types.Char] GHC.Types.Char GHC.Types.Char))
              ((\ (@(p_abg6 :: * -> * -> *))
                  (@(f_abg7 :: * -> *))
                  ($dChoice_abg8 :: Data.Profunctor.Choice.Choice p_abg6)
                  ($dApplicative_abg9 :: GHC.Base.Applicative f_abg7) ->
                  let {
                    f1_abga
                      :: p_abg6
                           (Data.Either.Either [GHC.Types.Char] ())
                           (Data.Either.Either [GHC.Types.Char] (f_abg7 ()))
                         -> p_abg6 [GHC.Types.Char] (f_abg7 [GHC.Types.Char])
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 290 0}]
                    f1_abga
                      = Data.Profunctor.Unsafe.dimap
                          @p_abg6
                          (Data.Profunctor.Choice.$p1Choice @p_abg6 $dChoice_abg8)
                          @[GHC.Types.Char]
                          @(Data.Either.Either [GHC.Types.Char] ())
                          @(Data.Either.Either [GHC.Types.Char] (f_abg7 ()))
                          @(f_abg7 [GHC.Types.Char])
                          (\ (s_abgb :: [GHC.Types.Char]) ->
                             case s_abgb of wild_abgc {
                               [] -> Data.Either.Right @[GHC.Types.Char] @() GHC.Tuple.Prim.();
                               : ds1_abgd ds2_abge ->
                                 Data.Either.Left @[GHC.Types.Char] @() wild_abgc
                             })
                          (let {
                             f2_abgg :: [GHC.Types.Char] -> f_abg7 [GHC.Types.Char]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abgg
                               = GHC.Base.pure @f_abg7 $dApplicative_abg9 @[GHC.Types.Char] } in
                           let {
                             ds2_abgh :: f_abg7 () -> f_abg7 [GHC.Types.Char]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 70 0}]
                             ds2_abgh
                               = GHC.Base.fmap
                                   @f_abg7
                                   (GHC.Base.$p1Applicative @f_abg7 $dApplicative_abg9)
                                   @()
                                   @[GHC.Types.Char]
                                   (\ (ds3_abgi :: ()) ->
                                      case ds3_abgi of { () -> GHC.Types.[] @GHC.Types.Char }) } in
                           \ (ds3_abgk :: Data.Either.Either [GHC.Types.Char] (f_abg7 ())) ->
                             case ds3_abgk of {
                               Data.Either.Left x_abgm -> f2_abgg x_abgm;
                               Data.Either.Right y_abgo -> ds2_abgh y_abgo
                             }) } in
                  let {
                    g_abgq
                      :: p_abg6 () (f_abg7 ())
                         -> p_abg6
                              (Data.Either.Either [GHC.Types.Char] ())
                              (Data.Either.Either [GHC.Types.Char] (f_abg7 ()))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abgq
                      = Data.Profunctor.Choice.right'
                          @p_abg6 $dChoice_abg8 @() @(f_abg7 ()) @[GHC.Types.Char] } in
                  \ (x_abgr :: p_abg6 () (f_abg7 ())) -> f1_abga (g_abgq x_abgr))
               `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0] <[GHC.Types.Char]>_N)
                       :: Control.Lens.Type.Prism' [GHC.Types.Char] ()
                          ~R# Control.Lens.Empty.AsEmpty [GHC.Types.Char]))
              (Data.Functor.Contravariant.$fContravariantConst @[GHC.Types.Char])
              (Data.Functor.Const.$fFunctorConst @[GHC.Types.Char])
    Cont:   ApplyToVal nodup hole Control.Lens.Getter.Getting
                                    GHC.Base.String Data.Text.Internal.Text GHC.Base.String
              ((\ (ds_abe3 [Occ=Once1] :: a_abe0) -> ds_abe3)
               `cast` (<a_abe0>_R
                       %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                          <*>_N <a_abe0>_R <a_abe0>_P)
                       :: (a_abe0 -> a_abe0)
                          ~R# (a_abe0 -> Data.Functor.Const.Const a_abe0 a_abe0)))
            ApplyToVal nodup hole Data.Text.Internal.Text
                                  -> Data.Functor.Const.Const
                                       GHC.Base.String Data.Text.Internal.Text
              (Control.Lens.Getter.view
                 @[GHC.Types.Char]
                 @((->) GHC.Base.String)
                 @Data.Text.Internal.Text
                 (Control.Monad.Reader.Class.$fMonadReaderrFUN @[GHC.Types.Char])
                 (Control.Lens.Cons.Extras.recons
                    @[GHC.Types.Char]
                    @GHC.Types.Char
                    @Data.Text.Internal.Text
                    (Control.Lens.Cons.$fConsListListab
                       @GHC.Types.Char @GHC.Types.Char)
                    Control.Lens.Cons.$fConsTextTextCharChar0
                    Control.Lens.Empty.$fAsEmptyText0
                    @(Data.Functor.Const.Const Data.Text.Internal.Text)
                    (Data.Functor.Contravariant.$fContravariantConst
                       @Data.Text.Internal.Text)
                    (Data.Functor.Const.$fFunctorConst @Data.Text.Internal.Text))
                 s_a8OC)
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N <GHC.Base.String>_R <Data.Text.Internal.Text>_P
                    :: Data.Functor.Const.Const GHC.Base.String Data.Text.Internal.Text
                       ~R# GHC.Base.String)
            Stop[RuleArgCtxt] GHC.Base.String
Rule fired
    Rule: Class op fmap
    Module: (BUILTIN)
    Before: GHC.Base.fmap
              TyArg Data.Functor.Const.Const GHC.Base.String
              ValArg Data.Functor.Const.$fFunctorConst @[GHC.Types.Char]
    After:  (Data.Functor.Const.$fFunctorConst2 @[GHC.Types.Char])
            `cast` (forall (a :: <*>_N) (b :: <*>_N).
                    <a -> b>_R
                    %<'GHC.Types.Many>_N ->_R <Data.Functor.Const.Const
                                                 [GHC.Types.Char] a>_R
                    %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                  <*>_N <[GHC.Types.Char]>_R <a>_P
                                              ; Sym (Data.Functor.Const.N:Const[0]
                                                         <*>_N <[GHC.Types.Char]>_R <b>_P)
                    :: (forall {a} {b}.
                        (a -> b)
                        -> Data.Functor.Const.Const [GHC.Types.Char] a
                        -> Data.Functor.Const.Const [GHC.Types.Char] a)
                       ~R# (forall {a} {b}.
                            (a -> b)
                            -> Data.Functor.Const.Const [GHC.Types.Char] a
                            -> Data.Functor.Const.Const [GHC.Types.Char] b))
    Cont:   ApplyToTy GHC.Base.String
            ApplyToTy Data.Text.Internal.Text
            ApplyToVal nodup hole (GHC.Base.String -> Data.Text.Internal.Text)
                                  -> Data.Functor.Const.Const GHC.Base.String GHC.Base.String
                                  -> Data.Functor.Const.Const
                                       GHC.Base.String Data.Text.Internal.Text
              Data.Text.Internal.pack
            ApplyToVal nodup hole Data.Functor.Const.Const
                                    GHC.Base.String GHC.Base.String
                                  -> Data.Functor.Const.Const
                                       GHC.Base.String Data.Text.Internal.Text
              (bc_aboj (ab_aboh x_abok))
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N <GHC.Base.String>_R <Data.Text.Internal.Text>_P
                    :: Data.Functor.Const.Const GHC.Base.String Data.Text.Internal.Text
                       ~R# GHC.Base.String)
            Stop[RuleArgCtxt] GHC.Base.String
Rule fired
    Rule: Class op reader
    Module: (BUILTIN)
    Before: Control.Monad.Reader.Class.reader
              TyArg [GHC.Types.Char]
              TyArg (->) GHC.Base.String
              ValArg Control.Monad.Reader.Class.$fMonadReaderrFUN
                       @[GHC.Types.Char]
    After:  \ (@a_abe8) -> GHC.Base.id @([GHC.Types.Char] -> a_abe8)
    Cont:   ApplyToTy Data.Text.Internal.Text
            ApplyToVal nodup hole ([GHC.Types.Char] -> Data.Text.Internal.Text)
                                  -> GHC.Base.String -> Data.Text.Internal.Text
              ((l_abe2
                  ((\ (ds_abe3 [Occ=Once1] :: a_abe0) -> ds_abe3)
                   `cast` (<a_abe0>_R
                           %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                              <*>_N <a_abe0>_R <a_abe0>_P)
                           :: (a_abe0 -> a_abe0)
                              ~R# (a_abe0 -> Data.Functor.Const.Const a_abe0 a_abe0))))
               `cast` (<s_abdY>_R
                       %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                     <*>_N <a_abe0>_R <s_abdY>_P
                       :: (s_abdY -> Data.Functor.Const.Const a_abe0 s_abdY)
                          ~R# (s_abdY -> a_abe0)))
            ApplyToVal nodup hole GHC.Base.String -> Data.Text.Internal.Text
              s_a8OC
            Stop[RuleArgCtxt, !P(L,L,L)] Data.Text.Internal.Text
Rule fired
    Rule: recons/string-text
    Module: (Control.Lens.Cons.Extras)
    Before: Control.Lens.Cons.Extras.recons
              TyArg [GHC.Types.Char]
              TyArg GHC.Types.Char
              TyArg Data.Text.Internal.Text
              ValArg (\ (@(p_abfz :: * -> * -> *))
                        (@(f_abfA :: * -> *))
                        ($dChoice_abfB :: Data.Profunctor.Choice.Choice p_abfz)
                        ($dApplicative_abfC :: GHC.Base.Applicative f_abfA) ->
                        let {
                          f1_abfD
                            :: p_abfz
                                 (Data.Either.Either
                                    [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                                 (Data.Either.Either
                                    [GHC.Types.Char] (f_abfA (GHC.Types.Char, [GHC.Types.Char])))
                               -> p_abfz [GHC.Types.Char] (f_abfA [GHC.Types.Char])
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 320 0}]
                          f1_abfD
                            = Data.Profunctor.Unsafe.dimap
                                @p_abfz
                                (Data.Profunctor.Choice.$p1Choice @p_abfz $dChoice_abfB)
                                @[GHC.Types.Char]
                                @(Data.Either.Either
                                    [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                                @(Data.Either.Either
                                    [GHC.Types.Char] (f_abfA (GHC.Types.Char, [GHC.Types.Char])))
                                @(f_abfA [GHC.Types.Char])
                                (\ (aas_abfE :: [GHC.Types.Char]) ->
                                   case aas_abfE of {
                                     [] ->
                                       Data.Either.Left
                                         @[GHC.Types.Char]
                                         @(GHC.Types.Char, [GHC.Types.Char])
                                         (GHC.Types.[] @GHC.Types.Char);
                                     : a1_abfG as_abfH ->
                                       Data.Either.Right
                                         @[GHC.Types.Char]
                                         @(GHC.Types.Char, [GHC.Types.Char])
                                         (a1_abfG, as_abfH)
                                   })
                                (let {
                                   f2_abfJ :: [GHC.Types.Char] -> f_abfA [GHC.Types.Char]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abfJ
                                     = GHC.Base.pure
                                         @f_abfA $dApplicative_abfC @[GHC.Types.Char] } in
                                 let {
                                   ds2_abfK
                                     :: f_abfA (GHC.Types.Char, [GHC.Types.Char])
                                        -> f_abfA [GHC.Types.Char]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 90 0}]
                                   ds2_abfK
                                     = GHC.Base.fmap
                                         @f_abfA
                                         (GHC.Base.$p1Applicative @f_abfA $dApplicative_abfC)
                                         @(GHC.Types.Char, [GHC.Types.Char])
                                         @[GHC.Types.Char]
                                         (\ (p1_abfL :: (GHC.Types.Char, [GHC.Types.Char])) ->
                                            GHC.Types.:
                                              @GHC.Types.Char
                                              (case p1_abfL of { (x_abfN, ds_abfO) -> x_abfN })
                                              (case p1_abfL of { (ds_abfR, y_abfS) ->
                                               y_abfS
                                               })) } in
                                 \ (ds3_abfU
                                      :: Data.Either.Either
                                           [GHC.Types.Char]
                                           (f_abfA (GHC.Types.Char, [GHC.Types.Char]))) ->
                                   case ds3_abfU of {
                                     Data.Either.Left x_abfW -> f2_abfJ x_abfW;
                                     Data.Either.Right y_abfY -> ds2_abfK y_abfY
                                   }) } in
                        let {
                          g_abg0
                            :: p_abfz
                                 (GHC.Types.Char, [GHC.Types.Char])
                                 (f_abfA (GHC.Types.Char, [GHC.Types.Char]))
                               -> p_abfz
                                    (Data.Either.Either
                                       [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                                    (Data.Either.Either
                                       [GHC.Types.Char] (f_abfA (GHC.Types.Char, [GHC.Types.Char])))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abg0
                            = Data.Profunctor.Choice.right'
                                @p_abfz
                                $dChoice_abfB
                                @(GHC.Types.Char, [GHC.Types.Char])
                                @(f_abfA (GHC.Types.Char, [GHC.Types.Char]))
                                @[GHC.Types.Char] } in
                        \ (x_abg1
                             :: p_abfz
                                  (GHC.Types.Char, [GHC.Types.Char])
                                  (f_abfA (GHC.Types.Char, [GHC.Types.Char]))) ->
                          f1_abfD (g_abg0 x_abg1))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <[GHC.Types.Char]>_N
                                      <[GHC.Types.Char]>_N
                                      <GHC.Types.Char>_N
                                      <GHC.Types.Char>_N)
                             :: Control.Lens.Type.Prism
                                  [GHC.Types.Char]
                                  [GHC.Types.Char]
                                  (GHC.Types.Char, [GHC.Types.Char])
                                  (GHC.Types.Char, [GHC.Types.Char])
                                ~R# Control.Lens.Cons.Cons
                                      [GHC.Types.Char]
                                      [GHC.Types.Char]
                                      GHC.Types.Char
                                      GHC.Types.Char)
              ValArg (\ (@(p_abhA :: * -> * -> *))
                        (@(f_abhB :: * -> *))
                        ($dChoice_abhC :: Data.Profunctor.Choice.Choice p_abhA)
                        ($dApplicative_abhD :: GHC.Base.Applicative f_abhB) ->
                        let {
                          f1_abhE
                            :: p_abhA
                                 (Data.Either.Either
                                    Data.Text.Internal.Text
                                    (GHC.Types.Char, Data.Text.Internal.Text))
                                 (Data.Either.Either
                                    Data.Text.Internal.Text
                                    (f_abhB (GHC.Types.Char, Data.Text.Internal.Text)))
                               -> p_abhA Data.Text.Internal.Text (f_abhB Data.Text.Internal.Text)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 340 0}]
                          f1_abhE
                            = Data.Profunctor.Unsafe.dimap
                                @p_abhA
                                (Data.Profunctor.Choice.$p1Choice @p_abhA $dChoice_abhC)
                                @Data.Text.Internal.Text
                                @(Data.Either.Either
                                    Data.Text.Internal.Text
                                    (GHC.Types.Char, Data.Text.Internal.Text))
                                @(Data.Either.Either
                                    Data.Text.Internal.Text
                                    (f_abhB (GHC.Types.Char, Data.Text.Internal.Text)))
                                @(f_abhB Data.Text.Internal.Text)
                                (\ (s1_abhF :: Data.Text.Internal.Text) ->
                                   case Data.Text.uncons s1_abhF of {
                                     GHC.Maybe.Nothing ->
                                       Data.Either.Left
                                         @Data.Text.Internal.Text
                                         @(GHC.Types.Char, Data.Text.Internal.Text)
                                         s1_abhF;
                                     GHC.Maybe.Just x_abhI ->
                                       Data.Either.Right
                                         @Data.Text.Internal.Text
                                         @(GHC.Types.Char, Data.Text.Internal.Text)
                                         x_abhI
                                   })
                                (let {
                                   f2_abhK
                                     :: Data.Text.Internal.Text -> f_abhB Data.Text.Internal.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abhK
                                     = GHC.Base.pure
                                         @f_abhB $dApplicative_abhD @Data.Text.Internal.Text } in
                                 let {
                                   ds2_abhL
                                     :: f_abhB (GHC.Types.Char, Data.Text.Internal.Text)
                                        -> f_abhB Data.Text.Internal.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 100 0}]
                                   ds2_abhL
                                     = GHC.Base.fmap
                                         @f_abhB
                                         (GHC.Base.$p1Applicative @f_abhB $dApplicative_abhD)
                                         @(GHC.Types.Char, Data.Text.Internal.Text)
                                         @Data.Text.Internal.Text
                                         (\ (p1_abhM
                                               :: (GHC.Types.Char, Data.Text.Internal.Text)) ->
                                            case p1_abhM of { (x_abhO, ds_abhP) ->
                                            Data.Text.cons x_abhO ds_abhP
                                            }) } in
                                 \ (ds3_abhR
                                      :: Data.Either.Either
                                           Data.Text.Internal.Text
                                           (f_abhB (GHC.Types.Char, Data.Text.Internal.Text))) ->
                                   case ds3_abhR of {
                                     Data.Either.Left x_abhT -> f2_abhK x_abhT;
                                     Data.Either.Right y_abhV -> ds2_abhL y_abhV
                                   }) } in
                        let {
                          g_abhX
                            :: p_abhA
                                 (GHC.Types.Char, Data.Text.Internal.Text)
                                 (f_abhB (GHC.Types.Char, Data.Text.Internal.Text))
                               -> p_abhA
                                    (Data.Either.Either
                                       Data.Text.Internal.Text
                                       (GHC.Types.Char, Data.Text.Internal.Text))
                                    (Data.Either.Either
                                       Data.Text.Internal.Text
                                       (f_abhB (GHC.Types.Char, Data.Text.Internal.Text)))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abhX
                            = Data.Profunctor.Choice.right'
                                @p_abhA
                                $dChoice_abhC
                                @(GHC.Types.Char, Data.Text.Internal.Text)
                                @(f_abhB (GHC.Types.Char, Data.Text.Internal.Text))
                                @Data.Text.Internal.Text } in
                        \ (x_abhY
                             :: p_abhA
                                  (GHC.Types.Char, Data.Text.Internal.Text)
                                  (f_abhB (GHC.Types.Char, Data.Text.Internal.Text))) ->
                          f1_abhE (g_abhX x_abhY))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <Data.Text.Internal.Text>_N
                                      <Data.Text.Internal.Text>_N
                                      <GHC.Types.Char>_N
                                      <GHC.Types.Char>_N)
                             :: Control.Lens.Type.Prism
                                  Data.Text.Internal.Text
                                  Data.Text.Internal.Text
                                  (GHC.Types.Char, Data.Text.Internal.Text)
                                  (GHC.Types.Char, Data.Text.Internal.Text)
                                ~R# Control.Lens.Cons.Cons
                                      Data.Text.Internal.Text
                                      Data.Text.Internal.Text
                                      GHC.Types.Char
                                      GHC.Types.Char)
              ValArg (\ (@(p_abhZ :: * -> * -> *))
                        (@(f_abi0 :: * -> *))
                        ($dChoice_abi1 :: Data.Profunctor.Choice.Choice p_abhZ)
                        ($dApplicative_abi2 :: GHC.Base.Applicative f_abi0) ->
                        let {
                          f1_abi3
                            :: p_abhZ
                                 (Data.Either.Either Data.Text.Internal.Text ())
                                 (Data.Either.Either Data.Text.Internal.Text (f_abi0 ()))
                               -> p_abhZ Data.Text.Internal.Text (f_abi0 Data.Text.Internal.Text)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 310 0}]
                          f1_abi3
                            = Data.Profunctor.Unsafe.dimap
                                @p_abhZ
                                (Data.Profunctor.Choice.$p1Choice @p_abhZ $dChoice_abi1)
                                @Data.Text.Internal.Text
                                @(Data.Either.Either Data.Text.Internal.Text ())
                                @(Data.Either.Either Data.Text.Internal.Text (f_abi0 ()))
                                @(f_abi0 Data.Text.Internal.Text)
                                (\ (s_abi4 :: Data.Text.Internal.Text) ->
                                   case Data.Text.null s_abi4 of {
                                     GHC.Types.False ->
                                       Data.Either.Left @Data.Text.Internal.Text @() s_abi4;
                                     GHC.Types.True ->
                                       Data.Either.Right
                                         @Data.Text.Internal.Text @() GHC.Tuple.Prim.()
                                   })
                                (let {
                                   f2_abi7
                                     :: Data.Text.Internal.Text -> f_abi0 Data.Text.Internal.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abi7
                                     = GHC.Base.pure
                                         @f_abi0 $dApplicative_abi2 @Data.Text.Internal.Text } in
                                 let {
                                   ds2_abi8 :: f_abi0 () -> f_abi0 Data.Text.Internal.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 70 0}]
                                   ds2_abi8
                                     = GHC.Base.fmap
                                         @f_abi0
                                         (GHC.Base.$p1Applicative @f_abi0 $dApplicative_abi2)
                                         @()
                                         @Data.Text.Internal.Text
                                         (\ (ds3_abi9 :: ()) ->
                                            case ds3_abi9 of { () ->
                                            Data.Text.Internal.empty
                                            }) } in
                                 \ (ds3_abib
                                      :: Data.Either.Either Data.Text.Internal.Text (f_abi0 ())) ->
                                   case ds3_abib of {
                                     Data.Either.Left x_abid -> f2_abi7 x_abid;
                                     Data.Either.Right y_abif -> ds2_abi8 y_abif
                                   }) } in
                        let {
                          g_abih
                            :: p_abhZ () (f_abi0 ())
                               -> p_abhZ
                                    (Data.Either.Either Data.Text.Internal.Text ())
                                    (Data.Either.Either Data.Text.Internal.Text (f_abi0 ()))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abih
                            = Data.Profunctor.Choice.right'
                                @p_abhZ
                                $dChoice_abi1
                                @()
                                @(f_abi0 ())
                                @Data.Text.Internal.Text } in
                        \ (x_abii :: p_abhZ () (f_abi0 ())) -> f1_abi3 (g_abih x_abii))
                     `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                      <Data.Text.Internal.Text>_N)
                             :: Control.Lens.Type.Prism' Data.Text.Internal.Text ()
                                ~R# Control.Lens.Empty.AsEmpty Data.Text.Internal.Text)
              TyArg Data.Functor.Const.Const Data.Text.Internal.Text
              ValArg Data.Functor.Contravariant.$fContravariantConst
                       @Data.Text.Internal.Text
              ValArg Data.Functor.Const.$fFunctorConst @Data.Text.Internal.Text
    After:  (\ (@(f_abex :: * -> *))
               ($dCons_abey
                  :: Control.Lens.Cons.Cons
                       GHC.Base.String GHC.Base.String GHC.Types.Char GHC.Types.Char)
               ($dCons1_abez
                  :: Control.Lens.Cons.Cons
                       Data.Text.Internal.Text
                       Data.Text.Internal.Text
                       GHC.Types.Char
                       GHC.Types.Char)
               ($dAsEmpty_abeA
                  :: Control.Lens.Empty.AsEmpty Data.Text.Internal.Text)
               ($dContravariant_abeB
                  :: Data.Functor.Contravariant.Contravariant f_abex)
               ($dFunctor_abeC :: GHC.Base.Functor f_abex) ->
               Data.Profunctor.Unsafe.$fProfunctorFUN_$cdimap
                 @GHC.Base.String
                 @Data.Text.Internal.Text
                 @(f_abex Data.Text.Internal.Text)
                 @(f_abex GHC.Base.String)
                 Data.Text.Internal.pack
                 (GHC.Base.fmap
                    @f_abex
                    $dFunctor_abeC
                    @Data.Text.Internal.Text
                    @GHC.Base.String
                    Data.Text.Show.unpack))
              @(Data.Functor.Const.Const Data.Text.Internal.Text)
              ((\ (@(p_abfz :: * -> * -> *))
                  (@(f_abfA :: * -> *))
                  ($dChoice_abfB :: Data.Profunctor.Choice.Choice p_abfz)
                  ($dApplicative_abfC :: GHC.Base.Applicative f_abfA) ->
                  let {
                    f1_abfD
                      :: p_abfz
                           (Data.Either.Either
                              [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                           (Data.Either.Either
                              [GHC.Types.Char] (f_abfA (GHC.Types.Char, [GHC.Types.Char])))
                         -> p_abfz [GHC.Types.Char] (f_abfA [GHC.Types.Char])
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 320 0}]
                    f1_abfD
                      = Data.Profunctor.Unsafe.dimap
                          @p_abfz
                          (Data.Profunctor.Choice.$p1Choice @p_abfz $dChoice_abfB)
                          @[GHC.Types.Char]
                          @(Data.Either.Either
                              [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                          @(Data.Either.Either
                              [GHC.Types.Char] (f_abfA (GHC.Types.Char, [GHC.Types.Char])))
                          @(f_abfA [GHC.Types.Char])
                          (\ (aas_abfE :: [GHC.Types.Char]) ->
                             case aas_abfE of {
                               [] ->
                                 Data.Either.Left
                                   @[GHC.Types.Char]
                                   @(GHC.Types.Char, [GHC.Types.Char])
                                   (GHC.Types.[] @GHC.Types.Char);
                               : a1_abfG as_abfH ->
                                 Data.Either.Right
                                   @[GHC.Types.Char]
                                   @(GHC.Types.Char, [GHC.Types.Char])
                                   (a1_abfG, as_abfH)
                             })
                          (let {
                             f2_abfJ :: [GHC.Types.Char] -> f_abfA [GHC.Types.Char]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abfJ
                               = GHC.Base.pure @f_abfA $dApplicative_abfC @[GHC.Types.Char] } in
                           let {
                             ds2_abfK
                               :: f_abfA (GHC.Types.Char, [GHC.Types.Char])
                                  -> f_abfA [GHC.Types.Char]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 90 0}]
                             ds2_abfK
                               = GHC.Base.fmap
                                   @f_abfA
                                   (GHC.Base.$p1Applicative @f_abfA $dApplicative_abfC)
                                   @(GHC.Types.Char, [GHC.Types.Char])
                                   @[GHC.Types.Char]
                                   (\ (p1_abfL :: (GHC.Types.Char, [GHC.Types.Char])) ->
                                      GHC.Types.:
                                        @GHC.Types.Char
                                        (case p1_abfL of { (x_abfN, ds_abfO) -> x_abfN })
                                        (case p1_abfL of { (ds_abfR, y_abfS) -> y_abfS })) } in
                           \ (ds3_abfU
                                :: Data.Either.Either
                                     [GHC.Types.Char]
                                     (f_abfA (GHC.Types.Char, [GHC.Types.Char]))) ->
                             case ds3_abfU of {
                               Data.Either.Left x_abfW -> f2_abfJ x_abfW;
                               Data.Either.Right y_abfY -> ds2_abfK y_abfY
                             }) } in
                  let {
                    g_abg0
                      :: p_abfz
                           (GHC.Types.Char, [GHC.Types.Char])
                           (f_abfA (GHC.Types.Char, [GHC.Types.Char]))
                         -> p_abfz
                              (Data.Either.Either
                                 [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                              (Data.Either.Either
                                 [GHC.Types.Char] (f_abfA (GHC.Types.Char, [GHC.Types.Char])))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abg0
                      = Data.Profunctor.Choice.right'
                          @p_abfz
                          $dChoice_abfB
                          @(GHC.Types.Char, [GHC.Types.Char])
                          @(f_abfA (GHC.Types.Char, [GHC.Types.Char]))
                          @[GHC.Types.Char] } in
                  \ (x_abg1
                       :: p_abfz
                            (GHC.Types.Char, [GHC.Types.Char])
                            (f_abfA (GHC.Types.Char, [GHC.Types.Char]))) ->
                    f1_abfD (g_abg0 x_abg1))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <[GHC.Types.Char]>_N
                                <[GHC.Types.Char]>_N
                                <GHC.Types.Char>_N
                                <GHC.Types.Char>_N)
                       :: Control.Lens.Type.Prism
                            [GHC.Types.Char]
                            [GHC.Types.Char]
                            (GHC.Types.Char, [GHC.Types.Char])
                            (GHC.Types.Char, [GHC.Types.Char])
                          ~R# Control.Lens.Cons.Cons
                                [GHC.Types.Char] [GHC.Types.Char] GHC.Types.Char GHC.Types.Char))
              ((\ (@(p_abhA :: * -> * -> *))
                  (@(f_abhB :: * -> *))
                  ($dChoice_abhC :: Data.Profunctor.Choice.Choice p_abhA)
                  ($dApplicative_abhD :: GHC.Base.Applicative f_abhB) ->
                  let {
                    f1_abhE
                      :: p_abhA
                           (Data.Either.Either
                              Data.Text.Internal.Text (GHC.Types.Char, Data.Text.Internal.Text))
                           (Data.Either.Either
                              Data.Text.Internal.Text
                              (f_abhB (GHC.Types.Char, Data.Text.Internal.Text)))
                         -> p_abhA Data.Text.Internal.Text (f_abhB Data.Text.Internal.Text)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 340 0}]
                    f1_abhE
                      = Data.Profunctor.Unsafe.dimap
                          @p_abhA
                          (Data.Profunctor.Choice.$p1Choice @p_abhA $dChoice_abhC)
                          @Data.Text.Internal.Text
                          @(Data.Either.Either
                              Data.Text.Internal.Text (GHC.Types.Char, Data.Text.Internal.Text))
                          @(Data.Either.Either
                              Data.Text.Internal.Text
                              (f_abhB (GHC.Types.Char, Data.Text.Internal.Text)))
                          @(f_abhB Data.Text.Internal.Text)
                          (\ (s1_abhF :: Data.Text.Internal.Text) ->
                             case Data.Text.uncons s1_abhF of {
                               GHC.Maybe.Nothing ->
                                 Data.Either.Left
                                   @Data.Text.Internal.Text
                                   @(GHC.Types.Char, Data.Text.Internal.Text)
                                   s1_abhF;
                               GHC.Maybe.Just x_abhI ->
                                 Data.Either.Right
                                   @Data.Text.Internal.Text
                                   @(GHC.Types.Char, Data.Text.Internal.Text)
                                   x_abhI
                             })
                          (let {
                             f2_abhK
                               :: Data.Text.Internal.Text -> f_abhB Data.Text.Internal.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abhK
                               = GHC.Base.pure
                                   @f_abhB $dApplicative_abhD @Data.Text.Internal.Text } in
                           let {
                             ds2_abhL
                               :: f_abhB (GHC.Types.Char, Data.Text.Internal.Text)
                                  -> f_abhB Data.Text.Internal.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 100 0}]
                             ds2_abhL
                               = GHC.Base.fmap
                                   @f_abhB
                                   (GHC.Base.$p1Applicative @f_abhB $dApplicative_abhD)
                                   @(GHC.Types.Char, Data.Text.Internal.Text)
                                   @Data.Text.Internal.Text
                                   (\ (p1_abhM :: (GHC.Types.Char, Data.Text.Internal.Text)) ->
                                      case p1_abhM of { (x_abhO, ds_abhP) ->
                                      Data.Text.cons x_abhO ds_abhP
                                      }) } in
                           \ (ds3_abhR
                                :: Data.Either.Either
                                     Data.Text.Internal.Text
                                     (f_abhB (GHC.Types.Char, Data.Text.Internal.Text))) ->
                             case ds3_abhR of {
                               Data.Either.Left x_abhT -> f2_abhK x_abhT;
                               Data.Either.Right y_abhV -> ds2_abhL y_abhV
                             }) } in
                  let {
                    g_abhX
                      :: p_abhA
                           (GHC.Types.Char, Data.Text.Internal.Text)
                           (f_abhB (GHC.Types.Char, Data.Text.Internal.Text))
                         -> p_abhA
                              (Data.Either.Either
                                 Data.Text.Internal.Text (GHC.Types.Char, Data.Text.Internal.Text))
                              (Data.Either.Either
                                 Data.Text.Internal.Text
                                 (f_abhB (GHC.Types.Char, Data.Text.Internal.Text)))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abhX
                      = Data.Profunctor.Choice.right'
                          @p_abhA
                          $dChoice_abhC
                          @(GHC.Types.Char, Data.Text.Internal.Text)
                          @(f_abhB (GHC.Types.Char, Data.Text.Internal.Text))
                          @Data.Text.Internal.Text } in
                  \ (x_abhY
                       :: p_abhA
                            (GHC.Types.Char, Data.Text.Internal.Text)
                            (f_abhB (GHC.Types.Char, Data.Text.Internal.Text))) ->
                    f1_abhE (g_abhX x_abhY))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <Data.Text.Internal.Text>_N
                                <Data.Text.Internal.Text>_N
                                <GHC.Types.Char>_N
                                <GHC.Types.Char>_N)
                       :: Control.Lens.Type.Prism
                            Data.Text.Internal.Text
                            Data.Text.Internal.Text
                            (GHC.Types.Char, Data.Text.Internal.Text)
                            (GHC.Types.Char, Data.Text.Internal.Text)
                          ~R# Control.Lens.Cons.Cons
                                Data.Text.Internal.Text
                                Data.Text.Internal.Text
                                GHC.Types.Char
                                GHC.Types.Char))
              ((\ (@(p_abhZ :: * -> * -> *))
                  (@(f_abi0 :: * -> *))
                  ($dChoice_abi1 :: Data.Profunctor.Choice.Choice p_abhZ)
                  ($dApplicative_abi2 :: GHC.Base.Applicative f_abi0) ->
                  let {
                    f1_abi3
                      :: p_abhZ
                           (Data.Either.Either Data.Text.Internal.Text ())
                           (Data.Either.Either Data.Text.Internal.Text (f_abi0 ()))
                         -> p_abhZ Data.Text.Internal.Text (f_abi0 Data.Text.Internal.Text)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 310 0}]
                    f1_abi3
                      = Data.Profunctor.Unsafe.dimap
                          @p_abhZ
                          (Data.Profunctor.Choice.$p1Choice @p_abhZ $dChoice_abi1)
                          @Data.Text.Internal.Text
                          @(Data.Either.Either Data.Text.Internal.Text ())
                          @(Data.Either.Either Data.Text.Internal.Text (f_abi0 ()))
                          @(f_abi0 Data.Text.Internal.Text)
                          (\ (s_abi4 :: Data.Text.Internal.Text) ->
                             case Data.Text.null s_abi4 of {
                               GHC.Types.False ->
                                 Data.Either.Left @Data.Text.Internal.Text @() s_abi4;
                               GHC.Types.True ->
                                 Data.Either.Right @Data.Text.Internal.Text @() GHC.Tuple.Prim.()
                             })
                          (let {
                             f2_abi7
                               :: Data.Text.Internal.Text -> f_abi0 Data.Text.Internal.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abi7
                               = GHC.Base.pure
                                   @f_abi0 $dApplicative_abi2 @Data.Text.Internal.Text } in
                           let {
                             ds2_abi8 :: f_abi0 () -> f_abi0 Data.Text.Internal.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 70 0}]
                             ds2_abi8
                               = GHC.Base.fmap
                                   @f_abi0
                                   (GHC.Base.$p1Applicative @f_abi0 $dApplicative_abi2)
                                   @()
                                   @Data.Text.Internal.Text
                                   (\ (ds3_abi9 :: ()) ->
                                      case ds3_abi9 of { () -> Data.Text.Internal.empty }) } in
                           \ (ds3_abib
                                :: Data.Either.Either Data.Text.Internal.Text (f_abi0 ())) ->
                             case ds3_abib of {
                               Data.Either.Left x_abid -> f2_abi7 x_abid;
                               Data.Either.Right y_abif -> ds2_abi8 y_abif
                             }) } in
                  let {
                    g_abih
                      :: p_abhZ () (f_abi0 ())
                         -> p_abhZ
                              (Data.Either.Either Data.Text.Internal.Text ())
                              (Data.Either.Either Data.Text.Internal.Text (f_abi0 ()))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abih
                      = Data.Profunctor.Choice.right'
                          @p_abhZ
                          $dChoice_abi1
                          @()
                          @(f_abi0 ())
                          @Data.Text.Internal.Text } in
                  \ (x_abii :: p_abhZ () (f_abi0 ())) -> f1_abi3 (g_abih x_abii))
               `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                <Data.Text.Internal.Text>_N)
                       :: Control.Lens.Type.Prism' Data.Text.Internal.Text ()
                          ~R# Control.Lens.Empty.AsEmpty Data.Text.Internal.Text))
              (Data.Functor.Contravariant.$fContravariantConst
                 @Data.Text.Internal.Text)
              (Data.Functor.Const.$fFunctorConst @Data.Text.Internal.Text)
    Cont:   ApplyToVal nodup hole Control.Lens.Getter.Getting
                                    Data.Text.Internal.Text [GHC.Types.Char] Data.Text.Internal.Text
              ((\ (ds_abe3 [Occ=Once1] :: a_abe0) -> ds_abe3)
               `cast` (<a_abe0>_R
                       %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                          <*>_N <a_abe0>_R <a_abe0>_P)
                       :: (a_abe0 -> a_abe0)
                          ~R# (a_abe0 -> Data.Functor.Const.Const a_abe0 a_abe0)))
            ApplyToVal nodup hole [GHC.Types.Char]
                                  -> Data.Functor.Const.Const
                                       Data.Text.Internal.Text [GHC.Types.Char]
              s_a8OC
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N <Data.Text.Internal.Text>_R <[GHC.Types.Char]>_P
                    :: Data.Functor.Const.Const
                         Data.Text.Internal.Text [GHC.Types.Char]
                       ~R# Data.Text.Internal.Text)
            Stop[RuleArgCtxt, !P(L,L,L)] Data.Text.Internal.Text
Rule fired
    Rule: Class op fmap
    Module: (BUILTIN)
    Before: GHC.Base.fmap
              TyArg Data.Functor.Const.Const Data.Text.Internal.Text
              ValArg Data.Functor.Const.$fFunctorConst @Data.Text.Internal.Text
    After:  (Data.Functor.Const.$fFunctorConst2
               @Data.Text.Internal.Text)
            `cast` (forall (a :: <*>_N) (b :: <*>_N).
                    <a -> b>_R
                    %<'GHC.Types.Many>_N ->_R <Data.Functor.Const.Const
                                                 Data.Text.Internal.Text a>_R
                    %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                  <*>_N <Data.Text.Internal.Text>_R <a>_P
                                              ; Sym (Data.Functor.Const.N:Const[0]
                                                         <*>_N <Data.Text.Internal.Text>_R <b>_P)
                    :: (forall {a} {b}.
                        (a -> b)
                        -> Data.Functor.Const.Const Data.Text.Internal.Text a
                        -> Data.Functor.Const.Const Data.Text.Internal.Text a)
                       ~R# (forall {a} {b}.
                            (a -> b)
                            -> Data.Functor.Const.Const Data.Text.Internal.Text a
                            -> Data.Functor.Const.Const Data.Text.Internal.Text b))
    Cont:   ApplyToTy Data.Text.Internal.Text
            ApplyToTy GHC.Base.String
            ApplyToVal nodup hole (Data.Text.Internal.Text -> GHC.Base.String)
                                  -> Data.Functor.Const.Const
                                       Data.Text.Internal.Text Data.Text.Internal.Text
                                  -> Data.Functor.Const.Const
                                       Data.Text.Internal.Text GHC.Base.String
              Data.Text.Show.unpack
            ApplyToVal nodup hole Data.Functor.Const.Const
                                    Data.Text.Internal.Text Data.Text.Internal.Text
                                  -> Data.Functor.Const.Const
                                       Data.Text.Internal.Text GHC.Base.String
              (bc_aboj (ab_aboh x_abok))
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N <Data.Text.Internal.Text>_R <[GHC.Types.Char]>_P
                    :: Data.Functor.Const.Const
                         Data.Text.Internal.Text [GHC.Types.Char]
                       ~R# Data.Text.Internal.Text)
            Stop[RuleArgCtxt, !P(L,L,L)] Data.Text.Internal.Text
Rule fired
    Rule: eqString
    Module: (GHC.Base)
    Before: GHC.Classes.==
              TyArg GHC.Base.String
              ValArg GHC.Classes.$fEqList_$s$fEqList1
              ValArg Data.Text.Show.unpack (Data.Text.Internal.pack s_a8OC)
              ValArg s_a8OC
    After:  (\ ($dEq_aaZD :: GHC.Classes.Eq GHC.Base.String) ->
               GHC.Base.eqString)
              GHC.Classes.$fEqList_$s$fEqList1
              ValArg Data.Text.Show.unpack (Data.Text.Internal.pack s_a8OC)
              ValArg s_a8OC
    Cont:   Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: unpack
    Module: (GHC.Base)
    Before: GHC.CString.unpackCString# ValArg "Str -> TL -> Str"#
    After:  (\ (a_ab6H :: GHC.Prim.Addr#) ->
               GHC.Base.build
                 @GHC.Types.Char
                 (\ (@b_ab6I) -> GHC.CString.unpackFoldrCString# @b_ab6I a_ab6H))
              "Str -> TL -> Str"#
    Cont:   Stop[BoringCtxt] Test.Tasty.Core.TestName
Rule fired
    Rule: Class op property
    Module: (BUILTIN)
    Before: Test.QuickCheck.Property.property
              TyArg GHC.Base.String -> GHC.Types.Bool ValArg $dTestable_a91r
    After:  Test.QuickCheck.Property.$fTestableFUN_$cproperty
              @[GHC.Types.Char]
              @GHC.Types.Bool
              $dArbitrary_a9IP
              GHC.Show.$fShowList_$s$fShowList1
              Test.QuickCheck.Property.$fTestableBool
    Cont:   ApplyToVal nodup hole (GHC.Base.String -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              prop_ab6U
            CastIt (Sym (Test.Tasty.QuickCheck.N:QC[0])
                    :: Test.QuickCheck.Property.Property ~R# Test.Tasty.QuickCheck.QC)
            Stop[BoringCtxt] Test.Tasty.QuickCheck.QC
Rule fired
    Rule: Class op propertyForAllShrinkShow
    Module: (BUILTIN)
    Before: Test.QuickCheck.Property.propertyForAllShrinkShow
              TyArg GHC.Types.Bool ValArg Test.QuickCheck.Property.$fTestableBool
    After:  Test.QuickCheck.Property.$fTestableBool1
            `cast` (forall (a :: <*>_N).
                    <Test.QuickCheck.Gen.Gen a>_R
                    %<'GHC.Types.Many>_N ->_R <a -> [a]>_R
                    %<'GHC.Types.Many>_N ->_R <a -> [GHC.Base.String]>_R
                    %<'GHC.Types.Many>_N ->_R <a -> GHC.Types.Bool>_R
                    %<'GHC.Types.Many>_N ->_R Sym (Test.QuickCheck.Gen.N:Gen[0]
                                                       (Test.QuickCheck.Property.N:Prop[0]))
                                              ; Sym (Test.QuickCheck.Property.N:Property[0])
                    :: (forall {a}.
                        Test.QuickCheck.Gen.Gen a
                        -> (a -> [a])
                        -> (a -> [GHC.Base.String])
                        -> (a -> GHC.Types.Bool)
                        -> Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int
                        -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result)
                       ~R# (forall {a}.
                            Test.QuickCheck.Gen.Gen a
                            -> (a -> [a])
                            -> (a -> [GHC.Base.String])
                            -> (a -> GHC.Types.Bool)
                            -> Test.QuickCheck.Property.Property))
    Cont:   ApplyToTy [GHC.Types.Char]
            ApplyToVal nodup hole Test.QuickCheck.Gen.Gen [GHC.Types.Char]
                                  -> ([GHC.Types.Char] -> [[GHC.Types.Char]])
                                  -> ([GHC.Types.Char] -> [GHC.Base.String])
                                  -> ([GHC.Types.Char] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (Test.QuickCheck.Arbitrary.arbitrary @a_ab8C $dArbitrary_ab8E)
            ApplyToVal nodup hole ([GHC.Types.Char] -> [[GHC.Types.Char]])
                                  -> ([GHC.Types.Char] -> [GHC.Base.String])
                                  -> ([GHC.Types.Char] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (Test.QuickCheck.Arbitrary.shrink @a_ab8C $dArbitrary_ab8E)
            ApplyToVal nodup hole ([GHC.Types.Char] -> [GHC.Base.String])
                                  -> ([GHC.Types.Char] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (let {
                 g_ab8I [Occ=OnceL1!] :: a_ab8C -> GHC.Base.String
                 [LclId]
                 g_ab8I = GHC.Show.show @a_ab8C $dShow_ab8F } in
               \ (x_ab8J [Occ=Once1] :: a_ab8C) ->
                 GHC.Types.:
                   @GHC.Base.String (g_ab8I x_ab8J) (GHC.Types.[] @GHC.Base.String))
            ApplyToVal nodup hole ([GHC.Types.Char] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              f_ab8H
            CastIt (Sym (Test.Tasty.QuickCheck.N:QC[0])
                    :: Test.QuickCheck.Property.Property ~R# Test.Tasty.QuickCheck.QC)
            Stop[BoringCtxt] Test.Tasty.QuickCheck.QC
Rule fired
    Rule: Class op arbitrary
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.arbitrary
              TyArg [GHC.Types.Char] ValArg $dArbitrary_a9IP
    After:  (Test.QuickCheck.Arbitrary.$fArbitraryList1
               @GHC.Types.Char Test.QuickCheck.Arbitrary.$fArbitraryChar)
            `cast` (Sym (Test.QuickCheck.Gen.N:Gen[0] <[GHC.Types.Char]>_R)
                    :: (Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int -> [GHC.Types.Char])
                       ~R# Test.QuickCheck.Gen.Gen [GHC.Types.Char])
    Cont:   Stop[BoringCtxt] Test.QuickCheck.Gen.Gen [GHC.Types.Char]
Rule fired
    Rule: Class op arbitrary
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.arbitrary
              TyArg GHC.Types.Char
              ValArg Test.QuickCheck.Arbitrary.$fArbitraryChar
    After:  Test.QuickCheck.Arbitrary.$fArbitraryChar_$carbitrary
    Cont:   Stop[BoringCtxt, C(S,C(1,L))] Test.QuickCheck.Gen.Gen
                                            GHC.Types.Char
Rule fired
    Rule: Class op shrink
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.shrink
              TyArg [GHC.Types.Char] ValArg $dArbitrary_a9IP
    After:  Test.QuickCheck.Arbitrary.$fArbitraryList_$cshrink
              @GHC.Types.Char Test.QuickCheck.Arbitrary.$fArbitraryChar
    Cont:   Stop[BoringCtxt] [GHC.Types.Char] -> [[GHC.Types.Char]]
Rule fired
    Rule: Class op shrink
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.shrink
              TyArg GHC.Types.Char
              ValArg Test.QuickCheck.Arbitrary.$fArbitraryChar
    After:  Test.QuickCheck.Arbitrary.$fArbitraryChar_$cshrink
    Cont:   Stop[DiscArgCtxt, C(S,L)] GHC.Types.Char
                                      -> [GHC.Types.Char]
Rule fired
    Rule: Class op show
    Module: (BUILTIN)
    Before: GHC.Show.show
              TyArg [GHC.Types.Char] ValArg GHC.Show.$fShowList_$s$fShowList1
    After:  GHC.Show.$fShowList_$s$cshow1
    Cont:   Stop[RhsCtxt(NonRecursive)] [GHC.Types.Char]
                                        -> GHC.Base.String
Rule fired
    Rule: Class op reader
    Module: (BUILTIN)
    Before: Control.Monad.Reader.Class.reader
              TyArg Data.Text.Internal.Lazy.Text
              TyArg (->) Data.Text.Internal.Lazy.Text
              ValArg Control.Monad.Reader.Class.$fMonadReaderrFUN
                       @Data.Text.Internal.Lazy.Text
    After:  \ (@a_abe8) ->
              GHC.Base.id @(Data.Text.Internal.Lazy.Text -> a_abe8)
    Cont:   ApplyToTy GHC.Base.String
            ApplyToVal nodup hole (Data.Text.Internal.Lazy.Text
                                   -> GHC.Base.String)
                                  -> Data.Text.Internal.Lazy.Text -> GHC.Base.String
              ((l_abe2
                  ((\ (ds_abe3 [Occ=Once1] :: a_abe0) -> ds_abe3)
                   `cast` (<a_abe0>_R
                           %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                              <*>_N <a_abe0>_R <a_abe0>_P)
                           :: (a_abe0 -> a_abe0)
                              ~R# (a_abe0 -> Data.Functor.Const.Const a_abe0 a_abe0))))
               `cast` (<s_abdY>_R
                       %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                     <*>_N <a_abe0>_R <s_abdY>_P
                       :: (s_abdY -> Data.Functor.Const.Const a_abe0 s_abdY)
                          ~R# (s_abdY -> a_abe0)))
            ApplyToVal nodup hole Data.Text.Internal.Lazy.Text
                                  -> GHC.Base.String
              (Control.Lens.Getter.view
                 @[GHC.Types.Char]
                 @((->) GHC.Base.String)
                 @Data.Text.Internal.Lazy.Text
                 (Control.Monad.Reader.Class.$fMonadReaderrFUN @[GHC.Types.Char])
                 (Control.Lens.Cons.Extras.recons
                    @[GHC.Types.Char]
                    @GHC.Types.Char
                    @Data.Text.Internal.Lazy.Text
                    (Control.Lens.Cons.$fConsListListab
                       @GHC.Types.Char @GHC.Types.Char)
                    Control.Lens.Cons.$fConsTextTextCharChar
                    Control.Lens.Empty.$fAsEmptyText
                    @(Data.Functor.Const.Const Data.Text.Internal.Lazy.Text)
                    (Data.Functor.Contravariant.$fContravariantConst
                       @Data.Text.Internal.Lazy.Text)
                    (Data.Functor.Const.$fFunctorConst @Data.Text.Internal.Lazy.Text))
                 s_a8OD)
            Stop[RuleArgCtxt] GHC.Base.String
Rule fired
    Rule: recons/lazytext-string
    Module: (Control.Lens.Cons.Extras)
    Before: Control.Lens.Cons.Extras.recons
              TyArg Data.Text.Internal.Lazy.Text
              TyArg GHC.Types.Char
              TyArg GHC.Base.String
              ValArg (\ (@(p_abip :: * -> * -> *))
                        (@(f_abiq :: * -> *))
                        ($dChoice_abir :: Data.Profunctor.Choice.Choice p_abip)
                        ($dApplicative_abis :: GHC.Base.Applicative f_abiq) ->
                        let {
                          f1_abit
                            :: p_abip
                                 (Data.Either.Either
                                    Data.Text.Internal.Lazy.Text
                                    (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                                 (Data.Either.Either
                                    Data.Text.Internal.Lazy.Text
                                    (f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                               -> p_abip
                                    Data.Text.Internal.Lazy.Text
                                    (f_abiq Data.Text.Internal.Lazy.Text)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 639 0}]
                          f1_abit
                            = Data.Profunctor.Unsafe.dimap
                                @p_abip
                                (Data.Profunctor.Choice.$p1Choice @p_abip $dChoice_abir)
                                @Data.Text.Internal.Lazy.Text
                                @(Data.Either.Either
                                    Data.Text.Internal.Lazy.Text
                                    (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                                @(Data.Either.Either
                                    Data.Text.Internal.Lazy.Text
                                    (f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                                @(f_abiq Data.Text.Internal.Lazy.Text)
                                (\ (s1_abiu :: Data.Text.Internal.Lazy.Text) ->
                                   case s1_abiu of {
                                     Data.Text.Internal.Lazy.Empty ->
                                       Data.Either.Left
                                         @Data.Text.Internal.Lazy.Text
                                         @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                         Data.Text.Internal.Lazy.Empty;
                                     Data.Text.Internal.Lazy.Chunk bx_abiB bx1_abiC bx2_abiD
                                                                   ts_abiE ->
                                       Data.Either.Right
                                         @Data.Text.Internal.Lazy.Text
                                         @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                         (case GHC.Prim.indexWord8Array# bx_abiB bx1_abiC of r#_abiG
                                          { __DEFAULT ->
                                          let {
                                            c#_abiH :: GHC.Prim.Int#
                                            [LclId,
                                             Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                     Value=False, ConLike=False, WorkFree=False,
                                                     Expandable=False,
                                                     Guidance=IF_ARGS [] 4 0}]
                                            c#_abiH
                                              = GHC.Prim.word2Int#
                                                  (GHC.Prim.clz8#
                                                     (GHC.Prim.and#
                                                        (GHC.Prim.not#
                                                           (GHC.Prim.word8ToWord# r#_abiG))
                                                        255##)) } in
                                          case GHC.Prim.xorI# c#_abiH (GHC.Prim.<=# c#_abiH 0#) of {
                                            __DEFAULT ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abiB (GHC.Prim.+# bx1_abiC 1#)
                                              of r#1_abiJ
                                              { __DEFAULT ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abiB (GHC.Prim.+# bx1_abiC 2#)
                                              of r#2_abiK
                                              { __DEFAULT ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abiB (GHC.Prim.+# bx1_abiC 3#)
                                              of r#3_abiL
                                              { __DEFAULT ->
                                              GHC.Types.C#
                                                (GHC.Prim.chr#
                                                   (GHC.Prim.-#
                                                      (GHC.Prim.+#
                                                         (GHC.Prim.+#
                                                            (GHC.Prim.+#
                                                               (GHC.Prim.uncheckedIShiftL#
                                                                  (GHC.Prim.-#
                                                                     (GHC.Prim.word2Int#
                                                                        (GHC.Prim.word8ToWord#
                                                                           r#_abiG))
                                                                     240#)
                                                                  18#)
                                                               (GHC.Prim.uncheckedIShiftL#
                                                                  (GHC.Prim.-#
                                                                     (GHC.Prim.word2Int#
                                                                        (GHC.Prim.word8ToWord#
                                                                           r#1_abiJ))
                                                                     128#)
                                                                  12#))
                                                            (GHC.Prim.uncheckedIShiftL#
                                                               (GHC.Prim.-#
                                                                  (GHC.Prim.word2Int#
                                                                     (GHC.Prim.word8ToWord#
                                                                        r#2_abiK))
                                                                  128#)
                                                               6#))
                                                         (GHC.Prim.word2Int#
                                                            (GHC.Prim.word8ToWord# r#3_abiL)))
                                                      128#))
                                              }
                                              }
                                              };
                                            1# ->
                                              GHC.Types.C#
                                                (GHC.Prim.chr#
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.word8ToWord# r#_abiG)));
                                            2# ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abiB (GHC.Prim.+# bx1_abiC 1#)
                                              of r#1_abiM
                                              { __DEFAULT ->
                                              GHC.Types.C#
                                                (GHC.Prim.chr#
                                                   (GHC.Prim.-#
                                                      (GHC.Prim.+#
                                                         (GHC.Prim.uncheckedIShiftL#
                                                            (GHC.Prim.-#
                                                               (GHC.Prim.word2Int#
                                                                  (GHC.Prim.word8ToWord# r#_abiG))
                                                               192#)
                                                            6#)
                                                         (GHC.Prim.word2Int#
                                                            (GHC.Prim.word8ToWord# r#1_abiM)))
                                                      128#))
                                              };
                                            3# ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abiB (GHC.Prim.+# bx1_abiC 1#)
                                              of r#1_abiN
                                              { __DEFAULT ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abiB (GHC.Prim.+# bx1_abiC 2#)
                                              of r#2_abiO
                                              { __DEFAULT ->
                                              GHC.Types.C#
                                                (GHC.Prim.chr#
                                                   (GHC.Prim.-#
                                                      (GHC.Prim.+#
                                                         (GHC.Prim.+#
                                                            (GHC.Prim.uncheckedIShiftL#
                                                               (GHC.Prim.-#
                                                                  (GHC.Prim.word2Int#
                                                                     (GHC.Prim.word8ToWord#
                                                                        r#_abiG))
                                                                  224#)
                                                               12#)
                                                            (GHC.Prim.uncheckedIShiftL#
                                                               (GHC.Prim.-#
                                                                  (GHC.Prim.word2Int#
                                                                     (GHC.Prim.word8ToWord#
                                                                        r#1_abiN))
                                                                  128#)
                                                               6#))
                                                         (GHC.Prim.word2Int#
                                                            (GHC.Prim.word8ToWord# r#2_abiO)))
                                                      128#))
                                              }
                                              }
                                          }
                                          },
                                          case Data.Text.compareLength
                                                 (Data.Text.Internal.Text bx_abiB bx1_abiC bx2_abiD)
                                                 (GHC.Types.I# 1#)
                                          of {
                                            __DEFAULT ->
                                              case GHC.Prim.indexWord8Array# bx_abiB bx1_abiC
                                              of r#_abiQ
                                              { __DEFAULT ->
                                              let {
                                                c#_abiR :: GHC.Prim.Int#
                                                [LclId,
                                                 Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                         Value=False, ConLike=False, WorkFree=False,
                                                         Expandable=False,
                                                         Guidance=IF_ARGS [] 4 0}]
                                                c#_abiR
                                                  = GHC.Prim.word2Int#
                                                      (GHC.Prim.clz8#
                                                         (GHC.Prim.and#
                                                            (GHC.Prim.not#
                                                               (GHC.Prim.word8ToWord# r#_abiQ))
                                                            255##)) } in
                                              let {
                                                y_abiS :: GHC.Prim.Int#
                                                [LclId,
                                                 Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                         Value=False, ConLike=False, WorkFree=False,
                                                         Expandable=False,
                                                         Guidance=IF_ARGS [] 2 0}]
                                                y_abiS
                                                  = GHC.Prim.xorI#
                                                      c#_abiR (GHC.Prim.<=# c#_abiR 0#) } in
                                              Data.Text.Internal.Lazy.$WChunk
                                                (Data.Text.Internal.$WText
                                                   (Data.Text.Array.ByteArray bx_abiB)
                                                   (GHC.Types.I# (GHC.Prim.+# bx1_abiC y_abiS))
                                                   (GHC.Types.I# (GHC.Prim.-# bx2_abiD y_abiS)))
                                                ts_abiE
                                              };
                                            GHC.Types.EQ -> ts_abiE
                                          })
                                   })
                                (let {
                                   f2_abiU
                                     :: Data.Text.Internal.Lazy.Text
                                        -> f_abiq Data.Text.Internal.Lazy.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abiU
                                     = GHC.Base.pure
                                         @f_abiq
                                         $dApplicative_abis
                                         @Data.Text.Internal.Lazy.Text } in
                                 let {
                                   ds2_abiV
                                     :: f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                        -> f_abiq Data.Text.Internal.Lazy.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 100 0}]
                                   ds2_abiV
                                     = GHC.Base.fmap
                                         @f_abiq
                                         (GHC.Base.$p1Applicative @f_abiq $dApplicative_abis)
                                         @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                         @Data.Text.Internal.Lazy.Text
                                         (\ (p1_abiW
                                               :: (GHC.Types.Char, Data.Text.Internal.Lazy.Text)) ->
                                            case p1_abiW of { (x_abiY, ds_abiZ) ->
                                            Data.Text.Lazy.cons x_abiY ds_abiZ
                                            }) } in
                                 \ (ds3_abj1
                                      :: Data.Either.Either
                                           Data.Text.Internal.Lazy.Text
                                           (f_abiq
                                              (GHC.Types.Char, Data.Text.Internal.Lazy.Text))) ->
                                   case ds3_abj1 of {
                                     Data.Either.Left x_abj3 -> f2_abiU x_abj3;
                                     Data.Either.Right y_abj5 -> ds2_abiV y_abj5
                                   }) } in
                        let {
                          g_abj7
                            :: p_abip
                                 (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                 (f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                               -> p_abip
                                    (Data.Either.Either
                                       Data.Text.Internal.Lazy.Text
                                       (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                                    (Data.Either.Either
                                       Data.Text.Internal.Lazy.Text
                                       (f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abj7
                            = Data.Profunctor.Choice.right'
                                @p_abip
                                $dChoice_abir
                                @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                @(f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                                @Data.Text.Internal.Lazy.Text } in
                        \ (x_abj8
                             :: p_abip
                                  (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                  (f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text))) ->
                          f1_abit (g_abj7 x_abj8))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <Data.Text.Internal.Lazy.Text>_N
                                      <Data.Text.Internal.Lazy.Text>_N
                                      <GHC.Types.Char>_N
                                      <GHC.Types.Char>_N)
                             :: Control.Lens.Type.Prism
                                  Data.Text.Internal.Lazy.Text
                                  Data.Text.Internal.Lazy.Text
                                  (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                  (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                ~R# Control.Lens.Cons.Cons
                                      Data.Text.Internal.Lazy.Text
                                      Data.Text.Internal.Lazy.Text
                                      GHC.Types.Char
                                      GHC.Types.Char)
              ValArg (\ (@(p_abfz :: * -> * -> *))
                        (@(f_abfA :: * -> *))
                        ($dChoice_abfB :: Data.Profunctor.Choice.Choice p_abfz)
                        ($dApplicative_abfC :: GHC.Base.Applicative f_abfA) ->
                        let {
                          f1_abfD
                            :: p_abfz
                                 (Data.Either.Either
                                    [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                                 (Data.Either.Either
                                    [GHC.Types.Char] (f_abfA (GHC.Types.Char, [GHC.Types.Char])))
                               -> p_abfz [GHC.Types.Char] (f_abfA [GHC.Types.Char])
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 320 0}]
                          f1_abfD
                            = Data.Profunctor.Unsafe.dimap
                                @p_abfz
                                (Data.Profunctor.Choice.$p1Choice @p_abfz $dChoice_abfB)
                                @[GHC.Types.Char]
                                @(Data.Either.Either
                                    [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                                @(Data.Either.Either
                                    [GHC.Types.Char] (f_abfA (GHC.Types.Char, [GHC.Types.Char])))
                                @(f_abfA [GHC.Types.Char])
                                (\ (aas_abfE :: [GHC.Types.Char]) ->
                                   case aas_abfE of {
                                     [] ->
                                       Data.Either.Left
                                         @[GHC.Types.Char]
                                         @(GHC.Types.Char, [GHC.Types.Char])
                                         (GHC.Types.[] @GHC.Types.Char);
                                     : a1_abfG as_abfH ->
                                       Data.Either.Right
                                         @[GHC.Types.Char]
                                         @(GHC.Types.Char, [GHC.Types.Char])
                                         (a1_abfG, as_abfH)
                                   })
                                (let {
                                   f2_abfJ :: [GHC.Types.Char] -> f_abfA [GHC.Types.Char]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abfJ
                                     = GHC.Base.pure
                                         @f_abfA $dApplicative_abfC @[GHC.Types.Char] } in
                                 let {
                                   ds2_abfK
                                     :: f_abfA (GHC.Types.Char, [GHC.Types.Char])
                                        -> f_abfA [GHC.Types.Char]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 90 0}]
                                   ds2_abfK
                                     = GHC.Base.fmap
                                         @f_abfA
                                         (GHC.Base.$p1Applicative @f_abfA $dApplicative_abfC)
                                         @(GHC.Types.Char, [GHC.Types.Char])
                                         @[GHC.Types.Char]
                                         (\ (p1_abfL :: (GHC.Types.Char, [GHC.Types.Char])) ->
                                            GHC.Types.:
                                              @GHC.Types.Char
                                              (case p1_abfL of { (x_abfN, ds_abfO) -> x_abfN })
                                              (case p1_abfL of { (ds_abfR, y_abfS) ->
                                               y_abfS
                                               })) } in
                                 \ (ds3_abfU
                                      :: Data.Either.Either
                                           [GHC.Types.Char]
                                           (f_abfA (GHC.Types.Char, [GHC.Types.Char]))) ->
                                   case ds3_abfU of {
                                     Data.Either.Left x_abfW -> f2_abfJ x_abfW;
                                     Data.Either.Right y_abfY -> ds2_abfK y_abfY
                                   }) } in
                        let {
                          g_abg0
                            :: p_abfz
                                 (GHC.Types.Char, [GHC.Types.Char])
                                 (f_abfA (GHC.Types.Char, [GHC.Types.Char]))
                               -> p_abfz
                                    (Data.Either.Either
                                       [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                                    (Data.Either.Either
                                       [GHC.Types.Char] (f_abfA (GHC.Types.Char, [GHC.Types.Char])))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abg0
                            = Data.Profunctor.Choice.right'
                                @p_abfz
                                $dChoice_abfB
                                @(GHC.Types.Char, [GHC.Types.Char])
                                @(f_abfA (GHC.Types.Char, [GHC.Types.Char]))
                                @[GHC.Types.Char] } in
                        \ (x_abg1
                             :: p_abfz
                                  (GHC.Types.Char, [GHC.Types.Char])
                                  (f_abfA (GHC.Types.Char, [GHC.Types.Char]))) ->
                          f1_abfD (g_abg0 x_abg1))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <[GHC.Types.Char]>_N
                                      <[GHC.Types.Char]>_N
                                      <GHC.Types.Char>_N
                                      <GHC.Types.Char>_N)
                             :: Control.Lens.Type.Prism
                                  [GHC.Types.Char]
                                  [GHC.Types.Char]
                                  (GHC.Types.Char, [GHC.Types.Char])
                                  (GHC.Types.Char, [GHC.Types.Char])
                                ~R# Control.Lens.Cons.Cons
                                      [GHC.Types.Char]
                                      [GHC.Types.Char]
                                      GHC.Types.Char
                                      GHC.Types.Char)
              ValArg (\ (@(p_abg6 :: * -> * -> *))
                        (@(f_abg7 :: * -> *))
                        ($dChoice_abg8 :: Data.Profunctor.Choice.Choice p_abg6)
                        ($dApplicative_abg9 :: GHC.Base.Applicative f_abg7) ->
                        let {
                          f1_abga
                            :: p_abg6
                                 (Data.Either.Either [GHC.Types.Char] ())
                                 (Data.Either.Either [GHC.Types.Char] (f_abg7 ()))
                               -> p_abg6 [GHC.Types.Char] (f_abg7 [GHC.Types.Char])
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 290 0}]
                          f1_abga
                            = Data.Profunctor.Unsafe.dimap
                                @p_abg6
                                (Data.Profunctor.Choice.$p1Choice @p_abg6 $dChoice_abg8)
                                @[GHC.Types.Char]
                                @(Data.Either.Either [GHC.Types.Char] ())
                                @(Data.Either.Either [GHC.Types.Char] (f_abg7 ()))
                                @(f_abg7 [GHC.Types.Char])
                                (\ (s_abgb :: [GHC.Types.Char]) ->
                                   case s_abgb of wild_abgc {
                                     [] ->
                                       Data.Either.Right @[GHC.Types.Char] @() GHC.Tuple.Prim.();
                                     : ds1_abgd ds2_abge ->
                                       Data.Either.Left @[GHC.Types.Char] @() wild_abgc
                                   })
                                (let {
                                   f2_abgg :: [GHC.Types.Char] -> f_abg7 [GHC.Types.Char]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abgg
                                     = GHC.Base.pure
                                         @f_abg7 $dApplicative_abg9 @[GHC.Types.Char] } in
                                 let {
                                   ds2_abgh :: f_abg7 () -> f_abg7 [GHC.Types.Char]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 70 0}]
                                   ds2_abgh
                                     = GHC.Base.fmap
                                         @f_abg7
                                         (GHC.Base.$p1Applicative @f_abg7 $dApplicative_abg9)
                                         @()
                                         @[GHC.Types.Char]
                                         (\ (ds3_abgi :: ()) ->
                                            case ds3_abgi of { () ->
                                            GHC.Types.[] @GHC.Types.Char
                                            }) } in
                                 \ (ds3_abgk :: Data.Either.Either [GHC.Types.Char] (f_abg7 ())) ->
                                   case ds3_abgk of {
                                     Data.Either.Left x_abgm -> f2_abgg x_abgm;
                                     Data.Either.Right y_abgo -> ds2_abgh y_abgo
                                   }) } in
                        let {
                          g_abgq
                            :: p_abg6 () (f_abg7 ())
                               -> p_abg6
                                    (Data.Either.Either [GHC.Types.Char] ())
                                    (Data.Either.Either [GHC.Types.Char] (f_abg7 ()))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abgq
                            = Data.Profunctor.Choice.right'
                                @p_abg6 $dChoice_abg8 @() @(f_abg7 ()) @[GHC.Types.Char] } in
                        \ (x_abgr :: p_abg6 () (f_abg7 ())) -> f1_abga (g_abgq x_abgr))
                     `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0] <[GHC.Types.Char]>_N)
                             :: Control.Lens.Type.Prism' [GHC.Types.Char] ()
                                ~R# Control.Lens.Empty.AsEmpty [GHC.Types.Char])
              TyArg Data.Functor.Const.Const GHC.Base.String
              ValArg Data.Functor.Contravariant.$fContravariantConst
                       @[GHC.Types.Char]
              ValArg Data.Functor.Const.$fFunctorConst @[GHC.Types.Char]
    After:  (\ (@(f_abeV :: * -> *))
               ($dCons_abeW
                  :: Control.Lens.Cons.Cons
                       Data.Text.Internal.Lazy.Text
                       Data.Text.Internal.Lazy.Text
                       GHC.Types.Char
                       GHC.Types.Char)
               ($dCons1_abeX
                  :: Control.Lens.Cons.Cons
                       GHC.Base.String GHC.Base.String GHC.Types.Char GHC.Types.Char)
               ($dAsEmpty_abeY :: Control.Lens.Empty.AsEmpty GHC.Base.String)
               ($dContravariant_abeZ
                  :: Data.Functor.Contravariant.Contravariant f_abeV)
               ($dFunctor_abf0 :: GHC.Base.Functor f_abeV) ->
               Data.Profunctor.Unsafe.$fProfunctorFUN_$cdimap
                 @Data.Text.Internal.Lazy.Text
                 @GHC.Base.String
                 @(f_abeV GHC.Base.String)
                 @(f_abeV Data.Text.Internal.Lazy.Text)
                 Data.Text.Lazy.unpack
                 (GHC.Base.fmap
                    @f_abeV
                    $dFunctor_abf0
                    @GHC.Base.String
                    @Data.Text.Internal.Lazy.Text
                    Data.Text.Lazy.pack))
              @(Data.Functor.Const.Const GHC.Base.String)
              ((\ (@(p_abip :: * -> * -> *))
                  (@(f_abiq :: * -> *))
                  ($dChoice_abir :: Data.Profunctor.Choice.Choice p_abip)
                  ($dApplicative_abis :: GHC.Base.Applicative f_abiq) ->
                  let {
                    f1_abit
                      :: p_abip
                           (Data.Either.Either
                              Data.Text.Internal.Lazy.Text
                              (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                           (Data.Either.Either
                              Data.Text.Internal.Lazy.Text
                              (f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                         -> p_abip
                              Data.Text.Internal.Lazy.Text (f_abiq Data.Text.Internal.Lazy.Text)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 639 0}]
                    f1_abit
                      = Data.Profunctor.Unsafe.dimap
                          @p_abip
                          (Data.Profunctor.Choice.$p1Choice @p_abip $dChoice_abir)
                          @Data.Text.Internal.Lazy.Text
                          @(Data.Either.Either
                              Data.Text.Internal.Lazy.Text
                              (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                          @(Data.Either.Either
                              Data.Text.Internal.Lazy.Text
                              (f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                          @(f_abiq Data.Text.Internal.Lazy.Text)
                          (\ (s1_abiu :: Data.Text.Internal.Lazy.Text) ->
                             case s1_abiu of {
                               Data.Text.Internal.Lazy.Empty ->
                                 Data.Either.Left
                                   @Data.Text.Internal.Lazy.Text
                                   @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                   Data.Text.Internal.Lazy.Empty;
                               Data.Text.Internal.Lazy.Chunk bx_abiB bx1_abiC bx2_abiD ts_abiE ->
                                 Data.Either.Right
                                   @Data.Text.Internal.Lazy.Text
                                   @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                   (case GHC.Prim.indexWord8Array# bx_abiB bx1_abiC of r#_abiG
                                    { __DEFAULT ->
                                    let {
                                      c#_abiH :: GHC.Prim.Int#
                                      [LclId,
                                       Unf=Unf{Src=<vanilla>, TopLvl=False,
                                               Value=False, ConLike=False, WorkFree=False,
                                               Expandable=False,
                                               Guidance=IF_ARGS [] 4 0}]
                                      c#_abiH
                                        = GHC.Prim.word2Int#
                                            (GHC.Prim.clz8#
                                               (GHC.Prim.and#
                                                  (GHC.Prim.not# (GHC.Prim.word8ToWord# r#_abiG))
                                                  255##)) } in
                                    case GHC.Prim.xorI# c#_abiH (GHC.Prim.<=# c#_abiH 0#) of {
                                      __DEFAULT ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abiB (GHC.Prim.+# bx1_abiC 1#)
                                        of r#1_abiJ
                                        { __DEFAULT ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abiB (GHC.Prim.+# bx1_abiC 2#)
                                        of r#2_abiK
                                        { __DEFAULT ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abiB (GHC.Prim.+# bx1_abiC 3#)
                                        of r#3_abiL
                                        { __DEFAULT ->
                                        GHC.Types.C#
                                          (GHC.Prim.chr#
                                             (GHC.Prim.-#
                                                (GHC.Prim.+#
                                                   (GHC.Prim.+#
                                                      (GHC.Prim.+#
                                                         (GHC.Prim.uncheckedIShiftL#
                                                            (GHC.Prim.-#
                                                               (GHC.Prim.word2Int#
                                                                  (GHC.Prim.word8ToWord# r#_abiG))
                                                               240#)
                                                            18#)
                                                         (GHC.Prim.uncheckedIShiftL#
                                                            (GHC.Prim.-#
                                                               (GHC.Prim.word2Int#
                                                                  (GHC.Prim.word8ToWord# r#1_abiJ))
                                                               128#)
                                                            12#))
                                                      (GHC.Prim.uncheckedIShiftL#
                                                         (GHC.Prim.-#
                                                            (GHC.Prim.word2Int#
                                                               (GHC.Prim.word8ToWord# r#2_abiK))
                                                            128#)
                                                         6#))
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.word8ToWord# r#3_abiL)))
                                                128#))
                                        }
                                        }
                                        };
                                      1# ->
                                        GHC.Types.C#
                                          (GHC.Prim.chr#
                                             (GHC.Prim.word2Int# (GHC.Prim.word8ToWord# r#_abiG)));
                                      2# ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abiB (GHC.Prim.+# bx1_abiC 1#)
                                        of r#1_abiM
                                        { __DEFAULT ->
                                        GHC.Types.C#
                                          (GHC.Prim.chr#
                                             (GHC.Prim.-#
                                                (GHC.Prim.+#
                                                   (GHC.Prim.uncheckedIShiftL#
                                                      (GHC.Prim.-#
                                                         (GHC.Prim.word2Int#
                                                            (GHC.Prim.word8ToWord# r#_abiG))
                                                         192#)
                                                      6#)
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.word8ToWord# r#1_abiM)))
                                                128#))
                                        };
                                      3# ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abiB (GHC.Prim.+# bx1_abiC 1#)
                                        of r#1_abiN
                                        { __DEFAULT ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abiB (GHC.Prim.+# bx1_abiC 2#)
                                        of r#2_abiO
                                        { __DEFAULT ->
                                        GHC.Types.C#
                                          (GHC.Prim.chr#
                                             (GHC.Prim.-#
                                                (GHC.Prim.+#
                                                   (GHC.Prim.+#
                                                      (GHC.Prim.uncheckedIShiftL#
                                                         (GHC.Prim.-#
                                                            (GHC.Prim.word2Int#
                                                               (GHC.Prim.word8ToWord# r#_abiG))
                                                            224#)
                                                         12#)
                                                      (GHC.Prim.uncheckedIShiftL#
                                                         (GHC.Prim.-#
                                                            (GHC.Prim.word2Int#
                                                               (GHC.Prim.word8ToWord# r#1_abiN))
                                                            128#)
                                                         6#))
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.word8ToWord# r#2_abiO)))
                                                128#))
                                        }
                                        }
                                    }
                                    },
                                    case Data.Text.compareLength
                                           (Data.Text.Internal.Text bx_abiB bx1_abiC bx2_abiD)
                                           (GHC.Types.I# 1#)
                                    of {
                                      __DEFAULT ->
                                        case GHC.Prim.indexWord8Array# bx_abiB bx1_abiC of r#_abiQ
                                        { __DEFAULT ->
                                        let {
                                          c#_abiR :: GHC.Prim.Int#
                                          [LclId,
                                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                   Value=False, ConLike=False, WorkFree=False,
                                                   Expandable=False,
                                                   Guidance=IF_ARGS [] 4 0}]
                                          c#_abiR
                                            = GHC.Prim.word2Int#
                                                (GHC.Prim.clz8#
                                                   (GHC.Prim.and#
                                                      (GHC.Prim.not#
                                                         (GHC.Prim.word8ToWord# r#_abiQ))
                                                      255##)) } in
                                        let {
                                          y_abiS :: GHC.Prim.Int#
                                          [LclId,
                                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                   Value=False, ConLike=False, WorkFree=False,
                                                   Expandable=False,
                                                   Guidance=IF_ARGS [] 2 0}]
                                          y_abiS
                                            = GHC.Prim.xorI# c#_abiR (GHC.Prim.<=# c#_abiR 0#) } in
                                        Data.Text.Internal.Lazy.$WChunk
                                          (Data.Text.Internal.$WText
                                             (Data.Text.Array.ByteArray bx_abiB)
                                             (GHC.Types.I# (GHC.Prim.+# bx1_abiC y_abiS))
                                             (GHC.Types.I# (GHC.Prim.-# bx2_abiD y_abiS)))
                                          ts_abiE
                                        };
                                      GHC.Types.EQ -> ts_abiE
                                    })
                             })
                          (let {
                             f2_abiU
                               :: Data.Text.Internal.Lazy.Text
                                  -> f_abiq Data.Text.Internal.Lazy.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abiU
                               = GHC.Base.pure
                                   @f_abiq $dApplicative_abis @Data.Text.Internal.Lazy.Text } in
                           let {
                             ds2_abiV
                               :: f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                  -> f_abiq Data.Text.Internal.Lazy.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 100 0}]
                             ds2_abiV
                               = GHC.Base.fmap
                                   @f_abiq
                                   (GHC.Base.$p1Applicative @f_abiq $dApplicative_abis)
                                   @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                   @Data.Text.Internal.Lazy.Text
                                   (\ (p1_abiW :: (GHC.Types.Char, Data.Text.Internal.Lazy.Text)) ->
                                      case p1_abiW of { (x_abiY, ds_abiZ) ->
                                      Data.Text.Lazy.cons x_abiY ds_abiZ
                                      }) } in
                           \ (ds3_abj1
                                :: Data.Either.Either
                                     Data.Text.Internal.Lazy.Text
                                     (f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text))) ->
                             case ds3_abj1 of {
                               Data.Either.Left x_abj3 -> f2_abiU x_abj3;
                               Data.Either.Right y_abj5 -> ds2_abiV y_abj5
                             }) } in
                  let {
                    g_abj7
                      :: p_abip
                           (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                           (f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                         -> p_abip
                              (Data.Either.Either
                                 Data.Text.Internal.Lazy.Text
                                 (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                              (Data.Either.Either
                                 Data.Text.Internal.Lazy.Text
                                 (f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abj7
                      = Data.Profunctor.Choice.right'
                          @p_abip
                          $dChoice_abir
                          @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                          @(f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                          @Data.Text.Internal.Lazy.Text } in
                  \ (x_abj8
                       :: p_abip
                            (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                            (f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text))) ->
                    f1_abit (g_abj7 x_abj8))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <Data.Text.Internal.Lazy.Text>_N
                                <Data.Text.Internal.Lazy.Text>_N
                                <GHC.Types.Char>_N
                                <GHC.Types.Char>_N)
                       :: Control.Lens.Type.Prism
                            Data.Text.Internal.Lazy.Text
                            Data.Text.Internal.Lazy.Text
                            (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                            (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                          ~R# Control.Lens.Cons.Cons
                                Data.Text.Internal.Lazy.Text
                                Data.Text.Internal.Lazy.Text
                                GHC.Types.Char
                                GHC.Types.Char))
              ((\ (@(p_abfz :: * -> * -> *))
                  (@(f_abfA :: * -> *))
                  ($dChoice_abfB :: Data.Profunctor.Choice.Choice p_abfz)
                  ($dApplicative_abfC :: GHC.Base.Applicative f_abfA) ->
                  let {
                    f1_abfD
                      :: p_abfz
                           (Data.Either.Either
                              [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                           (Data.Either.Either
                              [GHC.Types.Char] (f_abfA (GHC.Types.Char, [GHC.Types.Char])))
                         -> p_abfz [GHC.Types.Char] (f_abfA [GHC.Types.Char])
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 320 0}]
                    f1_abfD
                      = Data.Profunctor.Unsafe.dimap
                          @p_abfz
                          (Data.Profunctor.Choice.$p1Choice @p_abfz $dChoice_abfB)
                          @[GHC.Types.Char]
                          @(Data.Either.Either
                              [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                          @(Data.Either.Either
                              [GHC.Types.Char] (f_abfA (GHC.Types.Char, [GHC.Types.Char])))
                          @(f_abfA [GHC.Types.Char])
                          (\ (aas_abfE :: [GHC.Types.Char]) ->
                             case aas_abfE of {
                               [] ->
                                 Data.Either.Left
                                   @[GHC.Types.Char]
                                   @(GHC.Types.Char, [GHC.Types.Char])
                                   (GHC.Types.[] @GHC.Types.Char);
                               : a1_abfG as_abfH ->
                                 Data.Either.Right
                                   @[GHC.Types.Char]
                                   @(GHC.Types.Char, [GHC.Types.Char])
                                   (a1_abfG, as_abfH)
                             })
                          (let {
                             f2_abfJ :: [GHC.Types.Char] -> f_abfA [GHC.Types.Char]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abfJ
                               = GHC.Base.pure @f_abfA $dApplicative_abfC @[GHC.Types.Char] } in
                           let {
                             ds2_abfK
                               :: f_abfA (GHC.Types.Char, [GHC.Types.Char])
                                  -> f_abfA [GHC.Types.Char]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 90 0}]
                             ds2_abfK
                               = GHC.Base.fmap
                                   @f_abfA
                                   (GHC.Base.$p1Applicative @f_abfA $dApplicative_abfC)
                                   @(GHC.Types.Char, [GHC.Types.Char])
                                   @[GHC.Types.Char]
                                   (\ (p1_abfL :: (GHC.Types.Char, [GHC.Types.Char])) ->
                                      GHC.Types.:
                                        @GHC.Types.Char
                                        (case p1_abfL of { (x_abfN, ds_abfO) -> x_abfN })
                                        (case p1_abfL of { (ds_abfR, y_abfS) -> y_abfS })) } in
                           \ (ds3_abfU
                                :: Data.Either.Either
                                     [GHC.Types.Char]
                                     (f_abfA (GHC.Types.Char, [GHC.Types.Char]))) ->
                             case ds3_abfU of {
                               Data.Either.Left x_abfW -> f2_abfJ x_abfW;
                               Data.Either.Right y_abfY -> ds2_abfK y_abfY
                             }) } in
                  let {
                    g_abg0
                      :: p_abfz
                           (GHC.Types.Char, [GHC.Types.Char])
                           (f_abfA (GHC.Types.Char, [GHC.Types.Char]))
                         -> p_abfz
                              (Data.Either.Either
                                 [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                              (Data.Either.Either
                                 [GHC.Types.Char] (f_abfA (GHC.Types.Char, [GHC.Types.Char])))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abg0
                      = Data.Profunctor.Choice.right'
                          @p_abfz
                          $dChoice_abfB
                          @(GHC.Types.Char, [GHC.Types.Char])
                          @(f_abfA (GHC.Types.Char, [GHC.Types.Char]))
                          @[GHC.Types.Char] } in
                  \ (x_abg1
                       :: p_abfz
                            (GHC.Types.Char, [GHC.Types.Char])
                            (f_abfA (GHC.Types.Char, [GHC.Types.Char]))) ->
                    f1_abfD (g_abg0 x_abg1))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <[GHC.Types.Char]>_N
                                <[GHC.Types.Char]>_N
                                <GHC.Types.Char>_N
                                <GHC.Types.Char>_N)
                       :: Control.Lens.Type.Prism
                            [GHC.Types.Char]
                            [GHC.Types.Char]
                            (GHC.Types.Char, [GHC.Types.Char])
                            (GHC.Types.Char, [GHC.Types.Char])
                          ~R# Control.Lens.Cons.Cons
                                [GHC.Types.Char] [GHC.Types.Char] GHC.Types.Char GHC.Types.Char))
              ((\ (@(p_abg6 :: * -> * -> *))
                  (@(f_abg7 :: * -> *))
                  ($dChoice_abg8 :: Data.Profunctor.Choice.Choice p_abg6)
                  ($dApplicative_abg9 :: GHC.Base.Applicative f_abg7) ->
                  let {
                    f1_abga
                      :: p_abg6
                           (Data.Either.Either [GHC.Types.Char] ())
                           (Data.Either.Either [GHC.Types.Char] (f_abg7 ()))
                         -> p_abg6 [GHC.Types.Char] (f_abg7 [GHC.Types.Char])
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 290 0}]
                    f1_abga
                      = Data.Profunctor.Unsafe.dimap
                          @p_abg6
                          (Data.Profunctor.Choice.$p1Choice @p_abg6 $dChoice_abg8)
                          @[GHC.Types.Char]
                          @(Data.Either.Either [GHC.Types.Char] ())
                          @(Data.Either.Either [GHC.Types.Char] (f_abg7 ()))
                          @(f_abg7 [GHC.Types.Char])
                          (\ (s_abgb :: [GHC.Types.Char]) ->
                             case s_abgb of wild_abgc {
                               [] -> Data.Either.Right @[GHC.Types.Char] @() GHC.Tuple.Prim.();
                               : ds1_abgd ds2_abge ->
                                 Data.Either.Left @[GHC.Types.Char] @() wild_abgc
                             })
                          (let {
                             f2_abgg :: [GHC.Types.Char] -> f_abg7 [GHC.Types.Char]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abgg
                               = GHC.Base.pure @f_abg7 $dApplicative_abg9 @[GHC.Types.Char] } in
                           let {
                             ds2_abgh :: f_abg7 () -> f_abg7 [GHC.Types.Char]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 70 0}]
                             ds2_abgh
                               = GHC.Base.fmap
                                   @f_abg7
                                   (GHC.Base.$p1Applicative @f_abg7 $dApplicative_abg9)
                                   @()
                                   @[GHC.Types.Char]
                                   (\ (ds3_abgi :: ()) ->
                                      case ds3_abgi of { () -> GHC.Types.[] @GHC.Types.Char }) } in
                           \ (ds3_abgk :: Data.Either.Either [GHC.Types.Char] (f_abg7 ())) ->
                             case ds3_abgk of {
                               Data.Either.Left x_abgm -> f2_abgg x_abgm;
                               Data.Either.Right y_abgo -> ds2_abgh y_abgo
                             }) } in
                  let {
                    g_abgq
                      :: p_abg6 () (f_abg7 ())
                         -> p_abg6
                              (Data.Either.Either [GHC.Types.Char] ())
                              (Data.Either.Either [GHC.Types.Char] (f_abg7 ()))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abgq
                      = Data.Profunctor.Choice.right'
                          @p_abg6 $dChoice_abg8 @() @(f_abg7 ()) @[GHC.Types.Char] } in
                  \ (x_abgr :: p_abg6 () (f_abg7 ())) -> f1_abga (g_abgq x_abgr))
               `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0] <[GHC.Types.Char]>_N)
                       :: Control.Lens.Type.Prism' [GHC.Types.Char] ()
                          ~R# Control.Lens.Empty.AsEmpty [GHC.Types.Char]))
              (Data.Functor.Contravariant.$fContravariantConst @[GHC.Types.Char])
              (Data.Functor.Const.$fFunctorConst @[GHC.Types.Char])
    Cont:   ApplyToVal nodup hole Control.Lens.Getter.Getting
                                    GHC.Base.String Data.Text.Internal.Lazy.Text GHC.Base.String
              ((\ (ds_abe3 [Occ=Once1] :: a_abe0) -> ds_abe3)
               `cast` (<a_abe0>_R
                       %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                          <*>_N <a_abe0>_R <a_abe0>_P)
                       :: (a_abe0 -> a_abe0)
                          ~R# (a_abe0 -> Data.Functor.Const.Const a_abe0 a_abe0)))
            ApplyToVal nodup hole Data.Text.Internal.Lazy.Text
                                  -> Data.Functor.Const.Const
                                       GHC.Base.String Data.Text.Internal.Lazy.Text
              (Control.Lens.Getter.view
                 @[GHC.Types.Char]
                 @((->) GHC.Base.String)
                 @Data.Text.Internal.Lazy.Text
                 (Control.Monad.Reader.Class.$fMonadReaderrFUN @[GHC.Types.Char])
                 (Control.Lens.Cons.Extras.recons
                    @[GHC.Types.Char]
                    @GHC.Types.Char
                    @Data.Text.Internal.Lazy.Text
                    (Control.Lens.Cons.$fConsListListab
                       @GHC.Types.Char @GHC.Types.Char)
                    Control.Lens.Cons.$fConsTextTextCharChar
                    Control.Lens.Empty.$fAsEmptyText
                    @(Data.Functor.Const.Const Data.Text.Internal.Lazy.Text)
                    (Data.Functor.Contravariant.$fContravariantConst
                       @Data.Text.Internal.Lazy.Text)
                    (Data.Functor.Const.$fFunctorConst @Data.Text.Internal.Lazy.Text))
                 s_a8OD)
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N <GHC.Base.String>_R <Data.Text.Internal.Lazy.Text>_P
                    :: Data.Functor.Const.Const
                         GHC.Base.String Data.Text.Internal.Lazy.Text
                       ~R# GHC.Base.String)
            Stop[RuleArgCtxt] GHC.Base.String
Rule fired
    Rule: Class op fmap
    Module: (BUILTIN)
    Before: GHC.Base.fmap
              TyArg Data.Functor.Const.Const GHC.Base.String
              ValArg Data.Functor.Const.$fFunctorConst @[GHC.Types.Char]
    After:  (Data.Functor.Const.$fFunctorConst2 @[GHC.Types.Char])
            `cast` (forall (a :: <*>_N) (b :: <*>_N).
                    <a -> b>_R
                    %<'GHC.Types.Many>_N ->_R <Data.Functor.Const.Const
                                                 [GHC.Types.Char] a>_R
                    %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                  <*>_N <[GHC.Types.Char]>_R <a>_P
                                              ; Sym (Data.Functor.Const.N:Const[0]
                                                         <*>_N <[GHC.Types.Char]>_R <b>_P)
                    :: (forall {a} {b}.
                        (a -> b)
                        -> Data.Functor.Const.Const [GHC.Types.Char] a
                        -> Data.Functor.Const.Const [GHC.Types.Char] a)
                       ~R# (forall {a} {b}.
                            (a -> b)
                            -> Data.Functor.Const.Const [GHC.Types.Char] a
                            -> Data.Functor.Const.Const [GHC.Types.Char] b))
    Cont:   ApplyToTy GHC.Base.String
            ApplyToTy Data.Text.Internal.Lazy.Text
            ApplyToVal nodup hole (GHC.Base.String
                                   -> Data.Text.Internal.Lazy.Text)
                                  -> Data.Functor.Const.Const GHC.Base.String GHC.Base.String
                                  -> Data.Functor.Const.Const
                                       GHC.Base.String Data.Text.Internal.Lazy.Text
              Data.Text.Lazy.pack
            ApplyToVal nodup hole Data.Functor.Const.Const
                                    GHC.Base.String GHC.Base.String
                                  -> Data.Functor.Const.Const
                                       GHC.Base.String Data.Text.Internal.Lazy.Text
              (bc_aboj (ab_aboh x_abok))
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N <GHC.Base.String>_R <Data.Text.Internal.Lazy.Text>_P
                    :: Data.Functor.Const.Const
                         GHC.Base.String Data.Text.Internal.Lazy.Text
                       ~R# GHC.Base.String)
            Stop[RuleArgCtxt] GHC.Base.String
Rule fired
    Rule: Class op reader
    Module: (BUILTIN)
    Before: Control.Monad.Reader.Class.reader
              TyArg [GHC.Types.Char]
              TyArg (->) GHC.Base.String
              ValArg Control.Monad.Reader.Class.$fMonadReaderrFUN
                       @[GHC.Types.Char]
    After:  \ (@a_abe8) -> GHC.Base.id @([GHC.Types.Char] -> a_abe8)
    Cont:   ApplyToTy Data.Text.Internal.Lazy.Text
            ApplyToVal nodup hole ([GHC.Types.Char]
                                   -> Data.Text.Internal.Lazy.Text)
                                  -> GHC.Base.String -> Data.Text.Internal.Lazy.Text
              ((l_abe2
                  ((\ (ds_abe3 [Occ=Once1] :: a_abe0) -> ds_abe3)
                   `cast` (<a_abe0>_R
                           %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                              <*>_N <a_abe0>_R <a_abe0>_P)
                           :: (a_abe0 -> a_abe0)
                              ~R# (a_abe0 -> Data.Functor.Const.Const a_abe0 a_abe0))))
               `cast` (<s_abdY>_R
                       %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                     <*>_N <a_abe0>_R <s_abdY>_P
                       :: (s_abdY -> Data.Functor.Const.Const a_abe0 s_abdY)
                          ~R# (s_abdY -> a_abe0)))
            ApplyToVal nodup hole GHC.Base.String
                                  -> Data.Text.Internal.Lazy.Text
              s_a8OD
            Stop[RuleArgCtxt] Data.Text.Internal.Lazy.Text
Rule fired
    Rule: recons/string-lazytext
    Module: (Control.Lens.Cons.Extras)
    Before: Control.Lens.Cons.Extras.recons
              TyArg [GHC.Types.Char]
              TyArg GHC.Types.Char
              TyArg Data.Text.Internal.Lazy.Text
              ValArg (\ (@(p_abfz :: * -> * -> *))
                        (@(f_abfA :: * -> *))
                        ($dChoice_abfB :: Data.Profunctor.Choice.Choice p_abfz)
                        ($dApplicative_abfC :: GHC.Base.Applicative f_abfA) ->
                        let {
                          f1_abfD
                            :: p_abfz
                                 (Data.Either.Either
                                    [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                                 (Data.Either.Either
                                    [GHC.Types.Char] (f_abfA (GHC.Types.Char, [GHC.Types.Char])))
                               -> p_abfz [GHC.Types.Char] (f_abfA [GHC.Types.Char])
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 320 0}]
                          f1_abfD
                            = Data.Profunctor.Unsafe.dimap
                                @p_abfz
                                (Data.Profunctor.Choice.$p1Choice @p_abfz $dChoice_abfB)
                                @[GHC.Types.Char]
                                @(Data.Either.Either
                                    [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                                @(Data.Either.Either
                                    [GHC.Types.Char] (f_abfA (GHC.Types.Char, [GHC.Types.Char])))
                                @(f_abfA [GHC.Types.Char])
                                (\ (aas_abfE :: [GHC.Types.Char]) ->
                                   case aas_abfE of {
                                     [] ->
                                       Data.Either.Left
                                         @[GHC.Types.Char]
                                         @(GHC.Types.Char, [GHC.Types.Char])
                                         (GHC.Types.[] @GHC.Types.Char);
                                     : a1_abfG as_abfH ->
                                       Data.Either.Right
                                         @[GHC.Types.Char]
                                         @(GHC.Types.Char, [GHC.Types.Char])
                                         (a1_abfG, as_abfH)
                                   })
                                (let {
                                   f2_abfJ :: [GHC.Types.Char] -> f_abfA [GHC.Types.Char]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abfJ
                                     = GHC.Base.pure
                                         @f_abfA $dApplicative_abfC @[GHC.Types.Char] } in
                                 let {
                                   ds2_abfK
                                     :: f_abfA (GHC.Types.Char, [GHC.Types.Char])
                                        -> f_abfA [GHC.Types.Char]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 90 0}]
                                   ds2_abfK
                                     = GHC.Base.fmap
                                         @f_abfA
                                         (GHC.Base.$p1Applicative @f_abfA $dApplicative_abfC)
                                         @(GHC.Types.Char, [GHC.Types.Char])
                                         @[GHC.Types.Char]
                                         (\ (p1_abfL :: (GHC.Types.Char, [GHC.Types.Char])) ->
                                            GHC.Types.:
                                              @GHC.Types.Char
                                              (case p1_abfL of { (x_abfN, ds_abfO) -> x_abfN })
                                              (case p1_abfL of { (ds_abfR, y_abfS) ->
                                               y_abfS
                                               })) } in
                                 \ (ds3_abfU
                                      :: Data.Either.Either
                                           [GHC.Types.Char]
                                           (f_abfA (GHC.Types.Char, [GHC.Types.Char]))) ->
                                   case ds3_abfU of {
                                     Data.Either.Left x_abfW -> f2_abfJ x_abfW;
                                     Data.Either.Right y_abfY -> ds2_abfK y_abfY
                                   }) } in
                        let {
                          g_abg0
                            :: p_abfz
                                 (GHC.Types.Char, [GHC.Types.Char])
                                 (f_abfA (GHC.Types.Char, [GHC.Types.Char]))
                               -> p_abfz
                                    (Data.Either.Either
                                       [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                                    (Data.Either.Either
                                       [GHC.Types.Char] (f_abfA (GHC.Types.Char, [GHC.Types.Char])))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abg0
                            = Data.Profunctor.Choice.right'
                                @p_abfz
                                $dChoice_abfB
                                @(GHC.Types.Char, [GHC.Types.Char])
                                @(f_abfA (GHC.Types.Char, [GHC.Types.Char]))
                                @[GHC.Types.Char] } in
                        \ (x_abg1
                             :: p_abfz
                                  (GHC.Types.Char, [GHC.Types.Char])
                                  (f_abfA (GHC.Types.Char, [GHC.Types.Char]))) ->
                          f1_abfD (g_abg0 x_abg1))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <[GHC.Types.Char]>_N
                                      <[GHC.Types.Char]>_N
                                      <GHC.Types.Char>_N
                                      <GHC.Types.Char>_N)
                             :: Control.Lens.Type.Prism
                                  [GHC.Types.Char]
                                  [GHC.Types.Char]
                                  (GHC.Types.Char, [GHC.Types.Char])
                                  (GHC.Types.Char, [GHC.Types.Char])
                                ~R# Control.Lens.Cons.Cons
                                      [GHC.Types.Char]
                                      [GHC.Types.Char]
                                      GHC.Types.Char
                                      GHC.Types.Char)
              ValArg (\ (@(p_abip :: * -> * -> *))
                        (@(f_abiq :: * -> *))
                        ($dChoice_abir :: Data.Profunctor.Choice.Choice p_abip)
                        ($dApplicative_abis :: GHC.Base.Applicative f_abiq) ->
                        let {
                          f1_abit
                            :: p_abip
                                 (Data.Either.Either
                                    Data.Text.Internal.Lazy.Text
                                    (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                                 (Data.Either.Either
                                    Data.Text.Internal.Lazy.Text
                                    (f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                               -> p_abip
                                    Data.Text.Internal.Lazy.Text
                                    (f_abiq Data.Text.Internal.Lazy.Text)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 639 0}]
                          f1_abit
                            = Data.Profunctor.Unsafe.dimap
                                @p_abip
                                (Data.Profunctor.Choice.$p1Choice @p_abip $dChoice_abir)
                                @Data.Text.Internal.Lazy.Text
                                @(Data.Either.Either
                                    Data.Text.Internal.Lazy.Text
                                    (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                                @(Data.Either.Either
                                    Data.Text.Internal.Lazy.Text
                                    (f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                                @(f_abiq Data.Text.Internal.Lazy.Text)
                                (\ (s1_abiu :: Data.Text.Internal.Lazy.Text) ->
                                   case s1_abiu of {
                                     Data.Text.Internal.Lazy.Empty ->
                                       Data.Either.Left
                                         @Data.Text.Internal.Lazy.Text
                                         @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                         Data.Text.Internal.Lazy.Empty;
                                     Data.Text.Internal.Lazy.Chunk bx_abiB bx1_abiC bx2_abiD
                                                                   ts_abiE ->
                                       Data.Either.Right
                                         @Data.Text.Internal.Lazy.Text
                                         @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                         (case GHC.Prim.indexWord8Array# bx_abiB bx1_abiC of r#_abiG
                                          { __DEFAULT ->
                                          let {
                                            c#_abiH :: GHC.Prim.Int#
                                            [LclId,
                                             Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                     Value=False, ConLike=False, WorkFree=False,
                                                     Expandable=False,
                                                     Guidance=IF_ARGS [] 4 0}]
                                            c#_abiH
                                              = GHC.Prim.word2Int#
                                                  (GHC.Prim.clz8#
                                                     (GHC.Prim.and#
                                                        (GHC.Prim.not#
                                                           (GHC.Prim.word8ToWord# r#_abiG))
                                                        255##)) } in
                                          case GHC.Prim.xorI# c#_abiH (GHC.Prim.<=# c#_abiH 0#) of {
                                            __DEFAULT ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abiB (GHC.Prim.+# bx1_abiC 1#)
                                              of r#1_abiJ
                                              { __DEFAULT ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abiB (GHC.Prim.+# bx1_abiC 2#)
                                              of r#2_abiK
                                              { __DEFAULT ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abiB (GHC.Prim.+# bx1_abiC 3#)
                                              of r#3_abiL
                                              { __DEFAULT ->
                                              GHC.Types.C#
                                                (GHC.Prim.chr#
                                                   (GHC.Prim.-#
                                                      (GHC.Prim.+#
                                                         (GHC.Prim.+#
                                                            (GHC.Prim.+#
                                                               (GHC.Prim.uncheckedIShiftL#
                                                                  (GHC.Prim.-#
                                                                     (GHC.Prim.word2Int#
                                                                        (GHC.Prim.word8ToWord#
                                                                           r#_abiG))
                                                                     240#)
                                                                  18#)
                                                               (GHC.Prim.uncheckedIShiftL#
                                                                  (GHC.Prim.-#
                                                                     (GHC.Prim.word2Int#
                                                                        (GHC.Prim.word8ToWord#
                                                                           r#1_abiJ))
                                                                     128#)
                                                                  12#))
                                                            (GHC.Prim.uncheckedIShiftL#
                                                               (GHC.Prim.-#
                                                                  (GHC.Prim.word2Int#
                                                                     (GHC.Prim.word8ToWord#
                                                                        r#2_abiK))
                                                                  128#)
                                                               6#))
                                                         (GHC.Prim.word2Int#
                                                            (GHC.Prim.word8ToWord# r#3_abiL)))
                                                      128#))
                                              }
                                              }
                                              };
                                            1# ->
                                              GHC.Types.C#
                                                (GHC.Prim.chr#
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.word8ToWord# r#_abiG)));
                                            2# ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abiB (GHC.Prim.+# bx1_abiC 1#)
                                              of r#1_abiM
                                              { __DEFAULT ->
                                              GHC.Types.C#
                                                (GHC.Prim.chr#
                                                   (GHC.Prim.-#
                                                      (GHC.Prim.+#
                                                         (GHC.Prim.uncheckedIShiftL#
                                                            (GHC.Prim.-#
                                                               (GHC.Prim.word2Int#
                                                                  (GHC.Prim.word8ToWord# r#_abiG))
                                                               192#)
                                                            6#)
                                                         (GHC.Prim.word2Int#
                                                            (GHC.Prim.word8ToWord# r#1_abiM)))
                                                      128#))
                                              };
                                            3# ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abiB (GHC.Prim.+# bx1_abiC 1#)
                                              of r#1_abiN
                                              { __DEFAULT ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abiB (GHC.Prim.+# bx1_abiC 2#)
                                              of r#2_abiO
                                              { __DEFAULT ->
                                              GHC.Types.C#
                                                (GHC.Prim.chr#
                                                   (GHC.Prim.-#
                                                      (GHC.Prim.+#
                                                         (GHC.Prim.+#
                                                            (GHC.Prim.uncheckedIShiftL#
                                                               (GHC.Prim.-#
                                                                  (GHC.Prim.word2Int#
                                                                     (GHC.Prim.word8ToWord#
                                                                        r#_abiG))
                                                                  224#)
                                                               12#)
                                                            (GHC.Prim.uncheckedIShiftL#
                                                               (GHC.Prim.-#
                                                                  (GHC.Prim.word2Int#
                                                                     (GHC.Prim.word8ToWord#
                                                                        r#1_abiN))
                                                                  128#)
                                                               6#))
                                                         (GHC.Prim.word2Int#
                                                            (GHC.Prim.word8ToWord# r#2_abiO)))
                                                      128#))
                                              }
                                              }
                                          }
                                          },
                                          case Data.Text.compareLength
                                                 (Data.Text.Internal.Text bx_abiB bx1_abiC bx2_abiD)
                                                 (GHC.Types.I# 1#)
                                          of {
                                            __DEFAULT ->
                                              case GHC.Prim.indexWord8Array# bx_abiB bx1_abiC
                                              of r#_abiQ
                                              { __DEFAULT ->
                                              let {
                                                c#_abiR :: GHC.Prim.Int#
                                                [LclId,
                                                 Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                         Value=False, ConLike=False, WorkFree=False,
                                                         Expandable=False,
                                                         Guidance=IF_ARGS [] 4 0}]
                                                c#_abiR
                                                  = GHC.Prim.word2Int#
                                                      (GHC.Prim.clz8#
                                                         (GHC.Prim.and#
                                                            (GHC.Prim.not#
                                                               (GHC.Prim.word8ToWord# r#_abiQ))
                                                            255##)) } in
                                              let {
                                                y_abiS :: GHC.Prim.Int#
                                                [LclId,
                                                 Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                         Value=False, ConLike=False, WorkFree=False,
                                                         Expandable=False,
                                                         Guidance=IF_ARGS [] 2 0}]
                                                y_abiS
                                                  = GHC.Prim.xorI#
                                                      c#_abiR (GHC.Prim.<=# c#_abiR 0#) } in
                                              Data.Text.Internal.Lazy.$WChunk
                                                (Data.Text.Internal.$WText
                                                   (Data.Text.Array.ByteArray bx_abiB)
                                                   (GHC.Types.I# (GHC.Prim.+# bx1_abiC y_abiS))
                                                   (GHC.Types.I# (GHC.Prim.-# bx2_abiD y_abiS)))
                                                ts_abiE
                                              };
                                            GHC.Types.EQ -> ts_abiE
                                          })
                                   })
                                (let {
                                   f2_abiU
                                     :: Data.Text.Internal.Lazy.Text
                                        -> f_abiq Data.Text.Internal.Lazy.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abiU
                                     = GHC.Base.pure
                                         @f_abiq
                                         $dApplicative_abis
                                         @Data.Text.Internal.Lazy.Text } in
                                 let {
                                   ds2_abiV
                                     :: f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                        -> f_abiq Data.Text.Internal.Lazy.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 100 0}]
                                   ds2_abiV
                                     = GHC.Base.fmap
                                         @f_abiq
                                         (GHC.Base.$p1Applicative @f_abiq $dApplicative_abis)
                                         @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                         @Data.Text.Internal.Lazy.Text
                                         (\ (p1_abiW
                                               :: (GHC.Types.Char, Data.Text.Internal.Lazy.Text)) ->
                                            case p1_abiW of { (x_abiY, ds_abiZ) ->
                                            Data.Text.Lazy.cons x_abiY ds_abiZ
                                            }) } in
                                 \ (ds3_abj1
                                      :: Data.Either.Either
                                           Data.Text.Internal.Lazy.Text
                                           (f_abiq
                                              (GHC.Types.Char, Data.Text.Internal.Lazy.Text))) ->
                                   case ds3_abj1 of {
                                     Data.Either.Left x_abj3 -> f2_abiU x_abj3;
                                     Data.Either.Right y_abj5 -> ds2_abiV y_abj5
                                   }) } in
                        let {
                          g_abj7
                            :: p_abip
                                 (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                 (f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                               -> p_abip
                                    (Data.Either.Either
                                       Data.Text.Internal.Lazy.Text
                                       (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                                    (Data.Either.Either
                                       Data.Text.Internal.Lazy.Text
                                       (f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abj7
                            = Data.Profunctor.Choice.right'
                                @p_abip
                                $dChoice_abir
                                @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                @(f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                                @Data.Text.Internal.Lazy.Text } in
                        \ (x_abj8
                             :: p_abip
                                  (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                  (f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text))) ->
                          f1_abit (g_abj7 x_abj8))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <Data.Text.Internal.Lazy.Text>_N
                                      <Data.Text.Internal.Lazy.Text>_N
                                      <GHC.Types.Char>_N
                                      <GHC.Types.Char>_N)
                             :: Control.Lens.Type.Prism
                                  Data.Text.Internal.Lazy.Text
                                  Data.Text.Internal.Lazy.Text
                                  (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                  (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                ~R# Control.Lens.Cons.Cons
                                      Data.Text.Internal.Lazy.Text
                                      Data.Text.Internal.Lazy.Text
                                      GHC.Types.Char
                                      GHC.Types.Char)
              ValArg (\ (@(p_abjb :: * -> * -> *))
                        (@(f_abjc :: * -> *))
                        ($dChoice_abjd :: Data.Profunctor.Choice.Choice p_abjb)
                        ($dApplicative_abje :: GHC.Base.Applicative f_abjc) ->
                        let {
                          f1_abjf
                            :: p_abjb
                                 (Data.Either.Either Data.Text.Internal.Lazy.Text ())
                                 (Data.Either.Either Data.Text.Internal.Lazy.Text (f_abjc ()))
                               -> p_abjb
                                    Data.Text.Internal.Lazy.Text
                                    (f_abjc Data.Text.Internal.Lazy.Text)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 310 0}]
                          f1_abjf
                            = Data.Profunctor.Unsafe.dimap
                                @p_abjb
                                (Data.Profunctor.Choice.$p1Choice @p_abjb $dChoice_abjd)
                                @Data.Text.Internal.Lazy.Text
                                @(Data.Either.Either Data.Text.Internal.Lazy.Text ())
                                @(Data.Either.Either Data.Text.Internal.Lazy.Text (f_abjc ()))
                                @(f_abjc Data.Text.Internal.Lazy.Text)
                                (\ (s_abjg :: Data.Text.Internal.Lazy.Text) ->
                                   case Data.Text.Lazy.null s_abjg of {
                                     GHC.Types.False ->
                                       Data.Either.Left @Data.Text.Internal.Lazy.Text @() s_abjg;
                                     GHC.Types.True ->
                                       Data.Either.Right
                                         @Data.Text.Internal.Lazy.Text @() GHC.Tuple.Prim.()
                                   })
                                (let {
                                   f2_abjj
                                     :: Data.Text.Internal.Lazy.Text
                                        -> f_abjc Data.Text.Internal.Lazy.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abjj
                                     = GHC.Base.pure
                                         @f_abjc
                                         $dApplicative_abje
                                         @Data.Text.Internal.Lazy.Text } in
                                 let {
                                   ds2_abjk :: f_abjc () -> f_abjc Data.Text.Internal.Lazy.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 70 0}]
                                   ds2_abjk
                                     = GHC.Base.fmap
                                         @f_abjc
                                         (GHC.Base.$p1Applicative @f_abjc $dApplicative_abje)
                                         @()
                                         @Data.Text.Internal.Lazy.Text
                                         (\ (ds3_abjl :: ()) ->
                                            case ds3_abjl of { () ->
                                            Data.Text.Internal.Lazy.empty
                                            }) } in
                                 \ (ds3_abjn
                                      :: Data.Either.Either
                                           Data.Text.Internal.Lazy.Text (f_abjc ())) ->
                                   case ds3_abjn of {
                                     Data.Either.Left x_abjp -> f2_abjj x_abjp;
                                     Data.Either.Right y_abjr -> ds2_abjk y_abjr
                                   }) } in
                        let {
                          g_abjt
                            :: p_abjb () (f_abjc ())
                               -> p_abjb
                                    (Data.Either.Either Data.Text.Internal.Lazy.Text ())
                                    (Data.Either.Either Data.Text.Internal.Lazy.Text (f_abjc ()))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abjt
                            = Data.Profunctor.Choice.right'
                                @p_abjb
                                $dChoice_abjd
                                @()
                                @(f_abjc ())
                                @Data.Text.Internal.Lazy.Text } in
                        \ (x_abju :: p_abjb () (f_abjc ())) -> f1_abjf (g_abjt x_abju))
                     `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                      <Data.Text.Internal.Lazy.Text>_N)
                             :: Control.Lens.Type.Prism' Data.Text.Internal.Lazy.Text ()
                                ~R# Control.Lens.Empty.AsEmpty Data.Text.Internal.Lazy.Text)
              TyArg Data.Functor.Const.Const Data.Text.Internal.Lazy.Text
              ValArg Data.Functor.Contravariant.$fContravariantConst
                       @Data.Text.Internal.Lazy.Text
              ValArg Data.Functor.Const.$fFunctorConst
                       @Data.Text.Internal.Lazy.Text
    After:  (\ (@(f_abeD :: * -> *))
               ($dCons_abeE
                  :: Control.Lens.Cons.Cons
                       GHC.Base.String GHC.Base.String GHC.Types.Char GHC.Types.Char)
               ($dCons1_abeF
                  :: Control.Lens.Cons.Cons
                       Data.Text.Internal.Lazy.Text
                       Data.Text.Internal.Lazy.Text
                       GHC.Types.Char
                       GHC.Types.Char)
               ($dAsEmpty_abeG
                  :: Control.Lens.Empty.AsEmpty Data.Text.Internal.Lazy.Text)
               ($dContravariant_abeH
                  :: Data.Functor.Contravariant.Contravariant f_abeD)
               ($dFunctor_abeI :: GHC.Base.Functor f_abeD) ->
               Data.Profunctor.Unsafe.$fProfunctorFUN_$cdimap
                 @GHC.Base.String
                 @Data.Text.Internal.Lazy.Text
                 @(f_abeD Data.Text.Internal.Lazy.Text)
                 @(f_abeD GHC.Base.String)
                 Data.Text.Lazy.pack
                 (GHC.Base.fmap
                    @f_abeD
                    $dFunctor_abeI
                    @Data.Text.Internal.Lazy.Text
                    @GHC.Base.String
                    Data.Text.Lazy.unpack))
              @(Data.Functor.Const.Const Data.Text.Internal.Lazy.Text)
              ((\ (@(p_abfz :: * -> * -> *))
                  (@(f_abfA :: * -> *))
                  ($dChoice_abfB :: Data.Profunctor.Choice.Choice p_abfz)
                  ($dApplicative_abfC :: GHC.Base.Applicative f_abfA) ->
                  let {
                    f1_abfD
                      :: p_abfz
                           (Data.Either.Either
                              [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                           (Data.Either.Either
                              [GHC.Types.Char] (f_abfA (GHC.Types.Char, [GHC.Types.Char])))
                         -> p_abfz [GHC.Types.Char] (f_abfA [GHC.Types.Char])
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 320 0}]
                    f1_abfD
                      = Data.Profunctor.Unsafe.dimap
                          @p_abfz
                          (Data.Profunctor.Choice.$p1Choice @p_abfz $dChoice_abfB)
                          @[GHC.Types.Char]
                          @(Data.Either.Either
                              [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                          @(Data.Either.Either
                              [GHC.Types.Char] (f_abfA (GHC.Types.Char, [GHC.Types.Char])))
                          @(f_abfA [GHC.Types.Char])
                          (\ (aas_abfE :: [GHC.Types.Char]) ->
                             case aas_abfE of {
                               [] ->
                                 Data.Either.Left
                                   @[GHC.Types.Char]
                                   @(GHC.Types.Char, [GHC.Types.Char])
                                   (GHC.Types.[] @GHC.Types.Char);
                               : a1_abfG as_abfH ->
                                 Data.Either.Right
                                   @[GHC.Types.Char]
                                   @(GHC.Types.Char, [GHC.Types.Char])
                                   (a1_abfG, as_abfH)
                             })
                          (let {
                             f2_abfJ :: [GHC.Types.Char] -> f_abfA [GHC.Types.Char]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abfJ
                               = GHC.Base.pure @f_abfA $dApplicative_abfC @[GHC.Types.Char] } in
                           let {
                             ds2_abfK
                               :: f_abfA (GHC.Types.Char, [GHC.Types.Char])
                                  -> f_abfA [GHC.Types.Char]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 90 0}]
                             ds2_abfK
                               = GHC.Base.fmap
                                   @f_abfA
                                   (GHC.Base.$p1Applicative @f_abfA $dApplicative_abfC)
                                   @(GHC.Types.Char, [GHC.Types.Char])
                                   @[GHC.Types.Char]
                                   (\ (p1_abfL :: (GHC.Types.Char, [GHC.Types.Char])) ->
                                      GHC.Types.:
                                        @GHC.Types.Char
                                        (case p1_abfL of { (x_abfN, ds_abfO) -> x_abfN })
                                        (case p1_abfL of { (ds_abfR, y_abfS) -> y_abfS })) } in
                           \ (ds3_abfU
                                :: Data.Either.Either
                                     [GHC.Types.Char]
                                     (f_abfA (GHC.Types.Char, [GHC.Types.Char]))) ->
                             case ds3_abfU of {
                               Data.Either.Left x_abfW -> f2_abfJ x_abfW;
                               Data.Either.Right y_abfY -> ds2_abfK y_abfY
                             }) } in
                  let {
                    g_abg0
                      :: p_abfz
                           (GHC.Types.Char, [GHC.Types.Char])
                           (f_abfA (GHC.Types.Char, [GHC.Types.Char]))
                         -> p_abfz
                              (Data.Either.Either
                                 [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                              (Data.Either.Either
                                 [GHC.Types.Char] (f_abfA (GHC.Types.Char, [GHC.Types.Char])))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abg0
                      = Data.Profunctor.Choice.right'
                          @p_abfz
                          $dChoice_abfB
                          @(GHC.Types.Char, [GHC.Types.Char])
                          @(f_abfA (GHC.Types.Char, [GHC.Types.Char]))
                          @[GHC.Types.Char] } in
                  \ (x_abg1
                       :: p_abfz
                            (GHC.Types.Char, [GHC.Types.Char])
                            (f_abfA (GHC.Types.Char, [GHC.Types.Char]))) ->
                    f1_abfD (g_abg0 x_abg1))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <[GHC.Types.Char]>_N
                                <[GHC.Types.Char]>_N
                                <GHC.Types.Char>_N
                                <GHC.Types.Char>_N)
                       :: Control.Lens.Type.Prism
                            [GHC.Types.Char]
                            [GHC.Types.Char]
                            (GHC.Types.Char, [GHC.Types.Char])
                            (GHC.Types.Char, [GHC.Types.Char])
                          ~R# Control.Lens.Cons.Cons
                                [GHC.Types.Char] [GHC.Types.Char] GHC.Types.Char GHC.Types.Char))
              ((\ (@(p_abip :: * -> * -> *))
                  (@(f_abiq :: * -> *))
                  ($dChoice_abir :: Data.Profunctor.Choice.Choice p_abip)
                  ($dApplicative_abis :: GHC.Base.Applicative f_abiq) ->
                  let {
                    f1_abit
                      :: p_abip
                           (Data.Either.Either
                              Data.Text.Internal.Lazy.Text
                              (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                           (Data.Either.Either
                              Data.Text.Internal.Lazy.Text
                              (f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                         -> p_abip
                              Data.Text.Internal.Lazy.Text (f_abiq Data.Text.Internal.Lazy.Text)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 639 0}]
                    f1_abit
                      = Data.Profunctor.Unsafe.dimap
                          @p_abip
                          (Data.Profunctor.Choice.$p1Choice @p_abip $dChoice_abir)
                          @Data.Text.Internal.Lazy.Text
                          @(Data.Either.Either
                              Data.Text.Internal.Lazy.Text
                              (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                          @(Data.Either.Either
                              Data.Text.Internal.Lazy.Text
                              (f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                          @(f_abiq Data.Text.Internal.Lazy.Text)
                          (\ (s1_abiu :: Data.Text.Internal.Lazy.Text) ->
                             case s1_abiu of {
                               Data.Text.Internal.Lazy.Empty ->
                                 Data.Either.Left
                                   @Data.Text.Internal.Lazy.Text
                                   @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                   Data.Text.Internal.Lazy.Empty;
                               Data.Text.Internal.Lazy.Chunk bx_abiB bx1_abiC bx2_abiD ts_abiE ->
                                 Data.Either.Right
                                   @Data.Text.Internal.Lazy.Text
                                   @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                   (case GHC.Prim.indexWord8Array# bx_abiB bx1_abiC of r#_abiG
                                    { __DEFAULT ->
                                    let {
                                      c#_abiH :: GHC.Prim.Int#
                                      [LclId,
                                       Unf=Unf{Src=<vanilla>, TopLvl=False,
                                               Value=False, ConLike=False, WorkFree=False,
                                               Expandable=False,
                                               Guidance=IF_ARGS [] 4 0}]
                                      c#_abiH
                                        = GHC.Prim.word2Int#
                                            (GHC.Prim.clz8#
                                               (GHC.Prim.and#
                                                  (GHC.Prim.not# (GHC.Prim.word8ToWord# r#_abiG))
                                                  255##)) } in
                                    case GHC.Prim.xorI# c#_abiH (GHC.Prim.<=# c#_abiH 0#) of {
                                      __DEFAULT ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abiB (GHC.Prim.+# bx1_abiC 1#)
                                        of r#1_abiJ
                                        { __DEFAULT ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abiB (GHC.Prim.+# bx1_abiC 2#)
                                        of r#2_abiK
                                        { __DEFAULT ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abiB (GHC.Prim.+# bx1_abiC 3#)
                                        of r#3_abiL
                                        { __DEFAULT ->
                                        GHC.Types.C#
                                          (GHC.Prim.chr#
                                             (GHC.Prim.-#
                                                (GHC.Prim.+#
                                                   (GHC.Prim.+#
                                                      (GHC.Prim.+#
                                                         (GHC.Prim.uncheckedIShiftL#
                                                            (GHC.Prim.-#
                                                               (GHC.Prim.word2Int#
                                                                  (GHC.Prim.word8ToWord# r#_abiG))
                                                               240#)
                                                            18#)
                                                         (GHC.Prim.uncheckedIShiftL#
                                                            (GHC.Prim.-#
                                                               (GHC.Prim.word2Int#
                                                                  (GHC.Prim.word8ToWord# r#1_abiJ))
                                                               128#)
                                                            12#))
                                                      (GHC.Prim.uncheckedIShiftL#
                                                         (GHC.Prim.-#
                                                            (GHC.Prim.word2Int#
                                                               (GHC.Prim.word8ToWord# r#2_abiK))
                                                            128#)
                                                         6#))
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.word8ToWord# r#3_abiL)))
                                                128#))
                                        }
                                        }
                                        };
                                      1# ->
                                        GHC.Types.C#
                                          (GHC.Prim.chr#
                                             (GHC.Prim.word2Int# (GHC.Prim.word8ToWord# r#_abiG)));
                                      2# ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abiB (GHC.Prim.+# bx1_abiC 1#)
                                        of r#1_abiM
                                        { __DEFAULT ->
                                        GHC.Types.C#
                                          (GHC.Prim.chr#
                                             (GHC.Prim.-#
                                                (GHC.Prim.+#
                                                   (GHC.Prim.uncheckedIShiftL#
                                                      (GHC.Prim.-#
                                                         (GHC.Prim.word2Int#
                                                            (GHC.Prim.word8ToWord# r#_abiG))
                                                         192#)
                                                      6#)
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.word8ToWord# r#1_abiM)))
                                                128#))
                                        };
                                      3# ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abiB (GHC.Prim.+# bx1_abiC 1#)
                                        of r#1_abiN
                                        { __DEFAULT ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abiB (GHC.Prim.+# bx1_abiC 2#)
                                        of r#2_abiO
                                        { __DEFAULT ->
                                        GHC.Types.C#
                                          (GHC.Prim.chr#
                                             (GHC.Prim.-#
                                                (GHC.Prim.+#
                                                   (GHC.Prim.+#
                                                      (GHC.Prim.uncheckedIShiftL#
                                                         (GHC.Prim.-#
                                                            (GHC.Prim.word2Int#
                                                               (GHC.Prim.word8ToWord# r#_abiG))
                                                            224#)
                                                         12#)
                                                      (GHC.Prim.uncheckedIShiftL#
                                                         (GHC.Prim.-#
                                                            (GHC.Prim.word2Int#
                                                               (GHC.Prim.word8ToWord# r#1_abiN))
                                                            128#)
                                                         6#))
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.word8ToWord# r#2_abiO)))
                                                128#))
                                        }
                                        }
                                    }
                                    },
                                    case Data.Text.compareLength
                                           (Data.Text.Internal.Text bx_abiB bx1_abiC bx2_abiD)
                                           (GHC.Types.I# 1#)
                                    of {
                                      __DEFAULT ->
                                        case GHC.Prim.indexWord8Array# bx_abiB bx1_abiC of r#_abiQ
                                        { __DEFAULT ->
                                        let {
                                          c#_abiR :: GHC.Prim.Int#
                                          [LclId,
                                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                   Value=False, ConLike=False, WorkFree=False,
                                                   Expandable=False,
                                                   Guidance=IF_ARGS [] 4 0}]
                                          c#_abiR
                                            = GHC.Prim.word2Int#
                                                (GHC.Prim.clz8#
                                                   (GHC.Prim.and#
                                                      (GHC.Prim.not#
                                                         (GHC.Prim.word8ToWord# r#_abiQ))
                                                      255##)) } in
                                        let {
                                          y_abiS :: GHC.Prim.Int#
                                          [LclId,
                                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                   Value=False, ConLike=False, WorkFree=False,
                                                   Expandable=False,
                                                   Guidance=IF_ARGS [] 2 0}]
                                          y_abiS
                                            = GHC.Prim.xorI# c#_abiR (GHC.Prim.<=# c#_abiR 0#) } in
                                        Data.Text.Internal.Lazy.$WChunk
                                          (Data.Text.Internal.$WText
                                             (Data.Text.Array.ByteArray bx_abiB)
                                             (GHC.Types.I# (GHC.Prim.+# bx1_abiC y_abiS))
                                             (GHC.Types.I# (GHC.Prim.-# bx2_abiD y_abiS)))
                                          ts_abiE
                                        };
                                      GHC.Types.EQ -> ts_abiE
                                    })
                             })
                          (let {
                             f2_abiU
                               :: Data.Text.Internal.Lazy.Text
                                  -> f_abiq Data.Text.Internal.Lazy.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abiU
                               = GHC.Base.pure
                                   @f_abiq $dApplicative_abis @Data.Text.Internal.Lazy.Text } in
                           let {
                             ds2_abiV
                               :: f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                  -> f_abiq Data.Text.Internal.Lazy.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 100 0}]
                             ds2_abiV
                               = GHC.Base.fmap
                                   @f_abiq
                                   (GHC.Base.$p1Applicative @f_abiq $dApplicative_abis)
                                   @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                   @Data.Text.Internal.Lazy.Text
                                   (\ (p1_abiW :: (GHC.Types.Char, Data.Text.Internal.Lazy.Text)) ->
                                      case p1_abiW of { (x_abiY, ds_abiZ) ->
                                      Data.Text.Lazy.cons x_abiY ds_abiZ
                                      }) } in
                           \ (ds3_abj1
                                :: Data.Either.Either
                                     Data.Text.Internal.Lazy.Text
                                     (f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text))) ->
                             case ds3_abj1 of {
                               Data.Either.Left x_abj3 -> f2_abiU x_abj3;
                               Data.Either.Right y_abj5 -> ds2_abiV y_abj5
                             }) } in
                  let {
                    g_abj7
                      :: p_abip
                           (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                           (f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                         -> p_abip
                              (Data.Either.Either
                                 Data.Text.Internal.Lazy.Text
                                 (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                              (Data.Either.Either
                                 Data.Text.Internal.Lazy.Text
                                 (f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abj7
                      = Data.Profunctor.Choice.right'
                          @p_abip
                          $dChoice_abir
                          @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                          @(f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                          @Data.Text.Internal.Lazy.Text } in
                  \ (x_abj8
                       :: p_abip
                            (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                            (f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text))) ->
                    f1_abit (g_abj7 x_abj8))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <Data.Text.Internal.Lazy.Text>_N
                                <Data.Text.Internal.Lazy.Text>_N
                                <GHC.Types.Char>_N
                                <GHC.Types.Char>_N)
                       :: Control.Lens.Type.Prism
                            Data.Text.Internal.Lazy.Text
                            Data.Text.Internal.Lazy.Text
                            (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                            (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                          ~R# Control.Lens.Cons.Cons
                                Data.Text.Internal.Lazy.Text
                                Data.Text.Internal.Lazy.Text
                                GHC.Types.Char
                                GHC.Types.Char))
              ((\ (@(p_abjb :: * -> * -> *))
                  (@(f_abjc :: * -> *))
                  ($dChoice_abjd :: Data.Profunctor.Choice.Choice p_abjb)
                  ($dApplicative_abje :: GHC.Base.Applicative f_abjc) ->
                  let {
                    f1_abjf
                      :: p_abjb
                           (Data.Either.Either Data.Text.Internal.Lazy.Text ())
                           (Data.Either.Either Data.Text.Internal.Lazy.Text (f_abjc ()))
                         -> p_abjb
                              Data.Text.Internal.Lazy.Text (f_abjc Data.Text.Internal.Lazy.Text)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 310 0}]
                    f1_abjf
                      = Data.Profunctor.Unsafe.dimap
                          @p_abjb
                          (Data.Profunctor.Choice.$p1Choice @p_abjb $dChoice_abjd)
                          @Data.Text.Internal.Lazy.Text
                          @(Data.Either.Either Data.Text.Internal.Lazy.Text ())
                          @(Data.Either.Either Data.Text.Internal.Lazy.Text (f_abjc ()))
                          @(f_abjc Data.Text.Internal.Lazy.Text)
                          (\ (s_abjg :: Data.Text.Internal.Lazy.Text) ->
                             case Data.Text.Lazy.null s_abjg of {
                               GHC.Types.False ->
                                 Data.Either.Left @Data.Text.Internal.Lazy.Text @() s_abjg;
                               GHC.Types.True ->
                                 Data.Either.Right
                                   @Data.Text.Internal.Lazy.Text @() GHC.Tuple.Prim.()
                             })
                          (let {
                             f2_abjj
                               :: Data.Text.Internal.Lazy.Text
                                  -> f_abjc Data.Text.Internal.Lazy.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abjj
                               = GHC.Base.pure
                                   @f_abjc $dApplicative_abje @Data.Text.Internal.Lazy.Text } in
                           let {
                             ds2_abjk :: f_abjc () -> f_abjc Data.Text.Internal.Lazy.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 70 0}]
                             ds2_abjk
                               = GHC.Base.fmap
                                   @f_abjc
                                   (GHC.Base.$p1Applicative @f_abjc $dApplicative_abje)
                                   @()
                                   @Data.Text.Internal.Lazy.Text
                                   (\ (ds3_abjl :: ()) ->
                                      case ds3_abjl of { () -> Data.Text.Internal.Lazy.empty }) } in
                           \ (ds3_abjn
                                :: Data.Either.Either Data.Text.Internal.Lazy.Text (f_abjc ())) ->
                             case ds3_abjn of {
                               Data.Either.Left x_abjp -> f2_abjj x_abjp;
                               Data.Either.Right y_abjr -> ds2_abjk y_abjr
                             }) } in
                  let {
                    g_abjt
                      :: p_abjb () (f_abjc ())
                         -> p_abjb
                              (Data.Either.Either Data.Text.Internal.Lazy.Text ())
                              (Data.Either.Either Data.Text.Internal.Lazy.Text (f_abjc ()))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abjt
                      = Data.Profunctor.Choice.right'
                          @p_abjb
                          $dChoice_abjd
                          @()
                          @(f_abjc ())
                          @Data.Text.Internal.Lazy.Text } in
                  \ (x_abju :: p_abjb () (f_abjc ())) -> f1_abjf (g_abjt x_abju))
               `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                <Data.Text.Internal.Lazy.Text>_N)
                       :: Control.Lens.Type.Prism' Data.Text.Internal.Lazy.Text ()
                          ~R# Control.Lens.Empty.AsEmpty Data.Text.Internal.Lazy.Text))
              (Data.Functor.Contravariant.$fContravariantConst
                 @Data.Text.Internal.Lazy.Text)
              (Data.Functor.Const.$fFunctorConst @Data.Text.Internal.Lazy.Text)
    Cont:   ApplyToVal nodup hole Control.Lens.Getter.Getting
                                    Data.Text.Internal.Lazy.Text
                                    [GHC.Types.Char]
                                    Data.Text.Internal.Lazy.Text
              ((\ (ds_abe3 [Occ=Once1] :: a_abe0) -> ds_abe3)
               `cast` (<a_abe0>_R
                       %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                          <*>_N <a_abe0>_R <a_abe0>_P)
                       :: (a_abe0 -> a_abe0)
                          ~R# (a_abe0 -> Data.Functor.Const.Const a_abe0 a_abe0)))
            ApplyToVal nodup hole [GHC.Types.Char]
                                  -> Data.Functor.Const.Const
                                       Data.Text.Internal.Lazy.Text [GHC.Types.Char]
              s_a8OD
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N <Data.Text.Internal.Lazy.Text>_R <[GHC.Types.Char]>_P
                    :: Data.Functor.Const.Const
                         Data.Text.Internal.Lazy.Text [GHC.Types.Char]
                       ~R# Data.Text.Internal.Lazy.Text)
            Stop[RuleArgCtxt] Data.Text.Internal.Lazy.Text
Rule fired
    Rule: Class op fmap
    Module: (BUILTIN)
    Before: GHC.Base.fmap
              TyArg Data.Functor.Const.Const Data.Text.Internal.Lazy.Text
              ValArg Data.Functor.Const.$fFunctorConst
                       @Data.Text.Internal.Lazy.Text
    After:  (Data.Functor.Const.$fFunctorConst2
               @Data.Text.Internal.Lazy.Text)
            `cast` (forall (a :: <*>_N) (b :: <*>_N).
                    <a -> b>_R
                    %<'GHC.Types.Many>_N ->_R <Data.Functor.Const.Const
                                                 Data.Text.Internal.Lazy.Text a>_R
                    %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                  <*>_N <Data.Text.Internal.Lazy.Text>_R <a>_P
                                              ; Sym (Data.Functor.Const.N:Const[0]
                                                         <*>_N
                                                         <Data.Text.Internal.Lazy.Text>_R
                                                         <b>_P)
                    :: (forall {a} {b}.
                        (a -> b)
                        -> Data.Functor.Const.Const Data.Text.Internal.Lazy.Text a
                        -> Data.Functor.Const.Const Data.Text.Internal.Lazy.Text a)
                       ~R# (forall {a} {b}.
                            (a -> b)
                            -> Data.Functor.Const.Const Data.Text.Internal.Lazy.Text a
                            -> Data.Functor.Const.Const Data.Text.Internal.Lazy.Text b))
    Cont:   ApplyToTy Data.Text.Internal.Lazy.Text
            ApplyToTy GHC.Base.String
            ApplyToVal nodup hole (Data.Text.Internal.Lazy.Text
                                   -> GHC.Base.String)
                                  -> Data.Functor.Const.Const
                                       Data.Text.Internal.Lazy.Text Data.Text.Internal.Lazy.Text
                                  -> Data.Functor.Const.Const
                                       Data.Text.Internal.Lazy.Text GHC.Base.String
              Data.Text.Lazy.unpack
            ApplyToVal nodup hole Data.Functor.Const.Const
                                    Data.Text.Internal.Lazy.Text Data.Text.Internal.Lazy.Text
                                  -> Data.Functor.Const.Const
                                       Data.Text.Internal.Lazy.Text GHC.Base.String
              (bc_aboj (ab_aboh x_abok))
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N <Data.Text.Internal.Lazy.Text>_R <[GHC.Types.Char]>_P
                    :: Data.Functor.Const.Const
                         Data.Text.Internal.Lazy.Text [GHC.Types.Char]
                       ~R# Data.Text.Internal.Lazy.Text)
            Stop[RuleArgCtxt] Data.Text.Internal.Lazy.Text
Rule fired
    Rule: eqString
    Module: (GHC.Base)
    Before: GHC.Classes.==
              TyArg GHC.Base.String
              ValArg GHC.Classes.$fEqList_$s$fEqList1
              ValArg Data.Text.Lazy.unpack (Data.Text.Lazy.pack s_a8OD)
              ValArg s_a8OD
    After:  (\ ($dEq_aaZD :: GHC.Classes.Eq GHC.Base.String) ->
               GHC.Base.eqString)
              GHC.Classes.$fEqList_$s$fEqList1
              ValArg Data.Text.Lazy.unpack (Data.Text.Lazy.pack s_a8OD)
              ValArg s_a8OD
    Cont:   Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: unpack
    Module: (GHC.Base)
    Before: GHC.CString.unpackCString# ValArg "T -> TL -> T"#
    After:  (\ (a_ab6H :: GHC.Prim.Addr#) ->
               GHC.Base.build
                 @GHC.Types.Char
                 (\ (@b_ab6I) -> GHC.CString.unpackFoldrCString# @b_ab6I a_ab6H))
              "T -> TL -> T"#
    Cont:   Stop[BoringCtxt] Test.Tasty.Core.TestName
Rule fired
    Rule: Class op property
    Module: (BUILTIN)
    Before: Test.QuickCheck.Property.property
              TyArg Data.Text.Internal.Text -> GHC.Types.Bool
              ValArg $dTestable_a97V
    After:  Test.QuickCheck.Property.$fTestableFUN_$cproperty
              @Data.Text.Internal.Text
              @GHC.Types.Bool
              Test.QuickCheck.Instances.Text.$fArbitraryText0
              Data.Text.Show.$fShowText
              Test.QuickCheck.Property.$fTestableBool
    Cont:   ApplyToVal nodup hole (Data.Text.Internal.Text
                                   -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              prop_ab6U
            CastIt (Sym (Test.Tasty.QuickCheck.N:QC[0])
                    :: Test.QuickCheck.Property.Property ~R# Test.Tasty.QuickCheck.QC)
            Stop[BoringCtxt] Test.Tasty.QuickCheck.QC
Rule fired
    Rule: Class op propertyForAllShrinkShow
    Module: (BUILTIN)
    Before: Test.QuickCheck.Property.propertyForAllShrinkShow
              TyArg GHC.Types.Bool ValArg Test.QuickCheck.Property.$fTestableBool
    After:  Test.QuickCheck.Property.$fTestableBool1
            `cast` (forall (a :: <*>_N).
                    <Test.QuickCheck.Gen.Gen a>_R
                    %<'GHC.Types.Many>_N ->_R <a -> [a]>_R
                    %<'GHC.Types.Many>_N ->_R <a -> [GHC.Base.String]>_R
                    %<'GHC.Types.Many>_N ->_R <a -> GHC.Types.Bool>_R
                    %<'GHC.Types.Many>_N ->_R Sym (Test.QuickCheck.Gen.N:Gen[0]
                                                       (Test.QuickCheck.Property.N:Prop[0]))
                                              ; Sym (Test.QuickCheck.Property.N:Property[0])
                    :: (forall {a}.
                        Test.QuickCheck.Gen.Gen a
                        -> (a -> [a])
                        -> (a -> [GHC.Base.String])
                        -> (a -> GHC.Types.Bool)
                        -> Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int
                        -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result)
                       ~R# (forall {a}.
                            Test.QuickCheck.Gen.Gen a
                            -> (a -> [a])
                            -> (a -> [GHC.Base.String])
                            -> (a -> GHC.Types.Bool)
                            -> Test.QuickCheck.Property.Property))
    Cont:   ApplyToTy Data.Text.Internal.Text
            ApplyToVal nodup hole Test.QuickCheck.Gen.Gen
                                    Data.Text.Internal.Text
                                  -> (Data.Text.Internal.Text -> [Data.Text.Internal.Text])
                                  -> (Data.Text.Internal.Text -> [GHC.Base.String])
                                  -> (Data.Text.Internal.Text -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (Test.QuickCheck.Arbitrary.arbitrary @a_ab8C $dArbitrary_ab8E)
            ApplyToVal nodup hole (Data.Text.Internal.Text
                                   -> [Data.Text.Internal.Text])
                                  -> (Data.Text.Internal.Text -> [GHC.Base.String])
                                  -> (Data.Text.Internal.Text -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (Test.QuickCheck.Arbitrary.shrink @a_ab8C $dArbitrary_ab8E)
            ApplyToVal nodup hole (Data.Text.Internal.Text
                                   -> [GHC.Base.String])
                                  -> (Data.Text.Internal.Text -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (let {
                 g_ab8I [Occ=OnceL1!] :: a_ab8C -> GHC.Base.String
                 [LclId]
                 g_ab8I = GHC.Show.show @a_ab8C $dShow_ab8F } in
               \ (x_ab8J [Occ=Once1] :: a_ab8C) ->
                 GHC.Types.:
                   @GHC.Base.String (g_ab8I x_ab8J) (GHC.Types.[] @GHC.Base.String))
            ApplyToVal nodup hole (Data.Text.Internal.Text -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              f_ab8H
            CastIt (Sym (Test.Tasty.QuickCheck.N:QC[0])
                    :: Test.QuickCheck.Property.Property ~R# Test.Tasty.QuickCheck.QC)
            Stop[BoringCtxt] Test.Tasty.QuickCheck.QC
Rule fired
    Rule: Class op arbitrary
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.arbitrary
              TyArg Data.Text.Internal.Text
              ValArg Test.QuickCheck.Instances.Text.$fArbitraryText0
    After:  Test.QuickCheck.Instances.Text.$fArbitraryText3
            `cast` (Sym (Test.QuickCheck.Gen.N:Gen[0]
                             <Data.Text.Internal.Text>_R)
                    :: (Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int -> Data.Text.Internal.Text)
                       ~R# Test.QuickCheck.Gen.Gen Data.Text.Internal.Text)
    Cont:   Stop[BoringCtxt] Test.QuickCheck.Gen.Gen
                               Data.Text.Internal.Text
Rule fired
    Rule: Class op shrink
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.shrink
              TyArg Data.Text.Internal.Text
              ValArg Test.QuickCheck.Instances.Text.$fArbitraryText0
    After:  Test.QuickCheck.Instances.Text.$fArbitraryText0_$cshrink
    Cont:   Stop[BoringCtxt] Data.Text.Internal.Text
                             -> [Data.Text.Internal.Text]
Rule fired
    Rule: Class op show
    Module: (BUILTIN)
    Before: GHC.Show.show
              TyArg Data.Text.Internal.Text ValArg Data.Text.Show.$fShowText
    After:  Data.Text.Show.$fShowText_$cshow
    Cont:   Stop[RhsCtxt(NonRecursive)] Data.Text.Internal.Text
                                        -> GHC.Base.String
Rule fired
    Rule: Class op reader
    Module: (BUILTIN)
    Before: Control.Monad.Reader.Class.reader
              TyArg Data.Text.Internal.Lazy.Text
              TyArg (->) Data.Text.Internal.Lazy.Text
              ValArg Control.Monad.Reader.Class.$fMonadReaderrFUN
                       @Data.Text.Internal.Lazy.Text
    After:  \ (@a_abe8) ->
              GHC.Base.id @(Data.Text.Internal.Lazy.Text -> a_abe8)
    Cont:   ApplyToTy Data.Text.Internal.Text
            ApplyToVal nodup hole (Data.Text.Internal.Lazy.Text
                                   -> Data.Text.Internal.Text)
                                  -> Data.Text.Internal.Lazy.Text -> Data.Text.Internal.Text
              ((l_abe2
                  ((\ (ds_abe3 [Occ=Once1] :: a_abe0) -> ds_abe3)
                   `cast` (<a_abe0>_R
                           %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                              <*>_N <a_abe0>_R <a_abe0>_P)
                           :: (a_abe0 -> a_abe0)
                              ~R# (a_abe0 -> Data.Functor.Const.Const a_abe0 a_abe0))))
               `cast` (<s_abdY>_R
                       %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                     <*>_N <a_abe0>_R <s_abdY>_P
                       :: (s_abdY -> Data.Functor.Const.Const a_abe0 s_abdY)
                          ~R# (s_abdY -> a_abe0)))
            ApplyToVal nodup hole Data.Text.Internal.Lazy.Text
                                  -> Data.Text.Internal.Text
              (Control.Lens.Getter.view
                 @Data.Text.Internal.Text
                 @((->) Data.Text.Internal.Text)
                 @Data.Text.Internal.Lazy.Text
                 (Control.Monad.Reader.Class.$fMonadReaderrFUN
                    @Data.Text.Internal.Text)
                 (Control.Lens.Cons.Extras.recons
                    @Data.Text.Internal.Text
                    @GHC.Types.Char
                    @Data.Text.Internal.Lazy.Text
                    Control.Lens.Cons.$fConsTextTextCharChar0
                    Control.Lens.Cons.$fConsTextTextCharChar
                    Control.Lens.Empty.$fAsEmptyText
                    @(Data.Functor.Const.Const Data.Text.Internal.Lazy.Text)
                    (Data.Functor.Contravariant.$fContravariantConst
                       @Data.Text.Internal.Lazy.Text)
                    (Data.Functor.Const.$fFunctorConst @Data.Text.Internal.Lazy.Text))
                 s_a8OE)
            Stop[RuleArgCtxt] Data.Text.Internal.Text
Rule fired
    Rule: recons/text-strict
    Module: (Control.Lens.Cons.Extras)
    Before: Control.Lens.Cons.Extras.recons
              TyArg Data.Text.Internal.Lazy.Text
              TyArg GHC.Types.Char
              TyArg Data.Text.Internal.Text
              ValArg (\ (@(p_abip :: * -> * -> *))
                        (@(f_abiq :: * -> *))
                        ($dChoice_abir :: Data.Profunctor.Choice.Choice p_abip)
                        ($dApplicative_abis :: GHC.Base.Applicative f_abiq) ->
                        let {
                          f1_abit
                            :: p_abip
                                 (Data.Either.Either
                                    Data.Text.Internal.Lazy.Text
                                    (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                                 (Data.Either.Either
                                    Data.Text.Internal.Lazy.Text
                                    (f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                               -> p_abip
                                    Data.Text.Internal.Lazy.Text
                                    (f_abiq Data.Text.Internal.Lazy.Text)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 639 0}]
                          f1_abit
                            = Data.Profunctor.Unsafe.dimap
                                @p_abip
                                (Data.Profunctor.Choice.$p1Choice @p_abip $dChoice_abir)
                                @Data.Text.Internal.Lazy.Text
                                @(Data.Either.Either
                                    Data.Text.Internal.Lazy.Text
                                    (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                                @(Data.Either.Either
                                    Data.Text.Internal.Lazy.Text
                                    (f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                                @(f_abiq Data.Text.Internal.Lazy.Text)
                                (\ (s1_abiu :: Data.Text.Internal.Lazy.Text) ->
                                   case s1_abiu of {
                                     Data.Text.Internal.Lazy.Empty ->
                                       Data.Either.Left
                                         @Data.Text.Internal.Lazy.Text
                                         @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                         Data.Text.Internal.Lazy.Empty;
                                     Data.Text.Internal.Lazy.Chunk bx_abiB bx1_abiC bx2_abiD
                                                                   ts_abiE ->
                                       Data.Either.Right
                                         @Data.Text.Internal.Lazy.Text
                                         @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                         (case GHC.Prim.indexWord8Array# bx_abiB bx1_abiC of r#_abiG
                                          { __DEFAULT ->
                                          let {
                                            c#_abiH :: GHC.Prim.Int#
                                            [LclId,
                                             Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                     Value=False, ConLike=False, WorkFree=False,
                                                     Expandable=False,
                                                     Guidance=IF_ARGS [] 4 0}]
                                            c#_abiH
                                              = GHC.Prim.word2Int#
                                                  (GHC.Prim.clz8#
                                                     (GHC.Prim.and#
                                                        (GHC.Prim.not#
                                                           (GHC.Prim.word8ToWord# r#_abiG))
                                                        255##)) } in
                                          case GHC.Prim.xorI# c#_abiH (GHC.Prim.<=# c#_abiH 0#) of {
                                            __DEFAULT ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abiB (GHC.Prim.+# bx1_abiC 1#)
                                              of r#1_abiJ
                                              { __DEFAULT ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abiB (GHC.Prim.+# bx1_abiC 2#)
                                              of r#2_abiK
                                              { __DEFAULT ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abiB (GHC.Prim.+# bx1_abiC 3#)
                                              of r#3_abiL
                                              { __DEFAULT ->
                                              GHC.Types.C#
                                                (GHC.Prim.chr#
                                                   (GHC.Prim.-#
                                                      (GHC.Prim.+#
                                                         (GHC.Prim.+#
                                                            (GHC.Prim.+#
                                                               (GHC.Prim.uncheckedIShiftL#
                                                                  (GHC.Prim.-#
                                                                     (GHC.Prim.word2Int#
                                                                        (GHC.Prim.word8ToWord#
                                                                           r#_abiG))
                                                                     240#)
                                                                  18#)
                                                               (GHC.Prim.uncheckedIShiftL#
                                                                  (GHC.Prim.-#
                                                                     (GHC.Prim.word2Int#
                                                                        (GHC.Prim.word8ToWord#
                                                                           r#1_abiJ))
                                                                     128#)
                                                                  12#))
                                                            (GHC.Prim.uncheckedIShiftL#
                                                               (GHC.Prim.-#
                                                                  (GHC.Prim.word2Int#
                                                                     (GHC.Prim.word8ToWord#
                                                                        r#2_abiK))
                                                                  128#)
                                                               6#))
                                                         (GHC.Prim.word2Int#
                                                            (GHC.Prim.word8ToWord# r#3_abiL)))
                                                      128#))
                                              }
                                              }
                                              };
                                            1# ->
                                              GHC.Types.C#
                                                (GHC.Prim.chr#
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.word8ToWord# r#_abiG)));
                                            2# ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abiB (GHC.Prim.+# bx1_abiC 1#)
                                              of r#1_abiM
                                              { __DEFAULT ->
                                              GHC.Types.C#
                                                (GHC.Prim.chr#
                                                   (GHC.Prim.-#
                                                      (GHC.Prim.+#
                                                         (GHC.Prim.uncheckedIShiftL#
                                                            (GHC.Prim.-#
                                                               (GHC.Prim.word2Int#
                                                                  (GHC.Prim.word8ToWord# r#_abiG))
                                                               192#)
                                                            6#)
                                                         (GHC.Prim.word2Int#
                                                            (GHC.Prim.word8ToWord# r#1_abiM)))
                                                      128#))
                                              };
                                            3# ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abiB (GHC.Prim.+# bx1_abiC 1#)
                                              of r#1_abiN
                                              { __DEFAULT ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abiB (GHC.Prim.+# bx1_abiC 2#)
                                              of r#2_abiO
                                              { __DEFAULT ->
                                              GHC.Types.C#
                                                (GHC.Prim.chr#
                                                   (GHC.Prim.-#
                                                      (GHC.Prim.+#
                                                         (GHC.Prim.+#
                                                            (GHC.Prim.uncheckedIShiftL#
                                                               (GHC.Prim.-#
                                                                  (GHC.Prim.word2Int#
                                                                     (GHC.Prim.word8ToWord#
                                                                        r#_abiG))
                                                                  224#)
                                                               12#)
                                                            (GHC.Prim.uncheckedIShiftL#
                                                               (GHC.Prim.-#
                                                                  (GHC.Prim.word2Int#
                                                                     (GHC.Prim.word8ToWord#
                                                                        r#1_abiN))
                                                                  128#)
                                                               6#))
                                                         (GHC.Prim.word2Int#
                                                            (GHC.Prim.word8ToWord# r#2_abiO)))
                                                      128#))
                                              }
                                              }
                                          }
                                          },
                                          case Data.Text.compareLength
                                                 (Data.Text.Internal.Text bx_abiB bx1_abiC bx2_abiD)
                                                 (GHC.Types.I# 1#)
                                          of {
                                            __DEFAULT ->
                                              case GHC.Prim.indexWord8Array# bx_abiB bx1_abiC
                                              of r#_abiQ
                                              { __DEFAULT ->
                                              let {
                                                c#_abiR :: GHC.Prim.Int#
                                                [LclId,
                                                 Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                         Value=False, ConLike=False, WorkFree=False,
                                                         Expandable=False,
                                                         Guidance=IF_ARGS [] 4 0}]
                                                c#_abiR
                                                  = GHC.Prim.word2Int#
                                                      (GHC.Prim.clz8#
                                                         (GHC.Prim.and#
                                                            (GHC.Prim.not#
                                                               (GHC.Prim.word8ToWord# r#_abiQ))
                                                            255##)) } in
                                              let {
                                                y_abiS :: GHC.Prim.Int#
                                                [LclId,
                                                 Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                         Value=False, ConLike=False, WorkFree=False,
                                                         Expandable=False,
                                                         Guidance=IF_ARGS [] 2 0}]
                                                y_abiS
                                                  = GHC.Prim.xorI#
                                                      c#_abiR (GHC.Prim.<=# c#_abiR 0#) } in
                                              Data.Text.Internal.Lazy.$WChunk
                                                (Data.Text.Internal.$WText
                                                   (Data.Text.Array.ByteArray bx_abiB)
                                                   (GHC.Types.I# (GHC.Prim.+# bx1_abiC y_abiS))
                                                   (GHC.Types.I# (GHC.Prim.-# bx2_abiD y_abiS)))
                                                ts_abiE
                                              };
                                            GHC.Types.EQ -> ts_abiE
                                          })
                                   })
                                (let {
                                   f2_abiU
                                     :: Data.Text.Internal.Lazy.Text
                                        -> f_abiq Data.Text.Internal.Lazy.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abiU
                                     = GHC.Base.pure
                                         @f_abiq
                                         $dApplicative_abis
                                         @Data.Text.Internal.Lazy.Text } in
                                 let {
                                   ds2_abiV
                                     :: f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                        -> f_abiq Data.Text.Internal.Lazy.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 100 0}]
                                   ds2_abiV
                                     = GHC.Base.fmap
                                         @f_abiq
                                         (GHC.Base.$p1Applicative @f_abiq $dApplicative_abis)
                                         @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                         @Data.Text.Internal.Lazy.Text
                                         (\ (p1_abiW
                                               :: (GHC.Types.Char, Data.Text.Internal.Lazy.Text)) ->
                                            case p1_abiW of { (x_abiY, ds_abiZ) ->
                                            Data.Text.Lazy.cons x_abiY ds_abiZ
                                            }) } in
                                 \ (ds3_abj1
                                      :: Data.Either.Either
                                           Data.Text.Internal.Lazy.Text
                                           (f_abiq
                                              (GHC.Types.Char, Data.Text.Internal.Lazy.Text))) ->
                                   case ds3_abj1 of {
                                     Data.Either.Left x_abj3 -> f2_abiU x_abj3;
                                     Data.Either.Right y_abj5 -> ds2_abiV y_abj5
                                   }) } in
                        let {
                          g_abj7
                            :: p_abip
                                 (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                 (f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                               -> p_abip
                                    (Data.Either.Either
                                       Data.Text.Internal.Lazy.Text
                                       (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                                    (Data.Either.Either
                                       Data.Text.Internal.Lazy.Text
                                       (f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abj7
                            = Data.Profunctor.Choice.right'
                                @p_abip
                                $dChoice_abir
                                @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                @(f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                                @Data.Text.Internal.Lazy.Text } in
                        \ (x_abj8
                             :: p_abip
                                  (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                  (f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text))) ->
                          f1_abit (g_abj7 x_abj8))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <Data.Text.Internal.Lazy.Text>_N
                                      <Data.Text.Internal.Lazy.Text>_N
                                      <GHC.Types.Char>_N
                                      <GHC.Types.Char>_N)
                             :: Control.Lens.Type.Prism
                                  Data.Text.Internal.Lazy.Text
                                  Data.Text.Internal.Lazy.Text
                                  (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                  (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                ~R# Control.Lens.Cons.Cons
                                      Data.Text.Internal.Lazy.Text
                                      Data.Text.Internal.Lazy.Text
                                      GHC.Types.Char
                                      GHC.Types.Char)
              ValArg (\ (@(p_abhA :: * -> * -> *))
                        (@(f_abhB :: * -> *))
                        ($dChoice_abhC :: Data.Profunctor.Choice.Choice p_abhA)
                        ($dApplicative_abhD :: GHC.Base.Applicative f_abhB) ->
                        let {
                          f1_abhE
                            :: p_abhA
                                 (Data.Either.Either
                                    Data.Text.Internal.Text
                                    (GHC.Types.Char, Data.Text.Internal.Text))
                                 (Data.Either.Either
                                    Data.Text.Internal.Text
                                    (f_abhB (GHC.Types.Char, Data.Text.Internal.Text)))
                               -> p_abhA Data.Text.Internal.Text (f_abhB Data.Text.Internal.Text)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 340 0}]
                          f1_abhE
                            = Data.Profunctor.Unsafe.dimap
                                @p_abhA
                                (Data.Profunctor.Choice.$p1Choice @p_abhA $dChoice_abhC)
                                @Data.Text.Internal.Text
                                @(Data.Either.Either
                                    Data.Text.Internal.Text
                                    (GHC.Types.Char, Data.Text.Internal.Text))
                                @(Data.Either.Either
                                    Data.Text.Internal.Text
                                    (f_abhB (GHC.Types.Char, Data.Text.Internal.Text)))
                                @(f_abhB Data.Text.Internal.Text)
                                (\ (s1_abhF :: Data.Text.Internal.Text) ->
                                   case Data.Text.uncons s1_abhF of {
                                     GHC.Maybe.Nothing ->
                                       Data.Either.Left
                                         @Data.Text.Internal.Text
                                         @(GHC.Types.Char, Data.Text.Internal.Text)
                                         s1_abhF;
                                     GHC.Maybe.Just x_abhI ->
                                       Data.Either.Right
                                         @Data.Text.Internal.Text
                                         @(GHC.Types.Char, Data.Text.Internal.Text)
                                         x_abhI
                                   })
                                (let {
                                   f2_abhK
                                     :: Data.Text.Internal.Text -> f_abhB Data.Text.Internal.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abhK
                                     = GHC.Base.pure
                                         @f_abhB $dApplicative_abhD @Data.Text.Internal.Text } in
                                 let {
                                   ds2_abhL
                                     :: f_abhB (GHC.Types.Char, Data.Text.Internal.Text)
                                        -> f_abhB Data.Text.Internal.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 100 0}]
                                   ds2_abhL
                                     = GHC.Base.fmap
                                         @f_abhB
                                         (GHC.Base.$p1Applicative @f_abhB $dApplicative_abhD)
                                         @(GHC.Types.Char, Data.Text.Internal.Text)
                                         @Data.Text.Internal.Text
                                         (\ (p1_abhM
                                               :: (GHC.Types.Char, Data.Text.Internal.Text)) ->
                                            case p1_abhM of { (x_abhO, ds_abhP) ->
                                            Data.Text.cons x_abhO ds_abhP
                                            }) } in
                                 \ (ds3_abhR
                                      :: Data.Either.Either
                                           Data.Text.Internal.Text
                                           (f_abhB (GHC.Types.Char, Data.Text.Internal.Text))) ->
                                   case ds3_abhR of {
                                     Data.Either.Left x_abhT -> f2_abhK x_abhT;
                                     Data.Either.Right y_abhV -> ds2_abhL y_abhV
                                   }) } in
                        let {
                          g_abhX
                            :: p_abhA
                                 (GHC.Types.Char, Data.Text.Internal.Text)
                                 (f_abhB (GHC.Types.Char, Data.Text.Internal.Text))
                               -> p_abhA
                                    (Data.Either.Either
                                       Data.Text.Internal.Text
                                       (GHC.Types.Char, Data.Text.Internal.Text))
                                    (Data.Either.Either
                                       Data.Text.Internal.Text
                                       (f_abhB (GHC.Types.Char, Data.Text.Internal.Text)))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abhX
                            = Data.Profunctor.Choice.right'
                                @p_abhA
                                $dChoice_abhC
                                @(GHC.Types.Char, Data.Text.Internal.Text)
                                @(f_abhB (GHC.Types.Char, Data.Text.Internal.Text))
                                @Data.Text.Internal.Text } in
                        \ (x_abhY
                             :: p_abhA
                                  (GHC.Types.Char, Data.Text.Internal.Text)
                                  (f_abhB (GHC.Types.Char, Data.Text.Internal.Text))) ->
                          f1_abhE (g_abhX x_abhY))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <Data.Text.Internal.Text>_N
                                      <Data.Text.Internal.Text>_N
                                      <GHC.Types.Char>_N
                                      <GHC.Types.Char>_N)
                             :: Control.Lens.Type.Prism
                                  Data.Text.Internal.Text
                                  Data.Text.Internal.Text
                                  (GHC.Types.Char, Data.Text.Internal.Text)
                                  (GHC.Types.Char, Data.Text.Internal.Text)
                                ~R# Control.Lens.Cons.Cons
                                      Data.Text.Internal.Text
                                      Data.Text.Internal.Text
                                      GHC.Types.Char
                                      GHC.Types.Char)
              ValArg (\ (@(p_abhZ :: * -> * -> *))
                        (@(f_abi0 :: * -> *))
                        ($dChoice_abi1 :: Data.Profunctor.Choice.Choice p_abhZ)
                        ($dApplicative_abi2 :: GHC.Base.Applicative f_abi0) ->
                        let {
                          f1_abi3
                            :: p_abhZ
                                 (Data.Either.Either Data.Text.Internal.Text ())
                                 (Data.Either.Either Data.Text.Internal.Text (f_abi0 ()))
                               -> p_abhZ Data.Text.Internal.Text (f_abi0 Data.Text.Internal.Text)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 310 0}]
                          f1_abi3
                            = Data.Profunctor.Unsafe.dimap
                                @p_abhZ
                                (Data.Profunctor.Choice.$p1Choice @p_abhZ $dChoice_abi1)
                                @Data.Text.Internal.Text
                                @(Data.Either.Either Data.Text.Internal.Text ())
                                @(Data.Either.Either Data.Text.Internal.Text (f_abi0 ()))
                                @(f_abi0 Data.Text.Internal.Text)
                                (\ (s_abi4 :: Data.Text.Internal.Text) ->
                                   case Data.Text.null s_abi4 of {
                                     GHC.Types.False ->
                                       Data.Either.Left @Data.Text.Internal.Text @() s_abi4;
                                     GHC.Types.True ->
                                       Data.Either.Right
                                         @Data.Text.Internal.Text @() GHC.Tuple.Prim.()
                                   })
                                (let {
                                   f2_abi7
                                     :: Data.Text.Internal.Text -> f_abi0 Data.Text.Internal.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abi7
                                     = GHC.Base.pure
                                         @f_abi0 $dApplicative_abi2 @Data.Text.Internal.Text } in
                                 let {
                                   ds2_abi8 :: f_abi0 () -> f_abi0 Data.Text.Internal.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 70 0}]
                                   ds2_abi8
                                     = GHC.Base.fmap
                                         @f_abi0
                                         (GHC.Base.$p1Applicative @f_abi0 $dApplicative_abi2)
                                         @()
                                         @Data.Text.Internal.Text
                                         (\ (ds3_abi9 :: ()) ->
                                            case ds3_abi9 of { () ->
                                            Data.Text.Internal.empty
                                            }) } in
                                 \ (ds3_abib
                                      :: Data.Either.Either Data.Text.Internal.Text (f_abi0 ())) ->
                                   case ds3_abib of {
                                     Data.Either.Left x_abid -> f2_abi7 x_abid;
                                     Data.Either.Right y_abif -> ds2_abi8 y_abif
                                   }) } in
                        let {
                          g_abih
                            :: p_abhZ () (f_abi0 ())
                               -> p_abhZ
                                    (Data.Either.Either Data.Text.Internal.Text ())
                                    (Data.Either.Either Data.Text.Internal.Text (f_abi0 ()))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abih
                            = Data.Profunctor.Choice.right'
                                @p_abhZ
                                $dChoice_abi1
                                @()
                                @(f_abi0 ())
                                @Data.Text.Internal.Text } in
                        \ (x_abii :: p_abhZ () (f_abi0 ())) -> f1_abi3 (g_abih x_abii))
                     `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                      <Data.Text.Internal.Text>_N)
                             :: Control.Lens.Type.Prism' Data.Text.Internal.Text ()
                                ~R# Control.Lens.Empty.AsEmpty Data.Text.Internal.Text)
              TyArg Data.Functor.Const.Const Data.Text.Internal.Text
              ValArg Data.Functor.Contravariant.$fContravariantConst
                       @Data.Text.Internal.Text
              ValArg Data.Functor.Const.$fFunctorConst @Data.Text.Internal.Text
    After:  (\ (@(f_abel :: * -> *))
               ($dCons_abem
                  :: Control.Lens.Cons.Cons
                       Data.Text.Internal.Lazy.Text
                       Data.Text.Internal.Lazy.Text
                       GHC.Types.Char
                       GHC.Types.Char)
               ($dCons1_aben
                  :: Control.Lens.Cons.Cons
                       Data.Text.Internal.Text
                       Data.Text.Internal.Text
                       GHC.Types.Char
                       GHC.Types.Char)
               ($dAsEmpty_abeo
                  :: Control.Lens.Empty.AsEmpty Data.Text.Internal.Text)
               ($dContravariant_abep
                  :: Data.Functor.Contravariant.Contravariant f_abel)
               ($dFunctor_abeq :: GHC.Base.Functor f_abel) ->
               Data.Profunctor.Unsafe.$fProfunctorFUN_$cdimap
                 @Data.Text.Internal.Lazy.Text
                 @Data.Text.Internal.Text
                 @(f_abel Data.Text.Internal.Text)
                 @(f_abel Data.Text.Internal.Lazy.Text)
                 Data.Text.Lazy.toStrict
                 (GHC.Base.fmap
                    @f_abel
                    $dFunctor_abeq
                    @Data.Text.Internal.Text
                    @Data.Text.Internal.Lazy.Text
                    Data.Text.Lazy.fromStrict))
              @(Data.Functor.Const.Const Data.Text.Internal.Text)
              ((\ (@(p_abip :: * -> * -> *))
                  (@(f_abiq :: * -> *))
                  ($dChoice_abir :: Data.Profunctor.Choice.Choice p_abip)
                  ($dApplicative_abis :: GHC.Base.Applicative f_abiq) ->
                  let {
                    f1_abit
                      :: p_abip
                           (Data.Either.Either
                              Data.Text.Internal.Lazy.Text
                              (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                           (Data.Either.Either
                              Data.Text.Internal.Lazy.Text
                              (f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                         -> p_abip
                              Data.Text.Internal.Lazy.Text (f_abiq Data.Text.Internal.Lazy.Text)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 639 0}]
                    f1_abit
                      = Data.Profunctor.Unsafe.dimap
                          @p_abip
                          (Data.Profunctor.Choice.$p1Choice @p_abip $dChoice_abir)
                          @Data.Text.Internal.Lazy.Text
                          @(Data.Either.Either
                              Data.Text.Internal.Lazy.Text
                              (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                          @(Data.Either.Either
                              Data.Text.Internal.Lazy.Text
                              (f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                          @(f_abiq Data.Text.Internal.Lazy.Text)
                          (\ (s1_abiu :: Data.Text.Internal.Lazy.Text) ->
                             case s1_abiu of {
                               Data.Text.Internal.Lazy.Empty ->
                                 Data.Either.Left
                                   @Data.Text.Internal.Lazy.Text
                                   @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                   Data.Text.Internal.Lazy.Empty;
                               Data.Text.Internal.Lazy.Chunk bx_abiB bx1_abiC bx2_abiD ts_abiE ->
                                 Data.Either.Right
                                   @Data.Text.Internal.Lazy.Text
                                   @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                   (case GHC.Prim.indexWord8Array# bx_abiB bx1_abiC of r#_abiG
                                    { __DEFAULT ->
                                    let {
                                      c#_abiH :: GHC.Prim.Int#
                                      [LclId,
                                       Unf=Unf{Src=<vanilla>, TopLvl=False,
                                               Value=False, ConLike=False, WorkFree=False,
                                               Expandable=False,
                                               Guidance=IF_ARGS [] 4 0}]
                                      c#_abiH
                                        = GHC.Prim.word2Int#
                                            (GHC.Prim.clz8#
                                               (GHC.Prim.and#
                                                  (GHC.Prim.not# (GHC.Prim.word8ToWord# r#_abiG))
                                                  255##)) } in
                                    case GHC.Prim.xorI# c#_abiH (GHC.Prim.<=# c#_abiH 0#) of {
                                      __DEFAULT ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abiB (GHC.Prim.+# bx1_abiC 1#)
                                        of r#1_abiJ
                                        { __DEFAULT ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abiB (GHC.Prim.+# bx1_abiC 2#)
                                        of r#2_abiK
                                        { __DEFAULT ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abiB (GHC.Prim.+# bx1_abiC 3#)
                                        of r#3_abiL
                                        { __DEFAULT ->
                                        GHC.Types.C#
                                          (GHC.Prim.chr#
                                             (GHC.Prim.-#
                                                (GHC.Prim.+#
                                                   (GHC.Prim.+#
                                                      (GHC.Prim.+#
                                                         (GHC.Prim.uncheckedIShiftL#
                                                            (GHC.Prim.-#
                                                               (GHC.Prim.word2Int#
                                                                  (GHC.Prim.word8ToWord# r#_abiG))
                                                               240#)
                                                            18#)
                                                         (GHC.Prim.uncheckedIShiftL#
                                                            (GHC.Prim.-#
                                                               (GHC.Prim.word2Int#
                                                                  (GHC.Prim.word8ToWord# r#1_abiJ))
                                                               128#)
                                                            12#))
                                                      (GHC.Prim.uncheckedIShiftL#
                                                         (GHC.Prim.-#
                                                            (GHC.Prim.word2Int#
                                                               (GHC.Prim.word8ToWord# r#2_abiK))
                                                            128#)
                                                         6#))
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.word8ToWord# r#3_abiL)))
                                                128#))
                                        }
                                        }
                                        };
                                      1# ->
                                        GHC.Types.C#
                                          (GHC.Prim.chr#
                                             (GHC.Prim.word2Int# (GHC.Prim.word8ToWord# r#_abiG)));
                                      2# ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abiB (GHC.Prim.+# bx1_abiC 1#)
                                        of r#1_abiM
                                        { __DEFAULT ->
                                        GHC.Types.C#
                                          (GHC.Prim.chr#
                                             (GHC.Prim.-#
                                                (GHC.Prim.+#
                                                   (GHC.Prim.uncheckedIShiftL#
                                                      (GHC.Prim.-#
                                                         (GHC.Prim.word2Int#
                                                            (GHC.Prim.word8ToWord# r#_abiG))
                                                         192#)
                                                      6#)
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.word8ToWord# r#1_abiM)))
                                                128#))
                                        };
                                      3# ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abiB (GHC.Prim.+# bx1_abiC 1#)
                                        of r#1_abiN
                                        { __DEFAULT ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abiB (GHC.Prim.+# bx1_abiC 2#)
                                        of r#2_abiO
                                        { __DEFAULT ->
                                        GHC.Types.C#
                                          (GHC.Prim.chr#
                                             (GHC.Prim.-#
                                                (GHC.Prim.+#
                                                   (GHC.Prim.+#
                                                      (GHC.Prim.uncheckedIShiftL#
                                                         (GHC.Prim.-#
                                                            (GHC.Prim.word2Int#
                                                               (GHC.Prim.word8ToWord# r#_abiG))
                                                            224#)
                                                         12#)
                                                      (GHC.Prim.uncheckedIShiftL#
                                                         (GHC.Prim.-#
                                                            (GHC.Prim.word2Int#
                                                               (GHC.Prim.word8ToWord# r#1_abiN))
                                                            128#)
                                                         6#))
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.word8ToWord# r#2_abiO)))
                                                128#))
                                        }
                                        }
                                    }
                                    },
                                    case Data.Text.compareLength
                                           (Data.Text.Internal.Text bx_abiB bx1_abiC bx2_abiD)
                                           (GHC.Types.I# 1#)
                                    of {
                                      __DEFAULT ->
                                        case GHC.Prim.indexWord8Array# bx_abiB bx1_abiC of r#_abiQ
                                        { __DEFAULT ->
                                        let {
                                          c#_abiR :: GHC.Prim.Int#
                                          [LclId,
                                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                   Value=False, ConLike=False, WorkFree=False,
                                                   Expandable=False,
                                                   Guidance=IF_ARGS [] 4 0}]
                                          c#_abiR
                                            = GHC.Prim.word2Int#
                                                (GHC.Prim.clz8#
                                                   (GHC.Prim.and#
                                                      (GHC.Prim.not#
                                                         (GHC.Prim.word8ToWord# r#_abiQ))
                                                      255##)) } in
                                        let {
                                          y_abiS :: GHC.Prim.Int#
                                          [LclId,
                                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                   Value=False, ConLike=False, WorkFree=False,
                                                   Expandable=False,
                                                   Guidance=IF_ARGS [] 2 0}]
                                          y_abiS
                                            = GHC.Prim.xorI# c#_abiR (GHC.Prim.<=# c#_abiR 0#) } in
                                        Data.Text.Internal.Lazy.$WChunk
                                          (Data.Text.Internal.$WText
                                             (Data.Text.Array.ByteArray bx_abiB)
                                             (GHC.Types.I# (GHC.Prim.+# bx1_abiC y_abiS))
                                             (GHC.Types.I# (GHC.Prim.-# bx2_abiD y_abiS)))
                                          ts_abiE
                                        };
                                      GHC.Types.EQ -> ts_abiE
                                    })
                             })
                          (let {
                             f2_abiU
                               :: Data.Text.Internal.Lazy.Text
                                  -> f_abiq Data.Text.Internal.Lazy.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abiU
                               = GHC.Base.pure
                                   @f_abiq $dApplicative_abis @Data.Text.Internal.Lazy.Text } in
                           let {
                             ds2_abiV
                               :: f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                  -> f_abiq Data.Text.Internal.Lazy.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 100 0}]
                             ds2_abiV
                               = GHC.Base.fmap
                                   @f_abiq
                                   (GHC.Base.$p1Applicative @f_abiq $dApplicative_abis)
                                   @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                   @Data.Text.Internal.Lazy.Text
                                   (\ (p1_abiW :: (GHC.Types.Char, Data.Text.Internal.Lazy.Text)) ->
                                      case p1_abiW of { (x_abiY, ds_abiZ) ->
                                      Data.Text.Lazy.cons x_abiY ds_abiZ
                                      }) } in
                           \ (ds3_abj1
                                :: Data.Either.Either
                                     Data.Text.Internal.Lazy.Text
                                     (f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text))) ->
                             case ds3_abj1 of {
                               Data.Either.Left x_abj3 -> f2_abiU x_abj3;
                               Data.Either.Right y_abj5 -> ds2_abiV y_abj5
                             }) } in
                  let {
                    g_abj7
                      :: p_abip
                           (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                           (f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                         -> p_abip
                              (Data.Either.Either
                                 Data.Text.Internal.Lazy.Text
                                 (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                              (Data.Either.Either
                                 Data.Text.Internal.Lazy.Text
                                 (f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abj7
                      = Data.Profunctor.Choice.right'
                          @p_abip
                          $dChoice_abir
                          @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                          @(f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                          @Data.Text.Internal.Lazy.Text } in
                  \ (x_abj8
                       :: p_abip
                            (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                            (f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text))) ->
                    f1_abit (g_abj7 x_abj8))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <Data.Text.Internal.Lazy.Text>_N
                                <Data.Text.Internal.Lazy.Text>_N
                                <GHC.Types.Char>_N
                                <GHC.Types.Char>_N)
                       :: Control.Lens.Type.Prism
                            Data.Text.Internal.Lazy.Text
                            Data.Text.Internal.Lazy.Text
                            (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                            (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                          ~R# Control.Lens.Cons.Cons
                                Data.Text.Internal.Lazy.Text
                                Data.Text.Internal.Lazy.Text
                                GHC.Types.Char
                                GHC.Types.Char))
              ((\ (@(p_abhA :: * -> * -> *))
                  (@(f_abhB :: * -> *))
                  ($dChoice_abhC :: Data.Profunctor.Choice.Choice p_abhA)
                  ($dApplicative_abhD :: GHC.Base.Applicative f_abhB) ->
                  let {
                    f1_abhE
                      :: p_abhA
                           (Data.Either.Either
                              Data.Text.Internal.Text (GHC.Types.Char, Data.Text.Internal.Text))
                           (Data.Either.Either
                              Data.Text.Internal.Text
                              (f_abhB (GHC.Types.Char, Data.Text.Internal.Text)))
                         -> p_abhA Data.Text.Internal.Text (f_abhB Data.Text.Internal.Text)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 340 0}]
                    f1_abhE
                      = Data.Profunctor.Unsafe.dimap
                          @p_abhA
                          (Data.Profunctor.Choice.$p1Choice @p_abhA $dChoice_abhC)
                          @Data.Text.Internal.Text
                          @(Data.Either.Either
                              Data.Text.Internal.Text (GHC.Types.Char, Data.Text.Internal.Text))
                          @(Data.Either.Either
                              Data.Text.Internal.Text
                              (f_abhB (GHC.Types.Char, Data.Text.Internal.Text)))
                          @(f_abhB Data.Text.Internal.Text)
                          (\ (s1_abhF :: Data.Text.Internal.Text) ->
                             case Data.Text.uncons s1_abhF of {
                               GHC.Maybe.Nothing ->
                                 Data.Either.Left
                                   @Data.Text.Internal.Text
                                   @(GHC.Types.Char, Data.Text.Internal.Text)
                                   s1_abhF;
                               GHC.Maybe.Just x_abhI ->
                                 Data.Either.Right
                                   @Data.Text.Internal.Text
                                   @(GHC.Types.Char, Data.Text.Internal.Text)
                                   x_abhI
                             })
                          (let {
                             f2_abhK
                               :: Data.Text.Internal.Text -> f_abhB Data.Text.Internal.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abhK
                               = GHC.Base.pure
                                   @f_abhB $dApplicative_abhD @Data.Text.Internal.Text } in
                           let {
                             ds2_abhL
                               :: f_abhB (GHC.Types.Char, Data.Text.Internal.Text)
                                  -> f_abhB Data.Text.Internal.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 100 0}]
                             ds2_abhL
                               = GHC.Base.fmap
                                   @f_abhB
                                   (GHC.Base.$p1Applicative @f_abhB $dApplicative_abhD)
                                   @(GHC.Types.Char, Data.Text.Internal.Text)
                                   @Data.Text.Internal.Text
                                   (\ (p1_abhM :: (GHC.Types.Char, Data.Text.Internal.Text)) ->
                                      case p1_abhM of { (x_abhO, ds_abhP) ->
                                      Data.Text.cons x_abhO ds_abhP
                                      }) } in
                           \ (ds3_abhR
                                :: Data.Either.Either
                                     Data.Text.Internal.Text
                                     (f_abhB (GHC.Types.Char, Data.Text.Internal.Text))) ->
                             case ds3_abhR of {
                               Data.Either.Left x_abhT -> f2_abhK x_abhT;
                               Data.Either.Right y_abhV -> ds2_abhL y_abhV
                             }) } in
                  let {
                    g_abhX
                      :: p_abhA
                           (GHC.Types.Char, Data.Text.Internal.Text)
                           (f_abhB (GHC.Types.Char, Data.Text.Internal.Text))
                         -> p_abhA
                              (Data.Either.Either
                                 Data.Text.Internal.Text (GHC.Types.Char, Data.Text.Internal.Text))
                              (Data.Either.Either
                                 Data.Text.Internal.Text
                                 (f_abhB (GHC.Types.Char, Data.Text.Internal.Text)))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abhX
                      = Data.Profunctor.Choice.right'
                          @p_abhA
                          $dChoice_abhC
                          @(GHC.Types.Char, Data.Text.Internal.Text)
                          @(f_abhB (GHC.Types.Char, Data.Text.Internal.Text))
                          @Data.Text.Internal.Text } in
                  \ (x_abhY
                       :: p_abhA
                            (GHC.Types.Char, Data.Text.Internal.Text)
                            (f_abhB (GHC.Types.Char, Data.Text.Internal.Text))) ->
                    f1_abhE (g_abhX x_abhY))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <Data.Text.Internal.Text>_N
                                <Data.Text.Internal.Text>_N
                                <GHC.Types.Char>_N
                                <GHC.Types.Char>_N)
                       :: Control.Lens.Type.Prism
                            Data.Text.Internal.Text
                            Data.Text.Internal.Text
                            (GHC.Types.Char, Data.Text.Internal.Text)
                            (GHC.Types.Char, Data.Text.Internal.Text)
                          ~R# Control.Lens.Cons.Cons
                                Data.Text.Internal.Text
                                Data.Text.Internal.Text
                                GHC.Types.Char
                                GHC.Types.Char))
              ((\ (@(p_abhZ :: * -> * -> *))
                  (@(f_abi0 :: * -> *))
                  ($dChoice_abi1 :: Data.Profunctor.Choice.Choice p_abhZ)
                  ($dApplicative_abi2 :: GHC.Base.Applicative f_abi0) ->
                  let {
                    f1_abi3
                      :: p_abhZ
                           (Data.Either.Either Data.Text.Internal.Text ())
                           (Data.Either.Either Data.Text.Internal.Text (f_abi0 ()))
                         -> p_abhZ Data.Text.Internal.Text (f_abi0 Data.Text.Internal.Text)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 310 0}]
                    f1_abi3
                      = Data.Profunctor.Unsafe.dimap
                          @p_abhZ
                          (Data.Profunctor.Choice.$p1Choice @p_abhZ $dChoice_abi1)
                          @Data.Text.Internal.Text
                          @(Data.Either.Either Data.Text.Internal.Text ())
                          @(Data.Either.Either Data.Text.Internal.Text (f_abi0 ()))
                          @(f_abi0 Data.Text.Internal.Text)
                          (\ (s_abi4 :: Data.Text.Internal.Text) ->
                             case Data.Text.null s_abi4 of {
                               GHC.Types.False ->
                                 Data.Either.Left @Data.Text.Internal.Text @() s_abi4;
                               GHC.Types.True ->
                                 Data.Either.Right @Data.Text.Internal.Text @() GHC.Tuple.Prim.()
                             })
                          (let {
                             f2_abi7
                               :: Data.Text.Internal.Text -> f_abi0 Data.Text.Internal.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abi7
                               = GHC.Base.pure
                                   @f_abi0 $dApplicative_abi2 @Data.Text.Internal.Text } in
                           let {
                             ds2_abi8 :: f_abi0 () -> f_abi0 Data.Text.Internal.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 70 0}]
                             ds2_abi8
                               = GHC.Base.fmap
                                   @f_abi0
                                   (GHC.Base.$p1Applicative @f_abi0 $dApplicative_abi2)
                                   @()
                                   @Data.Text.Internal.Text
                                   (\ (ds3_abi9 :: ()) ->
                                      case ds3_abi9 of { () -> Data.Text.Internal.empty }) } in
                           \ (ds3_abib
                                :: Data.Either.Either Data.Text.Internal.Text (f_abi0 ())) ->
                             case ds3_abib of {
                               Data.Either.Left x_abid -> f2_abi7 x_abid;
                               Data.Either.Right y_abif -> ds2_abi8 y_abif
                             }) } in
                  let {
                    g_abih
                      :: p_abhZ () (f_abi0 ())
                         -> p_abhZ
                              (Data.Either.Either Data.Text.Internal.Text ())
                              (Data.Either.Either Data.Text.Internal.Text (f_abi0 ()))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abih
                      = Data.Profunctor.Choice.right'
                          @p_abhZ
                          $dChoice_abi1
                          @()
                          @(f_abi0 ())
                          @Data.Text.Internal.Text } in
                  \ (x_abii :: p_abhZ () (f_abi0 ())) -> f1_abi3 (g_abih x_abii))
               `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                <Data.Text.Internal.Text>_N)
                       :: Control.Lens.Type.Prism' Data.Text.Internal.Text ()
                          ~R# Control.Lens.Empty.AsEmpty Data.Text.Internal.Text))
              (Data.Functor.Contravariant.$fContravariantConst
                 @Data.Text.Internal.Text)
              (Data.Functor.Const.$fFunctorConst @Data.Text.Internal.Text)
    Cont:   ApplyToVal nodup hole Control.Lens.Getter.Getting
                                    Data.Text.Internal.Text
                                    Data.Text.Internal.Lazy.Text
                                    Data.Text.Internal.Text
              ((\ (ds_abe3 [Occ=Once1] :: a_abe0) -> ds_abe3)
               `cast` (<a_abe0>_R
                       %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                          <*>_N <a_abe0>_R <a_abe0>_P)
                       :: (a_abe0 -> a_abe0)
                          ~R# (a_abe0 -> Data.Functor.Const.Const a_abe0 a_abe0)))
            ApplyToVal nodup hole Data.Text.Internal.Lazy.Text
                                  -> Data.Functor.Const.Const
                                       Data.Text.Internal.Text Data.Text.Internal.Lazy.Text
              (Control.Lens.Getter.view
                 @Data.Text.Internal.Text
                 @((->) Data.Text.Internal.Text)
                 @Data.Text.Internal.Lazy.Text
                 (Control.Monad.Reader.Class.$fMonadReaderrFUN
                    @Data.Text.Internal.Text)
                 (Control.Lens.Cons.Extras.recons
                    @Data.Text.Internal.Text
                    @GHC.Types.Char
                    @Data.Text.Internal.Lazy.Text
                    Control.Lens.Cons.$fConsTextTextCharChar0
                    Control.Lens.Cons.$fConsTextTextCharChar
                    Control.Lens.Empty.$fAsEmptyText
                    @(Data.Functor.Const.Const Data.Text.Internal.Lazy.Text)
                    (Data.Functor.Contravariant.$fContravariantConst
                       @Data.Text.Internal.Lazy.Text)
                    (Data.Functor.Const.$fFunctorConst @Data.Text.Internal.Lazy.Text))
                 s_a8OE)
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N <Data.Text.Internal.Text>_R <Data.Text.Internal.Lazy.Text>_P
                    :: Data.Functor.Const.Const
                         Data.Text.Internal.Text Data.Text.Internal.Lazy.Text
                       ~R# Data.Text.Internal.Text)
            Stop[RuleArgCtxt] Data.Text.Internal.Text
Rule fired
    Rule: Class op fmap
    Module: (BUILTIN)
    Before: GHC.Base.fmap
              TyArg Data.Functor.Const.Const Data.Text.Internal.Text
              ValArg Data.Functor.Const.$fFunctorConst @Data.Text.Internal.Text
    After:  (Data.Functor.Const.$fFunctorConst2
               @Data.Text.Internal.Text)
            `cast` (forall (a :: <*>_N) (b :: <*>_N).
                    <a -> b>_R
                    %<'GHC.Types.Many>_N ->_R <Data.Functor.Const.Const
                                                 Data.Text.Internal.Text a>_R
                    %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                  <*>_N <Data.Text.Internal.Text>_R <a>_P
                                              ; Sym (Data.Functor.Const.N:Const[0]
                                                         <*>_N <Data.Text.Internal.Text>_R <b>_P)
                    :: (forall {a} {b}.
                        (a -> b)
                        -> Data.Functor.Const.Const Data.Text.Internal.Text a
                        -> Data.Functor.Const.Const Data.Text.Internal.Text a)
                       ~R# (forall {a} {b}.
                            (a -> b)
                            -> Data.Functor.Const.Const Data.Text.Internal.Text a
                            -> Data.Functor.Const.Const Data.Text.Internal.Text b))
    Cont:   ApplyToTy Data.Text.Internal.Text
            ApplyToTy Data.Text.Internal.Lazy.Text
            ApplyToVal nodup hole (Data.Text.Internal.Text
                                   -> Data.Text.Internal.Lazy.Text)
                                  -> Data.Functor.Const.Const
                                       Data.Text.Internal.Text Data.Text.Internal.Text
                                  -> Data.Functor.Const.Const
                                       Data.Text.Internal.Text Data.Text.Internal.Lazy.Text
              Data.Text.Lazy.fromStrict
            ApplyToVal nodup hole Data.Functor.Const.Const
                                    Data.Text.Internal.Text Data.Text.Internal.Text
                                  -> Data.Functor.Const.Const
                                       Data.Text.Internal.Text Data.Text.Internal.Lazy.Text
              (bc_aboj (ab_aboh x_abok))
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N <Data.Text.Internal.Text>_R <Data.Text.Internal.Lazy.Text>_P
                    :: Data.Functor.Const.Const
                         Data.Text.Internal.Text Data.Text.Internal.Lazy.Text
                       ~R# Data.Text.Internal.Text)
            Stop[RuleArgCtxt] Data.Text.Internal.Text
Rule fired
    Rule: Class op reader
    Module: (BUILTIN)
    Before: Control.Monad.Reader.Class.reader
              TyArg Data.Text.Internal.Text
              TyArg (->) Data.Text.Internal.Text
              ValArg Control.Monad.Reader.Class.$fMonadReaderrFUN
                       @Data.Text.Internal.Text
    After:  \ (@a_abe8) ->
              GHC.Base.id @(Data.Text.Internal.Text -> a_abe8)
    Cont:   ApplyToTy Data.Text.Internal.Lazy.Text
            ApplyToVal nodup hole (Data.Text.Internal.Text
                                   -> Data.Text.Internal.Lazy.Text)
                                  -> Data.Text.Internal.Text -> Data.Text.Internal.Lazy.Text
              ((l_abe2
                  ((\ (ds_abe3 [Occ=Once1] :: a_abe0) -> ds_abe3)
                   `cast` (<a_abe0>_R
                           %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                              <*>_N <a_abe0>_R <a_abe0>_P)
                           :: (a_abe0 -> a_abe0)
                              ~R# (a_abe0 -> Data.Functor.Const.Const a_abe0 a_abe0))))
               `cast` (<s_abdY>_R
                       %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                     <*>_N <a_abe0>_R <s_abdY>_P
                       :: (s_abdY -> Data.Functor.Const.Const a_abe0 s_abdY)
                          ~R# (s_abdY -> a_abe0)))
            ApplyToVal nodup hole Data.Text.Internal.Text
                                  -> Data.Text.Internal.Lazy.Text
              s_a8OE
            Stop[RuleArgCtxt] Data.Text.Internal.Lazy.Text
Rule fired
    Rule: recons/text-lazy
    Module: (Control.Lens.Cons.Extras)
    Before: Control.Lens.Cons.Extras.recons
              TyArg Data.Text.Internal.Text
              TyArg GHC.Types.Char
              TyArg Data.Text.Internal.Lazy.Text
              ValArg (\ (@(p_abhA :: * -> * -> *))
                        (@(f_abhB :: * -> *))
                        ($dChoice_abhC :: Data.Profunctor.Choice.Choice p_abhA)
                        ($dApplicative_abhD :: GHC.Base.Applicative f_abhB) ->
                        let {
                          f1_abhE
                            :: p_abhA
                                 (Data.Either.Either
                                    Data.Text.Internal.Text
                                    (GHC.Types.Char, Data.Text.Internal.Text))
                                 (Data.Either.Either
                                    Data.Text.Internal.Text
                                    (f_abhB (GHC.Types.Char, Data.Text.Internal.Text)))
                               -> p_abhA Data.Text.Internal.Text (f_abhB Data.Text.Internal.Text)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 340 0}]
                          f1_abhE
                            = Data.Profunctor.Unsafe.dimap
                                @p_abhA
                                (Data.Profunctor.Choice.$p1Choice @p_abhA $dChoice_abhC)
                                @Data.Text.Internal.Text
                                @(Data.Either.Either
                                    Data.Text.Internal.Text
                                    (GHC.Types.Char, Data.Text.Internal.Text))
                                @(Data.Either.Either
                                    Data.Text.Internal.Text
                                    (f_abhB (GHC.Types.Char, Data.Text.Internal.Text)))
                                @(f_abhB Data.Text.Internal.Text)
                                (\ (s1_abhF :: Data.Text.Internal.Text) ->
                                   case Data.Text.uncons s1_abhF of {
                                     GHC.Maybe.Nothing ->
                                       Data.Either.Left
                                         @Data.Text.Internal.Text
                                         @(GHC.Types.Char, Data.Text.Internal.Text)
                                         s1_abhF;
                                     GHC.Maybe.Just x_abhI ->
                                       Data.Either.Right
                                         @Data.Text.Internal.Text
                                         @(GHC.Types.Char, Data.Text.Internal.Text)
                                         x_abhI
                                   })
                                (let {
                                   f2_abhK
                                     :: Data.Text.Internal.Text -> f_abhB Data.Text.Internal.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abhK
                                     = GHC.Base.pure
                                         @f_abhB $dApplicative_abhD @Data.Text.Internal.Text } in
                                 let {
                                   ds2_abhL
                                     :: f_abhB (GHC.Types.Char, Data.Text.Internal.Text)
                                        -> f_abhB Data.Text.Internal.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 100 0}]
                                   ds2_abhL
                                     = GHC.Base.fmap
                                         @f_abhB
                                         (GHC.Base.$p1Applicative @f_abhB $dApplicative_abhD)
                                         @(GHC.Types.Char, Data.Text.Internal.Text)
                                         @Data.Text.Internal.Text
                                         (\ (p1_abhM
                                               :: (GHC.Types.Char, Data.Text.Internal.Text)) ->
                                            case p1_abhM of { (x_abhO, ds_abhP) ->
                                            Data.Text.cons x_abhO ds_abhP
                                            }) } in
                                 \ (ds3_abhR
                                      :: Data.Either.Either
                                           Data.Text.Internal.Text
                                           (f_abhB (GHC.Types.Char, Data.Text.Internal.Text))) ->
                                   case ds3_abhR of {
                                     Data.Either.Left x_abhT -> f2_abhK x_abhT;
                                     Data.Either.Right y_abhV -> ds2_abhL y_abhV
                                   }) } in
                        let {
                          g_abhX
                            :: p_abhA
                                 (GHC.Types.Char, Data.Text.Internal.Text)
                                 (f_abhB (GHC.Types.Char, Data.Text.Internal.Text))
                               -> p_abhA
                                    (Data.Either.Either
                                       Data.Text.Internal.Text
                                       (GHC.Types.Char, Data.Text.Internal.Text))
                                    (Data.Either.Either
                                       Data.Text.Internal.Text
                                       (f_abhB (GHC.Types.Char, Data.Text.Internal.Text)))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abhX
                            = Data.Profunctor.Choice.right'
                                @p_abhA
                                $dChoice_abhC
                                @(GHC.Types.Char, Data.Text.Internal.Text)
                                @(f_abhB (GHC.Types.Char, Data.Text.Internal.Text))
                                @Data.Text.Internal.Text } in
                        \ (x_abhY
                             :: p_abhA
                                  (GHC.Types.Char, Data.Text.Internal.Text)
                                  (f_abhB (GHC.Types.Char, Data.Text.Internal.Text))) ->
                          f1_abhE (g_abhX x_abhY))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <Data.Text.Internal.Text>_N
                                      <Data.Text.Internal.Text>_N
                                      <GHC.Types.Char>_N
                                      <GHC.Types.Char>_N)
                             :: Control.Lens.Type.Prism
                                  Data.Text.Internal.Text
                                  Data.Text.Internal.Text
                                  (GHC.Types.Char, Data.Text.Internal.Text)
                                  (GHC.Types.Char, Data.Text.Internal.Text)
                                ~R# Control.Lens.Cons.Cons
                                      Data.Text.Internal.Text
                                      Data.Text.Internal.Text
                                      GHC.Types.Char
                                      GHC.Types.Char)
              ValArg (\ (@(p_abip :: * -> * -> *))
                        (@(f_abiq :: * -> *))
                        ($dChoice_abir :: Data.Profunctor.Choice.Choice p_abip)
                        ($dApplicative_abis :: GHC.Base.Applicative f_abiq) ->
                        let {
                          f1_abit
                            :: p_abip
                                 (Data.Either.Either
                                    Data.Text.Internal.Lazy.Text
                                    (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                                 (Data.Either.Either
                                    Data.Text.Internal.Lazy.Text
                                    (f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                               -> p_abip
                                    Data.Text.Internal.Lazy.Text
                                    (f_abiq Data.Text.Internal.Lazy.Text)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 639 0}]
                          f1_abit
                            = Data.Profunctor.Unsafe.dimap
                                @p_abip
                                (Data.Profunctor.Choice.$p1Choice @p_abip $dChoice_abir)
                                @Data.Text.Internal.Lazy.Text
                                @(Data.Either.Either
                                    Data.Text.Internal.Lazy.Text
                                    (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                                @(Data.Either.Either
                                    Data.Text.Internal.Lazy.Text
                                    (f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                                @(f_abiq Data.Text.Internal.Lazy.Text)
                                (\ (s1_abiu :: Data.Text.Internal.Lazy.Text) ->
                                   case s1_abiu of {
                                     Data.Text.Internal.Lazy.Empty ->
                                       Data.Either.Left
                                         @Data.Text.Internal.Lazy.Text
                                         @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                         Data.Text.Internal.Lazy.Empty;
                                     Data.Text.Internal.Lazy.Chunk bx_abiB bx1_abiC bx2_abiD
                                                                   ts_abiE ->
                                       Data.Either.Right
                                         @Data.Text.Internal.Lazy.Text
                                         @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                         (case GHC.Prim.indexWord8Array# bx_abiB bx1_abiC of r#_abiG
                                          { __DEFAULT ->
                                          let {
                                            c#_abiH :: GHC.Prim.Int#
                                            [LclId,
                                             Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                     Value=False, ConLike=False, WorkFree=False,
                                                     Expandable=False,
                                                     Guidance=IF_ARGS [] 4 0}]
                                            c#_abiH
                                              = GHC.Prim.word2Int#
                                                  (GHC.Prim.clz8#
                                                     (GHC.Prim.and#
                                                        (GHC.Prim.not#
                                                           (GHC.Prim.word8ToWord# r#_abiG))
                                                        255##)) } in
                                          case GHC.Prim.xorI# c#_abiH (GHC.Prim.<=# c#_abiH 0#) of {
                                            __DEFAULT ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abiB (GHC.Prim.+# bx1_abiC 1#)
                                              of r#1_abiJ
                                              { __DEFAULT ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abiB (GHC.Prim.+# bx1_abiC 2#)
                                              of r#2_abiK
                                              { __DEFAULT ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abiB (GHC.Prim.+# bx1_abiC 3#)
                                              of r#3_abiL
                                              { __DEFAULT ->
                                              GHC.Types.C#
                                                (GHC.Prim.chr#
                                                   (GHC.Prim.-#
                                                      (GHC.Prim.+#
                                                         (GHC.Prim.+#
                                                            (GHC.Prim.+#
                                                               (GHC.Prim.uncheckedIShiftL#
                                                                  (GHC.Prim.-#
                                                                     (GHC.Prim.word2Int#
                                                                        (GHC.Prim.word8ToWord#
                                                                           r#_abiG))
                                                                     240#)
                                                                  18#)
                                                               (GHC.Prim.uncheckedIShiftL#
                                                                  (GHC.Prim.-#
                                                                     (GHC.Prim.word2Int#
                                                                        (GHC.Prim.word8ToWord#
                                                                           r#1_abiJ))
                                                                     128#)
                                                                  12#))
                                                            (GHC.Prim.uncheckedIShiftL#
                                                               (GHC.Prim.-#
                                                                  (GHC.Prim.word2Int#
                                                                     (GHC.Prim.word8ToWord#
                                                                        r#2_abiK))
                                                                  128#)
                                                               6#))
                                                         (GHC.Prim.word2Int#
                                                            (GHC.Prim.word8ToWord# r#3_abiL)))
                                                      128#))
                                              }
                                              }
                                              };
                                            1# ->
                                              GHC.Types.C#
                                                (GHC.Prim.chr#
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.word8ToWord# r#_abiG)));
                                            2# ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abiB (GHC.Prim.+# bx1_abiC 1#)
                                              of r#1_abiM
                                              { __DEFAULT ->
                                              GHC.Types.C#
                                                (GHC.Prim.chr#
                                                   (GHC.Prim.-#
                                                      (GHC.Prim.+#
                                                         (GHC.Prim.uncheckedIShiftL#
                                                            (GHC.Prim.-#
                                                               (GHC.Prim.word2Int#
                                                                  (GHC.Prim.word8ToWord# r#_abiG))
                                                               192#)
                                                            6#)
                                                         (GHC.Prim.word2Int#
                                                            (GHC.Prim.word8ToWord# r#1_abiM)))
                                                      128#))
                                              };
                                            3# ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abiB (GHC.Prim.+# bx1_abiC 1#)
                                              of r#1_abiN
                                              { __DEFAULT ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abiB (GHC.Prim.+# bx1_abiC 2#)
                                              of r#2_abiO
                                              { __DEFAULT ->
                                              GHC.Types.C#
                                                (GHC.Prim.chr#
                                                   (GHC.Prim.-#
                                                      (GHC.Prim.+#
                                                         (GHC.Prim.+#
                                                            (GHC.Prim.uncheckedIShiftL#
                                                               (GHC.Prim.-#
                                                                  (GHC.Prim.word2Int#
                                                                     (GHC.Prim.word8ToWord#
                                                                        r#_abiG))
                                                                  224#)
                                                               12#)
                                                            (GHC.Prim.uncheckedIShiftL#
                                                               (GHC.Prim.-#
                                                                  (GHC.Prim.word2Int#
                                                                     (GHC.Prim.word8ToWord#
                                                                        r#1_abiN))
                                                                  128#)
                                                               6#))
                                                         (GHC.Prim.word2Int#
                                                            (GHC.Prim.word8ToWord# r#2_abiO)))
                                                      128#))
                                              }
                                              }
                                          }
                                          },
                                          case Data.Text.compareLength
                                                 (Data.Text.Internal.Text bx_abiB bx1_abiC bx2_abiD)
                                                 (GHC.Types.I# 1#)
                                          of {
                                            __DEFAULT ->
                                              case GHC.Prim.indexWord8Array# bx_abiB bx1_abiC
                                              of r#_abiQ
                                              { __DEFAULT ->
                                              let {
                                                c#_abiR :: GHC.Prim.Int#
                                                [LclId,
                                                 Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                         Value=False, ConLike=False, WorkFree=False,
                                                         Expandable=False,
                                                         Guidance=IF_ARGS [] 4 0}]
                                                c#_abiR
                                                  = GHC.Prim.word2Int#
                                                      (GHC.Prim.clz8#
                                                         (GHC.Prim.and#
                                                            (GHC.Prim.not#
                                                               (GHC.Prim.word8ToWord# r#_abiQ))
                                                            255##)) } in
                                              let {
                                                y_abiS :: GHC.Prim.Int#
                                                [LclId,
                                                 Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                         Value=False, ConLike=False, WorkFree=False,
                                                         Expandable=False,
                                                         Guidance=IF_ARGS [] 2 0}]
                                                y_abiS
                                                  = GHC.Prim.xorI#
                                                      c#_abiR (GHC.Prim.<=# c#_abiR 0#) } in
                                              Data.Text.Internal.Lazy.$WChunk
                                                (Data.Text.Internal.$WText
                                                   (Data.Text.Array.ByteArray bx_abiB)
                                                   (GHC.Types.I# (GHC.Prim.+# bx1_abiC y_abiS))
                                                   (GHC.Types.I# (GHC.Prim.-# bx2_abiD y_abiS)))
                                                ts_abiE
                                              };
                                            GHC.Types.EQ -> ts_abiE
                                          })
                                   })
                                (let {
                                   f2_abiU
                                     :: Data.Text.Internal.Lazy.Text
                                        -> f_abiq Data.Text.Internal.Lazy.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abiU
                                     = GHC.Base.pure
                                         @f_abiq
                                         $dApplicative_abis
                                         @Data.Text.Internal.Lazy.Text } in
                                 let {
                                   ds2_abiV
                                     :: f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                        -> f_abiq Data.Text.Internal.Lazy.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 100 0}]
                                   ds2_abiV
                                     = GHC.Base.fmap
                                         @f_abiq
                                         (GHC.Base.$p1Applicative @f_abiq $dApplicative_abis)
                                         @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                         @Data.Text.Internal.Lazy.Text
                                         (\ (p1_abiW
                                               :: (GHC.Types.Char, Data.Text.Internal.Lazy.Text)) ->
                                            case p1_abiW of { (x_abiY, ds_abiZ) ->
                                            Data.Text.Lazy.cons x_abiY ds_abiZ
                                            }) } in
                                 \ (ds3_abj1
                                      :: Data.Either.Either
                                           Data.Text.Internal.Lazy.Text
                                           (f_abiq
                                              (GHC.Types.Char, Data.Text.Internal.Lazy.Text))) ->
                                   case ds3_abj1 of {
                                     Data.Either.Left x_abj3 -> f2_abiU x_abj3;
                                     Data.Either.Right y_abj5 -> ds2_abiV y_abj5
                                   }) } in
                        let {
                          g_abj7
                            :: p_abip
                                 (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                 (f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                               -> p_abip
                                    (Data.Either.Either
                                       Data.Text.Internal.Lazy.Text
                                       (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                                    (Data.Either.Either
                                       Data.Text.Internal.Lazy.Text
                                       (f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abj7
                            = Data.Profunctor.Choice.right'
                                @p_abip
                                $dChoice_abir
                                @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                @(f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                                @Data.Text.Internal.Lazy.Text } in
                        \ (x_abj8
                             :: p_abip
                                  (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                  (f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text))) ->
                          f1_abit (g_abj7 x_abj8))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <Data.Text.Internal.Lazy.Text>_N
                                      <Data.Text.Internal.Lazy.Text>_N
                                      <GHC.Types.Char>_N
                                      <GHC.Types.Char>_N)
                             :: Control.Lens.Type.Prism
                                  Data.Text.Internal.Lazy.Text
                                  Data.Text.Internal.Lazy.Text
                                  (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                  (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                ~R# Control.Lens.Cons.Cons
                                      Data.Text.Internal.Lazy.Text
                                      Data.Text.Internal.Lazy.Text
                                      GHC.Types.Char
                                      GHC.Types.Char)
              ValArg (\ (@(p_abjb :: * -> * -> *))
                        (@(f_abjc :: * -> *))
                        ($dChoice_abjd :: Data.Profunctor.Choice.Choice p_abjb)
                        ($dApplicative_abje :: GHC.Base.Applicative f_abjc) ->
                        let {
                          f1_abjf
                            :: p_abjb
                                 (Data.Either.Either Data.Text.Internal.Lazy.Text ())
                                 (Data.Either.Either Data.Text.Internal.Lazy.Text (f_abjc ()))
                               -> p_abjb
                                    Data.Text.Internal.Lazy.Text
                                    (f_abjc Data.Text.Internal.Lazy.Text)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 310 0}]
                          f1_abjf
                            = Data.Profunctor.Unsafe.dimap
                                @p_abjb
                                (Data.Profunctor.Choice.$p1Choice @p_abjb $dChoice_abjd)
                                @Data.Text.Internal.Lazy.Text
                                @(Data.Either.Either Data.Text.Internal.Lazy.Text ())
                                @(Data.Either.Either Data.Text.Internal.Lazy.Text (f_abjc ()))
                                @(f_abjc Data.Text.Internal.Lazy.Text)
                                (\ (s_abjg :: Data.Text.Internal.Lazy.Text) ->
                                   case Data.Text.Lazy.null s_abjg of {
                                     GHC.Types.False ->
                                       Data.Either.Left @Data.Text.Internal.Lazy.Text @() s_abjg;
                                     GHC.Types.True ->
                                       Data.Either.Right
                                         @Data.Text.Internal.Lazy.Text @() GHC.Tuple.Prim.()
                                   })
                                (let {
                                   f2_abjj
                                     :: Data.Text.Internal.Lazy.Text
                                        -> f_abjc Data.Text.Internal.Lazy.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abjj
                                     = GHC.Base.pure
                                         @f_abjc
                                         $dApplicative_abje
                                         @Data.Text.Internal.Lazy.Text } in
                                 let {
                                   ds2_abjk :: f_abjc () -> f_abjc Data.Text.Internal.Lazy.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 70 0}]
                                   ds2_abjk
                                     = GHC.Base.fmap
                                         @f_abjc
                                         (GHC.Base.$p1Applicative @f_abjc $dApplicative_abje)
                                         @()
                                         @Data.Text.Internal.Lazy.Text
                                         (\ (ds3_abjl :: ()) ->
                                            case ds3_abjl of { () ->
                                            Data.Text.Internal.Lazy.empty
                                            }) } in
                                 \ (ds3_abjn
                                      :: Data.Either.Either
                                           Data.Text.Internal.Lazy.Text (f_abjc ())) ->
                                   case ds3_abjn of {
                                     Data.Either.Left x_abjp -> f2_abjj x_abjp;
                                     Data.Either.Right y_abjr -> ds2_abjk y_abjr
                                   }) } in
                        let {
                          g_abjt
                            :: p_abjb () (f_abjc ())
                               -> p_abjb
                                    (Data.Either.Either Data.Text.Internal.Lazy.Text ())
                                    (Data.Either.Either Data.Text.Internal.Lazy.Text (f_abjc ()))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abjt
                            = Data.Profunctor.Choice.right'
                                @p_abjb
                                $dChoice_abjd
                                @()
                                @(f_abjc ())
                                @Data.Text.Internal.Lazy.Text } in
                        \ (x_abju :: p_abjb () (f_abjc ())) -> f1_abjf (g_abjt x_abju))
                     `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                      <Data.Text.Internal.Lazy.Text>_N)
                             :: Control.Lens.Type.Prism' Data.Text.Internal.Lazy.Text ()
                                ~R# Control.Lens.Empty.AsEmpty Data.Text.Internal.Lazy.Text)
              TyArg Data.Functor.Const.Const Data.Text.Internal.Lazy.Text
              ValArg Data.Functor.Contravariant.$fContravariantConst
                       @Data.Text.Internal.Lazy.Text
              ValArg Data.Functor.Const.$fFunctorConst
                       @Data.Text.Internal.Lazy.Text
    After:  (\ (@(f_aber :: * -> *))
               ($dCons_abes
                  :: Control.Lens.Cons.Cons
                       Data.Text.Internal.Text
                       Data.Text.Internal.Text
                       GHC.Types.Char
                       GHC.Types.Char)
               ($dCons1_abet
                  :: Control.Lens.Cons.Cons
                       Data.Text.Internal.Lazy.Text
                       Data.Text.Internal.Lazy.Text
                       GHC.Types.Char
                       GHC.Types.Char)
               ($dAsEmpty_abeu
                  :: Control.Lens.Empty.AsEmpty Data.Text.Internal.Lazy.Text)
               ($dContravariant_abev
                  :: Data.Functor.Contravariant.Contravariant f_aber)
               ($dFunctor_abew :: GHC.Base.Functor f_aber) ->
               Data.Profunctor.Unsafe.$fProfunctorFUN_$cdimap
                 @Data.Text.Internal.Text
                 @Data.Text.Internal.Lazy.Text
                 @(f_aber Data.Text.Internal.Lazy.Text)
                 @(f_aber Data.Text.Internal.Text)
                 Data.Text.Lazy.fromStrict
                 (GHC.Base.fmap
                    @f_aber
                    $dFunctor_abew
                    @Data.Text.Internal.Lazy.Text
                    @Data.Text.Internal.Text
                    Data.Text.Lazy.toStrict))
              @(Data.Functor.Const.Const Data.Text.Internal.Lazy.Text)
              ((\ (@(p_abhA :: * -> * -> *))
                  (@(f_abhB :: * -> *))
                  ($dChoice_abhC :: Data.Profunctor.Choice.Choice p_abhA)
                  ($dApplicative_abhD :: GHC.Base.Applicative f_abhB) ->
                  let {
                    f1_abhE
                      :: p_abhA
                           (Data.Either.Either
                              Data.Text.Internal.Text (GHC.Types.Char, Data.Text.Internal.Text))
                           (Data.Either.Either
                              Data.Text.Internal.Text
                              (f_abhB (GHC.Types.Char, Data.Text.Internal.Text)))
                         -> p_abhA Data.Text.Internal.Text (f_abhB Data.Text.Internal.Text)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 340 0}]
                    f1_abhE
                      = Data.Profunctor.Unsafe.dimap
                          @p_abhA
                          (Data.Profunctor.Choice.$p1Choice @p_abhA $dChoice_abhC)
                          @Data.Text.Internal.Text
                          @(Data.Either.Either
                              Data.Text.Internal.Text (GHC.Types.Char, Data.Text.Internal.Text))
                          @(Data.Either.Either
                              Data.Text.Internal.Text
                              (f_abhB (GHC.Types.Char, Data.Text.Internal.Text)))
                          @(f_abhB Data.Text.Internal.Text)
                          (\ (s1_abhF :: Data.Text.Internal.Text) ->
                             case Data.Text.uncons s1_abhF of {
                               GHC.Maybe.Nothing ->
                                 Data.Either.Left
                                   @Data.Text.Internal.Text
                                   @(GHC.Types.Char, Data.Text.Internal.Text)
                                   s1_abhF;
                               GHC.Maybe.Just x_abhI ->
                                 Data.Either.Right
                                   @Data.Text.Internal.Text
                                   @(GHC.Types.Char, Data.Text.Internal.Text)
                                   x_abhI
                             })
                          (let {
                             f2_abhK
                               :: Data.Text.Internal.Text -> f_abhB Data.Text.Internal.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abhK
                               = GHC.Base.pure
                                   @f_abhB $dApplicative_abhD @Data.Text.Internal.Text } in
                           let {
                             ds2_abhL
                               :: f_abhB (GHC.Types.Char, Data.Text.Internal.Text)
                                  -> f_abhB Data.Text.Internal.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 100 0}]
                             ds2_abhL
                               = GHC.Base.fmap
                                   @f_abhB
                                   (GHC.Base.$p1Applicative @f_abhB $dApplicative_abhD)
                                   @(GHC.Types.Char, Data.Text.Internal.Text)
                                   @Data.Text.Internal.Text
                                   (\ (p1_abhM :: (GHC.Types.Char, Data.Text.Internal.Text)) ->
                                      case p1_abhM of { (x_abhO, ds_abhP) ->
                                      Data.Text.cons x_abhO ds_abhP
                                      }) } in
                           \ (ds3_abhR
                                :: Data.Either.Either
                                     Data.Text.Internal.Text
                                     (f_abhB (GHC.Types.Char, Data.Text.Internal.Text))) ->
                             case ds3_abhR of {
                               Data.Either.Left x_abhT -> f2_abhK x_abhT;
                               Data.Either.Right y_abhV -> ds2_abhL y_abhV
                             }) } in
                  let {
                    g_abhX
                      :: p_abhA
                           (GHC.Types.Char, Data.Text.Internal.Text)
                           (f_abhB (GHC.Types.Char, Data.Text.Internal.Text))
                         -> p_abhA
                              (Data.Either.Either
                                 Data.Text.Internal.Text (GHC.Types.Char, Data.Text.Internal.Text))
                              (Data.Either.Either
                                 Data.Text.Internal.Text
                                 (f_abhB (GHC.Types.Char, Data.Text.Internal.Text)))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abhX
                      = Data.Profunctor.Choice.right'
                          @p_abhA
                          $dChoice_abhC
                          @(GHC.Types.Char, Data.Text.Internal.Text)
                          @(f_abhB (GHC.Types.Char, Data.Text.Internal.Text))
                          @Data.Text.Internal.Text } in
                  \ (x_abhY
                       :: p_abhA
                            (GHC.Types.Char, Data.Text.Internal.Text)
                            (f_abhB (GHC.Types.Char, Data.Text.Internal.Text))) ->
                    f1_abhE (g_abhX x_abhY))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <Data.Text.Internal.Text>_N
                                <Data.Text.Internal.Text>_N
                                <GHC.Types.Char>_N
                                <GHC.Types.Char>_N)
                       :: Control.Lens.Type.Prism
                            Data.Text.Internal.Text
                            Data.Text.Internal.Text
                            (GHC.Types.Char, Data.Text.Internal.Text)
                            (GHC.Types.Char, Data.Text.Internal.Text)
                          ~R# Control.Lens.Cons.Cons
                                Data.Text.Internal.Text
                                Data.Text.Internal.Text
                                GHC.Types.Char
                                GHC.Types.Char))
              ((\ (@(p_abip :: * -> * -> *))
                  (@(f_abiq :: * -> *))
                  ($dChoice_abir :: Data.Profunctor.Choice.Choice p_abip)
                  ($dApplicative_abis :: GHC.Base.Applicative f_abiq) ->
                  let {
                    f1_abit
                      :: p_abip
                           (Data.Either.Either
                              Data.Text.Internal.Lazy.Text
                              (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                           (Data.Either.Either
                              Data.Text.Internal.Lazy.Text
                              (f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                         -> p_abip
                              Data.Text.Internal.Lazy.Text (f_abiq Data.Text.Internal.Lazy.Text)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 639 0}]
                    f1_abit
                      = Data.Profunctor.Unsafe.dimap
                          @p_abip
                          (Data.Profunctor.Choice.$p1Choice @p_abip $dChoice_abir)
                          @Data.Text.Internal.Lazy.Text
                          @(Data.Either.Either
                              Data.Text.Internal.Lazy.Text
                              (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                          @(Data.Either.Either
                              Data.Text.Internal.Lazy.Text
                              (f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                          @(f_abiq Data.Text.Internal.Lazy.Text)
                          (\ (s1_abiu :: Data.Text.Internal.Lazy.Text) ->
                             case s1_abiu of {
                               Data.Text.Internal.Lazy.Empty ->
                                 Data.Either.Left
                                   @Data.Text.Internal.Lazy.Text
                                   @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                   Data.Text.Internal.Lazy.Empty;
                               Data.Text.Internal.Lazy.Chunk bx_abiB bx1_abiC bx2_abiD ts_abiE ->
                                 Data.Either.Right
                                   @Data.Text.Internal.Lazy.Text
                                   @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                   (case GHC.Prim.indexWord8Array# bx_abiB bx1_abiC of r#_abiG
                                    { __DEFAULT ->
                                    let {
                                      c#_abiH :: GHC.Prim.Int#
                                      [LclId,
                                       Unf=Unf{Src=<vanilla>, TopLvl=False,
                                               Value=False, ConLike=False, WorkFree=False,
                                               Expandable=False,
                                               Guidance=IF_ARGS [] 4 0}]
                                      c#_abiH
                                        = GHC.Prim.word2Int#
                                            (GHC.Prim.clz8#
                                               (GHC.Prim.and#
                                                  (GHC.Prim.not# (GHC.Prim.word8ToWord# r#_abiG))
                                                  255##)) } in
                                    case GHC.Prim.xorI# c#_abiH (GHC.Prim.<=# c#_abiH 0#) of {
                                      __DEFAULT ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abiB (GHC.Prim.+# bx1_abiC 1#)
                                        of r#1_abiJ
                                        { __DEFAULT ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abiB (GHC.Prim.+# bx1_abiC 2#)
                                        of r#2_abiK
                                        { __DEFAULT ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abiB (GHC.Prim.+# bx1_abiC 3#)
                                        of r#3_abiL
                                        { __DEFAULT ->
                                        GHC.Types.C#
                                          (GHC.Prim.chr#
                                             (GHC.Prim.-#
                                                (GHC.Prim.+#
                                                   (GHC.Prim.+#
                                                      (GHC.Prim.+#
                                                         (GHC.Prim.uncheckedIShiftL#
                                                            (GHC.Prim.-#
                                                               (GHC.Prim.word2Int#
                                                                  (GHC.Prim.word8ToWord# r#_abiG))
                                                               240#)
                                                            18#)
                                                         (GHC.Prim.uncheckedIShiftL#
                                                            (GHC.Prim.-#
                                                               (GHC.Prim.word2Int#
                                                                  (GHC.Prim.word8ToWord# r#1_abiJ))
                                                               128#)
                                                            12#))
                                                      (GHC.Prim.uncheckedIShiftL#
                                                         (GHC.Prim.-#
                                                            (GHC.Prim.word2Int#
                                                               (GHC.Prim.word8ToWord# r#2_abiK))
                                                            128#)
                                                         6#))
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.word8ToWord# r#3_abiL)))
                                                128#))
                                        }
                                        }
                                        };
                                      1# ->
                                        GHC.Types.C#
                                          (GHC.Prim.chr#
                                             (GHC.Prim.word2Int# (GHC.Prim.word8ToWord# r#_abiG)));
                                      2# ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abiB (GHC.Prim.+# bx1_abiC 1#)
                                        of r#1_abiM
                                        { __DEFAULT ->
                                        GHC.Types.C#
                                          (GHC.Prim.chr#
                                             (GHC.Prim.-#
                                                (GHC.Prim.+#
                                                   (GHC.Prim.uncheckedIShiftL#
                                                      (GHC.Prim.-#
                                                         (GHC.Prim.word2Int#
                                                            (GHC.Prim.word8ToWord# r#_abiG))
                                                         192#)
                                                      6#)
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.word8ToWord# r#1_abiM)))
                                                128#))
                                        };
                                      3# ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abiB (GHC.Prim.+# bx1_abiC 1#)
                                        of r#1_abiN
                                        { __DEFAULT ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abiB (GHC.Prim.+# bx1_abiC 2#)
                                        of r#2_abiO
                                        { __DEFAULT ->
                                        GHC.Types.C#
                                          (GHC.Prim.chr#
                                             (GHC.Prim.-#
                                                (GHC.Prim.+#
                                                   (GHC.Prim.+#
                                                      (GHC.Prim.uncheckedIShiftL#
                                                         (GHC.Prim.-#
                                                            (GHC.Prim.word2Int#
                                                               (GHC.Prim.word8ToWord# r#_abiG))
                                                            224#)
                                                         12#)
                                                      (GHC.Prim.uncheckedIShiftL#
                                                         (GHC.Prim.-#
                                                            (GHC.Prim.word2Int#
                                                               (GHC.Prim.word8ToWord# r#1_abiN))
                                                            128#)
                                                         6#))
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.word8ToWord# r#2_abiO)))
                                                128#))
                                        }
                                        }
                                    }
                                    },
                                    case Data.Text.compareLength
                                           (Data.Text.Internal.Text bx_abiB bx1_abiC bx2_abiD)
                                           (GHC.Types.I# 1#)
                                    of {
                                      __DEFAULT ->
                                        case GHC.Prim.indexWord8Array# bx_abiB bx1_abiC of r#_abiQ
                                        { __DEFAULT ->
                                        let {
                                          c#_abiR :: GHC.Prim.Int#
                                          [LclId,
                                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                   Value=False, ConLike=False, WorkFree=False,
                                                   Expandable=False,
                                                   Guidance=IF_ARGS [] 4 0}]
                                          c#_abiR
                                            = GHC.Prim.word2Int#
                                                (GHC.Prim.clz8#
                                                   (GHC.Prim.and#
                                                      (GHC.Prim.not#
                                                         (GHC.Prim.word8ToWord# r#_abiQ))
                                                      255##)) } in
                                        let {
                                          y_abiS :: GHC.Prim.Int#
                                          [LclId,
                                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                   Value=False, ConLike=False, WorkFree=False,
                                                   Expandable=False,
                                                   Guidance=IF_ARGS [] 2 0}]
                                          y_abiS
                                            = GHC.Prim.xorI# c#_abiR (GHC.Prim.<=# c#_abiR 0#) } in
                                        Data.Text.Internal.Lazy.$WChunk
                                          (Data.Text.Internal.$WText
                                             (Data.Text.Array.ByteArray bx_abiB)
                                             (GHC.Types.I# (GHC.Prim.+# bx1_abiC y_abiS))
                                             (GHC.Types.I# (GHC.Prim.-# bx2_abiD y_abiS)))
                                          ts_abiE
                                        };
                                      GHC.Types.EQ -> ts_abiE
                                    })
                             })
                          (let {
                             f2_abiU
                               :: Data.Text.Internal.Lazy.Text
                                  -> f_abiq Data.Text.Internal.Lazy.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abiU
                               = GHC.Base.pure
                                   @f_abiq $dApplicative_abis @Data.Text.Internal.Lazy.Text } in
                           let {
                             ds2_abiV
                               :: f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                  -> f_abiq Data.Text.Internal.Lazy.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 100 0}]
                             ds2_abiV
                               = GHC.Base.fmap
                                   @f_abiq
                                   (GHC.Base.$p1Applicative @f_abiq $dApplicative_abis)
                                   @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                   @Data.Text.Internal.Lazy.Text
                                   (\ (p1_abiW :: (GHC.Types.Char, Data.Text.Internal.Lazy.Text)) ->
                                      case p1_abiW of { (x_abiY, ds_abiZ) ->
                                      Data.Text.Lazy.cons x_abiY ds_abiZ
                                      }) } in
                           \ (ds3_abj1
                                :: Data.Either.Either
                                     Data.Text.Internal.Lazy.Text
                                     (f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text))) ->
                             case ds3_abj1 of {
                               Data.Either.Left x_abj3 -> f2_abiU x_abj3;
                               Data.Either.Right y_abj5 -> ds2_abiV y_abj5
                             }) } in
                  let {
                    g_abj7
                      :: p_abip
                           (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                           (f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                         -> p_abip
                              (Data.Either.Either
                                 Data.Text.Internal.Lazy.Text
                                 (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                              (Data.Either.Either
                                 Data.Text.Internal.Lazy.Text
                                 (f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abj7
                      = Data.Profunctor.Choice.right'
                          @p_abip
                          $dChoice_abir
                          @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                          @(f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                          @Data.Text.Internal.Lazy.Text } in
                  \ (x_abj8
                       :: p_abip
                            (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                            (f_abiq (GHC.Types.Char, Data.Text.Internal.Lazy.Text))) ->
                    f1_abit (g_abj7 x_abj8))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <Data.Text.Internal.Lazy.Text>_N
                                <Data.Text.Internal.Lazy.Text>_N
                                <GHC.Types.Char>_N
                                <GHC.Types.Char>_N)
                       :: Control.Lens.Type.Prism
                            Data.Text.Internal.Lazy.Text
                            Data.Text.Internal.Lazy.Text
                            (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                            (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                          ~R# Control.Lens.Cons.Cons
                                Data.Text.Internal.Lazy.Text
                                Data.Text.Internal.Lazy.Text
                                GHC.Types.Char
                                GHC.Types.Char))
              ((\ (@(p_abjb :: * -> * -> *))
                  (@(f_abjc :: * -> *))
                  ($dChoice_abjd :: Data.Profunctor.Choice.Choice p_abjb)
                  ($dApplicative_abje :: GHC.Base.Applicative f_abjc) ->
                  let {
                    f1_abjf
                      :: p_abjb
                           (Data.Either.Either Data.Text.Internal.Lazy.Text ())
                           (Data.Either.Either Data.Text.Internal.Lazy.Text (f_abjc ()))
                         -> p_abjb
                              Data.Text.Internal.Lazy.Text (f_abjc Data.Text.Internal.Lazy.Text)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 310 0}]
                    f1_abjf
                      = Data.Profunctor.Unsafe.dimap
                          @p_abjb
                          (Data.Profunctor.Choice.$p1Choice @p_abjb $dChoice_abjd)
                          @Data.Text.Internal.Lazy.Text
                          @(Data.Either.Either Data.Text.Internal.Lazy.Text ())
                          @(Data.Either.Either Data.Text.Internal.Lazy.Text (f_abjc ()))
                          @(f_abjc Data.Text.Internal.Lazy.Text)
                          (\ (s_abjg :: Data.Text.Internal.Lazy.Text) ->
                             case Data.Text.Lazy.null s_abjg of {
                               GHC.Types.False ->
                                 Data.Either.Left @Data.Text.Internal.Lazy.Text @() s_abjg;
                               GHC.Types.True ->
                                 Data.Either.Right
                                   @Data.Text.Internal.Lazy.Text @() GHC.Tuple.Prim.()
                             })
                          (let {
                             f2_abjj
                               :: Data.Text.Internal.Lazy.Text
                                  -> f_abjc Data.Text.Internal.Lazy.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abjj
                               = GHC.Base.pure
                                   @f_abjc $dApplicative_abje @Data.Text.Internal.Lazy.Text } in
                           let {
                             ds2_abjk :: f_abjc () -> f_abjc Data.Text.Internal.Lazy.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 70 0}]
                             ds2_abjk
                               = GHC.Base.fmap
                                   @f_abjc
                                   (GHC.Base.$p1Applicative @f_abjc $dApplicative_abje)
                                   @()
                                   @Data.Text.Internal.Lazy.Text
                                   (\ (ds3_abjl :: ()) ->
                                      case ds3_abjl of { () -> Data.Text.Internal.Lazy.empty }) } in
                           \ (ds3_abjn
                                :: Data.Either.Either Data.Text.Internal.Lazy.Text (f_abjc ())) ->
                             case ds3_abjn of {
                               Data.Either.Left x_abjp -> f2_abjj x_abjp;
                               Data.Either.Right y_abjr -> ds2_abjk y_abjr
                             }) } in
                  let {
                    g_abjt
                      :: p_abjb () (f_abjc ())
                         -> p_abjb
                              (Data.Either.Either Data.Text.Internal.Lazy.Text ())
                              (Data.Either.Either Data.Text.Internal.Lazy.Text (f_abjc ()))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abjt
                      = Data.Profunctor.Choice.right'
                          @p_abjb
                          $dChoice_abjd
                          @()
                          @(f_abjc ())
                          @Data.Text.Internal.Lazy.Text } in
                  \ (x_abju :: p_abjb () (f_abjc ())) -> f1_abjf (g_abjt x_abju))
               `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                <Data.Text.Internal.Lazy.Text>_N)
                       :: Control.Lens.Type.Prism' Data.Text.Internal.Lazy.Text ()
                          ~R# Control.Lens.Empty.AsEmpty Data.Text.Internal.Lazy.Text))
              (Data.Functor.Contravariant.$fContravariantConst
                 @Data.Text.Internal.Lazy.Text)
              (Data.Functor.Const.$fFunctorConst @Data.Text.Internal.Lazy.Text)
    Cont:   ApplyToVal nodup hole Control.Lens.Getter.Getting
                                    Data.Text.Internal.Lazy.Text
                                    Data.Text.Internal.Text
                                    Data.Text.Internal.Lazy.Text
              ((\ (ds_abe3 [Occ=Once1] :: a_abe0) -> ds_abe3)
               `cast` (<a_abe0>_R
                       %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                          <*>_N <a_abe0>_R <a_abe0>_P)
                       :: (a_abe0 -> a_abe0)
                          ~R# (a_abe0 -> Data.Functor.Const.Const a_abe0 a_abe0)))
            ApplyToVal nodup hole Data.Text.Internal.Text
                                  -> Data.Functor.Const.Const
                                       Data.Text.Internal.Lazy.Text Data.Text.Internal.Text
              s_a8OE
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N <Data.Text.Internal.Lazy.Text>_R <Data.Text.Internal.Text>_P
                    :: Data.Functor.Const.Const
                         Data.Text.Internal.Lazy.Text Data.Text.Internal.Text
                       ~R# Data.Text.Internal.Lazy.Text)
            Stop[RuleArgCtxt] Data.Text.Internal.Lazy.Text
Rule fired
    Rule: Class op fmap
    Module: (BUILTIN)
    Before: GHC.Base.fmap
              TyArg Data.Functor.Const.Const Data.Text.Internal.Lazy.Text
              ValArg Data.Functor.Const.$fFunctorConst
                       @Data.Text.Internal.Lazy.Text
    After:  (Data.Functor.Const.$fFunctorConst2
               @Data.Text.Internal.Lazy.Text)
            `cast` (forall (a :: <*>_N) (b :: <*>_N).
                    <a -> b>_R
                    %<'GHC.Types.Many>_N ->_R <Data.Functor.Const.Const
                                                 Data.Text.Internal.Lazy.Text a>_R
                    %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                  <*>_N <Data.Text.Internal.Lazy.Text>_R <a>_P
                                              ; Sym (Data.Functor.Const.N:Const[0]
                                                         <*>_N
                                                         <Data.Text.Internal.Lazy.Text>_R
                                                         <b>_P)
                    :: (forall {a} {b}.
                        (a -> b)
                        -> Data.Functor.Const.Const Data.Text.Internal.Lazy.Text a
                        -> Data.Functor.Const.Const Data.Text.Internal.Lazy.Text a)
                       ~R# (forall {a} {b}.
                            (a -> b)
                            -> Data.Functor.Const.Const Data.Text.Internal.Lazy.Text a
                            -> Data.Functor.Const.Const Data.Text.Internal.Lazy.Text b))
    Cont:   ApplyToTy Data.Text.Internal.Lazy.Text
            ApplyToTy Data.Text.Internal.Text
            ApplyToVal nodup hole (Data.Text.Internal.Lazy.Text
                                   -> Data.Text.Internal.Text)
                                  -> Data.Functor.Const.Const
                                       Data.Text.Internal.Lazy.Text Data.Text.Internal.Lazy.Text
                                  -> Data.Functor.Const.Const
                                       Data.Text.Internal.Lazy.Text Data.Text.Internal.Text
              Data.Text.Lazy.toStrict
            ApplyToVal nodup hole Data.Functor.Const.Const
                                    Data.Text.Internal.Lazy.Text Data.Text.Internal.Lazy.Text
                                  -> Data.Functor.Const.Const
                                       Data.Text.Internal.Lazy.Text Data.Text.Internal.Text
              (bc_aboj (ab_aboh x_abok))
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N <Data.Text.Internal.Lazy.Text>_R <Data.Text.Internal.Text>_P
                    :: Data.Functor.Const.Const
                         Data.Text.Internal.Lazy.Text Data.Text.Internal.Text
                       ~R# Data.Text.Internal.Lazy.Text)
            Stop[RuleArgCtxt] Data.Text.Internal.Lazy.Text
Rule fired
    Rule: Class op ==
    Module: (BUILTIN)
    Before: GHC.Classes.==
              TyArg Data.Text.Internal.Text
              ValArg Data.Text.$fEqText
              ValArg Data.Text.Lazy.toStrict (Data.Text.Lazy.fromStrict s_a8OE)
              ValArg s_a8OE
    After:  Data.Text.$fEqText_$c==
              ValArg Data.Text.Lazy.toStrict (Data.Text.Lazy.fromStrict s_a8OE)
              ValArg s_a8OE
    Cont:   Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: unpack
    Module: (GHC.Base)
    Before: GHC.CString.unpackCString# ValArg "[W8] -> B -> [W8]"#
    After:  (\ (a_ab6H :: GHC.Prim.Addr#) ->
               GHC.Base.build
                 @GHC.Types.Char
                 (\ (@b_ab6I) -> GHC.CString.unpackFoldrCString# @b_ab6I a_ab6H))
              "[W8] -> B -> [W8]"#
    Cont:   Stop[BoringCtxt] Test.Tasty.Core.TestName
Rule fired
    Rule: Class op property
    Module: (BUILTIN)
    Before: Test.QuickCheck.Property.property
              TyArg [GHC.Word.Word8] -> GHC.Types.Bool ValArg $dTestable_a9du
    After:  Test.QuickCheck.Property.$fTestableFUN_$cproperty
              @[GHC.Word.Word8]
              @GHC.Types.Bool
              $dArbitrary_aabY
              $dShow_aabZ
              Test.QuickCheck.Property.$fTestableBool
    Cont:   ApplyToVal nodup hole ([GHC.Word.Word8] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              prop_ab6U
            CastIt (Sym (Test.Tasty.QuickCheck.N:QC[0])
                    :: Test.QuickCheck.Property.Property ~R# Test.Tasty.QuickCheck.QC)
            Stop[BoringCtxt] Test.Tasty.QuickCheck.QC
Rule fired
    Rule: Class op propertyForAllShrinkShow
    Module: (BUILTIN)
    Before: Test.QuickCheck.Property.propertyForAllShrinkShow
              TyArg GHC.Types.Bool ValArg Test.QuickCheck.Property.$fTestableBool
    After:  Test.QuickCheck.Property.$fTestableBool1
            `cast` (forall (a :: <*>_N).
                    <Test.QuickCheck.Gen.Gen a>_R
                    %<'GHC.Types.Many>_N ->_R <a -> [a]>_R
                    %<'GHC.Types.Many>_N ->_R <a -> [GHC.Base.String]>_R
                    %<'GHC.Types.Many>_N ->_R <a -> GHC.Types.Bool>_R
                    %<'GHC.Types.Many>_N ->_R Sym (Test.QuickCheck.Gen.N:Gen[0]
                                                       (Test.QuickCheck.Property.N:Prop[0]))
                                              ; Sym (Test.QuickCheck.Property.N:Property[0])
                    :: (forall {a}.
                        Test.QuickCheck.Gen.Gen a
                        -> (a -> [a])
                        -> (a -> [GHC.Base.String])
                        -> (a -> GHC.Types.Bool)
                        -> Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int
                        -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result)
                       ~R# (forall {a}.
                            Test.QuickCheck.Gen.Gen a
                            -> (a -> [a])
                            -> (a -> [GHC.Base.String])
                            -> (a -> GHC.Types.Bool)
                            -> Test.QuickCheck.Property.Property))
    Cont:   ApplyToTy [GHC.Word.Word8]
            ApplyToVal nodup hole Test.QuickCheck.Gen.Gen [GHC.Word.Word8]
                                  -> ([GHC.Word.Word8] -> [[GHC.Word.Word8]])
                                  -> ([GHC.Word.Word8] -> [GHC.Base.String])
                                  -> ([GHC.Word.Word8] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (Test.QuickCheck.Arbitrary.arbitrary @a_ab8C $dArbitrary_ab8E)
            ApplyToVal nodup hole ([GHC.Word.Word8] -> [[GHC.Word.Word8]])
                                  -> ([GHC.Word.Word8] -> [GHC.Base.String])
                                  -> ([GHC.Word.Word8] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (Test.QuickCheck.Arbitrary.shrink @a_ab8C $dArbitrary_ab8E)
            ApplyToVal nodup hole ([GHC.Word.Word8] -> [GHC.Base.String])
                                  -> ([GHC.Word.Word8] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (let {
                 g_ab8I [Occ=OnceL1!] :: a_ab8C -> GHC.Base.String
                 [LclId]
                 g_ab8I = GHC.Show.show @a_ab8C $dShow_ab8F } in
               \ (x_ab8J [Occ=Once1] :: a_ab8C) ->
                 GHC.Types.:
                   @GHC.Base.String (g_ab8I x_ab8J) (GHC.Types.[] @GHC.Base.String))
            ApplyToVal nodup hole ([GHC.Word.Word8] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              f_ab8H
            CastIt (Sym (Test.Tasty.QuickCheck.N:QC[0])
                    :: Test.QuickCheck.Property.Property ~R# Test.Tasty.QuickCheck.QC)
            Stop[BoringCtxt] Test.Tasty.QuickCheck.QC
Rule fired
    Rule: Class op arbitrary
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.arbitrary
              TyArg [GHC.Word.Word8] ValArg $dArbitrary_aabY
    After:  (Test.QuickCheck.Arbitrary.$fArbitraryList1
               @GHC.Word.Word8 Test.QuickCheck.Arbitrary.$fArbitraryWord8)
            `cast` (Sym (Test.QuickCheck.Gen.N:Gen[0] <[GHC.Word.Word8]>_R)
                    :: (Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int -> [GHC.Word.Word8])
                       ~R# Test.QuickCheck.Gen.Gen [GHC.Word.Word8])
    Cont:   Stop[BoringCtxt] Test.QuickCheck.Gen.Gen [GHC.Word.Word8]
Rule fired
    Rule: Class op arbitrary
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.arbitrary
              TyArg GHC.Word.Word8
              ValArg Test.QuickCheck.Arbitrary.$fArbitraryWord8
    After:  Test.QuickCheck.Arbitrary.$fArbitraryWord8_$sarbitrarySizedBoundedIntegral
            `cast` (Sym (Test.QuickCheck.Gen.N:Gen[0] <GHC.Word.Word8>_R)
                    :: (Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int -> GHC.Word.Word8)
                       ~R# Test.QuickCheck.Gen.Gen GHC.Word.Word8)
    Cont:   Stop[BoringCtxt, C(S,C(1,L))] Test.QuickCheck.Gen.Gen
                                            GHC.Word.Word8
Rule fired
    Rule: Class op shrink
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.shrink
              TyArg [GHC.Word.Word8] ValArg $dArbitrary_aabY
    After:  Test.QuickCheck.Arbitrary.$fArbitraryList_$cshrink
              @GHC.Word.Word8 Test.QuickCheck.Arbitrary.$fArbitraryWord8
    Cont:   Stop[BoringCtxt] [GHC.Word.Word8] -> [[GHC.Word.Word8]]
Rule fired
    Rule: Class op shrink
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.shrink
              TyArg GHC.Word.Word8
              ValArg Test.QuickCheck.Arbitrary.$fArbitraryWord8
    After:  Test.QuickCheck.Arbitrary.$fArbitraryWord8_$sshrinkIntegral
    Cont:   Stop[DiscArgCtxt, C(S,L)] GHC.Word.Word8
                                      -> [GHC.Word.Word8]
Rule fired
    Rule: Class op show
    Module: (BUILTIN)
    Before: GHC.Show.show TyArg [GHC.Word.Word8] ValArg $dShow_aabZ
    After:  GHC.Show.$fShowList_$cshow
              @GHC.Word.Word8 GHC.Word.$fShowWord8
    Cont:   Stop[RhsCtxt(NonRecursive)] [GHC.Word.Word8]
                                        -> GHC.Base.String
Rule fired
    Rule: Class op showList
    Module: (BUILTIN)
    Before: GHC.Show.showList
              TyArg GHC.Word.Word8 ValArg GHC.Word.$fShowWord8
    After:  GHC.Word.$fShowWord8_$cshowList
    Cont:   ApplyToVal nodup hole [GHC.Word.Word8] -> GHC.Show.ShowS
              x_abr2
            ApplyToVal nodup hole GHC.Show.ShowS (GHC.Types.[] @GHC.Types.Char)
            Stop[BoringCtxt] GHC.Base.String
Rule fired
    Rule: Class op reader
    Module: (BUILTIN)
    Before: Control.Monad.Reader.Class.reader
              TyArg Data.ByteString.Internal.Type.ByteString
              TyArg (->) Data.ByteString.Internal.Type.ByteString
              ValArg Control.Monad.Reader.Class.$fMonadReaderrFUN
                       @Data.ByteString.Internal.Type.ByteString
    After:  \ (@a_abe8) ->
              GHC.Base.id @(Data.ByteString.Internal.Type.ByteString -> a_abe8)
    Cont:   ApplyToTy [GHC.Word.Word8]
            ApplyToVal nodup hole (Data.ByteString.Internal.Type.ByteString
                                   -> [GHC.Word.Word8])
                                  -> Data.ByteString.Internal.Type.ByteString -> [GHC.Word.Word8]
              ((l_abe2
                  ((\ (ds_abe3 [Occ=Once1] :: a_abe0) -> ds_abe3)
                   `cast` (<a_abe0>_R
                           %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                              <*>_N <a_abe0>_R <a_abe0>_P)
                           :: (a_abe0 -> a_abe0)
                              ~R# (a_abe0 -> Data.Functor.Const.Const a_abe0 a_abe0))))
               `cast` (<s_abdY>_R
                       %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                     <*>_N <a_abe0>_R <s_abdY>_P
                       :: (s_abdY -> Data.Functor.Const.Const a_abe0 s_abdY)
                          ~R# (s_abdY -> a_abe0)))
            ApplyToVal nodup hole Data.ByteString.Internal.Type.ByteString
                                  -> [GHC.Word.Word8]
              (Control.Lens.Getter.view
                 @[GHC.Word.Word8]
                 @((->) [GHC.Word.Word8])
                 @Data.ByteString.Internal.Type.ByteString
                 (Control.Monad.Reader.Class.$fMonadReaderrFUN @[GHC.Word.Word8])
                 (Control.Lens.Cons.Extras.recons
                    @[GHC.Word.Word8]
                    @GHC.Word.Word8
                    @Data.ByteString.Internal.Type.ByteString
                    (Control.Lens.Cons.$fConsListListab
                       @GHC.Word.Word8 @GHC.Word.Word8)
                    Control.Lens.Cons.$fConsByteStringByteStringWord8Word80
                    Control.Lens.Empty.$fAsEmptyByteString0
                    @(Data.Functor.Const.Const
                        Data.ByteString.Internal.Type.ByteString)
                    (Data.Functor.Contravariant.$fContravariantConst
                       @Data.ByteString.Internal.Type.ByteString)
                    (Data.Functor.Const.$fFunctorConst
                       @Data.ByteString.Internal.Type.ByteString))
                 s_a8OF)
            Stop[RuleArgCtxt] [GHC.Word.Word8]
Rule fired
    Rule: recons/bs-list
    Module: (Control.Lens.Cons.Extras)
    Before: Control.Lens.Cons.Extras.recons
              TyArg Data.ByteString.Internal.Type.ByteString
              TyArg GHC.Word.Word8
              TyArg [GHC.Word.Word8]
              ValArg (\ (@(p_abjT :: * -> * -> *))
                        (@(f_abjU :: * -> *))
                        ($dChoice_abjV :: Data.Profunctor.Choice.Choice p_abjT)
                        ($dApplicative_abjW :: GHC.Base.Applicative f_abjU) ->
                        let {
                          f1_abjX
                            :: p_abjT
                                 (Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                                 (Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString
                                    (f_abjU
                                       (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                               -> p_abjT
                                    Data.ByteString.Internal.Type.ByteString
                                    (f_abjU Data.ByteString.Internal.Type.ByteString)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 612 0}]
                          f1_abjX
                            = Data.Profunctor.Unsafe.dimap
                                @p_abjT
                                (Data.Profunctor.Choice.$p1Choice @p_abjT $dChoice_abjV)
                                @Data.ByteString.Internal.Type.ByteString
                                @(Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                                @(Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString
                                    (f_abjU
                                       (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                                @(f_abjU Data.ByteString.Internal.Type.ByteString)
                                (\ (s1_abjY :: Data.ByteString.Internal.Type.ByteString) ->
                                   case s1_abjY of wild_abjZ
                                   { Data.ByteString.Internal.Type.BS bx_abk0 bx1_abk1 bx2_abk2 ->
                                   case GHC.Classes.leInt (GHC.Types.I# bx2_abk2) (GHC.Types.I# 0#)
                                   of {
                                     GHC.Types.False ->
                                       Data.Either.Right
                                         @Data.ByteString.Internal.Type.ByteString
                                         @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                         (case GHC.Prim.readWord8OffAddr#
                                                 @GHC.Prim.RealWorld bx_abk0 0# GHC.Prim.realWorld#
                                          of
                                          { (# ipv_abk7, ipv1_abk8 #) ->
                                          case GHC.Prim.touch#
                                                 @'GHC.Types.Lifted
                                                 @GHC.ForeignPtr.ForeignPtrContents
                                                 bx1_abk1
                                                 ipv_abk7
                                          of
                                          { __DEFAULT ->
                                          GHC.Word.W8# ipv1_abk8
                                          }
                                          },
                                          Data.ByteString.Internal.Type.$WBS
                                            (GHC.ForeignPtr.ForeignPtr
                                               @GHC.Word.Word8
                                               (GHC.Prim.plusAddr# bx_abk0 1#)
                                               bx1_abk1)
                                            (GHC.Types.I# (GHC.Prim.-# bx2_abk2 1#)));
                                     GHC.Types.True ->
                                       Data.Either.Left
                                         @Data.ByteString.Internal.Type.ByteString
                                         @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                         wild_abjZ
                                   }
                                   })
                                (let {
                                   f2_abkc
                                     :: Data.ByteString.Internal.Type.ByteString
                                        -> f_abjU Data.ByteString.Internal.Type.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abkc
                                     = GHC.Base.pure
                                         @f_abjU
                                         $dApplicative_abjW
                                         @Data.ByteString.Internal.Type.ByteString } in
                                 let {
                                   ds2_abkd
                                     :: f_abjU
                                          (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                        -> f_abjU Data.ByteString.Internal.Type.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 259 0}]
                                   ds2_abkd
                                     = GHC.Base.fmap
                                         @f_abjU
                                         (GHC.Base.$p1Applicative @f_abjU $dApplicative_abjW)
                                         @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                         @Data.ByteString.Internal.Type.ByteString
                                         (\ (p1_abke
                                               :: (GHC.Word.Word8,
                                                   Data.ByteString.Internal.Type.ByteString)) ->
                                            case p1_abke of { (ds_abkg, y_abkh) ->
                                            case y_abkh of
                                            { Data.ByteString.Internal.Type.BS bx_abkt bx1_abku
                                                                               bx2_abkv ->
                                            GHC.Magic.runRW#
                                              @GHC.Types.LiftedRep
                                              @Data.ByteString.Internal.Type.ByteString
                                              (\ (s_abkr [OS=OneShot]
                                                    :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                                                 let {
                                                   x_abks :: GHC.Prim.Int#
                                                   [LclId,
                                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                            Value=False, ConLike=False,
                                                            WorkFree=False, Expandable=False,
                                                            Guidance=IF_ARGS [] 1 0}]
                                                   x_abks = GHC.Prim.+# bx2_abkv 1# } in
                                                 case GHC.Prim.<# x_abks 0# of {
                                                   __DEFAULT ->
                                                     case GHC.Prim.newPinnedByteArray#
                                                            @GHC.Prim.RealWorld x_abks s_abkr
                                                     of
                                                     { (# ipv_abkA, ipv1_abkB #) ->
                                                     let {
                                                       ipv2_abkz :: GHC.Prim.Addr#
                                                       [LclId,
                                                        Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                                Value=False, ConLike=False,
                                                                WorkFree=False, Expandable=False,
                                                                Guidance=IF_ARGS [] 1 0}]
                                                       ipv2_abkz
                                                         = GHC.Prim.mutableByteArrayContents#
                                                             @GHC.Prim.RealWorld ipv1_abkB } in
                                                     let {
                                                       ipv3_abkD
                                                         :: GHC.ForeignPtr.ForeignPtrContents
                                                       [LclId,
                                                        Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                                Value=True, ConLike=True,
                                                                WorkFree=True, Expandable=True,
                                                                Guidance=IF_ARGS [] 10 10}]
                                                       ipv3_abkD
                                                         = GHC.ForeignPtr.PlainPtr ipv1_abkB } in
                                                     case ds_abkg of { GHC.Word.W8# x1_ablV ->
                                                     case GHC.Prim.writeWord8OffAddr#
                                                            @GHC.Prim.RealWorld
                                                            ipv2_abkz
                                                            0#
                                                            x1_ablV
                                                            ipv_abkA
                                                     of s2_ablX
                                                     { __DEFAULT ->
                                                     case GHC.Prim.touch#
                                                            @'GHC.Types.Lifted
                                                            @GHC.ForeignPtr.ForeignPtrContents
                                                            ipv3_abkD
                                                            s2_ablX
                                                     of s'_ablY
                                                     { __DEFAULT ->
                                                     case {__ffi_static_ccall_unsafe base:memcpy :: Addr#
                                          -> Addr#
                                          -> Word64#
                                          -> State# RealWorld
                                          -> (# State# RealWorld, Addr# #)}_ablZ
                                                            (GHC.Prim.plusAddr# ipv2_abkz 1#)
                                                            bx_abkt
                                                            (GHC.Prim.int64ToWord64#
                                                               (GHC.Prim.intToInt64# bx2_abkv))
                                                            s'_ablY
                                                     of
                                                     { (# ds4_abm1, ds5_abm2 #) ->
                                                     case GHC.Prim.touch#
                                                            @'GHC.Types.Lifted
                                                            @GHC.ForeignPtr.ForeignPtrContents
                                                            bx1_abku
                                                            ds4_abm1
                                                     of s'1_abm4
                                                     { __DEFAULT ->
                                                     case GHC.Prim.touch#
                                                            @'GHC.Types.Lifted
                                                            @GHC.ForeignPtr.ForeignPtrContents
                                                            ipv3_abkD
                                                            s'1_abm4
                                                     of s'2_abm5
                                                     { __DEFAULT ->
                                                     case GHC.Magic.lazy
                                                            @((GHC.Prim.State# GHC.Prim.RealWorld
                                                               -> (# GHC.Prim.State#
                                                                       GHC.Prim.RealWorld,
                                                                     GHC.Prim.Addr# #))
                                                              -> (# GHC.Prim.State#
                                                                      GHC.Prim.RealWorld,
                                                                    GHC.Prim.Addr# #))
                                                            (GHC.Magic.runRW#
                                                               @('GHC.Types.TupleRep
                                                                   '[GHC.Types.ZeroBitRep,
                                                                     'GHC.Types.AddrRep])
                                                               @(# GHC.Prim.State#
                                                                     GHC.Prim.RealWorld,
                                                                   GHC.Prim.Addr# #))
                                                            (\ _ [Occ=Dead] ->
                                                               (# s'2_abm5, ipv2_abkz #))
                                                     of
                                                     { (# ipv6_abm8, ipv7_abm9 #) ->
                                                     Data.ByteString.Internal.Type.BS
                                                       ipv7_abm9 ipv3_abkD x_abks
                                                     }
                                                     }
                                                     }
                                                     }
                                                     }
                                                     }
                                                     }
                                                     };
                                                   1# ->
                                                     case GHC.ForeignPtr.mallocPlainForeignPtrBytes2
                                                     of wild_00 {
                                                     }
                                                 })
                                            }
                                            }) } in
                                 \ (ds3_abmc
                                      :: Data.Either.Either
                                           Data.ByteString.Internal.Type.ByteString
                                           (f_abjU
                                              (GHC.Word.Word8,
                                               Data.ByteString.Internal.Type.ByteString))) ->
                                   case ds3_abmc of {
                                     Data.Either.Left x_abme -> f2_abkc x_abme;
                                     Data.Either.Right y_abmg -> ds2_abkd y_abmg
                                   }) } in
                        let {
                          g_abmi
                            :: p_abjT
                                 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                 (f_abjU (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                               -> p_abjT
                                    (Data.Either.Either
                                       Data.ByteString.Internal.Type.ByteString
                                       (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                                    (Data.Either.Either
                                       Data.ByteString.Internal.Type.ByteString
                                       (f_abjU
                                          (GHC.Word.Word8,
                                           Data.ByteString.Internal.Type.ByteString)))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abmi
                            = Data.Profunctor.Choice.right'
                                @p_abjT
                                $dChoice_abjV
                                @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                @(f_abjU
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                                @Data.ByteString.Internal.Type.ByteString } in
                        \ (x_abmj
                             :: p_abjT
                                  (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                  (f_abjU
                                     (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))) ->
                          f1_abjX (g_abmi x_abmj))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <Data.ByteString.Internal.Type.ByteString>_N
                                      <Data.ByteString.Internal.Type.ByteString>_N
                                      <GHC.Word.Word8>_N
                                      <GHC.Word.Word8>_N)
                             :: Control.Lens.Type.Prism
                                  Data.ByteString.Internal.Type.ByteString
                                  Data.ByteString.Internal.Type.ByteString
                                  (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                  (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                ~R# Control.Lens.Cons.Cons
                                      Data.ByteString.Internal.Type.ByteString
                                      Data.ByteString.Internal.Type.ByteString
                                      GHC.Word.Word8
                                      GHC.Word.Word8)
              ValArg (\ (@(p_abfz :: * -> * -> *))
                        (@(f_abfA :: * -> *))
                        ($dChoice_abfB :: Data.Profunctor.Choice.Choice p_abfz)
                        ($dApplicative_abfC :: GHC.Base.Applicative f_abfA) ->
                        let {
                          f1_abfD
                            :: p_abfz
                                 (Data.Either.Either
                                    [GHC.Word.Word8] (GHC.Word.Word8, [GHC.Word.Word8]))
                                 (Data.Either.Either
                                    [GHC.Word.Word8] (f_abfA (GHC.Word.Word8, [GHC.Word.Word8])))
                               -> p_abfz [GHC.Word.Word8] (f_abfA [GHC.Word.Word8])
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 320 0}]
                          f1_abfD
                            = Data.Profunctor.Unsafe.dimap
                                @p_abfz
                                (Data.Profunctor.Choice.$p1Choice @p_abfz $dChoice_abfB)
                                @[GHC.Word.Word8]
                                @(Data.Either.Either
                                    [GHC.Word.Word8] (GHC.Word.Word8, [GHC.Word.Word8]))
                                @(Data.Either.Either
                                    [GHC.Word.Word8] (f_abfA (GHC.Word.Word8, [GHC.Word.Word8])))
                                @(f_abfA [GHC.Word.Word8])
                                (\ (aas_abfE :: [GHC.Word.Word8]) ->
                                   case aas_abfE of {
                                     [] ->
                                       Data.Either.Left
                                         @[GHC.Word.Word8]
                                         @(GHC.Word.Word8, [GHC.Word.Word8])
                                         (GHC.Types.[] @GHC.Word.Word8);
                                     : a1_abfG as_abfH ->
                                       Data.Either.Right
                                         @[GHC.Word.Word8]
                                         @(GHC.Word.Word8, [GHC.Word.Word8])
                                         (a1_abfG, as_abfH)
                                   })
                                (let {
                                   f2_abfJ :: [GHC.Word.Word8] -> f_abfA [GHC.Word.Word8]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abfJ
                                     = GHC.Base.pure
                                         @f_abfA $dApplicative_abfC @[GHC.Word.Word8] } in
                                 let {
                                   ds2_abfK
                                     :: f_abfA (GHC.Word.Word8, [GHC.Word.Word8])
                                        -> f_abfA [GHC.Word.Word8]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 90 0}]
                                   ds2_abfK
                                     = GHC.Base.fmap
                                         @f_abfA
                                         (GHC.Base.$p1Applicative @f_abfA $dApplicative_abfC)
                                         @(GHC.Word.Word8, [GHC.Word.Word8])
                                         @[GHC.Word.Word8]
                                         (\ (p1_abfL :: (GHC.Word.Word8, [GHC.Word.Word8])) ->
                                            GHC.Types.:
                                              @GHC.Word.Word8
                                              (case p1_abfL of { (x_abfN, ds_abfO) -> x_abfN })
                                              (case p1_abfL of { (ds_abfR, y_abfS) ->
                                               y_abfS
                                               })) } in
                                 \ (ds3_abfU
                                      :: Data.Either.Either
                                           [GHC.Word.Word8]
                                           (f_abfA (GHC.Word.Word8, [GHC.Word.Word8]))) ->
                                   case ds3_abfU of {
                                     Data.Either.Left x_abfW -> f2_abfJ x_abfW;
                                     Data.Either.Right y_abfY -> ds2_abfK y_abfY
                                   }) } in
                        let {
                          g_abg0
                            :: p_abfz
                                 (GHC.Word.Word8, [GHC.Word.Word8])
                                 (f_abfA (GHC.Word.Word8, [GHC.Word.Word8]))
                               -> p_abfz
                                    (Data.Either.Either
                                       [GHC.Word.Word8] (GHC.Word.Word8, [GHC.Word.Word8]))
                                    (Data.Either.Either
                                       [GHC.Word.Word8] (f_abfA (GHC.Word.Word8, [GHC.Word.Word8])))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abg0
                            = Data.Profunctor.Choice.right'
                                @p_abfz
                                $dChoice_abfB
                                @(GHC.Word.Word8, [GHC.Word.Word8])
                                @(f_abfA (GHC.Word.Word8, [GHC.Word.Word8]))
                                @[GHC.Word.Word8] } in
                        \ (x_abg1
                             :: p_abfz
                                  (GHC.Word.Word8, [GHC.Word.Word8])
                                  (f_abfA (GHC.Word.Word8, [GHC.Word.Word8]))) ->
                          f1_abfD (g_abg0 x_abg1))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <[GHC.Word.Word8]>_N
                                      <[GHC.Word.Word8]>_N
                                      <GHC.Word.Word8>_N
                                      <GHC.Word.Word8>_N)
                             :: Control.Lens.Type.Prism
                                  [GHC.Word.Word8]
                                  [GHC.Word.Word8]
                                  (GHC.Word.Word8, [GHC.Word.Word8])
                                  (GHC.Word.Word8, [GHC.Word.Word8])
                                ~R# Control.Lens.Cons.Cons
                                      [GHC.Word.Word8]
                                      [GHC.Word.Word8]
                                      GHC.Word.Word8
                                      GHC.Word.Word8)
              ValArg (\ (@(p_abg6 :: * -> * -> *))
                        (@(f_abg7 :: * -> *))
                        ($dChoice_abg8 :: Data.Profunctor.Choice.Choice p_abg6)
                        ($dApplicative_abg9 :: GHC.Base.Applicative f_abg7) ->
                        let {
                          f1_abga
                            :: p_abg6
                                 (Data.Either.Either [GHC.Word.Word8] ())
                                 (Data.Either.Either [GHC.Word.Word8] (f_abg7 ()))
                               -> p_abg6 [GHC.Word.Word8] (f_abg7 [GHC.Word.Word8])
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 290 0}]
                          f1_abga
                            = Data.Profunctor.Unsafe.dimap
                                @p_abg6
                                (Data.Profunctor.Choice.$p1Choice @p_abg6 $dChoice_abg8)
                                @[GHC.Word.Word8]
                                @(Data.Either.Either [GHC.Word.Word8] ())
                                @(Data.Either.Either [GHC.Word.Word8] (f_abg7 ()))
                                @(f_abg7 [GHC.Word.Word8])
                                (\ (s_abgb :: [GHC.Word.Word8]) ->
                                   case s_abgb of wild_abgc {
                                     [] ->
                                       Data.Either.Right @[GHC.Word.Word8] @() GHC.Tuple.Prim.();
                                     : ds1_abgd ds2_abge ->
                                       Data.Either.Left @[GHC.Word.Word8] @() wild_abgc
                                   })
                                (let {
                                   f2_abgg :: [GHC.Word.Word8] -> f_abg7 [GHC.Word.Word8]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abgg
                                     = GHC.Base.pure
                                         @f_abg7 $dApplicative_abg9 @[GHC.Word.Word8] } in
                                 let {
                                   ds2_abgh :: f_abg7 () -> f_abg7 [GHC.Word.Word8]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 70 0}]
                                   ds2_abgh
                                     = GHC.Base.fmap
                                         @f_abg7
                                         (GHC.Base.$p1Applicative @f_abg7 $dApplicative_abg9)
                                         @()
                                         @[GHC.Word.Word8]
                                         (\ (ds3_abgi :: ()) ->
                                            case ds3_abgi of { () ->
                                            GHC.Types.[] @GHC.Word.Word8
                                            }) } in
                                 \ (ds3_abgk :: Data.Either.Either [GHC.Word.Word8] (f_abg7 ())) ->
                                   case ds3_abgk of {
                                     Data.Either.Left x_abgm -> f2_abgg x_abgm;
                                     Data.Either.Right y_abgo -> ds2_abgh y_abgo
                                   }) } in
                        let {
                          g_abgq
                            :: p_abg6 () (f_abg7 ())
                               -> p_abg6
                                    (Data.Either.Either [GHC.Word.Word8] ())
                                    (Data.Either.Either [GHC.Word.Word8] (f_abg7 ()))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abgq
                            = Data.Profunctor.Choice.right'
                                @p_abg6 $dChoice_abg8 @() @(f_abg7 ()) @[GHC.Word.Word8] } in
                        \ (x_abgr :: p_abg6 () (f_abg7 ())) -> f1_abga (g_abgq x_abgr))
                     `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0] <[GHC.Word.Word8]>_N)
                             :: Control.Lens.Type.Prism' [GHC.Word.Word8] ()
                                ~R# Control.Lens.Empty.AsEmpty [GHC.Word.Word8])
              TyArg Data.Functor.Const.Const [GHC.Word.Word8]
              ValArg Data.Functor.Contravariant.$fContravariantConst
                       @[GHC.Word.Word8]
              ValArg Data.Functor.Const.$fFunctorConst @[GHC.Word.Word8]
    After:  (\ (@(f_abfl :: * -> *))
               ($dCons_abfm
                  :: Control.Lens.Cons.Cons
                       Data.ByteString.Internal.Type.ByteString
                       Data.ByteString.Internal.Type.ByteString
                       GHC.Word.Word8
                       GHC.Word.Word8)
               ($dCons1_abfn
                  :: Control.Lens.Cons.Cons
                       [GHC.Word.Word8] [GHC.Word.Word8] GHC.Word.Word8 GHC.Word.Word8)
               ($dAsEmpty_abfo :: Control.Lens.Empty.AsEmpty [GHC.Word.Word8])
               ($dContravariant_abfp
                  :: Data.Functor.Contravariant.Contravariant f_abfl)
               ($dFunctor_abfq :: GHC.Base.Functor f_abfl) ->
               Data.Profunctor.Unsafe.$fProfunctorFUN_$cdimap
                 @Data.ByteString.Internal.Type.ByteString
                 @[GHC.Word.Word8]
                 @(f_abfl [GHC.Word.Word8])
                 @(f_abfl Data.ByteString.Internal.Type.ByteString)
                 Data.ByteString.unpack
                 (GHC.Base.fmap
                    @f_abfl
                    $dFunctor_abfq
                    @[GHC.Word.Word8]
                    @Data.ByteString.Internal.Type.ByteString
                    Data.ByteString.Internal.Type.packBytes))
              @(Data.Functor.Const.Const [GHC.Word.Word8])
              ((\ (@(p_abjT :: * -> * -> *))
                  (@(f_abjU :: * -> *))
                  ($dChoice_abjV :: Data.Profunctor.Choice.Choice p_abjT)
                  ($dApplicative_abjW :: GHC.Base.Applicative f_abjU) ->
                  let {
                    f1_abjX
                      :: p_abjT
                           (Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString
                              (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                           (Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString
                              (f_abjU
                                 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                         -> p_abjT
                              Data.ByteString.Internal.Type.ByteString
                              (f_abjU Data.ByteString.Internal.Type.ByteString)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 612 0}]
                    f1_abjX
                      = Data.Profunctor.Unsafe.dimap
                          @p_abjT
                          (Data.Profunctor.Choice.$p1Choice @p_abjT $dChoice_abjV)
                          @Data.ByteString.Internal.Type.ByteString
                          @(Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString
                              (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                          @(Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString
                              (f_abjU
                                 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                          @(f_abjU Data.ByteString.Internal.Type.ByteString)
                          (\ (s1_abjY :: Data.ByteString.Internal.Type.ByteString) ->
                             case s1_abjY of wild_abjZ
                             { Data.ByteString.Internal.Type.BS bx_abk0 bx1_abk1 bx2_abk2 ->
                             case GHC.Classes.leInt (GHC.Types.I# bx2_abk2) (GHC.Types.I# 0#)
                             of {
                               GHC.Types.False ->
                                 Data.Either.Right
                                   @Data.ByteString.Internal.Type.ByteString
                                   @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                   (case GHC.Prim.readWord8OffAddr#
                                           @GHC.Prim.RealWorld bx_abk0 0# GHC.Prim.realWorld#
                                    of
                                    { (# ipv_abk7, ipv1_abk8 #) ->
                                    case GHC.Prim.touch#
                                           @'GHC.Types.Lifted
                                           @GHC.ForeignPtr.ForeignPtrContents
                                           bx1_abk1
                                           ipv_abk7
                                    of
                                    { __DEFAULT ->
                                    GHC.Word.W8# ipv1_abk8
                                    }
                                    },
                                    Data.ByteString.Internal.Type.$WBS
                                      (GHC.ForeignPtr.ForeignPtr
                                         @GHC.Word.Word8 (GHC.Prim.plusAddr# bx_abk0 1#) bx1_abk1)
                                      (GHC.Types.I# (GHC.Prim.-# bx2_abk2 1#)));
                               GHC.Types.True ->
                                 Data.Either.Left
                                   @Data.ByteString.Internal.Type.ByteString
                                   @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                   wild_abjZ
                             }
                             })
                          (let {
                             f2_abkc
                               :: Data.ByteString.Internal.Type.ByteString
                                  -> f_abjU Data.ByteString.Internal.Type.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abkc
                               = GHC.Base.pure
                                   @f_abjU
                                   $dApplicative_abjW
                                   @Data.ByteString.Internal.Type.ByteString } in
                           let {
                             ds2_abkd
                               :: f_abjU
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                  -> f_abjU Data.ByteString.Internal.Type.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 259 0}]
                             ds2_abkd
                               = GHC.Base.fmap
                                   @f_abjU
                                   (GHC.Base.$p1Applicative @f_abjU $dApplicative_abjW)
                                   @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                   @Data.ByteString.Internal.Type.ByteString
                                   (\ (p1_abke
                                         :: (GHC.Word.Word8,
                                             Data.ByteString.Internal.Type.ByteString)) ->
                                      case p1_abke of { (ds_abkg, y_abkh) ->
                                      case y_abkh of
                                      { Data.ByteString.Internal.Type.BS bx_abkt bx1_abku
                                                                         bx2_abkv ->
                                      GHC.Magic.runRW#
                                        @GHC.Types.LiftedRep
                                        @Data.ByteString.Internal.Type.ByteString
                                        (\ (s_abkr [OS=OneShot]
                                              :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                                           let {
                                             x_abks :: GHC.Prim.Int#
                                             [LclId,
                                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                      Value=False, ConLike=False, WorkFree=False,
                                                      Expandable=False,
                                                      Guidance=IF_ARGS [] 1 0}]
                                             x_abks = GHC.Prim.+# bx2_abkv 1# } in
                                           case GHC.Prim.<# x_abks 0# of {
                                             __DEFAULT ->
                                               case GHC.Prim.newPinnedByteArray#
                                                      @GHC.Prim.RealWorld x_abks s_abkr
                                               of
                                               { (# ipv_abkA, ipv1_abkB #) ->
                                               let {
                                                 ipv2_abkz :: GHC.Prim.Addr#
                                                 [LclId,
                                                  Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                          Value=False, ConLike=False,
                                                          WorkFree=False, Expandable=False,
                                                          Guidance=IF_ARGS [] 1 0}]
                                                 ipv2_abkz
                                                   = GHC.Prim.mutableByteArrayContents#
                                                       @GHC.Prim.RealWorld ipv1_abkB } in
                                               let {
                                                 ipv3_abkD :: GHC.ForeignPtr.ForeignPtrContents
                                                 [LclId,
                                                  Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                          Value=True, ConLike=True, WorkFree=True,
                                                          Expandable=True,
                                                          Guidance=IF_ARGS [] 10 10}]
                                                 ipv3_abkD = GHC.ForeignPtr.PlainPtr ipv1_abkB } in
                                               case ds_abkg of { GHC.Word.W8# x1_ablV ->
                                               case GHC.Prim.writeWord8OffAddr#
                                                      @GHC.Prim.RealWorld
                                                      ipv2_abkz
                                                      0#
                                                      x1_ablV
                                                      ipv_abkA
                                               of s2_ablX
                                               { __DEFAULT ->
                                               case GHC.Prim.touch#
                                                      @'GHC.Types.Lifted
                                                      @GHC.ForeignPtr.ForeignPtrContents
                                                      ipv3_abkD
                                                      s2_ablX
                                               of s'_ablY
                                               { __DEFAULT ->
                                               case {__ffi_static_ccall_unsafe base:memcpy :: Addr#
                                          -> Addr#
                                          -> Word64#
                                          -> State# RealWorld
                                          -> (# State# RealWorld, Addr# #)}_ablZ
                                                      (GHC.Prim.plusAddr# ipv2_abkz 1#)
                                                      bx_abkt
                                                      (GHC.Prim.int64ToWord64#
                                                         (GHC.Prim.intToInt64# bx2_abkv))
                                                      s'_ablY
                                               of
                                               { (# ds4_abm1, ds5_abm2 #) ->
                                               case GHC.Prim.touch#
                                                      @'GHC.Types.Lifted
                                                      @GHC.ForeignPtr.ForeignPtrContents
                                                      bx1_abku
                                                      ds4_abm1
                                               of s'1_abm4
                                               { __DEFAULT ->
                                               case GHC.Prim.touch#
                                                      @'GHC.Types.Lifted
                                                      @GHC.ForeignPtr.ForeignPtrContents
                                                      ipv3_abkD
                                                      s'1_abm4
                                               of s'2_abm5
                                               { __DEFAULT ->
                                               case GHC.Magic.lazy
                                                      @((GHC.Prim.State# GHC.Prim.RealWorld
                                                         -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                               GHC.Prim.Addr# #))
                                                        -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                              GHC.Prim.Addr# #))
                                                      (GHC.Magic.runRW#
                                                         @('GHC.Types.TupleRep
                                                             '[GHC.Types.ZeroBitRep,
                                                               'GHC.Types.AddrRep])
                                                         @(# GHC.Prim.State# GHC.Prim.RealWorld,
                                                             GHC.Prim.Addr# #))
                                                      (\ _ [Occ=Dead] -> (# s'2_abm5, ipv2_abkz #))
                                               of
                                               { (# ipv6_abm8, ipv7_abm9 #) ->
                                               Data.ByteString.Internal.Type.BS
                                                 ipv7_abm9 ipv3_abkD x_abks
                                               }
                                               }
                                               }
                                               }
                                               }
                                               }
                                               }
                                               };
                                             1# ->
                                               case GHC.ForeignPtr.mallocPlainForeignPtrBytes2
                                               of wild_00 {
                                               }
                                           })
                                      }
                                      }) } in
                           \ (ds3_abmc
                                :: Data.Either.Either
                                     Data.ByteString.Internal.Type.ByteString
                                     (f_abjU
                                        (GHC.Word.Word8,
                                         Data.ByteString.Internal.Type.ByteString))) ->
                             case ds3_abmc of {
                               Data.Either.Left x_abme -> f2_abkc x_abme;
                               Data.Either.Right y_abmg -> ds2_abkd y_abmg
                             }) } in
                  let {
                    g_abmi
                      :: p_abjT
                           (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                           (f_abjU (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                         -> p_abjT
                              (Data.Either.Either
                                 Data.ByteString.Internal.Type.ByteString
                                 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                              (Data.Either.Either
                                 Data.ByteString.Internal.Type.ByteString
                                 (f_abjU
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abmi
                      = Data.Profunctor.Choice.right'
                          @p_abjT
                          $dChoice_abjV
                          @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                          @(f_abjU
                              (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                          @Data.ByteString.Internal.Type.ByteString } in
                  \ (x_abmj
                       :: p_abjT
                            (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                            (f_abjU
                               (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))) ->
                    f1_abjX (g_abmi x_abmj))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <Data.ByteString.Internal.Type.ByteString>_N
                                <Data.ByteString.Internal.Type.ByteString>_N
                                <GHC.Word.Word8>_N
                                <GHC.Word.Word8>_N)
                       :: Control.Lens.Type.Prism
                            Data.ByteString.Internal.Type.ByteString
                            Data.ByteString.Internal.Type.ByteString
                            (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                            (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                          ~R# Control.Lens.Cons.Cons
                                Data.ByteString.Internal.Type.ByteString
                                Data.ByteString.Internal.Type.ByteString
                                GHC.Word.Word8
                                GHC.Word.Word8))
              ((\ (@(p_abfz :: * -> * -> *))
                  (@(f_abfA :: * -> *))
                  ($dChoice_abfB :: Data.Profunctor.Choice.Choice p_abfz)
                  ($dApplicative_abfC :: GHC.Base.Applicative f_abfA) ->
                  let {
                    f1_abfD
                      :: p_abfz
                           (Data.Either.Either
                              [GHC.Word.Word8] (GHC.Word.Word8, [GHC.Word.Word8]))
                           (Data.Either.Either
                              [GHC.Word.Word8] (f_abfA (GHC.Word.Word8, [GHC.Word.Word8])))
                         -> p_abfz [GHC.Word.Word8] (f_abfA [GHC.Word.Word8])
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 320 0}]
                    f1_abfD
                      = Data.Profunctor.Unsafe.dimap
                          @p_abfz
                          (Data.Profunctor.Choice.$p1Choice @p_abfz $dChoice_abfB)
                          @[GHC.Word.Word8]
                          @(Data.Either.Either
                              [GHC.Word.Word8] (GHC.Word.Word8, [GHC.Word.Word8]))
                          @(Data.Either.Either
                              [GHC.Word.Word8] (f_abfA (GHC.Word.Word8, [GHC.Word.Word8])))
                          @(f_abfA [GHC.Word.Word8])
                          (\ (aas_abfE :: [GHC.Word.Word8]) ->
                             case aas_abfE of {
                               [] ->
                                 Data.Either.Left
                                   @[GHC.Word.Word8]
                                   @(GHC.Word.Word8, [GHC.Word.Word8])
                                   (GHC.Types.[] @GHC.Word.Word8);
                               : a1_abfG as_abfH ->
                                 Data.Either.Right
                                   @[GHC.Word.Word8]
                                   @(GHC.Word.Word8, [GHC.Word.Word8])
                                   (a1_abfG, as_abfH)
                             })
                          (let {
                             f2_abfJ :: [GHC.Word.Word8] -> f_abfA [GHC.Word.Word8]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abfJ
                               = GHC.Base.pure @f_abfA $dApplicative_abfC @[GHC.Word.Word8] } in
                           let {
                             ds2_abfK
                               :: f_abfA (GHC.Word.Word8, [GHC.Word.Word8])
                                  -> f_abfA [GHC.Word.Word8]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 90 0}]
                             ds2_abfK
                               = GHC.Base.fmap
                                   @f_abfA
                                   (GHC.Base.$p1Applicative @f_abfA $dApplicative_abfC)
                                   @(GHC.Word.Word8, [GHC.Word.Word8])
                                   @[GHC.Word.Word8]
                                   (\ (p1_abfL :: (GHC.Word.Word8, [GHC.Word.Word8])) ->
                                      GHC.Types.:
                                        @GHC.Word.Word8
                                        (case p1_abfL of { (x_abfN, ds_abfO) -> x_abfN })
                                        (case p1_abfL of { (ds_abfR, y_abfS) -> y_abfS })) } in
                           \ (ds3_abfU
                                :: Data.Either.Either
                                     [GHC.Word.Word8]
                                     (f_abfA (GHC.Word.Word8, [GHC.Word.Word8]))) ->
                             case ds3_abfU of {
                               Data.Either.Left x_abfW -> f2_abfJ x_abfW;
                               Data.Either.Right y_abfY -> ds2_abfK y_abfY
                             }) } in
                  let {
                    g_abg0
                      :: p_abfz
                           (GHC.Word.Word8, [GHC.Word.Word8])
                           (f_abfA (GHC.Word.Word8, [GHC.Word.Word8]))
                         -> p_abfz
                              (Data.Either.Either
                                 [GHC.Word.Word8] (GHC.Word.Word8, [GHC.Word.Word8]))
                              (Data.Either.Either
                                 [GHC.Word.Word8] (f_abfA (GHC.Word.Word8, [GHC.Word.Word8])))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abg0
                      = Data.Profunctor.Choice.right'
                          @p_abfz
                          $dChoice_abfB
                          @(GHC.Word.Word8, [GHC.Word.Word8])
                          @(f_abfA (GHC.Word.Word8, [GHC.Word.Word8]))
                          @[GHC.Word.Word8] } in
                  \ (x_abg1
                       :: p_abfz
                            (GHC.Word.Word8, [GHC.Word.Word8])
                            (f_abfA (GHC.Word.Word8, [GHC.Word.Word8]))) ->
                    f1_abfD (g_abg0 x_abg1))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <[GHC.Word.Word8]>_N
                                <[GHC.Word.Word8]>_N
                                <GHC.Word.Word8>_N
                                <GHC.Word.Word8>_N)
                       :: Control.Lens.Type.Prism
                            [GHC.Word.Word8]
                            [GHC.Word.Word8]
                            (GHC.Word.Word8, [GHC.Word.Word8])
                            (GHC.Word.Word8, [GHC.Word.Word8])
                          ~R# Control.Lens.Cons.Cons
                                [GHC.Word.Word8] [GHC.Word.Word8] GHC.Word.Word8 GHC.Word.Word8))
              ((\ (@(p_abg6 :: * -> * -> *))
                  (@(f_abg7 :: * -> *))
                  ($dChoice_abg8 :: Data.Profunctor.Choice.Choice p_abg6)
                  ($dApplicative_abg9 :: GHC.Base.Applicative f_abg7) ->
                  let {
                    f1_abga
                      :: p_abg6
                           (Data.Either.Either [GHC.Word.Word8] ())
                           (Data.Either.Either [GHC.Word.Word8] (f_abg7 ()))
                         -> p_abg6 [GHC.Word.Word8] (f_abg7 [GHC.Word.Word8])
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 290 0}]
                    f1_abga
                      = Data.Profunctor.Unsafe.dimap
                          @p_abg6
                          (Data.Profunctor.Choice.$p1Choice @p_abg6 $dChoice_abg8)
                          @[GHC.Word.Word8]
                          @(Data.Either.Either [GHC.Word.Word8] ())
                          @(Data.Either.Either [GHC.Word.Word8] (f_abg7 ()))
                          @(f_abg7 [GHC.Word.Word8])
                          (\ (s_abgb :: [GHC.Word.Word8]) ->
                             case s_abgb of wild_abgc {
                               [] -> Data.Either.Right @[GHC.Word.Word8] @() GHC.Tuple.Prim.();
                               : ds1_abgd ds2_abge ->
                                 Data.Either.Left @[GHC.Word.Word8] @() wild_abgc
                             })
                          (let {
                             f2_abgg :: [GHC.Word.Word8] -> f_abg7 [GHC.Word.Word8]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abgg
                               = GHC.Base.pure @f_abg7 $dApplicative_abg9 @[GHC.Word.Word8] } in
                           let {
                             ds2_abgh :: f_abg7 () -> f_abg7 [GHC.Word.Word8]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 70 0}]
                             ds2_abgh
                               = GHC.Base.fmap
                                   @f_abg7
                                   (GHC.Base.$p1Applicative @f_abg7 $dApplicative_abg9)
                                   @()
                                   @[GHC.Word.Word8]
                                   (\ (ds3_abgi :: ()) ->
                                      case ds3_abgi of { () -> GHC.Types.[] @GHC.Word.Word8 }) } in
                           \ (ds3_abgk :: Data.Either.Either [GHC.Word.Word8] (f_abg7 ())) ->
                             case ds3_abgk of {
                               Data.Either.Left x_abgm -> f2_abgg x_abgm;
                               Data.Either.Right y_abgo -> ds2_abgh y_abgo
                             }) } in
                  let {
                    g_abgq
                      :: p_abg6 () (f_abg7 ())
                         -> p_abg6
                              (Data.Either.Either [GHC.Word.Word8] ())
                              (Data.Either.Either [GHC.Word.Word8] (f_abg7 ()))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abgq
                      = Data.Profunctor.Choice.right'
                          @p_abg6 $dChoice_abg8 @() @(f_abg7 ()) @[GHC.Word.Word8] } in
                  \ (x_abgr :: p_abg6 () (f_abg7 ())) -> f1_abga (g_abgq x_abgr))
               `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0] <[GHC.Word.Word8]>_N)
                       :: Control.Lens.Type.Prism' [GHC.Word.Word8] ()
                          ~R# Control.Lens.Empty.AsEmpty [GHC.Word.Word8]))
              (Data.Functor.Contravariant.$fContravariantConst @[GHC.Word.Word8])
              (Data.Functor.Const.$fFunctorConst @[GHC.Word.Word8])
    Cont:   ApplyToVal nodup hole Control.Lens.Getter.Getting
                                    [GHC.Word.Word8]
                                    Data.ByteString.Internal.Type.ByteString
                                    [GHC.Word.Word8]
              ((\ (ds_abe3 [Occ=Once1] :: a_abe0) -> ds_abe3)
               `cast` (<a_abe0>_R
                       %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                          <*>_N <a_abe0>_R <a_abe0>_P)
                       :: (a_abe0 -> a_abe0)
                          ~R# (a_abe0 -> Data.Functor.Const.Const a_abe0 a_abe0)))
            ApplyToVal nodup hole Data.ByteString.Internal.Type.ByteString
                                  -> Data.Functor.Const.Const
                                       [GHC.Word.Word8] Data.ByteString.Internal.Type.ByteString
              (Control.Lens.Getter.view
                 @[GHC.Word.Word8]
                 @((->) [GHC.Word.Word8])
                 @Data.ByteString.Internal.Type.ByteString
                 (Control.Monad.Reader.Class.$fMonadReaderrFUN @[GHC.Word.Word8])
                 (Control.Lens.Cons.Extras.recons
                    @[GHC.Word.Word8]
                    @GHC.Word.Word8
                    @Data.ByteString.Internal.Type.ByteString
                    (Control.Lens.Cons.$fConsListListab
                       @GHC.Word.Word8 @GHC.Word.Word8)
                    Control.Lens.Cons.$fConsByteStringByteStringWord8Word80
                    Control.Lens.Empty.$fAsEmptyByteString0
                    @(Data.Functor.Const.Const
                        Data.ByteString.Internal.Type.ByteString)
                    (Data.Functor.Contravariant.$fContravariantConst
                       @Data.ByteString.Internal.Type.ByteString)
                    (Data.Functor.Const.$fFunctorConst
                       @Data.ByteString.Internal.Type.ByteString))
                 s_a8OF)
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N
                        <[GHC.Word.Word8]>_R
                        <Data.ByteString.Internal.Type.ByteString>_P
                    :: Data.Functor.Const.Const
                         [GHC.Word.Word8] Data.ByteString.Internal.Type.ByteString
                       ~R# [GHC.Word.Word8])
            Stop[RuleArgCtxt] [GHC.Word.Word8]
Rule fired
    Rule: Class op fmap
    Module: (BUILTIN)
    Before: GHC.Base.fmap
              TyArg Data.Functor.Const.Const [GHC.Word.Word8]
              ValArg Data.Functor.Const.$fFunctorConst @[GHC.Word.Word8]
    After:  (Data.Functor.Const.$fFunctorConst2 @[GHC.Word.Word8])
            `cast` (forall (a :: <*>_N) (b :: <*>_N).
                    <a -> b>_R
                    %<'GHC.Types.Many>_N ->_R <Data.Functor.Const.Const
                                                 [GHC.Word.Word8] a>_R
                    %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                  <*>_N <[GHC.Word.Word8]>_R <a>_P
                                              ; Sym (Data.Functor.Const.N:Const[0]
                                                         <*>_N <[GHC.Word.Word8]>_R <b>_P)
                    :: (forall {a} {b}.
                        (a -> b)
                        -> Data.Functor.Const.Const [GHC.Word.Word8] a
                        -> Data.Functor.Const.Const [GHC.Word.Word8] a)
                       ~R# (forall {a} {b}.
                            (a -> b)
                            -> Data.Functor.Const.Const [GHC.Word.Word8] a
                            -> Data.Functor.Const.Const [GHC.Word.Word8] b))
    Cont:   ApplyToTy [GHC.Word.Word8]
            ApplyToTy Data.ByteString.Internal.Type.ByteString
            ApplyToVal nodup hole ([GHC.Word.Word8]
                                   -> Data.ByteString.Internal.Type.ByteString)
                                  -> Data.Functor.Const.Const [GHC.Word.Word8] [GHC.Word.Word8]
                                  -> Data.Functor.Const.Const
                                       [GHC.Word.Word8] Data.ByteString.Internal.Type.ByteString
              Data.ByteString.Internal.Type.packBytes
            ApplyToVal nodup hole Data.Functor.Const.Const
                                    [GHC.Word.Word8] [GHC.Word.Word8]
                                  -> Data.Functor.Const.Const
                                       [GHC.Word.Word8] Data.ByteString.Internal.Type.ByteString
              (bc_aboj (ab_aboh x_abok))
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N
                        <[GHC.Word.Word8]>_R
                        <Data.ByteString.Internal.Type.ByteString>_P
                    :: Data.Functor.Const.Const
                         [GHC.Word.Word8] Data.ByteString.Internal.Type.ByteString
                       ~R# [GHC.Word.Word8])
            Stop[RuleArgCtxt] [GHC.Word.Word8]
Rule fired
    Rule: Class op reader
    Module: (BUILTIN)
    Before: Control.Monad.Reader.Class.reader
              TyArg [GHC.Word.Word8]
              TyArg (->) [GHC.Word.Word8]
              ValArg Control.Monad.Reader.Class.$fMonadReaderrFUN
                       @[GHC.Word.Word8]
    After:  \ (@a_abe8) -> GHC.Base.id @([GHC.Word.Word8] -> a_abe8)
    Cont:   ApplyToTy Data.ByteString.Internal.Type.ByteString
            ApplyToVal nodup hole ([GHC.Word.Word8]
                                   -> Data.ByteString.Internal.Type.ByteString)
                                  -> [GHC.Word.Word8] -> Data.ByteString.Internal.Type.ByteString
              ((l_abe2
                  ((\ (ds_abe3 [Occ=Once1] :: a_abe0) -> ds_abe3)
                   `cast` (<a_abe0>_R
                           %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                              <*>_N <a_abe0>_R <a_abe0>_P)
                           :: (a_abe0 -> a_abe0)
                              ~R# (a_abe0 -> Data.Functor.Const.Const a_abe0 a_abe0))))
               `cast` (<s_abdY>_R
                       %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                     <*>_N <a_abe0>_R <s_abdY>_P
                       :: (s_abdY -> Data.Functor.Const.Const a_abe0 s_abdY)
                          ~R# (s_abdY -> a_abe0)))
            ApplyToVal nodup hole [GHC.Word.Word8]
                                  -> Data.ByteString.Internal.Type.ByteString
              s_a8OF
            Stop[BoringCtxt] Data.ByteString.Internal.Type.ByteString
Rule fired
    Rule: recons/list-bs
    Module: (Control.Lens.Cons.Extras)
    Before: Control.Lens.Cons.Extras.recons
              TyArg [GHC.Word.Word8]
              TyArg GHC.Word.Word8
              TyArg Data.ByteString.Internal.Type.ByteString
              ValArg (\ (@(p_abfz :: * -> * -> *))
                        (@(f_abfA :: * -> *))
                        ($dChoice_abfB :: Data.Profunctor.Choice.Choice p_abfz)
                        ($dApplicative_abfC :: GHC.Base.Applicative f_abfA) ->
                        let {
                          f1_abfD
                            :: p_abfz
                                 (Data.Either.Either
                                    [GHC.Word.Word8] (GHC.Word.Word8, [GHC.Word.Word8]))
                                 (Data.Either.Either
                                    [GHC.Word.Word8] (f_abfA (GHC.Word.Word8, [GHC.Word.Word8])))
                               -> p_abfz [GHC.Word.Word8] (f_abfA [GHC.Word.Word8])
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 320 0}]
                          f1_abfD
                            = Data.Profunctor.Unsafe.dimap
                                @p_abfz
                                (Data.Profunctor.Choice.$p1Choice @p_abfz $dChoice_abfB)
                                @[GHC.Word.Word8]
                                @(Data.Either.Either
                                    [GHC.Word.Word8] (GHC.Word.Word8, [GHC.Word.Word8]))
                                @(Data.Either.Either
                                    [GHC.Word.Word8] (f_abfA (GHC.Word.Word8, [GHC.Word.Word8])))
                                @(f_abfA [GHC.Word.Word8])
                                (\ (aas_abfE :: [GHC.Word.Word8]) ->
                                   case aas_abfE of {
                                     [] ->
                                       Data.Either.Left
                                         @[GHC.Word.Word8]
                                         @(GHC.Word.Word8, [GHC.Word.Word8])
                                         (GHC.Types.[] @GHC.Word.Word8);
                                     : a1_abfG as_abfH ->
                                       Data.Either.Right
                                         @[GHC.Word.Word8]
                                         @(GHC.Word.Word8, [GHC.Word.Word8])
                                         (a1_abfG, as_abfH)
                                   })
                                (let {
                                   f2_abfJ :: [GHC.Word.Word8] -> f_abfA [GHC.Word.Word8]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abfJ
                                     = GHC.Base.pure
                                         @f_abfA $dApplicative_abfC @[GHC.Word.Word8] } in
                                 let {
                                   ds2_abfK
                                     :: f_abfA (GHC.Word.Word8, [GHC.Word.Word8])
                                        -> f_abfA [GHC.Word.Word8]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 90 0}]
                                   ds2_abfK
                                     = GHC.Base.fmap
                                         @f_abfA
                                         (GHC.Base.$p1Applicative @f_abfA $dApplicative_abfC)
                                         @(GHC.Word.Word8, [GHC.Word.Word8])
                                         @[GHC.Word.Word8]
                                         (\ (p1_abfL :: (GHC.Word.Word8, [GHC.Word.Word8])) ->
                                            GHC.Types.:
                                              @GHC.Word.Word8
                                              (case p1_abfL of { (x_abfN, ds_abfO) -> x_abfN })
                                              (case p1_abfL of { (ds_abfR, y_abfS) ->
                                               y_abfS
                                               })) } in
                                 \ (ds3_abfU
                                      :: Data.Either.Either
                                           [GHC.Word.Word8]
                                           (f_abfA (GHC.Word.Word8, [GHC.Word.Word8]))) ->
                                   case ds3_abfU of {
                                     Data.Either.Left x_abfW -> f2_abfJ x_abfW;
                                     Data.Either.Right y_abfY -> ds2_abfK y_abfY
                                   }) } in
                        let {
                          g_abg0
                            :: p_abfz
                                 (GHC.Word.Word8, [GHC.Word.Word8])
                                 (f_abfA (GHC.Word.Word8, [GHC.Word.Word8]))
                               -> p_abfz
                                    (Data.Either.Either
                                       [GHC.Word.Word8] (GHC.Word.Word8, [GHC.Word.Word8]))
                                    (Data.Either.Either
                                       [GHC.Word.Word8] (f_abfA (GHC.Word.Word8, [GHC.Word.Word8])))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abg0
                            = Data.Profunctor.Choice.right'
                                @p_abfz
                                $dChoice_abfB
                                @(GHC.Word.Word8, [GHC.Word.Word8])
                                @(f_abfA (GHC.Word.Word8, [GHC.Word.Word8]))
                                @[GHC.Word.Word8] } in
                        \ (x_abg1
                             :: p_abfz
                                  (GHC.Word.Word8, [GHC.Word.Word8])
                                  (f_abfA (GHC.Word.Word8, [GHC.Word.Word8]))) ->
                          f1_abfD (g_abg0 x_abg1))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <[GHC.Word.Word8]>_N
                                      <[GHC.Word.Word8]>_N
                                      <GHC.Word.Word8>_N
                                      <GHC.Word.Word8>_N)
                             :: Control.Lens.Type.Prism
                                  [GHC.Word.Word8]
                                  [GHC.Word.Word8]
                                  (GHC.Word.Word8, [GHC.Word.Word8])
                                  (GHC.Word.Word8, [GHC.Word.Word8])
                                ~R# Control.Lens.Cons.Cons
                                      [GHC.Word.Word8]
                                      [GHC.Word.Word8]
                                      GHC.Word.Word8
                                      GHC.Word.Word8)
              ValArg (\ (@(p_abjT :: * -> * -> *))
                        (@(f_abjU :: * -> *))
                        ($dChoice_abjV :: Data.Profunctor.Choice.Choice p_abjT)
                        ($dApplicative_abjW :: GHC.Base.Applicative f_abjU) ->
                        let {
                          f1_abjX
                            :: p_abjT
                                 (Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                                 (Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString
                                    (f_abjU
                                       (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                               -> p_abjT
                                    Data.ByteString.Internal.Type.ByteString
                                    (f_abjU Data.ByteString.Internal.Type.ByteString)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 612 0}]
                          f1_abjX
                            = Data.Profunctor.Unsafe.dimap
                                @p_abjT
                                (Data.Profunctor.Choice.$p1Choice @p_abjT $dChoice_abjV)
                                @Data.ByteString.Internal.Type.ByteString
                                @(Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                                @(Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString
                                    (f_abjU
                                       (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                                @(f_abjU Data.ByteString.Internal.Type.ByteString)
                                (\ (s1_abjY :: Data.ByteString.Internal.Type.ByteString) ->
                                   case s1_abjY of wild_abjZ
                                   { Data.ByteString.Internal.Type.BS bx_abk0 bx1_abk1 bx2_abk2 ->
                                   case GHC.Classes.leInt (GHC.Types.I# bx2_abk2) (GHC.Types.I# 0#)
                                   of {
                                     GHC.Types.False ->
                                       Data.Either.Right
                                         @Data.ByteString.Internal.Type.ByteString
                                         @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                         (case GHC.Prim.readWord8OffAddr#
                                                 @GHC.Prim.RealWorld bx_abk0 0# GHC.Prim.realWorld#
                                          of
                                          { (# ipv_abk7, ipv1_abk8 #) ->
                                          case GHC.Prim.touch#
                                                 @'GHC.Types.Lifted
                                                 @GHC.ForeignPtr.ForeignPtrContents
                                                 bx1_abk1
                                                 ipv_abk7
                                          of
                                          { __DEFAULT ->
                                          GHC.Word.W8# ipv1_abk8
                                          }
                                          },
                                          Data.ByteString.Internal.Type.$WBS
                                            (GHC.ForeignPtr.ForeignPtr
                                               @GHC.Word.Word8
                                               (GHC.Prim.plusAddr# bx_abk0 1#)
                                               bx1_abk1)
                                            (GHC.Types.I# (GHC.Prim.-# bx2_abk2 1#)));
                                     GHC.Types.True ->
                                       Data.Either.Left
                                         @Data.ByteString.Internal.Type.ByteString
                                         @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                         wild_abjZ
                                   }
                                   })
                                (let {
                                   f2_abkc
                                     :: Data.ByteString.Internal.Type.ByteString
                                        -> f_abjU Data.ByteString.Internal.Type.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abkc
                                     = GHC.Base.pure
                                         @f_abjU
                                         $dApplicative_abjW
                                         @Data.ByteString.Internal.Type.ByteString } in
                                 let {
                                   ds2_abkd
                                     :: f_abjU
                                          (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                        -> f_abjU Data.ByteString.Internal.Type.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 259 0}]
                                   ds2_abkd
                                     = GHC.Base.fmap
                                         @f_abjU
                                         (GHC.Base.$p1Applicative @f_abjU $dApplicative_abjW)
                                         @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                         @Data.ByteString.Internal.Type.ByteString
                                         (\ (p1_abke
                                               :: (GHC.Word.Word8,
                                                   Data.ByteString.Internal.Type.ByteString)) ->
                                            case p1_abke of { (ds_abkg, y_abkh) ->
                                            case y_abkh of
                                            { Data.ByteString.Internal.Type.BS bx_abkt bx1_abku
                                                                               bx2_abkv ->
                                            GHC.Magic.runRW#
                                              @GHC.Types.LiftedRep
                                              @Data.ByteString.Internal.Type.ByteString
                                              (\ (s_abkr [OS=OneShot]
                                                    :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                                                 let {
                                                   x_abks :: GHC.Prim.Int#
                                                   [LclId,
                                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                            Value=False, ConLike=False,
                                                            WorkFree=False, Expandable=False,
                                                            Guidance=IF_ARGS [] 1 0}]
                                                   x_abks = GHC.Prim.+# bx2_abkv 1# } in
                                                 case GHC.Prim.<# x_abks 0# of {
                                                   __DEFAULT ->
                                                     case GHC.Prim.newPinnedByteArray#
                                                            @GHC.Prim.RealWorld x_abks s_abkr
                                                     of
                                                     { (# ipv_abkA, ipv1_abkB #) ->
                                                     let {
                                                       ipv2_abkz :: GHC.Prim.Addr#
                                                       [LclId,
                                                        Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                                Value=False, ConLike=False,
                                                                WorkFree=False, Expandable=False,
                                                                Guidance=IF_ARGS [] 1 0}]
                                                       ipv2_abkz
                                                         = GHC.Prim.mutableByteArrayContents#
                                                             @GHC.Prim.RealWorld ipv1_abkB } in
                                                     let {
                                                       ipv3_abkD
                                                         :: GHC.ForeignPtr.ForeignPtrContents
                                                       [LclId,
                                                        Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                                Value=True, ConLike=True,
                                                                WorkFree=True, Expandable=True,
                                                                Guidance=IF_ARGS [] 10 10}]
                                                       ipv3_abkD
                                                         = GHC.ForeignPtr.PlainPtr ipv1_abkB } in
                                                     case ds_abkg of { GHC.Word.W8# x1_ablV ->
                                                     case GHC.Prim.writeWord8OffAddr#
                                                            @GHC.Prim.RealWorld
                                                            ipv2_abkz
                                                            0#
                                                            x1_ablV
                                                            ipv_abkA
                                                     of s2_ablX
                                                     { __DEFAULT ->
                                                     case GHC.Prim.touch#
                                                            @'GHC.Types.Lifted
                                                            @GHC.ForeignPtr.ForeignPtrContents
                                                            ipv3_abkD
                                                            s2_ablX
                                                     of s'_ablY
                                                     { __DEFAULT ->
                                                     case {__ffi_static_ccall_unsafe base:memcpy :: Addr#
                                          -> Addr#
                                          -> Word64#
                                          -> State# RealWorld
                                          -> (# State# RealWorld, Addr# #)}_ablZ
                                                            (GHC.Prim.plusAddr# ipv2_abkz 1#)
                                                            bx_abkt
                                                            (GHC.Prim.int64ToWord64#
                                                               (GHC.Prim.intToInt64# bx2_abkv))
                                                            s'_ablY
                                                     of
                                                     { (# ds4_abm1, ds5_abm2 #) ->
                                                     case GHC.Prim.touch#
                                                            @'GHC.Types.Lifted
                                                            @GHC.ForeignPtr.ForeignPtrContents
                                                            bx1_abku
                                                            ds4_abm1
                                                     of s'1_abm4
                                                     { __DEFAULT ->
                                                     case GHC.Prim.touch#
                                                            @'GHC.Types.Lifted
                                                            @GHC.ForeignPtr.ForeignPtrContents
                                                            ipv3_abkD
                                                            s'1_abm4
                                                     of s'2_abm5
                                                     { __DEFAULT ->
                                                     case GHC.Magic.lazy
                                                            @((GHC.Prim.State# GHC.Prim.RealWorld
                                                               -> (# GHC.Prim.State#
                                                                       GHC.Prim.RealWorld,
                                                                     GHC.Prim.Addr# #))
                                                              -> (# GHC.Prim.State#
                                                                      GHC.Prim.RealWorld,
                                                                    GHC.Prim.Addr# #))
                                                            (GHC.Magic.runRW#
                                                               @('GHC.Types.TupleRep
                                                                   '[GHC.Types.ZeroBitRep,
                                                                     'GHC.Types.AddrRep])
                                                               @(# GHC.Prim.State#
                                                                     GHC.Prim.RealWorld,
                                                                   GHC.Prim.Addr# #))
                                                            (\ _ [Occ=Dead] ->
                                                               (# s'2_abm5, ipv2_abkz #))
                                                     of
                                                     { (# ipv6_abm8, ipv7_abm9 #) ->
                                                     Data.ByteString.Internal.Type.BS
                                                       ipv7_abm9 ipv3_abkD x_abks
                                                     }
                                                     }
                                                     }
                                                     }
                                                     }
                                                     }
                                                     }
                                                     };
                                                   1# ->
                                                     case GHC.ForeignPtr.mallocPlainForeignPtrBytes2
                                                     of wild_00 {
                                                     }
                                                 })
                                            }
                                            }) } in
                                 \ (ds3_abmc
                                      :: Data.Either.Either
                                           Data.ByteString.Internal.Type.ByteString
                                           (f_abjU
                                              (GHC.Word.Word8,
                                               Data.ByteString.Internal.Type.ByteString))) ->
                                   case ds3_abmc of {
                                     Data.Either.Left x_abme -> f2_abkc x_abme;
                                     Data.Either.Right y_abmg -> ds2_abkd y_abmg
                                   }) } in
                        let {
                          g_abmi
                            :: p_abjT
                                 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                 (f_abjU (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                               -> p_abjT
                                    (Data.Either.Either
                                       Data.ByteString.Internal.Type.ByteString
                                       (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                                    (Data.Either.Either
                                       Data.ByteString.Internal.Type.ByteString
                                       (f_abjU
                                          (GHC.Word.Word8,
                                           Data.ByteString.Internal.Type.ByteString)))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abmi
                            = Data.Profunctor.Choice.right'
                                @p_abjT
                                $dChoice_abjV
                                @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                @(f_abjU
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                                @Data.ByteString.Internal.Type.ByteString } in
                        \ (x_abmj
                             :: p_abjT
                                  (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                  (f_abjU
                                     (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))) ->
                          f1_abjX (g_abmi x_abmj))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <Data.ByteString.Internal.Type.ByteString>_N
                                      <Data.ByteString.Internal.Type.ByteString>_N
                                      <GHC.Word.Word8>_N
                                      <GHC.Word.Word8>_N)
                             :: Control.Lens.Type.Prism
                                  Data.ByteString.Internal.Type.ByteString
                                  Data.ByteString.Internal.Type.ByteString
                                  (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                  (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                ~R# Control.Lens.Cons.Cons
                                      Data.ByteString.Internal.Type.ByteString
                                      Data.ByteString.Internal.Type.ByteString
                                      GHC.Word.Word8
                                      GHC.Word.Word8)
              ValArg (\ (@(p_abmq :: * -> * -> *))
                        (@(f_abmr :: * -> *))
                        ($dChoice_abms :: Data.Profunctor.Choice.Choice p_abmq)
                        ($dApplicative_abmt :: GHC.Base.Applicative f_abmr) ->
                        let {
                          f1_abmu
                            :: p_abmq
                                 (Data.Either.Either Data.ByteString.Internal.Type.ByteString ())
                                 (Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString (f_abmr ()))
                               -> p_abmq
                                    Data.ByteString.Internal.Type.ByteString
                                    (f_abmr Data.ByteString.Internal.Type.ByteString)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 350 0}]
                          f1_abmu
                            = Data.Profunctor.Unsafe.dimap
                                @p_abmq
                                (Data.Profunctor.Choice.$p1Choice @p_abmq $dChoice_abms)
                                @Data.ByteString.Internal.Type.ByteString
                                @(Data.Either.Either Data.ByteString.Internal.Type.ByteString ())
                                @(Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString (f_abmr ()))
                                @(f_abmr Data.ByteString.Internal.Type.ByteString)
                                (\ (s_abmv :: Data.ByteString.Internal.Type.ByteString) ->
                                   case s_abmv of wild_abmw
                                   { Data.ByteString.Internal.Type.BS bx_abmx bx1_abmy bx2_abmz ->
                                   case GHC.Classes.leInt (GHC.Types.I# bx2_abmz) (GHC.Types.I# 0#)
                                   of {
                                     GHC.Types.False ->
                                       Data.Either.Left
                                         @Data.ByteString.Internal.Type.ByteString @() wild_abmw;
                                     GHC.Types.True ->
                                       Data.Either.Right
                                         @Data.ByteString.Internal.Type.ByteString
                                         @()
                                         GHC.Tuple.Prim.()
                                   }
                                   })
                                (let {
                                   f2_abmD
                                     :: Data.ByteString.Internal.Type.ByteString
                                        -> f_abmr Data.ByteString.Internal.Type.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abmD
                                     = GHC.Base.pure
                                         @f_abmr
                                         $dApplicative_abmt
                                         @Data.ByteString.Internal.Type.ByteString } in
                                 let {
                                   ds2_abmE
                                     :: f_abmr () -> f_abmr Data.ByteString.Internal.Type.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 70 0}]
                                   ds2_abmE
                                     = GHC.Base.fmap
                                         @f_abmr
                                         (GHC.Base.$p1Applicative @f_abmr $dApplicative_abmt)
                                         @()
                                         @Data.ByteString.Internal.Type.ByteString
                                         (\ (ds3_abmF :: ()) ->
                                            case ds3_abmF of { () ->
                                            Data.ByteString.Internal.Type.empty
                                            }) } in
                                 \ (ds3_abmH
                                      :: Data.Either.Either
                                           Data.ByteString.Internal.Type.ByteString (f_abmr ())) ->
                                   case ds3_abmH of {
                                     Data.Either.Left x_abmJ -> f2_abmD x_abmJ;
                                     Data.Either.Right y_abmL -> ds2_abmE y_abmL
                                   }) } in
                        let {
                          g_abmN
                            :: p_abmq () (f_abmr ())
                               -> p_abmq
                                    (Data.Either.Either Data.ByteString.Internal.Type.ByteString ())
                                    (Data.Either.Either
                                       Data.ByteString.Internal.Type.ByteString (f_abmr ()))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abmN
                            = Data.Profunctor.Choice.right'
                                @p_abmq
                                $dChoice_abms
                                @()
                                @(f_abmr ())
                                @Data.ByteString.Internal.Type.ByteString } in
                        \ (x_abmO :: p_abmq () (f_abmr ())) -> f1_abmu (g_abmN x_abmO))
                     `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                      <Data.ByteString.Internal.Type.ByteString>_N)
                             :: Control.Lens.Type.Prism'
                                  Data.ByteString.Internal.Type.ByteString ()
                                ~R# Control.Lens.Empty.AsEmpty
                                      Data.ByteString.Internal.Type.ByteString)
              TyArg Data.Functor.Const.Const
                      Data.ByteString.Internal.Type.ByteString
              ValArg Data.Functor.Contravariant.$fContravariantConst
                       @Data.ByteString.Internal.Type.ByteString
              ValArg Data.Functor.Const.$fFunctorConst
                       @Data.ByteString.Internal.Type.ByteString
    After:  (\ (@(f_abeP :: * -> *))
               ($dCons_abeQ
                  :: Control.Lens.Cons.Cons
                       [GHC.Word.Word8] [GHC.Word.Word8] GHC.Word.Word8 GHC.Word.Word8)
               ($dCons1_abeR
                  :: Control.Lens.Cons.Cons
                       Data.ByteString.Internal.Type.ByteString
                       Data.ByteString.Internal.Type.ByteString
                       GHC.Word.Word8
                       GHC.Word.Word8)
               ($dAsEmpty_abeS
                  :: Control.Lens.Empty.AsEmpty
                       Data.ByteString.Internal.Type.ByteString)
               ($dContravariant_abeT
                  :: Data.Functor.Contravariant.Contravariant f_abeP)
               ($dFunctor_abeU :: GHC.Base.Functor f_abeP) ->
               Data.Profunctor.Unsafe.$fProfunctorFUN_$cdimap
                 @[GHC.Word.Word8]
                 @Data.ByteString.Internal.Type.ByteString
                 @(f_abeP Data.ByteString.Internal.Type.ByteString)
                 @(f_abeP [GHC.Word.Word8])
                 Data.ByteString.Internal.Type.packBytes
                 (GHC.Base.fmap
                    @f_abeP
                    $dFunctor_abeU
                    @Data.ByteString.Internal.Type.ByteString
                    @[GHC.Word.Word8]
                    Data.ByteString.unpack))
              @(Data.Functor.Const.Const
                  Data.ByteString.Internal.Type.ByteString)
              ((\ (@(p_abfz :: * -> * -> *))
                  (@(f_abfA :: * -> *))
                  ($dChoice_abfB :: Data.Profunctor.Choice.Choice p_abfz)
                  ($dApplicative_abfC :: GHC.Base.Applicative f_abfA) ->
                  let {
                    f1_abfD
                      :: p_abfz
                           (Data.Either.Either
                              [GHC.Word.Word8] (GHC.Word.Word8, [GHC.Word.Word8]))
                           (Data.Either.Either
                              [GHC.Word.Word8] (f_abfA (GHC.Word.Word8, [GHC.Word.Word8])))
                         -> p_abfz [GHC.Word.Word8] (f_abfA [GHC.Word.Word8])
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 320 0}]
                    f1_abfD
                      = Data.Profunctor.Unsafe.dimap
                          @p_abfz
                          (Data.Profunctor.Choice.$p1Choice @p_abfz $dChoice_abfB)
                          @[GHC.Word.Word8]
                          @(Data.Either.Either
                              [GHC.Word.Word8] (GHC.Word.Word8, [GHC.Word.Word8]))
                          @(Data.Either.Either
                              [GHC.Word.Word8] (f_abfA (GHC.Word.Word8, [GHC.Word.Word8])))
                          @(f_abfA [GHC.Word.Word8])
                          (\ (aas_abfE :: [GHC.Word.Word8]) ->
                             case aas_abfE of {
                               [] ->
                                 Data.Either.Left
                                   @[GHC.Word.Word8]
                                   @(GHC.Word.Word8, [GHC.Word.Word8])
                                   (GHC.Types.[] @GHC.Word.Word8);
                               : a1_abfG as_abfH ->
                                 Data.Either.Right
                                   @[GHC.Word.Word8]
                                   @(GHC.Word.Word8, [GHC.Word.Word8])
                                   (a1_abfG, as_abfH)
                             })
                          (let {
                             f2_abfJ :: [GHC.Word.Word8] -> f_abfA [GHC.Word.Word8]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abfJ
                               = GHC.Base.pure @f_abfA $dApplicative_abfC @[GHC.Word.Word8] } in
                           let {
                             ds2_abfK
                               :: f_abfA (GHC.Word.Word8, [GHC.Word.Word8])
                                  -> f_abfA [GHC.Word.Word8]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 90 0}]
                             ds2_abfK
                               = GHC.Base.fmap
                                   @f_abfA
                                   (GHC.Base.$p1Applicative @f_abfA $dApplicative_abfC)
                                   @(GHC.Word.Word8, [GHC.Word.Word8])
                                   @[GHC.Word.Word8]
                                   (\ (p1_abfL :: (GHC.Word.Word8, [GHC.Word.Word8])) ->
                                      GHC.Types.:
                                        @GHC.Word.Word8
                                        (case p1_abfL of { (x_abfN, ds_abfO) -> x_abfN })
                                        (case p1_abfL of { (ds_abfR, y_abfS) -> y_abfS })) } in
                           \ (ds3_abfU
                                :: Data.Either.Either
                                     [GHC.Word.Word8]
                                     (f_abfA (GHC.Word.Word8, [GHC.Word.Word8]))) ->
                             case ds3_abfU of {
                               Data.Either.Left x_abfW -> f2_abfJ x_abfW;
                               Data.Either.Right y_abfY -> ds2_abfK y_abfY
                             }) } in
                  let {
                    g_abg0
                      :: p_abfz
                           (GHC.Word.Word8, [GHC.Word.Word8])
                           (f_abfA (GHC.Word.Word8, [GHC.Word.Word8]))
                         -> p_abfz
                              (Data.Either.Either
                                 [GHC.Word.Word8] (GHC.Word.Word8, [GHC.Word.Word8]))
                              (Data.Either.Either
                                 [GHC.Word.Word8] (f_abfA (GHC.Word.Word8, [GHC.Word.Word8])))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abg0
                      = Data.Profunctor.Choice.right'
                          @p_abfz
                          $dChoice_abfB
                          @(GHC.Word.Word8, [GHC.Word.Word8])
                          @(f_abfA (GHC.Word.Word8, [GHC.Word.Word8]))
                          @[GHC.Word.Word8] } in
                  \ (x_abg1
                       :: p_abfz
                            (GHC.Word.Word8, [GHC.Word.Word8])
                            (f_abfA (GHC.Word.Word8, [GHC.Word.Word8]))) ->
                    f1_abfD (g_abg0 x_abg1))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <[GHC.Word.Word8]>_N
                                <[GHC.Word.Word8]>_N
                                <GHC.Word.Word8>_N
                                <GHC.Word.Word8>_N)
                       :: Control.Lens.Type.Prism
                            [GHC.Word.Word8]
                            [GHC.Word.Word8]
                            (GHC.Word.Word8, [GHC.Word.Word8])
                            (GHC.Word.Word8, [GHC.Word.Word8])
                          ~R# Control.Lens.Cons.Cons
                                [GHC.Word.Word8] [GHC.Word.Word8] GHC.Word.Word8 GHC.Word.Word8))
              ((\ (@(p_abjT :: * -> * -> *))
                  (@(f_abjU :: * -> *))
                  ($dChoice_abjV :: Data.Profunctor.Choice.Choice p_abjT)
                  ($dApplicative_abjW :: GHC.Base.Applicative f_abjU) ->
                  let {
                    f1_abjX
                      :: p_abjT
                           (Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString
                              (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                           (Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString
                              (f_abjU
                                 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                         -> p_abjT
                              Data.ByteString.Internal.Type.ByteString
                              (f_abjU Data.ByteString.Internal.Type.ByteString)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 612 0}]
                    f1_abjX
                      = Data.Profunctor.Unsafe.dimap
                          @p_abjT
                          (Data.Profunctor.Choice.$p1Choice @p_abjT $dChoice_abjV)
                          @Data.ByteString.Internal.Type.ByteString
                          @(Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString
                              (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                          @(Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString
                              (f_abjU
                                 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                          @(f_abjU Data.ByteString.Internal.Type.ByteString)
                          (\ (s1_abjY :: Data.ByteString.Internal.Type.ByteString) ->
                             case s1_abjY of wild_abjZ
                             { Data.ByteString.Internal.Type.BS bx_abk0 bx1_abk1 bx2_abk2 ->
                             case GHC.Classes.leInt (GHC.Types.I# bx2_abk2) (GHC.Types.I# 0#)
                             of {
                               GHC.Types.False ->
                                 Data.Either.Right
                                   @Data.ByteString.Internal.Type.ByteString
                                   @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                   (case GHC.Prim.readWord8OffAddr#
                                           @GHC.Prim.RealWorld bx_abk0 0# GHC.Prim.realWorld#
                                    of
                                    { (# ipv_abk7, ipv1_abk8 #) ->
                                    case GHC.Prim.touch#
                                           @'GHC.Types.Lifted
                                           @GHC.ForeignPtr.ForeignPtrContents
                                           bx1_abk1
                                           ipv_abk7
                                    of
                                    { __DEFAULT ->
                                    GHC.Word.W8# ipv1_abk8
                                    }
                                    },
                                    Data.ByteString.Internal.Type.$WBS
                                      (GHC.ForeignPtr.ForeignPtr
                                         @GHC.Word.Word8 (GHC.Prim.plusAddr# bx_abk0 1#) bx1_abk1)
                                      (GHC.Types.I# (GHC.Prim.-# bx2_abk2 1#)));
                               GHC.Types.True ->
                                 Data.Either.Left
                                   @Data.ByteString.Internal.Type.ByteString
                                   @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                   wild_abjZ
                             }
                             })
                          (let {
                             f2_abkc
                               :: Data.ByteString.Internal.Type.ByteString
                                  -> f_abjU Data.ByteString.Internal.Type.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abkc
                               = GHC.Base.pure
                                   @f_abjU
                                   $dApplicative_abjW
                                   @Data.ByteString.Internal.Type.ByteString } in
                           let {
                             ds2_abkd
                               :: f_abjU
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                  -> f_abjU Data.ByteString.Internal.Type.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 259 0}]
                             ds2_abkd
                               = GHC.Base.fmap
                                   @f_abjU
                                   (GHC.Base.$p1Applicative @f_abjU $dApplicative_abjW)
                                   @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                   @Data.ByteString.Internal.Type.ByteString
                                   (\ (p1_abke
                                         :: (GHC.Word.Word8,
                                             Data.ByteString.Internal.Type.ByteString)) ->
                                      case p1_abke of { (ds_abkg, y_abkh) ->
                                      case y_abkh of
                                      { Data.ByteString.Internal.Type.BS bx_abkt bx1_abku
                                                                         bx2_abkv ->
                                      GHC.Magic.runRW#
                                        @GHC.Types.LiftedRep
                                        @Data.ByteString.Internal.Type.ByteString
                                        (\ (s_abkr [OS=OneShot]
                                              :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                                           let {
                                             x_abks :: GHC.Prim.Int#
                                             [LclId,
                                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                      Value=False, ConLike=False, WorkFree=False,
                                                      Expandable=False,
                                                      Guidance=IF_ARGS [] 1 0}]
                                             x_abks = GHC.Prim.+# bx2_abkv 1# } in
                                           case GHC.Prim.<# x_abks 0# of {
                                             __DEFAULT ->
                                               case GHC.Prim.newPinnedByteArray#
                                                      @GHC.Prim.RealWorld x_abks s_abkr
                                               of
                                               { (# ipv_abkA, ipv1_abkB #) ->
                                               let {
                                                 ipv2_abkz :: GHC.Prim.Addr#
                                                 [LclId,
                                                  Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                          Value=False, ConLike=False,
                                                          WorkFree=False, Expandable=False,
                                                          Guidance=IF_ARGS [] 1 0}]
                                                 ipv2_abkz
                                                   = GHC.Prim.mutableByteArrayContents#
                                                       @GHC.Prim.RealWorld ipv1_abkB } in
                                               let {
                                                 ipv3_abkD :: GHC.ForeignPtr.ForeignPtrContents
                                                 [LclId,
                                                  Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                          Value=True, ConLike=True, WorkFree=True,
                                                          Expandable=True,
                                                          Guidance=IF_ARGS [] 10 10}]
                                                 ipv3_abkD = GHC.ForeignPtr.PlainPtr ipv1_abkB } in
                                               case ds_abkg of { GHC.Word.W8# x1_ablV ->
                                               case GHC.Prim.writeWord8OffAddr#
                                                      @GHC.Prim.RealWorld
                                                      ipv2_abkz
                                                      0#
                                                      x1_ablV
                                                      ipv_abkA
                                               of s2_ablX
                                               { __DEFAULT ->
                                               case GHC.Prim.touch#
                                                      @'GHC.Types.Lifted
                                                      @GHC.ForeignPtr.ForeignPtrContents
                                                      ipv3_abkD
                                                      s2_ablX
                                               of s'_ablY
                                               { __DEFAULT ->
                                               case {__ffi_static_ccall_unsafe base:memcpy :: Addr#
                                          -> Addr#
                                          -> Word64#
                                          -> State# RealWorld
                                          -> (# State# RealWorld, Addr# #)}_ablZ
                                                      (GHC.Prim.plusAddr# ipv2_abkz 1#)
                                                      bx_abkt
                                                      (GHC.Prim.int64ToWord64#
                                                         (GHC.Prim.intToInt64# bx2_abkv))
                                                      s'_ablY
                                               of
                                               { (# ds4_abm1, ds5_abm2 #) ->
                                               case GHC.Prim.touch#
                                                      @'GHC.Types.Lifted
                                                      @GHC.ForeignPtr.ForeignPtrContents
                                                      bx1_abku
                                                      ds4_abm1
                                               of s'1_abm4
                                               { __DEFAULT ->
                                               case GHC.Prim.touch#
                                                      @'GHC.Types.Lifted
                                                      @GHC.ForeignPtr.ForeignPtrContents
                                                      ipv3_abkD
                                                      s'1_abm4
                                               of s'2_abm5
                                               { __DEFAULT ->
                                               case GHC.Magic.lazy
                                                      @((GHC.Prim.State# GHC.Prim.RealWorld
                                                         -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                               GHC.Prim.Addr# #))
                                                        -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                              GHC.Prim.Addr# #))
                                                      (GHC.Magic.runRW#
                                                         @('GHC.Types.TupleRep
                                                             '[GHC.Types.ZeroBitRep,
                                                               'GHC.Types.AddrRep])
                                                         @(# GHC.Prim.State# GHC.Prim.RealWorld,
                                                             GHC.Prim.Addr# #))
                                                      (\ _ [Occ=Dead] -> (# s'2_abm5, ipv2_abkz #))
                                               of
                                               { (# ipv6_abm8, ipv7_abm9 #) ->
                                               Data.ByteString.Internal.Type.BS
                                                 ipv7_abm9 ipv3_abkD x_abks
                                               }
                                               }
                                               }
                                               }
                                               }
                                               }
                                               }
                                               };
                                             1# ->
                                               case GHC.ForeignPtr.mallocPlainForeignPtrBytes2
                                               of wild_00 {
                                               }
                                           })
                                      }
                                      }) } in
                           \ (ds3_abmc
                                :: Data.Either.Either
                                     Data.ByteString.Internal.Type.ByteString
                                     (f_abjU
                                        (GHC.Word.Word8,
                                         Data.ByteString.Internal.Type.ByteString))) ->
                             case ds3_abmc of {
                               Data.Either.Left x_abme -> f2_abkc x_abme;
                               Data.Either.Right y_abmg -> ds2_abkd y_abmg
                             }) } in
                  let {
                    g_abmi
                      :: p_abjT
                           (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                           (f_abjU (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                         -> p_abjT
                              (Data.Either.Either
                                 Data.ByteString.Internal.Type.ByteString
                                 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                              (Data.Either.Either
                                 Data.ByteString.Internal.Type.ByteString
                                 (f_abjU
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abmi
                      = Data.Profunctor.Choice.right'
                          @p_abjT
                          $dChoice_abjV
                          @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                          @(f_abjU
                              (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                          @Data.ByteString.Internal.Type.ByteString } in
                  \ (x_abmj
                       :: p_abjT
                            (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                            (f_abjU
                               (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))) ->
                    f1_abjX (g_abmi x_abmj))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <Data.ByteString.Internal.Type.ByteString>_N
                                <Data.ByteString.Internal.Type.ByteString>_N
                                <GHC.Word.Word8>_N
                                <GHC.Word.Word8>_N)
                       :: Control.Lens.Type.Prism
                            Data.ByteString.Internal.Type.ByteString
                            Data.ByteString.Internal.Type.ByteString
                            (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                            (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                          ~R# Control.Lens.Cons.Cons
                                Data.ByteString.Internal.Type.ByteString
                                Data.ByteString.Internal.Type.ByteString
                                GHC.Word.Word8
                                GHC.Word.Word8))
              ((\ (@(p_abmq :: * -> * -> *))
                  (@(f_abmr :: * -> *))
                  ($dChoice_abms :: Data.Profunctor.Choice.Choice p_abmq)
                  ($dApplicative_abmt :: GHC.Base.Applicative f_abmr) ->
                  let {
                    f1_abmu
                      :: p_abmq
                           (Data.Either.Either Data.ByteString.Internal.Type.ByteString ())
                           (Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString (f_abmr ()))
                         -> p_abmq
                              Data.ByteString.Internal.Type.ByteString
                              (f_abmr Data.ByteString.Internal.Type.ByteString)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 350 0}]
                    f1_abmu
                      = Data.Profunctor.Unsafe.dimap
                          @p_abmq
                          (Data.Profunctor.Choice.$p1Choice @p_abmq $dChoice_abms)
                          @Data.ByteString.Internal.Type.ByteString
                          @(Data.Either.Either Data.ByteString.Internal.Type.ByteString ())
                          @(Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString (f_abmr ()))
                          @(f_abmr Data.ByteString.Internal.Type.ByteString)
                          (\ (s_abmv :: Data.ByteString.Internal.Type.ByteString) ->
                             case s_abmv of wild_abmw
                             { Data.ByteString.Internal.Type.BS bx_abmx bx1_abmy bx2_abmz ->
                             case GHC.Classes.leInt (GHC.Types.I# bx2_abmz) (GHC.Types.I# 0#)
                             of {
                               GHC.Types.False ->
                                 Data.Either.Left
                                   @Data.ByteString.Internal.Type.ByteString @() wild_abmw;
                               GHC.Types.True ->
                                 Data.Either.Right
                                   @Data.ByteString.Internal.Type.ByteString @() GHC.Tuple.Prim.()
                             }
                             })
                          (let {
                             f2_abmD
                               :: Data.ByteString.Internal.Type.ByteString
                                  -> f_abmr Data.ByteString.Internal.Type.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abmD
                               = GHC.Base.pure
                                   @f_abmr
                                   $dApplicative_abmt
                                   @Data.ByteString.Internal.Type.ByteString } in
                           let {
                             ds2_abmE
                               :: f_abmr () -> f_abmr Data.ByteString.Internal.Type.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 70 0}]
                             ds2_abmE
                               = GHC.Base.fmap
                                   @f_abmr
                                   (GHC.Base.$p1Applicative @f_abmr $dApplicative_abmt)
                                   @()
                                   @Data.ByteString.Internal.Type.ByteString
                                   (\ (ds3_abmF :: ()) ->
                                      case ds3_abmF of { () ->
                                      Data.ByteString.Internal.Type.empty
                                      }) } in
                           \ (ds3_abmH
                                :: Data.Either.Either
                                     Data.ByteString.Internal.Type.ByteString (f_abmr ())) ->
                             case ds3_abmH of {
                               Data.Either.Left x_abmJ -> f2_abmD x_abmJ;
                               Data.Either.Right y_abmL -> ds2_abmE y_abmL
                             }) } in
                  let {
                    g_abmN
                      :: p_abmq () (f_abmr ())
                         -> p_abmq
                              (Data.Either.Either Data.ByteString.Internal.Type.ByteString ())
                              (Data.Either.Either
                                 Data.ByteString.Internal.Type.ByteString (f_abmr ()))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abmN
                      = Data.Profunctor.Choice.right'
                          @p_abmq
                          $dChoice_abms
                          @()
                          @(f_abmr ())
                          @Data.ByteString.Internal.Type.ByteString } in
                  \ (x_abmO :: p_abmq () (f_abmr ())) -> f1_abmu (g_abmN x_abmO))
               `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                <Data.ByteString.Internal.Type.ByteString>_N)
                       :: Control.Lens.Type.Prism'
                            Data.ByteString.Internal.Type.ByteString ()
                          ~R# Control.Lens.Empty.AsEmpty
                                Data.ByteString.Internal.Type.ByteString))
              (Data.Functor.Contravariant.$fContravariantConst
                 @Data.ByteString.Internal.Type.ByteString)
              (Data.Functor.Const.$fFunctorConst
                 @Data.ByteString.Internal.Type.ByteString)
    Cont:   ApplyToVal nodup hole Control.Lens.Getter.Getting
                                    Data.ByteString.Internal.Type.ByteString
                                    [GHC.Word.Word8]
                                    Data.ByteString.Internal.Type.ByteString
              ((\ (ds_abe3 [Occ=Once1] :: a_abe0) -> ds_abe3)
               `cast` (<a_abe0>_R
                       %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                          <*>_N <a_abe0>_R <a_abe0>_P)
                       :: (a_abe0 -> a_abe0)
                          ~R# (a_abe0 -> Data.Functor.Const.Const a_abe0 a_abe0)))
            ApplyToVal nodup hole [GHC.Word.Word8]
                                  -> Data.Functor.Const.Const
                                       Data.ByteString.Internal.Type.ByteString [GHC.Word.Word8]
              s_a8OF
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N
                        <Data.ByteString.Internal.Type.ByteString>_R
                        <[GHC.Word.Word8]>_P
                    :: Data.Functor.Const.Const
                         Data.ByteString.Internal.Type.ByteString [GHC.Word.Word8]
                       ~R# Data.ByteString.Internal.Type.ByteString)
            Stop[BoringCtxt] Data.ByteString.Internal.Type.ByteString
Rule fired
    Rule: Class op fmap
    Module: (BUILTIN)
    Before: GHC.Base.fmap
              TyArg Data.Functor.Const.Const
                      Data.ByteString.Internal.Type.ByteString
              ValArg Data.Functor.Const.$fFunctorConst
                       @Data.ByteString.Internal.Type.ByteString
    After:  (Data.Functor.Const.$fFunctorConst2
               @Data.ByteString.Internal.Type.ByteString)
            `cast` (forall (a :: <*>_N) (b :: <*>_N).
                    <a -> b>_R
                    %<'GHC.Types.Many>_N ->_R <Data.Functor.Const.Const
                                                 Data.ByteString.Internal.Type.ByteString a>_R
                    %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                  <*>_N
                                                  <Data.ByteString.Internal.Type.ByteString>_R
                                                  <a>_P
                                              ; Sym (Data.Functor.Const.N:Const[0]
                                                         <*>_N
                                                         <Data.ByteString.Internal.Type.ByteString>_R
                                                         <b>_P)
                    :: (forall {a} {b}.
                        (a -> b)
                        -> Data.Functor.Const.Const
                             Data.ByteString.Internal.Type.ByteString a
                        -> Data.Functor.Const.Const
                             Data.ByteString.Internal.Type.ByteString a)
                       ~R# (forall {a} {b}.
                            (a -> b)
                            -> Data.Functor.Const.Const
                                 Data.ByteString.Internal.Type.ByteString a
                            -> Data.Functor.Const.Const
                                 Data.ByteString.Internal.Type.ByteString b))
    Cont:   ApplyToTy Data.ByteString.Internal.Type.ByteString
            ApplyToTy [GHC.Word.Word8]
            ApplyToVal nodup hole (Data.ByteString.Internal.Type.ByteString
                                   -> [GHC.Word.Word8])
                                  -> Data.Functor.Const.Const
                                       Data.ByteString.Internal.Type.ByteString
                                       Data.ByteString.Internal.Type.ByteString
                                  -> Data.Functor.Const.Const
                                       Data.ByteString.Internal.Type.ByteString [GHC.Word.Word8]
              Data.ByteString.unpack
            ApplyToVal nodup hole Data.Functor.Const.Const
                                    Data.ByteString.Internal.Type.ByteString
                                    Data.ByteString.Internal.Type.ByteString
                                  -> Data.Functor.Const.Const
                                       Data.ByteString.Internal.Type.ByteString [GHC.Word.Word8]
              (bc_aboj (ab_aboh x_abok))
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N
                        <Data.ByteString.Internal.Type.ByteString>_R
                        <[GHC.Word.Word8]>_P
                    :: Data.Functor.Const.Const
                         Data.ByteString.Internal.Type.ByteString [GHC.Word.Word8]
                       ~R# Data.ByteString.Internal.Type.ByteString)
            Stop[BoringCtxt] Data.ByteString.Internal.Type.ByteString
Rule fired
    Rule: Class op ==
    Module: (BUILTIN)
    Before: GHC.Classes.==
              TyArg [GHC.Word.Word8]
              ValArg $dEq_a9dB
              ValArg GHC.Base.build
                       @GHC.Word.Word8
                       (\ (@b_abro) ->
                          Data.ByteString.unpackFoldr
                            @b_abro (Data.ByteString.Internal.Type.packBytes s_a8OF))
              ValArg s_a8OF
    After:  GHC.Classes.$fEqList_$c==
              @GHC.Word.Word8 GHC.Word.$fEqWord8
              ValArg GHC.Base.build
                       @GHC.Word.Word8
                       (\ (@b_abro) ->
                          Data.ByteString.unpackFoldr
                            @b_abro (Data.ByteString.Internal.Type.packBytes s_a8OF))
              ValArg s_a8OF
    Cont:   Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: unpack
    Module: (GHC.Base)
    Before: GHC.CString.unpackCString# ValArg "[W8] -> L -> [W8]"#
    After:  (\ (a_ab6H :: GHC.Prim.Addr#) ->
               GHC.Base.build
                 @GHC.Types.Char
                 (\ (@b_ab6I) -> GHC.CString.unpackFoldrCString# @b_ab6I a_ab6H))
              "[W8] -> L -> [W8]"#
    Cont:   Stop[BoringCtxt] Test.Tasty.Core.TestName
Rule fired
    Rule: Class op property
    Module: (BUILTIN)
    Before: Test.QuickCheck.Property.property
              TyArg [GHC.Word.Word8] -> GHC.Types.Bool ValArg $dTestable_a9du
    After:  Test.QuickCheck.Property.$fTestableFUN_$cproperty
              @[GHC.Word.Word8]
              @GHC.Types.Bool
              $dArbitrary_aabY
              $dShow_aabZ
              Test.QuickCheck.Property.$fTestableBool
    Cont:   ApplyToVal nodup hole ([GHC.Word.Word8] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              prop_ab6U
            CastIt (Sym (Test.Tasty.QuickCheck.N:QC[0])
                    :: Test.QuickCheck.Property.Property ~R# Test.Tasty.QuickCheck.QC)
            Stop[BoringCtxt] Test.Tasty.QuickCheck.QC
Rule fired
    Rule: Class op propertyForAllShrinkShow
    Module: (BUILTIN)
    Before: Test.QuickCheck.Property.propertyForAllShrinkShow
              TyArg GHC.Types.Bool ValArg Test.QuickCheck.Property.$fTestableBool
    After:  Test.QuickCheck.Property.$fTestableBool1
            `cast` (forall (a :: <*>_N).
                    <Test.QuickCheck.Gen.Gen a>_R
                    %<'GHC.Types.Many>_N ->_R <a -> [a]>_R
                    %<'GHC.Types.Many>_N ->_R <a -> [GHC.Base.String]>_R
                    %<'GHC.Types.Many>_N ->_R <a -> GHC.Types.Bool>_R
                    %<'GHC.Types.Many>_N ->_R Sym (Test.QuickCheck.Gen.N:Gen[0]
                                                       (Test.QuickCheck.Property.N:Prop[0]))
                                              ; Sym (Test.QuickCheck.Property.N:Property[0])
                    :: (forall {a}.
                        Test.QuickCheck.Gen.Gen a
                        -> (a -> [a])
                        -> (a -> [GHC.Base.String])
                        -> (a -> GHC.Types.Bool)
                        -> Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int
                        -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result)
                       ~R# (forall {a}.
                            Test.QuickCheck.Gen.Gen a
                            -> (a -> [a])
                            -> (a -> [GHC.Base.String])
                            -> (a -> GHC.Types.Bool)
                            -> Test.QuickCheck.Property.Property))
    Cont:   ApplyToTy [GHC.Word.Word8]
            ApplyToVal nodup hole Test.QuickCheck.Gen.Gen [GHC.Word.Word8]
                                  -> ([GHC.Word.Word8] -> [[GHC.Word.Word8]])
                                  -> ([GHC.Word.Word8] -> [GHC.Base.String])
                                  -> ([GHC.Word.Word8] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (Test.QuickCheck.Arbitrary.arbitrary @a_ab8C $dArbitrary_ab8E)
            ApplyToVal nodup hole ([GHC.Word.Word8] -> [[GHC.Word.Word8]])
                                  -> ([GHC.Word.Word8] -> [GHC.Base.String])
                                  -> ([GHC.Word.Word8] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (Test.QuickCheck.Arbitrary.shrink @a_ab8C $dArbitrary_ab8E)
            ApplyToVal nodup hole ([GHC.Word.Word8] -> [GHC.Base.String])
                                  -> ([GHC.Word.Word8] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (let {
                 g_ab8I [Occ=OnceL1!] :: a_ab8C -> GHC.Base.String
                 [LclId]
                 g_ab8I = GHC.Show.show @a_ab8C $dShow_ab8F } in
               \ (x_ab8J [Occ=Once1] :: a_ab8C) ->
                 GHC.Types.:
                   @GHC.Base.String (g_ab8I x_ab8J) (GHC.Types.[] @GHC.Base.String))
            ApplyToVal nodup hole ([GHC.Word.Word8] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              f_ab8H
            CastIt (Sym (Test.Tasty.QuickCheck.N:QC[0])
                    :: Test.QuickCheck.Property.Property ~R# Test.Tasty.QuickCheck.QC)
            Stop[BoringCtxt] Test.Tasty.QuickCheck.QC
Rule fired
    Rule: Class op arbitrary
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.arbitrary
              TyArg [GHC.Word.Word8] ValArg $dArbitrary_aabY
    After:  (Test.QuickCheck.Arbitrary.$fArbitraryList1
               @GHC.Word.Word8 Test.QuickCheck.Arbitrary.$fArbitraryWord8)
            `cast` (Sym (Test.QuickCheck.Gen.N:Gen[0] <[GHC.Word.Word8]>_R)
                    :: (Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int -> [GHC.Word.Word8])
                       ~R# Test.QuickCheck.Gen.Gen [GHC.Word.Word8])
    Cont:   Stop[BoringCtxt] Test.QuickCheck.Gen.Gen [GHC.Word.Word8]
Rule fired
    Rule: Class op arbitrary
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.arbitrary
              TyArg GHC.Word.Word8
              ValArg Test.QuickCheck.Arbitrary.$fArbitraryWord8
    After:  Test.QuickCheck.Arbitrary.$fArbitraryWord8_$sarbitrarySizedBoundedIntegral
            `cast` (Sym (Test.QuickCheck.Gen.N:Gen[0] <GHC.Word.Word8>_R)
                    :: (Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int -> GHC.Word.Word8)
                       ~R# Test.QuickCheck.Gen.Gen GHC.Word.Word8)
    Cont:   Stop[BoringCtxt, C(S,C(1,L))] Test.QuickCheck.Gen.Gen
                                            GHC.Word.Word8
Rule fired
    Rule: Class op shrink
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.shrink
              TyArg [GHC.Word.Word8] ValArg $dArbitrary_aabY
    After:  Test.QuickCheck.Arbitrary.$fArbitraryList_$cshrink
              @GHC.Word.Word8 Test.QuickCheck.Arbitrary.$fArbitraryWord8
    Cont:   Stop[BoringCtxt] [GHC.Word.Word8] -> [[GHC.Word.Word8]]
Rule fired
    Rule: Class op shrink
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.shrink
              TyArg GHC.Word.Word8
              ValArg Test.QuickCheck.Arbitrary.$fArbitraryWord8
    After:  Test.QuickCheck.Arbitrary.$fArbitraryWord8_$sshrinkIntegral
    Cont:   Stop[DiscArgCtxt, C(S,L)] GHC.Word.Word8
                                      -> [GHC.Word.Word8]
Rule fired
    Rule: Class op show
    Module: (BUILTIN)
    Before: GHC.Show.show TyArg [GHC.Word.Word8] ValArg $dShow_aabZ
    After:  GHC.Show.$fShowList_$cshow
              @GHC.Word.Word8 GHC.Word.$fShowWord8
    Cont:   Stop[RhsCtxt(NonRecursive)] [GHC.Word.Word8]
                                        -> GHC.Base.String
Rule fired
    Rule: Class op showList
    Module: (BUILTIN)
    Before: GHC.Show.showList
              TyArg GHC.Word.Word8 ValArg GHC.Word.$fShowWord8
    After:  GHC.Word.$fShowWord8_$cshowList
    Cont:   ApplyToVal nodup hole [GHC.Word.Word8] -> GHC.Show.ShowS
              x_abr2
            ApplyToVal nodup hole GHC.Show.ShowS (GHC.Types.[] @GHC.Types.Char)
            Stop[BoringCtxt] GHC.Base.String
Rule fired
    Rule: Class op reader
    Module: (BUILTIN)
    Before: Control.Monad.Reader.Class.reader
              TyArg Data.ByteString.Lazy.Internal.ByteString
              TyArg (->) Data.ByteString.Lazy.Internal.ByteString
              ValArg Control.Monad.Reader.Class.$fMonadReaderrFUN
                       @Data.ByteString.Lazy.Internal.ByteString
    After:  \ (@a_abe8) ->
              GHC.Base.id @(Data.ByteString.Lazy.Internal.ByteString -> a_abe8)
    Cont:   ApplyToTy [GHC.Word.Word8]
            ApplyToVal nodup hole (Data.ByteString.Lazy.Internal.ByteString
                                   -> [GHC.Word.Word8])
                                  -> Data.ByteString.Lazy.Internal.ByteString -> [GHC.Word.Word8]
              ((l_abe2
                  ((\ (ds_abe3 [Occ=Once1] :: a_abe0) -> ds_abe3)
                   `cast` (<a_abe0>_R
                           %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                              <*>_N <a_abe0>_R <a_abe0>_P)
                           :: (a_abe0 -> a_abe0)
                              ~R# (a_abe0 -> Data.Functor.Const.Const a_abe0 a_abe0))))
               `cast` (<s_abdY>_R
                       %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                     <*>_N <a_abe0>_R <s_abdY>_P
                       :: (s_abdY -> Data.Functor.Const.Const a_abe0 s_abdY)
                          ~R# (s_abdY -> a_abe0)))
            ApplyToVal nodup hole Data.ByteString.Lazy.Internal.ByteString
                                  -> [GHC.Word.Word8]
              (Control.Lens.Getter.view
                 @[GHC.Word.Word8]
                 @((->) [GHC.Word.Word8])
                 @Data.ByteString.Lazy.Internal.ByteString
                 (Control.Monad.Reader.Class.$fMonadReaderrFUN @[GHC.Word.Word8])
                 (Control.Lens.Cons.Extras.recons
                    @[GHC.Word.Word8]
                    @GHC.Word.Word8
                    @Data.ByteString.Lazy.Internal.ByteString
                    (Control.Lens.Cons.$fConsListListab
                       @GHC.Word.Word8 @GHC.Word.Word8)
                    Control.Lens.Cons.$fConsByteStringByteStringWord8Word8
                    Control.Lens.Empty.$fAsEmptyByteString
                    @(Data.Functor.Const.Const
                        Data.ByteString.Lazy.Internal.ByteString)
                    (Data.Functor.Contravariant.$fContravariantConst
                       @Data.ByteString.Lazy.Internal.ByteString)
                    (Data.Functor.Const.$fFunctorConst
                       @Data.ByteString.Lazy.Internal.ByteString))
                 s_a8OG)
            Stop[RuleArgCtxt] [GHC.Word.Word8]
Rule fired
    Rule: recons/lazybs-list
    Module: (Control.Lens.Cons.Extras)
    Before: Control.Lens.Cons.Extras.recons
              TyArg Data.ByteString.Lazy.Internal.ByteString
              TyArg GHC.Word.Word8
              TyArg [GHC.Word.Word8]
              ValArg (\ (@(p_abmT :: * -> * -> *))
                        (@(f_abmU :: * -> *))
                        ($dChoice_abmV :: Data.Profunctor.Choice.Choice p_abmT)
                        ($dApplicative_abmW :: GHC.Base.Applicative f_abmU) ->
                        let {
                          f1_abmX
                            :: p_abmT
                                 (Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                                 (Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (f_abmU
                                       (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                               -> p_abmT
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (f_abmU Data.ByteString.Lazy.Internal.ByteString)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 536 0}]
                          f1_abmX
                            = Data.Profunctor.Unsafe.dimap
                                @p_abmT
                                (Data.Profunctor.Choice.$p1Choice @p_abmT $dChoice_abmV)
                                @Data.ByteString.Lazy.Internal.ByteString
                                @(Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                                @(Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (f_abmU
                                       (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                                @(f_abmU Data.ByteString.Lazy.Internal.ByteString)
                                (\ (s1_abmY :: Data.ByteString.Lazy.Internal.ByteString) ->
                                   case s1_abmY of {
                                     Data.ByteString.Lazy.Internal.Empty ->
                                       Data.Either.Left
                                         @Data.ByteString.Lazy.Internal.ByteString
                                         @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                         Data.ByteString.Lazy.Internal.Empty;
                                     Data.ByteString.Lazy.Internal.Chunk bx_abn5 bx1_abn6 bx2_abn7
                                                                         cs_abn8 ->
                                       case bx2_abn7 of ds1_abna {
                                         __DEFAULT ->
                                           Data.Either.Right
                                             @Data.ByteString.Lazy.Internal.ByteString
                                             @(GHC.Word.Word8,
                                               Data.ByteString.Lazy.Internal.ByteString)
                                             (case GHC.Prim.readWord8OffAddr#
                                                     @GHC.Prim.RealWorld
                                                     bx_abn5
                                                     0#
                                                     GHC.Prim.realWorld#
                                              of
                                              { (# ipv_abnc, ipv1_abnd #) ->
                                              case GHC.Prim.touch#
                                                     @'GHC.Types.Lifted
                                                     @GHC.ForeignPtr.ForeignPtrContents
                                                     bx1_abn6
                                                     ipv_abnc
                                              of
                                              { __DEFAULT ->
                                              GHC.Word.W8# ipv1_abnd
                                              }
                                              },
                                              Data.ByteString.Lazy.Internal.$WChunk
                                                (Data.ByteString.Internal.Type.$WBS
                                                   (GHC.ForeignPtr.ForeignPtr
                                                      @GHC.Word.Word8
                                                      (GHC.Prim.plusAddr# bx_abn5 1#)
                                                      bx1_abn6)
                                                   (GHC.Types.I# (GHC.Prim.-# ds1_abna 1#)))
                                                cs_abn8);
                                         1# ->
                                           Data.Either.Right
                                             @Data.ByteString.Lazy.Internal.ByteString
                                             @(GHC.Word.Word8,
                                               Data.ByteString.Lazy.Internal.ByteString)
                                             (case GHC.Prim.readWord8OffAddr#
                                                     @GHC.Prim.RealWorld
                                                     bx_abn5
                                                     0#
                                                     GHC.Prim.realWorld#
                                              of
                                              { (# ipv_abnh, ipv1_abni #) ->
                                              case GHC.Prim.touch#
                                                     @'GHC.Types.Lifted
                                                     @GHC.ForeignPtr.ForeignPtrContents
                                                     bx1_abn6
                                                     ipv_abnh
                                              of
                                              { __DEFAULT ->
                                              GHC.Word.W8# ipv1_abni
                                              }
                                              },
                                              cs_abn8)
                                       }
                                   })
                                (let {
                                   f2_abnl
                                     :: Data.ByteString.Lazy.Internal.ByteString
                                        -> f_abmU Data.ByteString.Lazy.Internal.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abnl
                                     = GHC.Base.pure
                                         @f_abmU
                                         $dApplicative_abmW
                                         @Data.ByteString.Lazy.Internal.ByteString } in
                                 let {
                                   ds2_abnm
                                     :: f_abmU
                                          (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                        -> f_abmU Data.ByteString.Lazy.Internal.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 162 0}]
                                   ds2_abnm
                                     = GHC.Base.fmap
                                         @f_abmU
                                         (GHC.Base.$p1Applicative @f_abmU $dApplicative_abmW)
                                         @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                         @Data.ByteString.Lazy.Internal.ByteString
                                         (\ (p1_abnn
                                               :: (GHC.Word.Word8,
                                                   Data.ByteString.Lazy.Internal.ByteString)) ->
                                            case p1_abnn of { (x_abnp, ds_abnq) ->
                                            case x_abnp of { GHC.Word.W8# x#_abnt ->
                                            Data.ByteString.Lazy.Internal.$WChunk
                                              (Data.ByteString.Internal.Type.$WBS
                                                 (GHC.ForeignPtr.ForeignPtr
                                                    @GHC.Word.Word8
                                                    (GHC.Prim.plusAddr#
                                                       Data.ByteString.singleton1
                                                       (GHC.Prim.word2Int#
                                                          (GHC.Prim.word8ToWord# x#_abnt)))
                                                    GHC.ForeignPtr.FinalPtr)
                                                 (GHC.Types.I# 1#))
                                              ds_abnq
                                            }
                                            }) } in
                                 \ (ds3_abnv
                                      :: Data.Either.Either
                                           Data.ByteString.Lazy.Internal.ByteString
                                           (f_abmU
                                              (GHC.Word.Word8,
                                               Data.ByteString.Lazy.Internal.ByteString))) ->
                                   case ds3_abnv of {
                                     Data.Either.Left x_abnx -> f2_abnl x_abnx;
                                     Data.Either.Right y_abnz -> ds2_abnm y_abnz
                                   }) } in
                        let {
                          g_abnB
                            :: p_abmT
                                 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                 (f_abmU (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                               -> p_abmT
                                    (Data.Either.Either
                                       Data.ByteString.Lazy.Internal.ByteString
                                       (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                                    (Data.Either.Either
                                       Data.ByteString.Lazy.Internal.ByteString
                                       (f_abmU
                                          (GHC.Word.Word8,
                                           Data.ByteString.Lazy.Internal.ByteString)))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abnB
                            = Data.Profunctor.Choice.right'
                                @p_abmT
                                $dChoice_abmV
                                @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                @(f_abmU
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                                @Data.ByteString.Lazy.Internal.ByteString } in
                        \ (x_abnC
                             :: p_abmT
                                  (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                  (f_abmU
                                     (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))) ->
                          f1_abmX (g_abnB x_abnC))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <Data.ByteString.Lazy.Internal.ByteString>_N
                                      <Data.ByteString.Lazy.Internal.ByteString>_N
                                      <GHC.Word.Word8>_N
                                      <GHC.Word.Word8>_N)
                             :: Control.Lens.Type.Prism
                                  Data.ByteString.Lazy.Internal.ByteString
                                  Data.ByteString.Lazy.Internal.ByteString
                                  (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                  (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                ~R# Control.Lens.Cons.Cons
                                      Data.ByteString.Lazy.Internal.ByteString
                                      Data.ByteString.Lazy.Internal.ByteString
                                      GHC.Word.Word8
                                      GHC.Word.Word8)
              ValArg (\ (@(p_abfz :: * -> * -> *))
                        (@(f_abfA :: * -> *))
                        ($dChoice_abfB :: Data.Profunctor.Choice.Choice p_abfz)
                        ($dApplicative_abfC :: GHC.Base.Applicative f_abfA) ->
                        let {
                          f1_abfD
                            :: p_abfz
                                 (Data.Either.Either
                                    [GHC.Word.Word8] (GHC.Word.Word8, [GHC.Word.Word8]))
                                 (Data.Either.Either
                                    [GHC.Word.Word8] (f_abfA (GHC.Word.Word8, [GHC.Word.Word8])))
                               -> p_abfz [GHC.Word.Word8] (f_abfA [GHC.Word.Word8])
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 320 0}]
                          f1_abfD
                            = Data.Profunctor.Unsafe.dimap
                                @p_abfz
                                (Data.Profunctor.Choice.$p1Choice @p_abfz $dChoice_abfB)
                                @[GHC.Word.Word8]
                                @(Data.Either.Either
                                    [GHC.Word.Word8] (GHC.Word.Word8, [GHC.Word.Word8]))
                                @(Data.Either.Either
                                    [GHC.Word.Word8] (f_abfA (GHC.Word.Word8, [GHC.Word.Word8])))
                                @(f_abfA [GHC.Word.Word8])
                                (\ (aas_abfE :: [GHC.Word.Word8]) ->
                                   case aas_abfE of {
                                     [] ->
                                       Data.Either.Left
                                         @[GHC.Word.Word8]
                                         @(GHC.Word.Word8, [GHC.Word.Word8])
                                         (GHC.Types.[] @GHC.Word.Word8);
                                     : a1_abfG as_abfH ->
                                       Data.Either.Right
                                         @[GHC.Word.Word8]
                                         @(GHC.Word.Word8, [GHC.Word.Word8])
                                         (a1_abfG, as_abfH)
                                   })
                                (let {
                                   f2_abfJ :: [GHC.Word.Word8] -> f_abfA [GHC.Word.Word8]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abfJ
                                     = GHC.Base.pure
                                         @f_abfA $dApplicative_abfC @[GHC.Word.Word8] } in
                                 let {
                                   ds2_abfK
                                     :: f_abfA (GHC.Word.Word8, [GHC.Word.Word8])
                                        -> f_abfA [GHC.Word.Word8]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 90 0}]
                                   ds2_abfK
                                     = GHC.Base.fmap
                                         @f_abfA
                                         (GHC.Base.$p1Applicative @f_abfA $dApplicative_abfC)
                                         @(GHC.Word.Word8, [GHC.Word.Word8])
                                         @[GHC.Word.Word8]
                                         (\ (p1_abfL :: (GHC.Word.Word8, [GHC.Word.Word8])) ->
                                            GHC.Types.:
                                              @GHC.Word.Word8
                                              (case p1_abfL of { (x_abfN, ds_abfO) -> x_abfN })
                                              (case p1_abfL of { (ds_abfR, y_abfS) ->
                                               y_abfS
                                               })) } in
                                 \ (ds3_abfU
                                      :: Data.Either.Either
                                           [GHC.Word.Word8]
                                           (f_abfA (GHC.Word.Word8, [GHC.Word.Word8]))) ->
                                   case ds3_abfU of {
                                     Data.Either.Left x_abfW -> f2_abfJ x_abfW;
                                     Data.Either.Right y_abfY -> ds2_abfK y_abfY
                                   }) } in
                        let {
                          g_abg0
                            :: p_abfz
                                 (GHC.Word.Word8, [GHC.Word.Word8])
                                 (f_abfA (GHC.Word.Word8, [GHC.Word.Word8]))
                               -> p_abfz
                                    (Data.Either.Either
                                       [GHC.Word.Word8] (GHC.Word.Word8, [GHC.Word.Word8]))
                                    (Data.Either.Either
                                       [GHC.Word.Word8] (f_abfA (GHC.Word.Word8, [GHC.Word.Word8])))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abg0
                            = Data.Profunctor.Choice.right'
                                @p_abfz
                                $dChoice_abfB
                                @(GHC.Word.Word8, [GHC.Word.Word8])
                                @(f_abfA (GHC.Word.Word8, [GHC.Word.Word8]))
                                @[GHC.Word.Word8] } in
                        \ (x_abg1
                             :: p_abfz
                                  (GHC.Word.Word8, [GHC.Word.Word8])
                                  (f_abfA (GHC.Word.Word8, [GHC.Word.Word8]))) ->
                          f1_abfD (g_abg0 x_abg1))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <[GHC.Word.Word8]>_N
                                      <[GHC.Word.Word8]>_N
                                      <GHC.Word.Word8>_N
                                      <GHC.Word.Word8>_N)
                             :: Control.Lens.Type.Prism
                                  [GHC.Word.Word8]
                                  [GHC.Word.Word8]
                                  (GHC.Word.Word8, [GHC.Word.Word8])
                                  (GHC.Word.Word8, [GHC.Word.Word8])
                                ~R# Control.Lens.Cons.Cons
                                      [GHC.Word.Word8]
                                      [GHC.Word.Word8]
                                      GHC.Word.Word8
                                      GHC.Word.Word8)
              ValArg (\ (@(p_abg6 :: * -> * -> *))
                        (@(f_abg7 :: * -> *))
                        ($dChoice_abg8 :: Data.Profunctor.Choice.Choice p_abg6)
                        ($dApplicative_abg9 :: GHC.Base.Applicative f_abg7) ->
                        let {
                          f1_abga
                            :: p_abg6
                                 (Data.Either.Either [GHC.Word.Word8] ())
                                 (Data.Either.Either [GHC.Word.Word8] (f_abg7 ()))
                               -> p_abg6 [GHC.Word.Word8] (f_abg7 [GHC.Word.Word8])
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 290 0}]
                          f1_abga
                            = Data.Profunctor.Unsafe.dimap
                                @p_abg6
                                (Data.Profunctor.Choice.$p1Choice @p_abg6 $dChoice_abg8)
                                @[GHC.Word.Word8]
                                @(Data.Either.Either [GHC.Word.Word8] ())
                                @(Data.Either.Either [GHC.Word.Word8] (f_abg7 ()))
                                @(f_abg7 [GHC.Word.Word8])
                                (\ (s_abgb :: [GHC.Word.Word8]) ->
                                   case s_abgb of wild_abgc {
                                     [] ->
                                       Data.Either.Right @[GHC.Word.Word8] @() GHC.Tuple.Prim.();
                                     : ds1_abgd ds2_abge ->
                                       Data.Either.Left @[GHC.Word.Word8] @() wild_abgc
                                   })
                                (let {
                                   f2_abgg :: [GHC.Word.Word8] -> f_abg7 [GHC.Word.Word8]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abgg
                                     = GHC.Base.pure
                                         @f_abg7 $dApplicative_abg9 @[GHC.Word.Word8] } in
                                 let {
                                   ds2_abgh :: f_abg7 () -> f_abg7 [GHC.Word.Word8]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 70 0}]
                                   ds2_abgh
                                     = GHC.Base.fmap
                                         @f_abg7
                                         (GHC.Base.$p1Applicative @f_abg7 $dApplicative_abg9)
                                         @()
                                         @[GHC.Word.Word8]
                                         (\ (ds3_abgi :: ()) ->
                                            case ds3_abgi of { () ->
                                            GHC.Types.[] @GHC.Word.Word8
                                            }) } in
                                 \ (ds3_abgk :: Data.Either.Either [GHC.Word.Word8] (f_abg7 ())) ->
                                   case ds3_abgk of {
                                     Data.Either.Left x_abgm -> f2_abgg x_abgm;
                                     Data.Either.Right y_abgo -> ds2_abgh y_abgo
                                   }) } in
                        let {
                          g_abgq
                            :: p_abg6 () (f_abg7 ())
                               -> p_abg6
                                    (Data.Either.Either [GHC.Word.Word8] ())
                                    (Data.Either.Either [GHC.Word.Word8] (f_abg7 ()))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abgq
                            = Data.Profunctor.Choice.right'
                                @p_abg6 $dChoice_abg8 @() @(f_abg7 ()) @[GHC.Word.Word8] } in
                        \ (x_abgr :: p_abg6 () (f_abg7 ())) -> f1_abga (g_abgq x_abgr))
                     `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0] <[GHC.Word.Word8]>_N)
                             :: Control.Lens.Type.Prism' [GHC.Word.Word8] ()
                                ~R# Control.Lens.Empty.AsEmpty [GHC.Word.Word8])
              TyArg Data.Functor.Const.Const [GHC.Word.Word8]
              ValArg Data.Functor.Contravariant.$fContravariantConst
                       @[GHC.Word.Word8]
              ValArg Data.Functor.Const.$fFunctorConst @[GHC.Word.Word8]
    After:  (\ (@(f_abf1 :: * -> *))
               ($dCons_abf2
                  :: Control.Lens.Cons.Cons
                       Data.ByteString.Lazy.Internal.ByteString
                       Data.ByteString.Lazy.Internal.ByteString
                       GHC.Word.Word8
                       GHC.Word.Word8)
               ($dCons1_abf3
                  :: Control.Lens.Cons.Cons
                       [GHC.Word.Word8] [GHC.Word.Word8] GHC.Word.Word8 GHC.Word.Word8)
               ($dAsEmpty_abf4 :: Control.Lens.Empty.AsEmpty [GHC.Word.Word8])
               ($dContravariant_abf5
                  :: Data.Functor.Contravariant.Contravariant f_abf1)
               ($dFunctor_abf6 :: GHC.Base.Functor f_abf1) ->
               Data.Profunctor.Unsafe.$fProfunctorFUN_$cdimap
                 @Data.ByteString.Lazy.Internal.ByteString
                 @[GHC.Word.Word8]
                 @(f_abf1 [GHC.Word.Word8])
                 @(f_abf1 Data.ByteString.Lazy.Internal.ByteString)
                 Data.ByteString.Lazy.Internal.unpackBytes
                 (GHC.Base.fmap
                    @f_abf1
                    $dFunctor_abf6
                    @[GHC.Word.Word8]
                    @Data.ByteString.Lazy.Internal.ByteString
                    Data.ByteString.Lazy.Internal.packBytes))
              @(Data.Functor.Const.Const [GHC.Word.Word8])
              ((\ (@(p_abmT :: * -> * -> *))
                  (@(f_abmU :: * -> *))
                  ($dChoice_abmV :: Data.Profunctor.Choice.Choice p_abmT)
                  ($dApplicative_abmW :: GHC.Base.Applicative f_abmU) ->
                  let {
                    f1_abmX
                      :: p_abmT
                           (Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString
                              (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                           (Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString
                              (f_abmU
                                 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                         -> p_abmT
                              Data.ByteString.Lazy.Internal.ByteString
                              (f_abmU Data.ByteString.Lazy.Internal.ByteString)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 536 0}]
                    f1_abmX
                      = Data.Profunctor.Unsafe.dimap
                          @p_abmT
                          (Data.Profunctor.Choice.$p1Choice @p_abmT $dChoice_abmV)
                          @Data.ByteString.Lazy.Internal.ByteString
                          @(Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString
                              (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                          @(Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString
                              (f_abmU
                                 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                          @(f_abmU Data.ByteString.Lazy.Internal.ByteString)
                          (\ (s1_abmY :: Data.ByteString.Lazy.Internal.ByteString) ->
                             case s1_abmY of {
                               Data.ByteString.Lazy.Internal.Empty ->
                                 Data.Either.Left
                                   @Data.ByteString.Lazy.Internal.ByteString
                                   @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                   Data.ByteString.Lazy.Internal.Empty;
                               Data.ByteString.Lazy.Internal.Chunk bx_abn5 bx1_abn6 bx2_abn7
                                                                   cs_abn8 ->
                                 case bx2_abn7 of ds1_abna {
                                   __DEFAULT ->
                                     Data.Either.Right
                                       @Data.ByteString.Lazy.Internal.ByteString
                                       @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                       (case GHC.Prim.readWord8OffAddr#
                                               @GHC.Prim.RealWorld bx_abn5 0# GHC.Prim.realWorld#
                                        of
                                        { (# ipv_abnc, ipv1_abnd #) ->
                                        case GHC.Prim.touch#
                                               @'GHC.Types.Lifted
                                               @GHC.ForeignPtr.ForeignPtrContents
                                               bx1_abn6
                                               ipv_abnc
                                        of
                                        { __DEFAULT ->
                                        GHC.Word.W8# ipv1_abnd
                                        }
                                        },
                                        Data.ByteString.Lazy.Internal.$WChunk
                                          (Data.ByteString.Internal.Type.$WBS
                                             (GHC.ForeignPtr.ForeignPtr
                                                @GHC.Word.Word8
                                                (GHC.Prim.plusAddr# bx_abn5 1#)
                                                bx1_abn6)
                                             (GHC.Types.I# (GHC.Prim.-# ds1_abna 1#)))
                                          cs_abn8);
                                   1# ->
                                     Data.Either.Right
                                       @Data.ByteString.Lazy.Internal.ByteString
                                       @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                       (case GHC.Prim.readWord8OffAddr#
                                               @GHC.Prim.RealWorld bx_abn5 0# GHC.Prim.realWorld#
                                        of
                                        { (# ipv_abnh, ipv1_abni #) ->
                                        case GHC.Prim.touch#
                                               @'GHC.Types.Lifted
                                               @GHC.ForeignPtr.ForeignPtrContents
                                               bx1_abn6
                                               ipv_abnh
                                        of
                                        { __DEFAULT ->
                                        GHC.Word.W8# ipv1_abni
                                        }
                                        },
                                        cs_abn8)
                                 }
                             })
                          (let {
                             f2_abnl
                               :: Data.ByteString.Lazy.Internal.ByteString
                                  -> f_abmU Data.ByteString.Lazy.Internal.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abnl
                               = GHC.Base.pure
                                   @f_abmU
                                   $dApplicative_abmW
                                   @Data.ByteString.Lazy.Internal.ByteString } in
                           let {
                             ds2_abnm
                               :: f_abmU
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                  -> f_abmU Data.ByteString.Lazy.Internal.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 162 0}]
                             ds2_abnm
                               = GHC.Base.fmap
                                   @f_abmU
                                   (GHC.Base.$p1Applicative @f_abmU $dApplicative_abmW)
                                   @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                   @Data.ByteString.Lazy.Internal.ByteString
                                   (\ (p1_abnn
                                         :: (GHC.Word.Word8,
                                             Data.ByteString.Lazy.Internal.ByteString)) ->
                                      case p1_abnn of { (x_abnp, ds_abnq) ->
                                      case x_abnp of { GHC.Word.W8# x#_abnt ->
                                      Data.ByteString.Lazy.Internal.$WChunk
                                        (Data.ByteString.Internal.Type.$WBS
                                           (GHC.ForeignPtr.ForeignPtr
                                              @GHC.Word.Word8
                                              (GHC.Prim.plusAddr#
                                                 Data.ByteString.singleton1
                                                 (GHC.Prim.word2Int#
                                                    (GHC.Prim.word8ToWord# x#_abnt)))
                                              GHC.ForeignPtr.FinalPtr)
                                           (GHC.Types.I# 1#))
                                        ds_abnq
                                      }
                                      }) } in
                           \ (ds3_abnv
                                :: Data.Either.Either
                                     Data.ByteString.Lazy.Internal.ByteString
                                     (f_abmU
                                        (GHC.Word.Word8,
                                         Data.ByteString.Lazy.Internal.ByteString))) ->
                             case ds3_abnv of {
                               Data.Either.Left x_abnx -> f2_abnl x_abnx;
                               Data.Either.Right y_abnz -> ds2_abnm y_abnz
                             }) } in
                  let {
                    g_abnB
                      :: p_abmT
                           (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                           (f_abmU (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                         -> p_abmT
                              (Data.Either.Either
                                 Data.ByteString.Lazy.Internal.ByteString
                                 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                              (Data.Either.Either
                                 Data.ByteString.Lazy.Internal.ByteString
                                 (f_abmU
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abnB
                      = Data.Profunctor.Choice.right'
                          @p_abmT
                          $dChoice_abmV
                          @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                          @(f_abmU
                              (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                          @Data.ByteString.Lazy.Internal.ByteString } in
                  \ (x_abnC
                       :: p_abmT
                            (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                            (f_abmU
                               (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))) ->
                    f1_abmX (g_abnB x_abnC))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <Data.ByteString.Lazy.Internal.ByteString>_N
                                <Data.ByteString.Lazy.Internal.ByteString>_N
                                <GHC.Word.Word8>_N
                                <GHC.Word.Word8>_N)
                       :: Control.Lens.Type.Prism
                            Data.ByteString.Lazy.Internal.ByteString
                            Data.ByteString.Lazy.Internal.ByteString
                            (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                            (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                          ~R# Control.Lens.Cons.Cons
                                Data.ByteString.Lazy.Internal.ByteString
                                Data.ByteString.Lazy.Internal.ByteString
                                GHC.Word.Word8
                                GHC.Word.Word8))
              ((\ (@(p_abfz :: * -> * -> *))
                  (@(f_abfA :: * -> *))
                  ($dChoice_abfB :: Data.Profunctor.Choice.Choice p_abfz)
                  ($dApplicative_abfC :: GHC.Base.Applicative f_abfA) ->
                  let {
                    f1_abfD
                      :: p_abfz
                           (Data.Either.Either
                              [GHC.Word.Word8] (GHC.Word.Word8, [GHC.Word.Word8]))
                           (Data.Either.Either
                              [GHC.Word.Word8] (f_abfA (GHC.Word.Word8, [GHC.Word.Word8])))
                         -> p_abfz [GHC.Word.Word8] (f_abfA [GHC.Word.Word8])
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 320 0}]
                    f1_abfD
                      = Data.Profunctor.Unsafe.dimap
                          @p_abfz
                          (Data.Profunctor.Choice.$p1Choice @p_abfz $dChoice_abfB)
                          @[GHC.Word.Word8]
                          @(Data.Either.Either
                              [GHC.Word.Word8] (GHC.Word.Word8, [GHC.Word.Word8]))
                          @(Data.Either.Either
                              [GHC.Word.Word8] (f_abfA (GHC.Word.Word8, [GHC.Word.Word8])))
                          @(f_abfA [GHC.Word.Word8])
                          (\ (aas_abfE :: [GHC.Word.Word8]) ->
                             case aas_abfE of {
                               [] ->
                                 Data.Either.Left
                                   @[GHC.Word.Word8]
                                   @(GHC.Word.Word8, [GHC.Word.Word8])
                                   (GHC.Types.[] @GHC.Word.Word8);
                               : a1_abfG as_abfH ->
                                 Data.Either.Right
                                   @[GHC.Word.Word8]
                                   @(GHC.Word.Word8, [GHC.Word.Word8])
                                   (a1_abfG, as_abfH)
                             })
                          (let {
                             f2_abfJ :: [GHC.Word.Word8] -> f_abfA [GHC.Word.Word8]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abfJ
                               = GHC.Base.pure @f_abfA $dApplicative_abfC @[GHC.Word.Word8] } in
                           let {
                             ds2_abfK
                               :: f_abfA (GHC.Word.Word8, [GHC.Word.Word8])
                                  -> f_abfA [GHC.Word.Word8]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 90 0}]
                             ds2_abfK
                               = GHC.Base.fmap
                                   @f_abfA
                                   (GHC.Base.$p1Applicative @f_abfA $dApplicative_abfC)
                                   @(GHC.Word.Word8, [GHC.Word.Word8])
                                   @[GHC.Word.Word8]
                                   (\ (p1_abfL :: (GHC.Word.Word8, [GHC.Word.Word8])) ->
                                      GHC.Types.:
                                        @GHC.Word.Word8
                                        (case p1_abfL of { (x_abfN, ds_abfO) -> x_abfN })
                                        (case p1_abfL of { (ds_abfR, y_abfS) -> y_abfS })) } in
                           \ (ds3_abfU
                                :: Data.Either.Either
                                     [GHC.Word.Word8]
                                     (f_abfA (GHC.Word.Word8, [GHC.Word.Word8]))) ->
                             case ds3_abfU of {
                               Data.Either.Left x_abfW -> f2_abfJ x_abfW;
                               Data.Either.Right y_abfY -> ds2_abfK y_abfY
                             }) } in
                  let {
                    g_abg0
                      :: p_abfz
                           (GHC.Word.Word8, [GHC.Word.Word8])
                           (f_abfA (GHC.Word.Word8, [GHC.Word.Word8]))
                         -> p_abfz
                              (Data.Either.Either
                                 [GHC.Word.Word8] (GHC.Word.Word8, [GHC.Word.Word8]))
                              (Data.Either.Either
                                 [GHC.Word.Word8] (f_abfA (GHC.Word.Word8, [GHC.Word.Word8])))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abg0
                      = Data.Profunctor.Choice.right'
                          @p_abfz
                          $dChoice_abfB
                          @(GHC.Word.Word8, [GHC.Word.Word8])
                          @(f_abfA (GHC.Word.Word8, [GHC.Word.Word8]))
                          @[GHC.Word.Word8] } in
                  \ (x_abg1
                       :: p_abfz
                            (GHC.Word.Word8, [GHC.Word.Word8])
                            (f_abfA (GHC.Word.Word8, [GHC.Word.Word8]))) ->
                    f1_abfD (g_abg0 x_abg1))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <[GHC.Word.Word8]>_N
                                <[GHC.Word.Word8]>_N
                                <GHC.Word.Word8>_N
                                <GHC.Word.Word8>_N)
                       :: Control.Lens.Type.Prism
                            [GHC.Word.Word8]
                            [GHC.Word.Word8]
                            (GHC.Word.Word8, [GHC.Word.Word8])
                            (GHC.Word.Word8, [GHC.Word.Word8])
                          ~R# Control.Lens.Cons.Cons
                                [GHC.Word.Word8] [GHC.Word.Word8] GHC.Word.Word8 GHC.Word.Word8))
              ((\ (@(p_abg6 :: * -> * -> *))
                  (@(f_abg7 :: * -> *))
                  ($dChoice_abg8 :: Data.Profunctor.Choice.Choice p_abg6)
                  ($dApplicative_abg9 :: GHC.Base.Applicative f_abg7) ->
                  let {
                    f1_abga
                      :: p_abg6
                           (Data.Either.Either [GHC.Word.Word8] ())
                           (Data.Either.Either [GHC.Word.Word8] (f_abg7 ()))
                         -> p_abg6 [GHC.Word.Word8] (f_abg7 [GHC.Word.Word8])
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 290 0}]
                    f1_abga
                      = Data.Profunctor.Unsafe.dimap
                          @p_abg6
                          (Data.Profunctor.Choice.$p1Choice @p_abg6 $dChoice_abg8)
                          @[GHC.Word.Word8]
                          @(Data.Either.Either [GHC.Word.Word8] ())
                          @(Data.Either.Either [GHC.Word.Word8] (f_abg7 ()))
                          @(f_abg7 [GHC.Word.Word8])
                          (\ (s_abgb :: [GHC.Word.Word8]) ->
                             case s_abgb of wild_abgc {
                               [] -> Data.Either.Right @[GHC.Word.Word8] @() GHC.Tuple.Prim.();
                               : ds1_abgd ds2_abge ->
                                 Data.Either.Left @[GHC.Word.Word8] @() wild_abgc
                             })
                          (let {
                             f2_abgg :: [GHC.Word.Word8] -> f_abg7 [GHC.Word.Word8]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abgg
                               = GHC.Base.pure @f_abg7 $dApplicative_abg9 @[GHC.Word.Word8] } in
                           let {
                             ds2_abgh :: f_abg7 () -> f_abg7 [GHC.Word.Word8]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 70 0}]
                             ds2_abgh
                               = GHC.Base.fmap
                                   @f_abg7
                                   (GHC.Base.$p1Applicative @f_abg7 $dApplicative_abg9)
                                   @()
                                   @[GHC.Word.Word8]
                                   (\ (ds3_abgi :: ()) ->
                                      case ds3_abgi of { () -> GHC.Types.[] @GHC.Word.Word8 }) } in
                           \ (ds3_abgk :: Data.Either.Either [GHC.Word.Word8] (f_abg7 ())) ->
                             case ds3_abgk of {
                               Data.Either.Left x_abgm -> f2_abgg x_abgm;
                               Data.Either.Right y_abgo -> ds2_abgh y_abgo
                             }) } in
                  let {
                    g_abgq
                      :: p_abg6 () (f_abg7 ())
                         -> p_abg6
                              (Data.Either.Either [GHC.Word.Word8] ())
                              (Data.Either.Either [GHC.Word.Word8] (f_abg7 ()))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abgq
                      = Data.Profunctor.Choice.right'
                          @p_abg6 $dChoice_abg8 @() @(f_abg7 ()) @[GHC.Word.Word8] } in
                  \ (x_abgr :: p_abg6 () (f_abg7 ())) -> f1_abga (g_abgq x_abgr))
               `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0] <[GHC.Word.Word8]>_N)
                       :: Control.Lens.Type.Prism' [GHC.Word.Word8] ()
                          ~R# Control.Lens.Empty.AsEmpty [GHC.Word.Word8]))
              (Data.Functor.Contravariant.$fContravariantConst @[GHC.Word.Word8])
              (Data.Functor.Const.$fFunctorConst @[GHC.Word.Word8])
    Cont:   ApplyToVal nodup hole Control.Lens.Getter.Getting
                                    [GHC.Word.Word8]
                                    Data.ByteString.Lazy.Internal.ByteString
                                    [GHC.Word.Word8]
              ((\ (ds_abe3 [Occ=Once1] :: a_abe0) -> ds_abe3)
               `cast` (<a_abe0>_R
                       %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                          <*>_N <a_abe0>_R <a_abe0>_P)
                       :: (a_abe0 -> a_abe0)
                          ~R# (a_abe0 -> Data.Functor.Const.Const a_abe0 a_abe0)))
            ApplyToVal nodup hole Data.ByteString.Lazy.Internal.ByteString
                                  -> Data.Functor.Const.Const
                                       [GHC.Word.Word8] Data.ByteString.Lazy.Internal.ByteString
              (Control.Lens.Getter.view
                 @[GHC.Word.Word8]
                 @((->) [GHC.Word.Word8])
                 @Data.ByteString.Lazy.Internal.ByteString
                 (Control.Monad.Reader.Class.$fMonadReaderrFUN @[GHC.Word.Word8])
                 (Control.Lens.Cons.Extras.recons
                    @[GHC.Word.Word8]
                    @GHC.Word.Word8
                    @Data.ByteString.Lazy.Internal.ByteString
                    (Control.Lens.Cons.$fConsListListab
                       @GHC.Word.Word8 @GHC.Word.Word8)
                    Control.Lens.Cons.$fConsByteStringByteStringWord8Word8
                    Control.Lens.Empty.$fAsEmptyByteString
                    @(Data.Functor.Const.Const
                        Data.ByteString.Lazy.Internal.ByteString)
                    (Data.Functor.Contravariant.$fContravariantConst
                       @Data.ByteString.Lazy.Internal.ByteString)
                    (Data.Functor.Const.$fFunctorConst
                       @Data.ByteString.Lazy.Internal.ByteString))
                 s_a8OG)
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N
                        <[GHC.Word.Word8]>_R
                        <Data.ByteString.Lazy.Internal.ByteString>_P
                    :: Data.Functor.Const.Const
                         [GHC.Word.Word8] Data.ByteString.Lazy.Internal.ByteString
                       ~R# [GHC.Word.Word8])
            Stop[RuleArgCtxt] [GHC.Word.Word8]
Rule fired
    Rule: Class op fmap
    Module: (BUILTIN)
    Before: GHC.Base.fmap
              TyArg Data.Functor.Const.Const [GHC.Word.Word8]
              ValArg Data.Functor.Const.$fFunctorConst @[GHC.Word.Word8]
    After:  (Data.Functor.Const.$fFunctorConst2 @[GHC.Word.Word8])
            `cast` (forall (a :: <*>_N) (b :: <*>_N).
                    <a -> b>_R
                    %<'GHC.Types.Many>_N ->_R <Data.Functor.Const.Const
                                                 [GHC.Word.Word8] a>_R
                    %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                  <*>_N <[GHC.Word.Word8]>_R <a>_P
                                              ; Sym (Data.Functor.Const.N:Const[0]
                                                         <*>_N <[GHC.Word.Word8]>_R <b>_P)
                    :: (forall {a} {b}.
                        (a -> b)
                        -> Data.Functor.Const.Const [GHC.Word.Word8] a
                        -> Data.Functor.Const.Const [GHC.Word.Word8] a)
                       ~R# (forall {a} {b}.
                            (a -> b)
                            -> Data.Functor.Const.Const [GHC.Word.Word8] a
                            -> Data.Functor.Const.Const [GHC.Word.Word8] b))
    Cont:   ApplyToTy [GHC.Word.Word8]
            ApplyToTy Data.ByteString.Lazy.Internal.ByteString
            ApplyToVal nodup hole ([GHC.Word.Word8]
                                   -> Data.ByteString.Lazy.Internal.ByteString)
                                  -> Data.Functor.Const.Const [GHC.Word.Word8] [GHC.Word.Word8]
                                  -> Data.Functor.Const.Const
                                       [GHC.Word.Word8] Data.ByteString.Lazy.Internal.ByteString
              Data.ByteString.Lazy.Internal.packBytes
            ApplyToVal nodup hole Data.Functor.Const.Const
                                    [GHC.Word.Word8] [GHC.Word.Word8]
                                  -> Data.Functor.Const.Const
                                       [GHC.Word.Word8] Data.ByteString.Lazy.Internal.ByteString
              (bc_aboj (ab_aboh x_abok))
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N
                        <[GHC.Word.Word8]>_R
                        <Data.ByteString.Lazy.Internal.ByteString>_P
                    :: Data.Functor.Const.Const
                         [GHC.Word.Word8] Data.ByteString.Lazy.Internal.ByteString
                       ~R# [GHC.Word.Word8])
            Stop[RuleArgCtxt] [GHC.Word.Word8]
Rule fired
    Rule: Class op reader
    Module: (BUILTIN)
    Before: Control.Monad.Reader.Class.reader
              TyArg [GHC.Word.Word8]
              TyArg (->) [GHC.Word.Word8]
              ValArg Control.Monad.Reader.Class.$fMonadReaderrFUN
                       @[GHC.Word.Word8]
    After:  \ (@a_abe8) -> GHC.Base.id @([GHC.Word.Word8] -> a_abe8)
    Cont:   ApplyToTy Data.ByteString.Lazy.Internal.ByteString
            ApplyToVal nodup hole ([GHC.Word.Word8]
                                   -> Data.ByteString.Lazy.Internal.ByteString)
                                  -> [GHC.Word.Word8] -> Data.ByteString.Lazy.Internal.ByteString
              ((l_abe2
                  ((\ (ds_abe3 [Occ=Once1] :: a_abe0) -> ds_abe3)
                   `cast` (<a_abe0>_R
                           %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                              <*>_N <a_abe0>_R <a_abe0>_P)
                           :: (a_abe0 -> a_abe0)
                              ~R# (a_abe0 -> Data.Functor.Const.Const a_abe0 a_abe0))))
               `cast` (<s_abdY>_R
                       %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                     <*>_N <a_abe0>_R <s_abdY>_P
                       :: (s_abdY -> Data.Functor.Const.Const a_abe0 s_abdY)
                          ~R# (s_abdY -> a_abe0)))
            ApplyToVal nodup hole [GHC.Word.Word8]
                                  -> Data.ByteString.Lazy.Internal.ByteString
              s_a8OG
            Stop[RuleArgCtxt] Data.ByteString.Lazy.Internal.ByteString
Rule fired
    Rule: recons/list-lazybs
    Module: (Control.Lens.Cons.Extras)
    Before: Control.Lens.Cons.Extras.recons
              TyArg [GHC.Word.Word8]
              TyArg GHC.Word.Word8
              TyArg Data.ByteString.Lazy.Internal.ByteString
              ValArg (\ (@(p_abfz :: * -> * -> *))
                        (@(f_abfA :: * -> *))
                        ($dChoice_abfB :: Data.Profunctor.Choice.Choice p_abfz)
                        ($dApplicative_abfC :: GHC.Base.Applicative f_abfA) ->
                        let {
                          f1_abfD
                            :: p_abfz
                                 (Data.Either.Either
                                    [GHC.Word.Word8] (GHC.Word.Word8, [GHC.Word.Word8]))
                                 (Data.Either.Either
                                    [GHC.Word.Word8] (f_abfA (GHC.Word.Word8, [GHC.Word.Word8])))
                               -> p_abfz [GHC.Word.Word8] (f_abfA [GHC.Word.Word8])
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 320 0}]
                          f1_abfD
                            = Data.Profunctor.Unsafe.dimap
                                @p_abfz
                                (Data.Profunctor.Choice.$p1Choice @p_abfz $dChoice_abfB)
                                @[GHC.Word.Word8]
                                @(Data.Either.Either
                                    [GHC.Word.Word8] (GHC.Word.Word8, [GHC.Word.Word8]))
                                @(Data.Either.Either
                                    [GHC.Word.Word8] (f_abfA (GHC.Word.Word8, [GHC.Word.Word8])))
                                @(f_abfA [GHC.Word.Word8])
                                (\ (aas_abfE :: [GHC.Word.Word8]) ->
                                   case aas_abfE of {
                                     [] ->
                                       Data.Either.Left
                                         @[GHC.Word.Word8]
                                         @(GHC.Word.Word8, [GHC.Word.Word8])
                                         (GHC.Types.[] @GHC.Word.Word8);
                                     : a1_abfG as_abfH ->
                                       Data.Either.Right
                                         @[GHC.Word.Word8]
                                         @(GHC.Word.Word8, [GHC.Word.Word8])
                                         (a1_abfG, as_abfH)
                                   })
                                (let {
                                   f2_abfJ :: [GHC.Word.Word8] -> f_abfA [GHC.Word.Word8]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abfJ
                                     = GHC.Base.pure
                                         @f_abfA $dApplicative_abfC @[GHC.Word.Word8] } in
                                 let {
                                   ds2_abfK
                                     :: f_abfA (GHC.Word.Word8, [GHC.Word.Word8])
                                        -> f_abfA [GHC.Word.Word8]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 90 0}]
                                   ds2_abfK
                                     = GHC.Base.fmap
                                         @f_abfA
                                         (GHC.Base.$p1Applicative @f_abfA $dApplicative_abfC)
                                         @(GHC.Word.Word8, [GHC.Word.Word8])
                                         @[GHC.Word.Word8]
                                         (\ (p1_abfL :: (GHC.Word.Word8, [GHC.Word.Word8])) ->
                                            GHC.Types.:
                                              @GHC.Word.Word8
                                              (case p1_abfL of { (x_abfN, ds_abfO) -> x_abfN })
                                              (case p1_abfL of { (ds_abfR, y_abfS) ->
                                               y_abfS
                                               })) } in
                                 \ (ds3_abfU
                                      :: Data.Either.Either
                                           [GHC.Word.Word8]
                                           (f_abfA (GHC.Word.Word8, [GHC.Word.Word8]))) ->
                                   case ds3_abfU of {
                                     Data.Either.Left x_abfW -> f2_abfJ x_abfW;
                                     Data.Either.Right y_abfY -> ds2_abfK y_abfY
                                   }) } in
                        let {
                          g_abg0
                            :: p_abfz
                                 (GHC.Word.Word8, [GHC.Word.Word8])
                                 (f_abfA (GHC.Word.Word8, [GHC.Word.Word8]))
                               -> p_abfz
                                    (Data.Either.Either
                                       [GHC.Word.Word8] (GHC.Word.Word8, [GHC.Word.Word8]))
                                    (Data.Either.Either
                                       [GHC.Word.Word8] (f_abfA (GHC.Word.Word8, [GHC.Word.Word8])))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abg0
                            = Data.Profunctor.Choice.right'
                                @p_abfz
                                $dChoice_abfB
                                @(GHC.Word.Word8, [GHC.Word.Word8])
                                @(f_abfA (GHC.Word.Word8, [GHC.Word.Word8]))
                                @[GHC.Word.Word8] } in
                        \ (x_abg1
                             :: p_abfz
                                  (GHC.Word.Word8, [GHC.Word.Word8])
                                  (f_abfA (GHC.Word.Word8, [GHC.Word.Word8]))) ->
                          f1_abfD (g_abg0 x_abg1))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <[GHC.Word.Word8]>_N
                                      <[GHC.Word.Word8]>_N
                                      <GHC.Word.Word8>_N
                                      <GHC.Word.Word8>_N)
                             :: Control.Lens.Type.Prism
                                  [GHC.Word.Word8]
                                  [GHC.Word.Word8]
                                  (GHC.Word.Word8, [GHC.Word.Word8])
                                  (GHC.Word.Word8, [GHC.Word.Word8])
                                ~R# Control.Lens.Cons.Cons
                                      [GHC.Word.Word8]
                                      [GHC.Word.Word8]
                                      GHC.Word.Word8
                                      GHC.Word.Word8)
              ValArg (\ (@(p_abmT :: * -> * -> *))
                        (@(f_abmU :: * -> *))
                        ($dChoice_abmV :: Data.Profunctor.Choice.Choice p_abmT)
                        ($dApplicative_abmW :: GHC.Base.Applicative f_abmU) ->
                        let {
                          f1_abmX
                            :: p_abmT
                                 (Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                                 (Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (f_abmU
                                       (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                               -> p_abmT
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (f_abmU Data.ByteString.Lazy.Internal.ByteString)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 536 0}]
                          f1_abmX
                            = Data.Profunctor.Unsafe.dimap
                                @p_abmT
                                (Data.Profunctor.Choice.$p1Choice @p_abmT $dChoice_abmV)
                                @Data.ByteString.Lazy.Internal.ByteString
                                @(Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                                @(Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (f_abmU
                                       (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                                @(f_abmU Data.ByteString.Lazy.Internal.ByteString)
                                (\ (s1_abmY :: Data.ByteString.Lazy.Internal.ByteString) ->
                                   case s1_abmY of {
                                     Data.ByteString.Lazy.Internal.Empty ->
                                       Data.Either.Left
                                         @Data.ByteString.Lazy.Internal.ByteString
                                         @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                         Data.ByteString.Lazy.Internal.Empty;
                                     Data.ByteString.Lazy.Internal.Chunk bx_abn5 bx1_abn6 bx2_abn7
                                                                         cs_abn8 ->
                                       case bx2_abn7 of ds1_abna {
                                         __DEFAULT ->
                                           Data.Either.Right
                                             @Data.ByteString.Lazy.Internal.ByteString
                                             @(GHC.Word.Word8,
                                               Data.ByteString.Lazy.Internal.ByteString)
                                             (case GHC.Prim.readWord8OffAddr#
                                                     @GHC.Prim.RealWorld
                                                     bx_abn5
                                                     0#
                                                     GHC.Prim.realWorld#
                                              of
                                              { (# ipv_abnc, ipv1_abnd #) ->
                                              case GHC.Prim.touch#
                                                     @'GHC.Types.Lifted
                                                     @GHC.ForeignPtr.ForeignPtrContents
                                                     bx1_abn6
                                                     ipv_abnc
                                              of
                                              { __DEFAULT ->
                                              GHC.Word.W8# ipv1_abnd
                                              }
                                              },
                                              Data.ByteString.Lazy.Internal.$WChunk
                                                (Data.ByteString.Internal.Type.$WBS
                                                   (GHC.ForeignPtr.ForeignPtr
                                                      @GHC.Word.Word8
                                                      (GHC.Prim.plusAddr# bx_abn5 1#)
                                                      bx1_abn6)
                                                   (GHC.Types.I# (GHC.Prim.-# ds1_abna 1#)))
                                                cs_abn8);
                                         1# ->
                                           Data.Either.Right
                                             @Data.ByteString.Lazy.Internal.ByteString
                                             @(GHC.Word.Word8,
                                               Data.ByteString.Lazy.Internal.ByteString)
                                             (case GHC.Prim.readWord8OffAddr#
                                                     @GHC.Prim.RealWorld
                                                     bx_abn5
                                                     0#
                                                     GHC.Prim.realWorld#
                                              of
                                              { (# ipv_abnh, ipv1_abni #) ->
                                              case GHC.Prim.touch#
                                                     @'GHC.Types.Lifted
                                                     @GHC.ForeignPtr.ForeignPtrContents
                                                     bx1_abn6
                                                     ipv_abnh
                                              of
                                              { __DEFAULT ->
                                              GHC.Word.W8# ipv1_abni
                                              }
                                              },
                                              cs_abn8)
                                       }
                                   })
                                (let {
                                   f2_abnl
                                     :: Data.ByteString.Lazy.Internal.ByteString
                                        -> f_abmU Data.ByteString.Lazy.Internal.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abnl
                                     = GHC.Base.pure
                                         @f_abmU
                                         $dApplicative_abmW
                                         @Data.ByteString.Lazy.Internal.ByteString } in
                                 let {
                                   ds2_abnm
                                     :: f_abmU
                                          (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                        -> f_abmU Data.ByteString.Lazy.Internal.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 162 0}]
                                   ds2_abnm
                                     = GHC.Base.fmap
                                         @f_abmU
                                         (GHC.Base.$p1Applicative @f_abmU $dApplicative_abmW)
                                         @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                         @Data.ByteString.Lazy.Internal.ByteString
                                         (\ (p1_abnn
                                               :: (GHC.Word.Word8,
                                                   Data.ByteString.Lazy.Internal.ByteString)) ->
                                            case p1_abnn of { (x_abnp, ds_abnq) ->
                                            case x_abnp of { GHC.Word.W8# x#_abnt ->
                                            Data.ByteString.Lazy.Internal.$WChunk
                                              (Data.ByteString.Internal.Type.$WBS
                                                 (GHC.ForeignPtr.ForeignPtr
                                                    @GHC.Word.Word8
                                                    (GHC.Prim.plusAddr#
                                                       Data.ByteString.singleton1
                                                       (GHC.Prim.word2Int#
                                                          (GHC.Prim.word8ToWord# x#_abnt)))
                                                    GHC.ForeignPtr.FinalPtr)
                                                 (GHC.Types.I# 1#))
                                              ds_abnq
                                            }
                                            }) } in
                                 \ (ds3_abnv
                                      :: Data.Either.Either
                                           Data.ByteString.Lazy.Internal.ByteString
                                           (f_abmU
                                              (GHC.Word.Word8,
                                               Data.ByteString.Lazy.Internal.ByteString))) ->
                                   case ds3_abnv of {
                                     Data.Either.Left x_abnx -> f2_abnl x_abnx;
                                     Data.Either.Right y_abnz -> ds2_abnm y_abnz
                                   }) } in
                        let {
                          g_abnB
                            :: p_abmT
                                 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                 (f_abmU (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                               -> p_abmT
                                    (Data.Either.Either
                                       Data.ByteString.Lazy.Internal.ByteString
                                       (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                                    (Data.Either.Either
                                       Data.ByteString.Lazy.Internal.ByteString
                                       (f_abmU
                                          (GHC.Word.Word8,
                                           Data.ByteString.Lazy.Internal.ByteString)))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abnB
                            = Data.Profunctor.Choice.right'
                                @p_abmT
                                $dChoice_abmV
                                @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                @(f_abmU
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                                @Data.ByteString.Lazy.Internal.ByteString } in
                        \ (x_abnC
                             :: p_abmT
                                  (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                  (f_abmU
                                     (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))) ->
                          f1_abmX (g_abnB x_abnC))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <Data.ByteString.Lazy.Internal.ByteString>_N
                                      <Data.ByteString.Lazy.Internal.ByteString>_N
                                      <GHC.Word.Word8>_N
                                      <GHC.Word.Word8>_N)
                             :: Control.Lens.Type.Prism
                                  Data.ByteString.Lazy.Internal.ByteString
                                  Data.ByteString.Lazy.Internal.ByteString
                                  (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                  (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                ~R# Control.Lens.Cons.Cons
                                      Data.ByteString.Lazy.Internal.ByteString
                                      Data.ByteString.Lazy.Internal.ByteString
                                      GHC.Word.Word8
                                      GHC.Word.Word8)
              ValArg (\ (@(p_abnE :: * -> * -> *))
                        (@(f_abnF :: * -> *))
                        ($dChoice_abnG :: Data.Profunctor.Choice.Choice p_abnE)
                        ($dApplicative_abnH :: GHC.Base.Applicative f_abnF) ->
                        let {
                          f1_abnI
                            :: p_abnE
                                 (Data.Either.Either Data.ByteString.Lazy.Internal.ByteString ())
                                 (Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString (f_abnF ()))
                               -> p_abnE
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (f_abnF Data.ByteString.Lazy.Internal.ByteString)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 290 0}]
                          f1_abnI
                            = Data.Profunctor.Unsafe.dimap
                                @p_abnE
                                (Data.Profunctor.Choice.$p1Choice @p_abnE $dChoice_abnG)
                                @Data.ByteString.Lazy.Internal.ByteString
                                @(Data.Either.Either Data.ByteString.Lazy.Internal.ByteString ())
                                @(Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString (f_abnF ()))
                                @(f_abnF Data.ByteString.Lazy.Internal.ByteString)
                                (\ (s_abnJ :: Data.ByteString.Lazy.Internal.ByteString) ->
                                   case s_abnJ of wild_abnK {
                                     Data.ByteString.Lazy.Internal.Empty ->
                                       Data.Either.Right
                                         @Data.ByteString.Lazy.Internal.ByteString
                                         @()
                                         GHC.Tuple.Prim.();
                                     Data.ByteString.Lazy.Internal.Chunk ipv_abnL ipv1_abnM
                                                                         ipv2_abnN ipv3_abnO ->
                                       Data.Either.Left
                                         @Data.ByteString.Lazy.Internal.ByteString @() wild_abnK
                                   })
                                (let {
                                   f2_abnQ
                                     :: Data.ByteString.Lazy.Internal.ByteString
                                        -> f_abnF Data.ByteString.Lazy.Internal.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abnQ
                                     = GHC.Base.pure
                                         @f_abnF
                                         $dApplicative_abnH
                                         @Data.ByteString.Lazy.Internal.ByteString } in
                                 let {
                                   ds2_abnR
                                     :: f_abnF () -> f_abnF Data.ByteString.Lazy.Internal.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 70 0}]
                                   ds2_abnR
                                     = GHC.Base.fmap
                                         @f_abnF
                                         (GHC.Base.$p1Applicative @f_abnF $dApplicative_abnH)
                                         @()
                                         @Data.ByteString.Lazy.Internal.ByteString
                                         (\ (ds3_abnS :: ()) ->
                                            case ds3_abnS of { () ->
                                            Data.ByteString.Lazy.Internal.Empty
                                            }) } in
                                 \ (ds3_abnU
                                      :: Data.Either.Either
                                           Data.ByteString.Lazy.Internal.ByteString (f_abnF ())) ->
                                   case ds3_abnU of {
                                     Data.Either.Left x_abnW -> f2_abnQ x_abnW;
                                     Data.Either.Right y_abnY -> ds2_abnR y_abnY
                                   }) } in
                        let {
                          g_abo0
                            :: p_abnE () (f_abnF ())
                               -> p_abnE
                                    (Data.Either.Either Data.ByteString.Lazy.Internal.ByteString ())
                                    (Data.Either.Either
                                       Data.ByteString.Lazy.Internal.ByteString (f_abnF ()))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abo0
                            = Data.Profunctor.Choice.right'
                                @p_abnE
                                $dChoice_abnG
                                @()
                                @(f_abnF ())
                                @Data.ByteString.Lazy.Internal.ByteString } in
                        \ (x_abo1 :: p_abnE () (f_abnF ())) -> f1_abnI (g_abo0 x_abo1))
                     `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                      <Data.ByteString.Lazy.Internal.ByteString>_N)
                             :: Control.Lens.Type.Prism'
                                  Data.ByteString.Lazy.Internal.ByteString ()
                                ~R# Control.Lens.Empty.AsEmpty
                                      Data.ByteString.Lazy.Internal.ByteString)
              TyArg Data.Functor.Const.Const
                      Data.ByteString.Lazy.Internal.ByteString
              ValArg Data.Functor.Contravariant.$fContravariantConst
                       @Data.ByteString.Lazy.Internal.ByteString
              ValArg Data.Functor.Const.$fFunctorConst
                       @Data.ByteString.Lazy.Internal.ByteString
    After:  (\ (@(f_abeJ :: * -> *))
               ($dCons_abeK
                  :: Control.Lens.Cons.Cons
                       [GHC.Word.Word8] [GHC.Word.Word8] GHC.Word.Word8 GHC.Word.Word8)
               ($dCons1_abeL
                  :: Control.Lens.Cons.Cons
                       Data.ByteString.Lazy.Internal.ByteString
                       Data.ByteString.Lazy.Internal.ByteString
                       GHC.Word.Word8
                       GHC.Word.Word8)
               ($dAsEmpty_abeM
                  :: Control.Lens.Empty.AsEmpty
                       Data.ByteString.Lazy.Internal.ByteString)
               ($dContravariant_abeN
                  :: Data.Functor.Contravariant.Contravariant f_abeJ)
               ($dFunctor_abeO :: GHC.Base.Functor f_abeJ) ->
               Data.Profunctor.Unsafe.$fProfunctorFUN_$cdimap
                 @[GHC.Word.Word8]
                 @Data.ByteString.Lazy.Internal.ByteString
                 @(f_abeJ Data.ByteString.Lazy.Internal.ByteString)
                 @(f_abeJ [GHC.Word.Word8])
                 Data.ByteString.Lazy.Internal.packBytes
                 (GHC.Base.fmap
                    @f_abeJ
                    $dFunctor_abeO
                    @Data.ByteString.Lazy.Internal.ByteString
                    @[GHC.Word.Word8]
                    Data.ByteString.Lazy.Internal.unpackBytes))
              @(Data.Functor.Const.Const
                  Data.ByteString.Lazy.Internal.ByteString)
              ((\ (@(p_abfz :: * -> * -> *))
                  (@(f_abfA :: * -> *))
                  ($dChoice_abfB :: Data.Profunctor.Choice.Choice p_abfz)
                  ($dApplicative_abfC :: GHC.Base.Applicative f_abfA) ->
                  let {
                    f1_abfD
                      :: p_abfz
                           (Data.Either.Either
                              [GHC.Word.Word8] (GHC.Word.Word8, [GHC.Word.Word8]))
                           (Data.Either.Either
                              [GHC.Word.Word8] (f_abfA (GHC.Word.Word8, [GHC.Word.Word8])))
                         -> p_abfz [GHC.Word.Word8] (f_abfA [GHC.Word.Word8])
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 320 0}]
                    f1_abfD
                      = Data.Profunctor.Unsafe.dimap
                          @p_abfz
                          (Data.Profunctor.Choice.$p1Choice @p_abfz $dChoice_abfB)
                          @[GHC.Word.Word8]
                          @(Data.Either.Either
                              [GHC.Word.Word8] (GHC.Word.Word8, [GHC.Word.Word8]))
                          @(Data.Either.Either
                              [GHC.Word.Word8] (f_abfA (GHC.Word.Word8, [GHC.Word.Word8])))
                          @(f_abfA [GHC.Word.Word8])
                          (\ (aas_abfE :: [GHC.Word.Word8]) ->
                             case aas_abfE of {
                               [] ->
                                 Data.Either.Left
                                   @[GHC.Word.Word8]
                                   @(GHC.Word.Word8, [GHC.Word.Word8])
                                   (GHC.Types.[] @GHC.Word.Word8);
                               : a1_abfG as_abfH ->
                                 Data.Either.Right
                                   @[GHC.Word.Word8]
                                   @(GHC.Word.Word8, [GHC.Word.Word8])
                                   (a1_abfG, as_abfH)
                             })
                          (let {
                             f2_abfJ :: [GHC.Word.Word8] -> f_abfA [GHC.Word.Word8]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abfJ
                               = GHC.Base.pure @f_abfA $dApplicative_abfC @[GHC.Word.Word8] } in
                           let {
                             ds2_abfK
                               :: f_abfA (GHC.Word.Word8, [GHC.Word.Word8])
                                  -> f_abfA [GHC.Word.Word8]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 90 0}]
                             ds2_abfK
                               = GHC.Base.fmap
                                   @f_abfA
                                   (GHC.Base.$p1Applicative @f_abfA $dApplicative_abfC)
                                   @(GHC.Word.Word8, [GHC.Word.Word8])
                                   @[GHC.Word.Word8]
                                   (\ (p1_abfL :: (GHC.Word.Word8, [GHC.Word.Word8])) ->
                                      GHC.Types.:
                                        @GHC.Word.Word8
                                        (case p1_abfL of { (x_abfN, ds_abfO) -> x_abfN })
                                        (case p1_abfL of { (ds_abfR, y_abfS) -> y_abfS })) } in
                           \ (ds3_abfU
                                :: Data.Either.Either
                                     [GHC.Word.Word8]
                                     (f_abfA (GHC.Word.Word8, [GHC.Word.Word8]))) ->
                             case ds3_abfU of {
                               Data.Either.Left x_abfW -> f2_abfJ x_abfW;
                               Data.Either.Right y_abfY -> ds2_abfK y_abfY
                             }) } in
                  let {
                    g_abg0
                      :: p_abfz
                           (GHC.Word.Word8, [GHC.Word.Word8])
                           (f_abfA (GHC.Word.Word8, [GHC.Word.Word8]))
                         -> p_abfz
                              (Data.Either.Either
                                 [GHC.Word.Word8] (GHC.Word.Word8, [GHC.Word.Word8]))
                              (Data.Either.Either
                                 [GHC.Word.Word8] (f_abfA (GHC.Word.Word8, [GHC.Word.Word8])))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abg0
                      = Data.Profunctor.Choice.right'
                          @p_abfz
                          $dChoice_abfB
                          @(GHC.Word.Word8, [GHC.Word.Word8])
                          @(f_abfA (GHC.Word.Word8, [GHC.Word.Word8]))
                          @[GHC.Word.Word8] } in
                  \ (x_abg1
                       :: p_abfz
                            (GHC.Word.Word8, [GHC.Word.Word8])
                            (f_abfA (GHC.Word.Word8, [GHC.Word.Word8]))) ->
                    f1_abfD (g_abg0 x_abg1))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <[GHC.Word.Word8]>_N
                                <[GHC.Word.Word8]>_N
                                <GHC.Word.Word8>_N
                                <GHC.Word.Word8>_N)
                       :: Control.Lens.Type.Prism
                            [GHC.Word.Word8]
                            [GHC.Word.Word8]
                            (GHC.Word.Word8, [GHC.Word.Word8])
                            (GHC.Word.Word8, [GHC.Word.Word8])
                          ~R# Control.Lens.Cons.Cons
                                [GHC.Word.Word8] [GHC.Word.Word8] GHC.Word.Word8 GHC.Word.Word8))
              ((\ (@(p_abmT :: * -> * -> *))
                  (@(f_abmU :: * -> *))
                  ($dChoice_abmV :: Data.Profunctor.Choice.Choice p_abmT)
                  ($dApplicative_abmW :: GHC.Base.Applicative f_abmU) ->
                  let {
                    f1_abmX
                      :: p_abmT
                           (Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString
                              (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                           (Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString
                              (f_abmU
                                 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                         -> p_abmT
                              Data.ByteString.Lazy.Internal.ByteString
                              (f_abmU Data.ByteString.Lazy.Internal.ByteString)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 536 0}]
                    f1_abmX
                      = Data.Profunctor.Unsafe.dimap
                          @p_abmT
                          (Data.Profunctor.Choice.$p1Choice @p_abmT $dChoice_abmV)
                          @Data.ByteString.Lazy.Internal.ByteString
                          @(Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString
                              (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                          @(Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString
                              (f_abmU
                                 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                          @(f_abmU Data.ByteString.Lazy.Internal.ByteString)
                          (\ (s1_abmY :: Data.ByteString.Lazy.Internal.ByteString) ->
                             case s1_abmY of {
                               Data.ByteString.Lazy.Internal.Empty ->
                                 Data.Either.Left
                                   @Data.ByteString.Lazy.Internal.ByteString
                                   @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                   Data.ByteString.Lazy.Internal.Empty;
                               Data.ByteString.Lazy.Internal.Chunk bx_abn5 bx1_abn6 bx2_abn7
                                                                   cs_abn8 ->
                                 case bx2_abn7 of ds1_abna {
                                   __DEFAULT ->
                                     Data.Either.Right
                                       @Data.ByteString.Lazy.Internal.ByteString
                                       @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                       (case GHC.Prim.readWord8OffAddr#
                                               @GHC.Prim.RealWorld bx_abn5 0# GHC.Prim.realWorld#
                                        of
                                        { (# ipv_abnc, ipv1_abnd #) ->
                                        case GHC.Prim.touch#
                                               @'GHC.Types.Lifted
                                               @GHC.ForeignPtr.ForeignPtrContents
                                               bx1_abn6
                                               ipv_abnc
                                        of
                                        { __DEFAULT ->
                                        GHC.Word.W8# ipv1_abnd
                                        }
                                        },
                                        Data.ByteString.Lazy.Internal.$WChunk
                                          (Data.ByteString.Internal.Type.$WBS
                                             (GHC.ForeignPtr.ForeignPtr
                                                @GHC.Word.Word8
                                                (GHC.Prim.plusAddr# bx_abn5 1#)
                                                bx1_abn6)
                                             (GHC.Types.I# (GHC.Prim.-# ds1_abna 1#)))
                                          cs_abn8);
                                   1# ->
                                     Data.Either.Right
                                       @Data.ByteString.Lazy.Internal.ByteString
                                       @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                       (case GHC.Prim.readWord8OffAddr#
                                               @GHC.Prim.RealWorld bx_abn5 0# GHC.Prim.realWorld#
                                        of
                                        { (# ipv_abnh, ipv1_abni #) ->
                                        case GHC.Prim.touch#
                                               @'GHC.Types.Lifted
                                               @GHC.ForeignPtr.ForeignPtrContents
                                               bx1_abn6
                                               ipv_abnh
                                        of
                                        { __DEFAULT ->
                                        GHC.Word.W8# ipv1_abni
                                        }
                                        },
                                        cs_abn8)
                                 }
                             })
                          (let {
                             f2_abnl
                               :: Data.ByteString.Lazy.Internal.ByteString
                                  -> f_abmU Data.ByteString.Lazy.Internal.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abnl
                               = GHC.Base.pure
                                   @f_abmU
                                   $dApplicative_abmW
                                   @Data.ByteString.Lazy.Internal.ByteString } in
                           let {
                             ds2_abnm
                               :: f_abmU
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                  -> f_abmU Data.ByteString.Lazy.Internal.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 162 0}]
                             ds2_abnm
                               = GHC.Base.fmap
                                   @f_abmU
                                   (GHC.Base.$p1Applicative @f_abmU $dApplicative_abmW)
                                   @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                   @Data.ByteString.Lazy.Internal.ByteString
                                   (\ (p1_abnn
                                         :: (GHC.Word.Word8,
                                             Data.ByteString.Lazy.Internal.ByteString)) ->
                                      case p1_abnn of { (x_abnp, ds_abnq) ->
                                      case x_abnp of { GHC.Word.W8# x#_abnt ->
                                      Data.ByteString.Lazy.Internal.$WChunk
                                        (Data.ByteString.Internal.Type.$WBS
                                           (GHC.ForeignPtr.ForeignPtr
                                              @GHC.Word.Word8
                                              (GHC.Prim.plusAddr#
                                                 Data.ByteString.singleton1
                                                 (GHC.Prim.word2Int#
                                                    (GHC.Prim.word8ToWord# x#_abnt)))
                                              GHC.ForeignPtr.FinalPtr)
                                           (GHC.Types.I# 1#))
                                        ds_abnq
                                      }
                                      }) } in
                           \ (ds3_abnv
                                :: Data.Either.Either
                                     Data.ByteString.Lazy.Internal.ByteString
                                     (f_abmU
                                        (GHC.Word.Word8,
                                         Data.ByteString.Lazy.Internal.ByteString))) ->
                             case ds3_abnv of {
                               Data.Either.Left x_abnx -> f2_abnl x_abnx;
                               Data.Either.Right y_abnz -> ds2_abnm y_abnz
                             }) } in
                  let {
                    g_abnB
                      :: p_abmT
                           (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                           (f_abmU (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                         -> p_abmT
                              (Data.Either.Either
                                 Data.ByteString.Lazy.Internal.ByteString
                                 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                              (Data.Either.Either
                                 Data.ByteString.Lazy.Internal.ByteString
                                 (f_abmU
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abnB
                      = Data.Profunctor.Choice.right'
                          @p_abmT
                          $dChoice_abmV
                          @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                          @(f_abmU
                              (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                          @Data.ByteString.Lazy.Internal.ByteString } in
                  \ (x_abnC
                       :: p_abmT
                            (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                            (f_abmU
                               (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))) ->
                    f1_abmX (g_abnB x_abnC))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <Data.ByteString.Lazy.Internal.ByteString>_N
                                <Data.ByteString.Lazy.Internal.ByteString>_N
                                <GHC.Word.Word8>_N
                                <GHC.Word.Word8>_N)
                       :: Control.Lens.Type.Prism
                            Data.ByteString.Lazy.Internal.ByteString
                            Data.ByteString.Lazy.Internal.ByteString
                            (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                            (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                          ~R# Control.Lens.Cons.Cons
                                Data.ByteString.Lazy.Internal.ByteString
                                Data.ByteString.Lazy.Internal.ByteString
                                GHC.Word.Word8
                                GHC.Word.Word8))
              ((\ (@(p_abnE :: * -> * -> *))
                  (@(f_abnF :: * -> *))
                  ($dChoice_abnG :: Data.Profunctor.Choice.Choice p_abnE)
                  ($dApplicative_abnH :: GHC.Base.Applicative f_abnF) ->
                  let {
                    f1_abnI
                      :: p_abnE
                           (Data.Either.Either Data.ByteString.Lazy.Internal.ByteString ())
                           (Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString (f_abnF ()))
                         -> p_abnE
                              Data.ByteString.Lazy.Internal.ByteString
                              (f_abnF Data.ByteString.Lazy.Internal.ByteString)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 290 0}]
                    f1_abnI
                      = Data.Profunctor.Unsafe.dimap
                          @p_abnE
                          (Data.Profunctor.Choice.$p1Choice @p_abnE $dChoice_abnG)
                          @Data.ByteString.Lazy.Internal.ByteString
                          @(Data.Either.Either Data.ByteString.Lazy.Internal.ByteString ())
                          @(Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString (f_abnF ()))
                          @(f_abnF Data.ByteString.Lazy.Internal.ByteString)
                          (\ (s_abnJ :: Data.ByteString.Lazy.Internal.ByteString) ->
                             case s_abnJ of wild_abnK {
                               Data.ByteString.Lazy.Internal.Empty ->
                                 Data.Either.Right
                                   @Data.ByteString.Lazy.Internal.ByteString @() GHC.Tuple.Prim.();
                               Data.ByteString.Lazy.Internal.Chunk ipv_abnL ipv1_abnM ipv2_abnN
                                                                   ipv3_abnO ->
                                 Data.Either.Left
                                   @Data.ByteString.Lazy.Internal.ByteString @() wild_abnK
                             })
                          (let {
                             f2_abnQ
                               :: Data.ByteString.Lazy.Internal.ByteString
                                  -> f_abnF Data.ByteString.Lazy.Internal.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abnQ
                               = GHC.Base.pure
                                   @f_abnF
                                   $dApplicative_abnH
                                   @Data.ByteString.Lazy.Internal.ByteString } in
                           let {
                             ds2_abnR
                               :: f_abnF () -> f_abnF Data.ByteString.Lazy.Internal.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 70 0}]
                             ds2_abnR
                               = GHC.Base.fmap
                                   @f_abnF
                                   (GHC.Base.$p1Applicative @f_abnF $dApplicative_abnH)
                                   @()
                                   @Data.ByteString.Lazy.Internal.ByteString
                                   (\ (ds3_abnS :: ()) ->
                                      case ds3_abnS of { () ->
                                      Data.ByteString.Lazy.Internal.Empty
                                      }) } in
                           \ (ds3_abnU
                                :: Data.Either.Either
                                     Data.ByteString.Lazy.Internal.ByteString (f_abnF ())) ->
                             case ds3_abnU of {
                               Data.Either.Left x_abnW -> f2_abnQ x_abnW;
                               Data.Either.Right y_abnY -> ds2_abnR y_abnY
                             }) } in
                  let {
                    g_abo0
                      :: p_abnE () (f_abnF ())
                         -> p_abnE
                              (Data.Either.Either Data.ByteString.Lazy.Internal.ByteString ())
                              (Data.Either.Either
                                 Data.ByteString.Lazy.Internal.ByteString (f_abnF ()))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abo0
                      = Data.Profunctor.Choice.right'
                          @p_abnE
                          $dChoice_abnG
                          @()
                          @(f_abnF ())
                          @Data.ByteString.Lazy.Internal.ByteString } in
                  \ (x_abo1 :: p_abnE () (f_abnF ())) -> f1_abnI (g_abo0 x_abo1))
               `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                <Data.ByteString.Lazy.Internal.ByteString>_N)
                       :: Control.Lens.Type.Prism'
                            Data.ByteString.Lazy.Internal.ByteString ()
                          ~R# Control.Lens.Empty.AsEmpty
                                Data.ByteString.Lazy.Internal.ByteString))
              (Data.Functor.Contravariant.$fContravariantConst
                 @Data.ByteString.Lazy.Internal.ByteString)
              (Data.Functor.Const.$fFunctorConst
                 @Data.ByteString.Lazy.Internal.ByteString)
    Cont:   ApplyToVal nodup hole Control.Lens.Getter.Getting
                                    Data.ByteString.Lazy.Internal.ByteString
                                    [GHC.Word.Word8]
                                    Data.ByteString.Lazy.Internal.ByteString
              ((\ (ds_abe3 [Occ=Once1] :: a_abe0) -> ds_abe3)
               `cast` (<a_abe0>_R
                       %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                          <*>_N <a_abe0>_R <a_abe0>_P)
                       :: (a_abe0 -> a_abe0)
                          ~R# (a_abe0 -> Data.Functor.Const.Const a_abe0 a_abe0)))
            ApplyToVal nodup hole [GHC.Word.Word8]
                                  -> Data.Functor.Const.Const
                                       Data.ByteString.Lazy.Internal.ByteString [GHC.Word.Word8]
              s_a8OG
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N
                        <Data.ByteString.Lazy.Internal.ByteString>_R
                        <[GHC.Word.Word8]>_P
                    :: Data.Functor.Const.Const
                         Data.ByteString.Lazy.Internal.ByteString [GHC.Word.Word8]
                       ~R# Data.ByteString.Lazy.Internal.ByteString)
            Stop[RuleArgCtxt] Data.ByteString.Lazy.Internal.ByteString
Rule fired
    Rule: Class op fmap
    Module: (BUILTIN)
    Before: GHC.Base.fmap
              TyArg Data.Functor.Const.Const
                      Data.ByteString.Lazy.Internal.ByteString
              ValArg Data.Functor.Const.$fFunctorConst
                       @Data.ByteString.Lazy.Internal.ByteString
    After:  (Data.Functor.Const.$fFunctorConst2
               @Data.ByteString.Lazy.Internal.ByteString)
            `cast` (forall (a :: <*>_N) (b :: <*>_N).
                    <a -> b>_R
                    %<'GHC.Types.Many>_N ->_R <Data.Functor.Const.Const
                                                 Data.ByteString.Lazy.Internal.ByteString a>_R
                    %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                  <*>_N
                                                  <Data.ByteString.Lazy.Internal.ByteString>_R
                                                  <a>_P
                                              ; Sym (Data.Functor.Const.N:Const[0]
                                                         <*>_N
                                                         <Data.ByteString.Lazy.Internal.ByteString>_R
                                                         <b>_P)
                    :: (forall {a} {b}.
                        (a -> b)
                        -> Data.Functor.Const.Const
                             Data.ByteString.Lazy.Internal.ByteString a
                        -> Data.Functor.Const.Const
                             Data.ByteString.Lazy.Internal.ByteString a)
                       ~R# (forall {a} {b}.
                            (a -> b)
                            -> Data.Functor.Const.Const
                                 Data.ByteString.Lazy.Internal.ByteString a
                            -> Data.Functor.Const.Const
                                 Data.ByteString.Lazy.Internal.ByteString b))
    Cont:   ApplyToTy Data.ByteString.Lazy.Internal.ByteString
            ApplyToTy [GHC.Word.Word8]
            ApplyToVal nodup hole (Data.ByteString.Lazy.Internal.ByteString
                                   -> [GHC.Word.Word8])
                                  -> Data.Functor.Const.Const
                                       Data.ByteString.Lazy.Internal.ByteString
                                       Data.ByteString.Lazy.Internal.ByteString
                                  -> Data.Functor.Const.Const
                                       Data.ByteString.Lazy.Internal.ByteString [GHC.Word.Word8]
              Data.ByteString.Lazy.Internal.unpackBytes
            ApplyToVal nodup hole Data.Functor.Const.Const
                                    Data.ByteString.Lazy.Internal.ByteString
                                    Data.ByteString.Lazy.Internal.ByteString
                                  -> Data.Functor.Const.Const
                                       Data.ByteString.Lazy.Internal.ByteString [GHC.Word.Word8]
              (bc_aboj (ab_aboh x_abok))
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N
                        <Data.ByteString.Lazy.Internal.ByteString>_R
                        <[GHC.Word.Word8]>_P
                    :: Data.Functor.Const.Const
                         Data.ByteString.Lazy.Internal.ByteString [GHC.Word.Word8]
                       ~R# Data.ByteString.Lazy.Internal.ByteString)
            Stop[RuleArgCtxt] Data.ByteString.Lazy.Internal.ByteString
Rule fired
    Rule: Class op ==
    Module: (BUILTIN)
    Before: GHC.Classes.==
              TyArg [GHC.Word.Word8]
              ValArg $dEq_a9dB
              ValArg Data.ByteString.Lazy.Internal.unpackBytes
                       (Data.ByteString.Lazy.Internal.packBytes_$spackChunks 32# s_a8OG)
              ValArg s_a8OG
    After:  GHC.Classes.$fEqList_$c==
              @GHC.Word.Word8 GHC.Word.$fEqWord8
              ValArg Data.ByteString.Lazy.Internal.unpackBytes
                       (Data.ByteString.Lazy.Internal.packBytes_$spackChunks 32# s_a8OG)
              ValArg s_a8OG
    Cont:   Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: unpack
    Module: (GHC.Base)
    Before: GHC.CString.unpackCString# ValArg "B -> L -> B"#
    After:  (\ (a_ab6H :: GHC.Prim.Addr#) ->
               GHC.Base.build
                 @GHC.Types.Char
                 (\ (@b_ab6I) -> GHC.CString.unpackFoldrCString# @b_ab6I a_ab6H))
              "B -> L -> B"#
    Cont:   Stop[BoringCtxt] Test.Tasty.Core.TestName
Rule fired
    Rule: Class op property
    Module: (BUILTIN)
    Before: Test.QuickCheck.Property.property
              TyArg Data.ByteString.Internal.Type.ByteString -> GHC.Types.Bool
              ValArg $dTestable_a998
    After:  Test.QuickCheck.Property.$fTestableFUN_$cproperty
              @Data.ByteString.Internal.Type.ByteString
              @GHC.Types.Bool
              Test.QuickCheck.Instances.ByteString.$fArbitraryByteString0
              Data.ByteString.Internal.Type.$fShowByteString
              Test.QuickCheck.Property.$fTestableBool
    Cont:   ApplyToVal nodup hole (Data.ByteString.Internal.Type.ByteString
                                   -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              prop_ab6U
            CastIt (Sym (Test.Tasty.QuickCheck.N:QC[0])
                    :: Test.QuickCheck.Property.Property ~R# Test.Tasty.QuickCheck.QC)
            Stop[BoringCtxt] Test.Tasty.QuickCheck.QC
Rule fired
    Rule: Class op propertyForAllShrinkShow
    Module: (BUILTIN)
    Before: Test.QuickCheck.Property.propertyForAllShrinkShow
              TyArg GHC.Types.Bool ValArg Test.QuickCheck.Property.$fTestableBool
    After:  Test.QuickCheck.Property.$fTestableBool1
            `cast` (forall (a :: <*>_N).
                    <Test.QuickCheck.Gen.Gen a>_R
                    %<'GHC.Types.Many>_N ->_R <a -> [a]>_R
                    %<'GHC.Types.Many>_N ->_R <a -> [GHC.Base.String]>_R
                    %<'GHC.Types.Many>_N ->_R <a -> GHC.Types.Bool>_R
                    %<'GHC.Types.Many>_N ->_R Sym (Test.QuickCheck.Gen.N:Gen[0]
                                                       (Test.QuickCheck.Property.N:Prop[0]))
                                              ; Sym (Test.QuickCheck.Property.N:Property[0])
                    :: (forall {a}.
                        Test.QuickCheck.Gen.Gen a
                        -> (a -> [a])
                        -> (a -> [GHC.Base.String])
                        -> (a -> GHC.Types.Bool)
                        -> Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int
                        -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result)
                       ~R# (forall {a}.
                            Test.QuickCheck.Gen.Gen a
                            -> (a -> [a])
                            -> (a -> [GHC.Base.String])
                            -> (a -> GHC.Types.Bool)
                            -> Test.QuickCheck.Property.Property))
    Cont:   ApplyToTy Data.ByteString.Internal.Type.ByteString
            ApplyToVal nodup hole Test.QuickCheck.Gen.Gen
                                    Data.ByteString.Internal.Type.ByteString
                                  -> (Data.ByteString.Internal.Type.ByteString
                                      -> [Data.ByteString.Internal.Type.ByteString])
                                  -> (Data.ByteString.Internal.Type.ByteString -> [GHC.Base.String])
                                  -> (Data.ByteString.Internal.Type.ByteString -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (Test.QuickCheck.Arbitrary.arbitrary @a_ab8C $dArbitrary_ab8E)
            ApplyToVal nodup hole (Data.ByteString.Internal.Type.ByteString
                                   -> [Data.ByteString.Internal.Type.ByteString])
                                  -> (Data.ByteString.Internal.Type.ByteString -> [GHC.Base.String])
                                  -> (Data.ByteString.Internal.Type.ByteString -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (Test.QuickCheck.Arbitrary.shrink @a_ab8C $dArbitrary_ab8E)
            ApplyToVal nodup hole (Data.ByteString.Internal.Type.ByteString
                                   -> [GHC.Base.String])
                                  -> (Data.ByteString.Internal.Type.ByteString -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (let {
                 g_ab8I [Occ=OnceL1!] :: a_ab8C -> GHC.Base.String
                 [LclId]
                 g_ab8I = GHC.Show.show @a_ab8C $dShow_ab8F } in
               \ (x_ab8J [Occ=Once1] :: a_ab8C) ->
                 GHC.Types.:
                   @GHC.Base.String (g_ab8I x_ab8J) (GHC.Types.[] @GHC.Base.String))
            ApplyToVal nodup hole (Data.ByteString.Internal.Type.ByteString
                                   -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              f_ab8H
            CastIt (Sym (Test.Tasty.QuickCheck.N:QC[0])
                    :: Test.QuickCheck.Property.Property ~R# Test.Tasty.QuickCheck.QC)
            Stop[BoringCtxt] Test.Tasty.QuickCheck.QC
Rule fired
    Rule: Class op arbitrary
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.arbitrary
              TyArg Data.ByteString.Internal.Type.ByteString
              ValArg Test.QuickCheck.Instances.ByteString.$fArbitraryByteString0
    After:  Test.QuickCheck.Instances.ByteString.$fArbitraryByteString3
            `cast` (Sym (Test.QuickCheck.Gen.N:Gen[0]
                             <Data.ByteString.Internal.Type.ByteString>_R)
                    :: (Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int -> Data.ByteString.Internal.Type.ByteString)
                       ~R# Test.QuickCheck.Gen.Gen
                             Data.ByteString.Internal.Type.ByteString)
    Cont:   Stop[BoringCtxt] Test.QuickCheck.Gen.Gen
                               Data.ByteString.Internal.Type.ByteString
Rule fired
    Rule: Class op shrink
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.shrink
              TyArg Data.ByteString.Internal.Type.ByteString
              ValArg Test.QuickCheck.Instances.ByteString.$fArbitraryByteString0
    After:  Test.QuickCheck.Instances.ByteString.$fArbitraryByteString0_$cshrink
    Cont:   Stop[BoringCtxt] Data.ByteString.Internal.Type.ByteString
                             -> [Data.ByteString.Internal.Type.ByteString]
Rule fired
    Rule: Class op show
    Module: (BUILTIN)
    Before: GHC.Show.show
              TyArg Data.ByteString.Internal.Type.ByteString
              ValArg Data.ByteString.Internal.Type.$fShowByteString
    After:  Data.ByteString.Internal.Type.$fShowByteString_$cshow
    Cont:   Stop[RhsCtxt(NonRecursive)] Data.ByteString.Internal.Type.ByteString
                                        -> GHC.Base.String
Rule fired
    Rule: Class op reader
    Module: (BUILTIN)
    Before: Control.Monad.Reader.Class.reader
              TyArg Data.ByteString.Lazy.Internal.ByteString
              TyArg (->) Data.ByteString.Lazy.Internal.ByteString
              ValArg Control.Monad.Reader.Class.$fMonadReaderrFUN
                       @Data.ByteString.Lazy.Internal.ByteString
    After:  \ (@a_abe8) ->
              GHC.Base.id @(Data.ByteString.Lazy.Internal.ByteString -> a_abe8)
    Cont:   ApplyToTy Data.ByteString.Internal.Type.ByteString
            ApplyToVal nodup hole (Data.ByteString.Lazy.Internal.ByteString
                                   -> Data.ByteString.Internal.Type.ByteString)
                                  -> Data.ByteString.Lazy.Internal.ByteString
                                  -> Data.ByteString.Internal.Type.ByteString
              ((l_abe2
                  ((\ (ds_abe3 [Occ=Once1] :: a_abe0) -> ds_abe3)
                   `cast` (<a_abe0>_R
                           %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                              <*>_N <a_abe0>_R <a_abe0>_P)
                           :: (a_abe0 -> a_abe0)
                              ~R# (a_abe0 -> Data.Functor.Const.Const a_abe0 a_abe0))))
               `cast` (<s_abdY>_R
                       %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                     <*>_N <a_abe0>_R <s_abdY>_P
                       :: (s_abdY -> Data.Functor.Const.Const a_abe0 s_abdY)
                          ~R# (s_abdY -> a_abe0)))
            ApplyToVal nodup hole Data.ByteString.Lazy.Internal.ByteString
                                  -> Data.ByteString.Internal.Type.ByteString
              (Control.Lens.Getter.view
                 @Data.ByteString.Internal.Type.ByteString
                 @((->) Data.ByteString.Internal.Type.ByteString)
                 @Data.ByteString.Lazy.Internal.ByteString
                 (Control.Monad.Reader.Class.$fMonadReaderrFUN
                    @Data.ByteString.Internal.Type.ByteString)
                 (Control.Lens.Cons.Extras.recons
                    @Data.ByteString.Internal.Type.ByteString
                    @GHC.Word.Word8
                    @Data.ByteString.Lazy.Internal.ByteString
                    Control.Lens.Cons.$fConsByteStringByteStringWord8Word80
                    Control.Lens.Cons.$fConsByteStringByteStringWord8Word8
                    Control.Lens.Empty.$fAsEmptyByteString
                    @(Data.Functor.Const.Const
                        Data.ByteString.Lazy.Internal.ByteString)
                    (Data.Functor.Contravariant.$fContravariantConst
                       @Data.ByteString.Lazy.Internal.ByteString)
                    (Data.Functor.Const.$fFunctorConst
                       @Data.ByteString.Lazy.Internal.ByteString))
                 s_a8OH)
            Stop[RuleArgCtxt] Data.ByteString.Internal.Type.ByteString
Rule fired
    Rule: recons/bs-strict
    Module: (Control.Lens.Cons.Extras)
    Before: Control.Lens.Cons.Extras.recons
              TyArg Data.ByteString.Lazy.Internal.ByteString
              TyArg GHC.Word.Word8
              TyArg Data.ByteString.Internal.Type.ByteString
              ValArg (\ (@(p_abmT :: * -> * -> *))
                        (@(f_abmU :: * -> *))
                        ($dChoice_abmV :: Data.Profunctor.Choice.Choice p_abmT)
                        ($dApplicative_abmW :: GHC.Base.Applicative f_abmU) ->
                        let {
                          f1_abmX
                            :: p_abmT
                                 (Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                                 (Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (f_abmU
                                       (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                               -> p_abmT
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (f_abmU Data.ByteString.Lazy.Internal.ByteString)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 536 0}]
                          f1_abmX
                            = Data.Profunctor.Unsafe.dimap
                                @p_abmT
                                (Data.Profunctor.Choice.$p1Choice @p_abmT $dChoice_abmV)
                                @Data.ByteString.Lazy.Internal.ByteString
                                @(Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                                @(Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (f_abmU
                                       (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                                @(f_abmU Data.ByteString.Lazy.Internal.ByteString)
                                (\ (s1_abmY :: Data.ByteString.Lazy.Internal.ByteString) ->
                                   case s1_abmY of {
                                     Data.ByteString.Lazy.Internal.Empty ->
                                       Data.Either.Left
                                         @Data.ByteString.Lazy.Internal.ByteString
                                         @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                         Data.ByteString.Lazy.Internal.Empty;
                                     Data.ByteString.Lazy.Internal.Chunk bx_abn5 bx1_abn6 bx2_abn7
                                                                         cs_abn8 ->
                                       case bx2_abn7 of ds1_abna {
                                         __DEFAULT ->
                                           Data.Either.Right
                                             @Data.ByteString.Lazy.Internal.ByteString
                                             @(GHC.Word.Word8,
                                               Data.ByteString.Lazy.Internal.ByteString)
                                             (case GHC.Prim.readWord8OffAddr#
                                                     @GHC.Prim.RealWorld
                                                     bx_abn5
                                                     0#
                                                     GHC.Prim.realWorld#
                                              of
                                              { (# ipv_abnc, ipv1_abnd #) ->
                                              case GHC.Prim.touch#
                                                     @'GHC.Types.Lifted
                                                     @GHC.ForeignPtr.ForeignPtrContents
                                                     bx1_abn6
                                                     ipv_abnc
                                              of
                                              { __DEFAULT ->
                                              GHC.Word.W8# ipv1_abnd
                                              }
                                              },
                                              Data.ByteString.Lazy.Internal.$WChunk
                                                (Data.ByteString.Internal.Type.$WBS
                                                   (GHC.ForeignPtr.ForeignPtr
                                                      @GHC.Word.Word8
                                                      (GHC.Prim.plusAddr# bx_abn5 1#)
                                                      bx1_abn6)
                                                   (GHC.Types.I# (GHC.Prim.-# ds1_abna 1#)))
                                                cs_abn8);
                                         1# ->
                                           Data.Either.Right
                                             @Data.ByteString.Lazy.Internal.ByteString
                                             @(GHC.Word.Word8,
                                               Data.ByteString.Lazy.Internal.ByteString)
                                             (case GHC.Prim.readWord8OffAddr#
                                                     @GHC.Prim.RealWorld
                                                     bx_abn5
                                                     0#
                                                     GHC.Prim.realWorld#
                                              of
                                              { (# ipv_abnh, ipv1_abni #) ->
                                              case GHC.Prim.touch#
                                                     @'GHC.Types.Lifted
                                                     @GHC.ForeignPtr.ForeignPtrContents
                                                     bx1_abn6
                                                     ipv_abnh
                                              of
                                              { __DEFAULT ->
                                              GHC.Word.W8# ipv1_abni
                                              }
                                              },
                                              cs_abn8)
                                       }
                                   })
                                (let {
                                   f2_abnl
                                     :: Data.ByteString.Lazy.Internal.ByteString
                                        -> f_abmU Data.ByteString.Lazy.Internal.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abnl
                                     = GHC.Base.pure
                                         @f_abmU
                                         $dApplicative_abmW
                                         @Data.ByteString.Lazy.Internal.ByteString } in
                                 let {
                                   ds2_abnm
                                     :: f_abmU
                                          (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                        -> f_abmU Data.ByteString.Lazy.Internal.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 162 0}]
                                   ds2_abnm
                                     = GHC.Base.fmap
                                         @f_abmU
                                         (GHC.Base.$p1Applicative @f_abmU $dApplicative_abmW)
                                         @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                         @Data.ByteString.Lazy.Internal.ByteString
                                         (\ (p1_abnn
                                               :: (GHC.Word.Word8,
                                                   Data.ByteString.Lazy.Internal.ByteString)) ->
                                            case p1_abnn of { (x_abnp, ds_abnq) ->
                                            case x_abnp of { GHC.Word.W8# x#_abnt ->
                                            Data.ByteString.Lazy.Internal.$WChunk
                                              (Data.ByteString.Internal.Type.$WBS
                                                 (GHC.ForeignPtr.ForeignPtr
                                                    @GHC.Word.Word8
                                                    (GHC.Prim.plusAddr#
                                                       Data.ByteString.singleton1
                                                       (GHC.Prim.word2Int#
                                                          (GHC.Prim.word8ToWord# x#_abnt)))
                                                    GHC.ForeignPtr.FinalPtr)
                                                 (GHC.Types.I# 1#))
                                              ds_abnq
                                            }
                                            }) } in
                                 \ (ds3_abnv
                                      :: Data.Either.Either
                                           Data.ByteString.Lazy.Internal.ByteString
                                           (f_abmU
                                              (GHC.Word.Word8,
                                               Data.ByteString.Lazy.Internal.ByteString))) ->
                                   case ds3_abnv of {
                                     Data.Either.Left x_abnx -> f2_abnl x_abnx;
                                     Data.Either.Right y_abnz -> ds2_abnm y_abnz
                                   }) } in
                        let {
                          g_abnB
                            :: p_abmT
                                 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                 (f_abmU (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                               -> p_abmT
                                    (Data.Either.Either
                                       Data.ByteString.Lazy.Internal.ByteString
                                       (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                                    (Data.Either.Either
                                       Data.ByteString.Lazy.Internal.ByteString
                                       (f_abmU
                                          (GHC.Word.Word8,
                                           Data.ByteString.Lazy.Internal.ByteString)))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abnB
                            = Data.Profunctor.Choice.right'
                                @p_abmT
                                $dChoice_abmV
                                @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                @(f_abmU
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                                @Data.ByteString.Lazy.Internal.ByteString } in
                        \ (x_abnC
                             :: p_abmT
                                  (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                  (f_abmU
                                     (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))) ->
                          f1_abmX (g_abnB x_abnC))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <Data.ByteString.Lazy.Internal.ByteString>_N
                                      <Data.ByteString.Lazy.Internal.ByteString>_N
                                      <GHC.Word.Word8>_N
                                      <GHC.Word.Word8>_N)
                             :: Control.Lens.Type.Prism
                                  Data.ByteString.Lazy.Internal.ByteString
                                  Data.ByteString.Lazy.Internal.ByteString
                                  (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                  (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                ~R# Control.Lens.Cons.Cons
                                      Data.ByteString.Lazy.Internal.ByteString
                                      Data.ByteString.Lazy.Internal.ByteString
                                      GHC.Word.Word8
                                      GHC.Word.Word8)
              ValArg (\ (@(p_abjT :: * -> * -> *))
                        (@(f_abjU :: * -> *))
                        ($dChoice_abjV :: Data.Profunctor.Choice.Choice p_abjT)
                        ($dApplicative_abjW :: GHC.Base.Applicative f_abjU) ->
                        let {
                          f1_abjX
                            :: p_abjT
                                 (Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                                 (Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString
                                    (f_abjU
                                       (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                               -> p_abjT
                                    Data.ByteString.Internal.Type.ByteString
                                    (f_abjU Data.ByteString.Internal.Type.ByteString)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 612 0}]
                          f1_abjX
                            = Data.Profunctor.Unsafe.dimap
                                @p_abjT
                                (Data.Profunctor.Choice.$p1Choice @p_abjT $dChoice_abjV)
                                @Data.ByteString.Internal.Type.ByteString
                                @(Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                                @(Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString
                                    (f_abjU
                                       (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                                @(f_abjU Data.ByteString.Internal.Type.ByteString)
                                (\ (s1_abjY :: Data.ByteString.Internal.Type.ByteString) ->
                                   case s1_abjY of wild_abjZ
                                   { Data.ByteString.Internal.Type.BS bx_abk0 bx1_abk1 bx2_abk2 ->
                                   case GHC.Classes.leInt (GHC.Types.I# bx2_abk2) (GHC.Types.I# 0#)
                                   of {
                                     GHC.Types.False ->
                                       Data.Either.Right
                                         @Data.ByteString.Internal.Type.ByteString
                                         @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                         (case GHC.Prim.readWord8OffAddr#
                                                 @GHC.Prim.RealWorld bx_abk0 0# GHC.Prim.realWorld#
                                          of
                                          { (# ipv_abk7, ipv1_abk8 #) ->
                                          case GHC.Prim.touch#
                                                 @'GHC.Types.Lifted
                                                 @GHC.ForeignPtr.ForeignPtrContents
                                                 bx1_abk1
                                                 ipv_abk7
                                          of
                                          { __DEFAULT ->
                                          GHC.Word.W8# ipv1_abk8
                                          }
                                          },
                                          Data.ByteString.Internal.Type.$WBS
                                            (GHC.ForeignPtr.ForeignPtr
                                               @GHC.Word.Word8
                                               (GHC.Prim.plusAddr# bx_abk0 1#)
                                               bx1_abk1)
                                            (GHC.Types.I# (GHC.Prim.-# bx2_abk2 1#)));
                                     GHC.Types.True ->
                                       Data.Either.Left
                                         @Data.ByteString.Internal.Type.ByteString
                                         @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                         wild_abjZ
                                   }
                                   })
                                (let {
                                   f2_abkc
                                     :: Data.ByteString.Internal.Type.ByteString
                                        -> f_abjU Data.ByteString.Internal.Type.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abkc
                                     = GHC.Base.pure
                                         @f_abjU
                                         $dApplicative_abjW
                                         @Data.ByteString.Internal.Type.ByteString } in
                                 let {
                                   ds2_abkd
                                     :: f_abjU
                                          (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                        -> f_abjU Data.ByteString.Internal.Type.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 259 0}]
                                   ds2_abkd
                                     = GHC.Base.fmap
                                         @f_abjU
                                         (GHC.Base.$p1Applicative @f_abjU $dApplicative_abjW)
                                         @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                         @Data.ByteString.Internal.Type.ByteString
                                         (\ (p1_abke
                                               :: (GHC.Word.Word8,
                                                   Data.ByteString.Internal.Type.ByteString)) ->
                                            case p1_abke of { (ds_abkg, y_abkh) ->
                                            case y_abkh of
                                            { Data.ByteString.Internal.Type.BS bx_abkt bx1_abku
                                                                               bx2_abkv ->
                                            GHC.Magic.runRW#
                                              @GHC.Types.LiftedRep
                                              @Data.ByteString.Internal.Type.ByteString
                                              (\ (s_abkr [OS=OneShot]
                                                    :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                                                 let {
                                                   x_abks :: GHC.Prim.Int#
                                                   [LclId,
                                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                            Value=False, ConLike=False,
                                                            WorkFree=False, Expandable=False,
                                                            Guidance=IF_ARGS [] 1 0}]
                                                   x_abks = GHC.Prim.+# bx2_abkv 1# } in
                                                 case GHC.Prim.<# x_abks 0# of {
                                                   __DEFAULT ->
                                                     case GHC.Prim.newPinnedByteArray#
                                                            @GHC.Prim.RealWorld x_abks s_abkr
                                                     of
                                                     { (# ipv_abkA, ipv1_abkB #) ->
                                                     let {
                                                       ipv2_abkz :: GHC.Prim.Addr#
                                                       [LclId,
                                                        Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                                Value=False, ConLike=False,
                                                                WorkFree=False, Expandable=False,
                                                                Guidance=IF_ARGS [] 1 0}]
                                                       ipv2_abkz
                                                         = GHC.Prim.mutableByteArrayContents#
                                                             @GHC.Prim.RealWorld ipv1_abkB } in
                                                     let {
                                                       ipv3_abkD
                                                         :: GHC.ForeignPtr.ForeignPtrContents
                                                       [LclId,
                                                        Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                                Value=True, ConLike=True,
                                                                WorkFree=True, Expandable=True,
                                                                Guidance=IF_ARGS [] 10 10}]
                                                       ipv3_abkD
                                                         = GHC.ForeignPtr.PlainPtr ipv1_abkB } in
                                                     case ds_abkg of { GHC.Word.W8# x1_ablV ->
                                                     case GHC.Prim.writeWord8OffAddr#
                                                            @GHC.Prim.RealWorld
                                                            ipv2_abkz
                                                            0#
                                                            x1_ablV
                                                            ipv_abkA
                                                     of s2_ablX
                                                     { __DEFAULT ->
                                                     case GHC.Prim.touch#
                                                            @'GHC.Types.Lifted
                                                            @GHC.ForeignPtr.ForeignPtrContents
                                                            ipv3_abkD
                                                            s2_ablX
                                                     of s'_ablY
                                                     { __DEFAULT ->
                                                     case {__ffi_static_ccall_unsafe base:memcpy :: Addr#
                                          -> Addr#
                                          -> Word64#
                                          -> State# RealWorld
                                          -> (# State# RealWorld, Addr# #)}_ablZ
                                                            (GHC.Prim.plusAddr# ipv2_abkz 1#)
                                                            bx_abkt
                                                            (GHC.Prim.int64ToWord64#
                                                               (GHC.Prim.intToInt64# bx2_abkv))
                                                            s'_ablY
                                                     of
                                                     { (# ds4_abm1, ds5_abm2 #) ->
                                                     case GHC.Prim.touch#
                                                            @'GHC.Types.Lifted
                                                            @GHC.ForeignPtr.ForeignPtrContents
                                                            bx1_abku
                                                            ds4_abm1
                                                     of s'1_abm4
                                                     { __DEFAULT ->
                                                     case GHC.Prim.touch#
                                                            @'GHC.Types.Lifted
                                                            @GHC.ForeignPtr.ForeignPtrContents
                                                            ipv3_abkD
                                                            s'1_abm4
                                                     of s'2_abm5
                                                     { __DEFAULT ->
                                                     case GHC.Magic.lazy
                                                            @((GHC.Prim.State# GHC.Prim.RealWorld
                                                               -> (# GHC.Prim.State#
                                                                       GHC.Prim.RealWorld,
                                                                     GHC.Prim.Addr# #))
                                                              -> (# GHC.Prim.State#
                                                                      GHC.Prim.RealWorld,
                                                                    GHC.Prim.Addr# #))
                                                            (GHC.Magic.runRW#
                                                               @('GHC.Types.TupleRep
                                                                   '[GHC.Types.ZeroBitRep,
                                                                     'GHC.Types.AddrRep])
                                                               @(# GHC.Prim.State#
                                                                     GHC.Prim.RealWorld,
                                                                   GHC.Prim.Addr# #))
                                                            (\ _ [Occ=Dead] ->
                                                               (# s'2_abm5, ipv2_abkz #))
                                                     of
                                                     { (# ipv6_abm8, ipv7_abm9 #) ->
                                                     Data.ByteString.Internal.Type.BS
                                                       ipv7_abm9 ipv3_abkD x_abks
                                                     }
                                                     }
                                                     }
                                                     }
                                                     }
                                                     }
                                                     }
                                                     };
                                                   1# ->
                                                     case GHC.ForeignPtr.mallocPlainForeignPtrBytes2
                                                     of wild_00 {
                                                     }
                                                 })
                                            }
                                            }) } in
                                 \ (ds3_abmc
                                      :: Data.Either.Either
                                           Data.ByteString.Internal.Type.ByteString
                                           (f_abjU
                                              (GHC.Word.Word8,
                                               Data.ByteString.Internal.Type.ByteString))) ->
                                   case ds3_abmc of {
                                     Data.Either.Left x_abme -> f2_abkc x_abme;
                                     Data.Either.Right y_abmg -> ds2_abkd y_abmg
                                   }) } in
                        let {
                          g_abmi
                            :: p_abjT
                                 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                 (f_abjU (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                               -> p_abjT
                                    (Data.Either.Either
                                       Data.ByteString.Internal.Type.ByteString
                                       (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                                    (Data.Either.Either
                                       Data.ByteString.Internal.Type.ByteString
                                       (f_abjU
                                          (GHC.Word.Word8,
                                           Data.ByteString.Internal.Type.ByteString)))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abmi
                            = Data.Profunctor.Choice.right'
                                @p_abjT
                                $dChoice_abjV
                                @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                @(f_abjU
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                                @Data.ByteString.Internal.Type.ByteString } in
                        \ (x_abmj
                             :: p_abjT
                                  (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                  (f_abjU
                                     (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))) ->
                          f1_abjX (g_abmi x_abmj))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <Data.ByteString.Internal.Type.ByteString>_N
                                      <Data.ByteString.Internal.Type.ByteString>_N
                                      <GHC.Word.Word8>_N
                                      <GHC.Word.Word8>_N)
                             :: Control.Lens.Type.Prism
                                  Data.ByteString.Internal.Type.ByteString
                                  Data.ByteString.Internal.Type.ByteString
                                  (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                  (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                ~R# Control.Lens.Cons.Cons
                                      Data.ByteString.Internal.Type.ByteString
                                      Data.ByteString.Internal.Type.ByteString
                                      GHC.Word.Word8
                                      GHC.Word.Word8)
              ValArg (\ (@(p_abmq :: * -> * -> *))
                        (@(f_abmr :: * -> *))
                        ($dChoice_abms :: Data.Profunctor.Choice.Choice p_abmq)
                        ($dApplicative_abmt :: GHC.Base.Applicative f_abmr) ->
                        let {
                          f1_abmu
                            :: p_abmq
                                 (Data.Either.Either Data.ByteString.Internal.Type.ByteString ())
                                 (Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString (f_abmr ()))
                               -> p_abmq
                                    Data.ByteString.Internal.Type.ByteString
                                    (f_abmr Data.ByteString.Internal.Type.ByteString)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 350 0}]
                          f1_abmu
                            = Data.Profunctor.Unsafe.dimap
                                @p_abmq
                                (Data.Profunctor.Choice.$p1Choice @p_abmq $dChoice_abms)
                                @Data.ByteString.Internal.Type.ByteString
                                @(Data.Either.Either Data.ByteString.Internal.Type.ByteString ())
                                @(Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString (f_abmr ()))
                                @(f_abmr Data.ByteString.Internal.Type.ByteString)
                                (\ (s_abmv :: Data.ByteString.Internal.Type.ByteString) ->
                                   case s_abmv of wild_abmw
                                   { Data.ByteString.Internal.Type.BS bx_abmx bx1_abmy bx2_abmz ->
                                   case GHC.Classes.leInt (GHC.Types.I# bx2_abmz) (GHC.Types.I# 0#)
                                   of {
                                     GHC.Types.False ->
                                       Data.Either.Left
                                         @Data.ByteString.Internal.Type.ByteString @() wild_abmw;
                                     GHC.Types.True ->
                                       Data.Either.Right
                                         @Data.ByteString.Internal.Type.ByteString
                                         @()
                                         GHC.Tuple.Prim.()
                                   }
                                   })
                                (let {
                                   f2_abmD
                                     :: Data.ByteString.Internal.Type.ByteString
                                        -> f_abmr Data.ByteString.Internal.Type.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abmD
                                     = GHC.Base.pure
                                         @f_abmr
                                         $dApplicative_abmt
                                         @Data.ByteString.Internal.Type.ByteString } in
                                 let {
                                   ds2_abmE
                                     :: f_abmr () -> f_abmr Data.ByteString.Internal.Type.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 70 0}]
                                   ds2_abmE
                                     = GHC.Base.fmap
                                         @f_abmr
                                         (GHC.Base.$p1Applicative @f_abmr $dApplicative_abmt)
                                         @()
                                         @Data.ByteString.Internal.Type.ByteString
                                         (\ (ds3_abmF :: ()) ->
                                            case ds3_abmF of { () ->
                                            Data.ByteString.Internal.Type.empty
                                            }) } in
                                 \ (ds3_abmH
                                      :: Data.Either.Either
                                           Data.ByteString.Internal.Type.ByteString (f_abmr ())) ->
                                   case ds3_abmH of {
                                     Data.Either.Left x_abmJ -> f2_abmD x_abmJ;
                                     Data.Either.Right y_abmL -> ds2_abmE y_abmL
                                   }) } in
                        let {
                          g_abmN
                            :: p_abmq () (f_abmr ())
                               -> p_abmq
                                    (Data.Either.Either Data.ByteString.Internal.Type.ByteString ())
                                    (Data.Either.Either
                                       Data.ByteString.Internal.Type.ByteString (f_abmr ()))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abmN
                            = Data.Profunctor.Choice.right'
                                @p_abmq
                                $dChoice_abms
                                @()
                                @(f_abmr ())
                                @Data.ByteString.Internal.Type.ByteString } in
                        \ (x_abmO :: p_abmq () (f_abmr ())) -> f1_abmu (g_abmN x_abmO))
                     `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                      <Data.ByteString.Internal.Type.ByteString>_N)
                             :: Control.Lens.Type.Prism'
                                  Data.ByteString.Internal.Type.ByteString ()
                                ~R# Control.Lens.Empty.AsEmpty
                                      Data.ByteString.Internal.Type.ByteString)
              TyArg Data.Functor.Const.Const
                      Data.ByteString.Internal.Type.ByteString
              ValArg Data.Functor.Contravariant.$fContravariantConst
                       @Data.ByteString.Internal.Type.ByteString
              ValArg Data.Functor.Const.$fFunctorConst
                       @Data.ByteString.Internal.Type.ByteString
    After:  (\ (@(f_abff :: * -> *))
               ($dCons_abfg
                  :: Control.Lens.Cons.Cons
                       Data.ByteString.Lazy.Internal.ByteString
                       Data.ByteString.Lazy.Internal.ByteString
                       GHC.Word.Word8
                       GHC.Word.Word8)
               ($dCons1_abfh
                  :: Control.Lens.Cons.Cons
                       Data.ByteString.Internal.Type.ByteString
                       Data.ByteString.Internal.Type.ByteString
                       GHC.Word.Word8
                       GHC.Word.Word8)
               ($dAsEmpty_abfi
                  :: Control.Lens.Empty.AsEmpty
                       Data.ByteString.Internal.Type.ByteString)
               ($dContravariant_abfj
                  :: Data.Functor.Contravariant.Contravariant f_abff)
               ($dFunctor_abfk :: GHC.Base.Functor f_abff) ->
               Data.Profunctor.Unsafe.$fProfunctorFUN_$cdimap
                 @Data.ByteString.Lazy.Internal.ByteString
                 @Data.ByteString.Internal.Type.ByteString
                 @(f_abff Data.ByteString.Internal.Type.ByteString)
                 @(f_abff Data.ByteString.Lazy.Internal.ByteString)
                 Data.ByteString.Lazy.Internal.toStrict
                 (GHC.Base.fmap
                    @f_abff
                    $dFunctor_abfk
                    @Data.ByteString.Internal.Type.ByteString
                    @Data.ByteString.Lazy.Internal.ByteString
                    Data.ByteString.Lazy.Internal.fromStrict))
              @(Data.Functor.Const.Const
                  Data.ByteString.Internal.Type.ByteString)
              ((\ (@(p_abmT :: * -> * -> *))
                  (@(f_abmU :: * -> *))
                  ($dChoice_abmV :: Data.Profunctor.Choice.Choice p_abmT)
                  ($dApplicative_abmW :: GHC.Base.Applicative f_abmU) ->
                  let {
                    f1_abmX
                      :: p_abmT
                           (Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString
                              (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                           (Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString
                              (f_abmU
                                 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                         -> p_abmT
                              Data.ByteString.Lazy.Internal.ByteString
                              (f_abmU Data.ByteString.Lazy.Internal.ByteString)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 536 0}]
                    f1_abmX
                      = Data.Profunctor.Unsafe.dimap
                          @p_abmT
                          (Data.Profunctor.Choice.$p1Choice @p_abmT $dChoice_abmV)
                          @Data.ByteString.Lazy.Internal.ByteString
                          @(Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString
                              (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                          @(Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString
                              (f_abmU
                                 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                          @(f_abmU Data.ByteString.Lazy.Internal.ByteString)
                          (\ (s1_abmY :: Data.ByteString.Lazy.Internal.ByteString) ->
                             case s1_abmY of {
                               Data.ByteString.Lazy.Internal.Empty ->
                                 Data.Either.Left
                                   @Data.ByteString.Lazy.Internal.ByteString
                                   @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                   Data.ByteString.Lazy.Internal.Empty;
                               Data.ByteString.Lazy.Internal.Chunk bx_abn5 bx1_abn6 bx2_abn7
                                                                   cs_abn8 ->
                                 case bx2_abn7 of ds1_abna {
                                   __DEFAULT ->
                                     Data.Either.Right
                                       @Data.ByteString.Lazy.Internal.ByteString
                                       @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                       (case GHC.Prim.readWord8OffAddr#
                                               @GHC.Prim.RealWorld bx_abn5 0# GHC.Prim.realWorld#
                                        of
                                        { (# ipv_abnc, ipv1_abnd #) ->
                                        case GHC.Prim.touch#
                                               @'GHC.Types.Lifted
                                               @GHC.ForeignPtr.ForeignPtrContents
                                               bx1_abn6
                                               ipv_abnc
                                        of
                                        { __DEFAULT ->
                                        GHC.Word.W8# ipv1_abnd
                                        }
                                        },
                                        Data.ByteString.Lazy.Internal.$WChunk
                                          (Data.ByteString.Internal.Type.$WBS
                                             (GHC.ForeignPtr.ForeignPtr
                                                @GHC.Word.Word8
                                                (GHC.Prim.plusAddr# bx_abn5 1#)
                                                bx1_abn6)
                                             (GHC.Types.I# (GHC.Prim.-# ds1_abna 1#)))
                                          cs_abn8);
                                   1# ->
                                     Data.Either.Right
                                       @Data.ByteString.Lazy.Internal.ByteString
                                       @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                       (case GHC.Prim.readWord8OffAddr#
                                               @GHC.Prim.RealWorld bx_abn5 0# GHC.Prim.realWorld#
                                        of
                                        { (# ipv_abnh, ipv1_abni #) ->
                                        case GHC.Prim.touch#
                                               @'GHC.Types.Lifted
                                               @GHC.ForeignPtr.ForeignPtrContents
                                               bx1_abn6
                                               ipv_abnh
                                        of
                                        { __DEFAULT ->
                                        GHC.Word.W8# ipv1_abni
                                        }
                                        },
                                        cs_abn8)
                                 }
                             })
                          (let {
                             f2_abnl
                               :: Data.ByteString.Lazy.Internal.ByteString
                                  -> f_abmU Data.ByteString.Lazy.Internal.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abnl
                               = GHC.Base.pure
                                   @f_abmU
                                   $dApplicative_abmW
                                   @Data.ByteString.Lazy.Internal.ByteString } in
                           let {
                             ds2_abnm
                               :: f_abmU
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                  -> f_abmU Data.ByteString.Lazy.Internal.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 162 0}]
                             ds2_abnm
                               = GHC.Base.fmap
                                   @f_abmU
                                   (GHC.Base.$p1Applicative @f_abmU $dApplicative_abmW)
                                   @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                   @Data.ByteString.Lazy.Internal.ByteString
                                   (\ (p1_abnn
                                         :: (GHC.Word.Word8,
                                             Data.ByteString.Lazy.Internal.ByteString)) ->
                                      case p1_abnn of { (x_abnp, ds_abnq) ->
                                      case x_abnp of { GHC.Word.W8# x#_abnt ->
                                      Data.ByteString.Lazy.Internal.$WChunk
                                        (Data.ByteString.Internal.Type.$WBS
                                           (GHC.ForeignPtr.ForeignPtr
                                              @GHC.Word.Word8
                                              (GHC.Prim.plusAddr#
                                                 Data.ByteString.singleton1
                                                 (GHC.Prim.word2Int#
                                                    (GHC.Prim.word8ToWord# x#_abnt)))
                                              GHC.ForeignPtr.FinalPtr)
                                           (GHC.Types.I# 1#))
                                        ds_abnq
                                      }
                                      }) } in
                           \ (ds3_abnv
                                :: Data.Either.Either
                                     Data.ByteString.Lazy.Internal.ByteString
                                     (f_abmU
                                        (GHC.Word.Word8,
                                         Data.ByteString.Lazy.Internal.ByteString))) ->
                             case ds3_abnv of {
                               Data.Either.Left x_abnx -> f2_abnl x_abnx;
                               Data.Either.Right y_abnz -> ds2_abnm y_abnz
                             }) } in
                  let {
                    g_abnB
                      :: p_abmT
                           (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                           (f_abmU (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                         -> p_abmT
                              (Data.Either.Either
                                 Data.ByteString.Lazy.Internal.ByteString
                                 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                              (Data.Either.Either
                                 Data.ByteString.Lazy.Internal.ByteString
                                 (f_abmU
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abnB
                      = Data.Profunctor.Choice.right'
                          @p_abmT
                          $dChoice_abmV
                          @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                          @(f_abmU
                              (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                          @Data.ByteString.Lazy.Internal.ByteString } in
                  \ (x_abnC
                       :: p_abmT
                            (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                            (f_abmU
                               (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))) ->
                    f1_abmX (g_abnB x_abnC))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <Data.ByteString.Lazy.Internal.ByteString>_N
                                <Data.ByteString.Lazy.Internal.ByteString>_N
                                <GHC.Word.Word8>_N
                                <GHC.Word.Word8>_N)
                       :: Control.Lens.Type.Prism
                            Data.ByteString.Lazy.Internal.ByteString
                            Data.ByteString.Lazy.Internal.ByteString
                            (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                            (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                          ~R# Control.Lens.Cons.Cons
                                Data.ByteString.Lazy.Internal.ByteString
                                Data.ByteString.Lazy.Internal.ByteString
                                GHC.Word.Word8
                                GHC.Word.Word8))
              ((\ (@(p_abjT :: * -> * -> *))
                  (@(f_abjU :: * -> *))
                  ($dChoice_abjV :: Data.Profunctor.Choice.Choice p_abjT)
                  ($dApplicative_abjW :: GHC.Base.Applicative f_abjU) ->
                  let {
                    f1_abjX
                      :: p_abjT
                           (Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString
                              (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                           (Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString
                              (f_abjU
                                 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                         -> p_abjT
                              Data.ByteString.Internal.Type.ByteString
                              (f_abjU Data.ByteString.Internal.Type.ByteString)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 612 0}]
                    f1_abjX
                      = Data.Profunctor.Unsafe.dimap
                          @p_abjT
                          (Data.Profunctor.Choice.$p1Choice @p_abjT $dChoice_abjV)
                          @Data.ByteString.Internal.Type.ByteString
                          @(Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString
                              (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                          @(Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString
                              (f_abjU
                                 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                          @(f_abjU Data.ByteString.Internal.Type.ByteString)
                          (\ (s1_abjY :: Data.ByteString.Internal.Type.ByteString) ->
                             case s1_abjY of wild_abjZ
                             { Data.ByteString.Internal.Type.BS bx_abk0 bx1_abk1 bx2_abk2 ->
                             case GHC.Classes.leInt (GHC.Types.I# bx2_abk2) (GHC.Types.I# 0#)
                             of {
                               GHC.Types.False ->
                                 Data.Either.Right
                                   @Data.ByteString.Internal.Type.ByteString
                                   @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                   (case GHC.Prim.readWord8OffAddr#
                                           @GHC.Prim.RealWorld bx_abk0 0# GHC.Prim.realWorld#
                                    of
                                    { (# ipv_abk7, ipv1_abk8 #) ->
                                    case GHC.Prim.touch#
                                           @'GHC.Types.Lifted
                                           @GHC.ForeignPtr.ForeignPtrContents
                                           bx1_abk1
                                           ipv_abk7
                                    of
                                    { __DEFAULT ->
                                    GHC.Word.W8# ipv1_abk8
                                    }
                                    },
                                    Data.ByteString.Internal.Type.$WBS
                                      (GHC.ForeignPtr.ForeignPtr
                                         @GHC.Word.Word8 (GHC.Prim.plusAddr# bx_abk0 1#) bx1_abk1)
                                      (GHC.Types.I# (GHC.Prim.-# bx2_abk2 1#)));
                               GHC.Types.True ->
                                 Data.Either.Left
                                   @Data.ByteString.Internal.Type.ByteString
                                   @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                   wild_abjZ
                             }
                             })
                          (let {
                             f2_abkc
                               :: Data.ByteString.Internal.Type.ByteString
                                  -> f_abjU Data.ByteString.Internal.Type.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abkc
                               = GHC.Base.pure
                                   @f_abjU
                                   $dApplicative_abjW
                                   @Data.ByteString.Internal.Type.ByteString } in
                           let {
                             ds2_abkd
                               :: f_abjU
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                  -> f_abjU Data.ByteString.Internal.Type.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 259 0}]
                             ds2_abkd
                               = GHC.Base.fmap
                                   @f_abjU
                                   (GHC.Base.$p1Applicative @f_abjU $dApplicative_abjW)
                                   @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                   @Data.ByteString.Internal.Type.ByteString
                                   (\ (p1_abke
                                         :: (GHC.Word.Word8,
                                             Data.ByteString.Internal.Type.ByteString)) ->
                                      case p1_abke of { (ds_abkg, y_abkh) ->
                                      case y_abkh of
                                      { Data.ByteString.Internal.Type.BS bx_abkt bx1_abku
                                                                         bx2_abkv ->
                                      GHC.Magic.runRW#
                                        @GHC.Types.LiftedRep
                                        @Data.ByteString.Internal.Type.ByteString
                                        (\ (s_abkr [OS=OneShot]
                                              :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                                           let {
                                             x_abks :: GHC.Prim.Int#
                                             [LclId,
                                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                      Value=False, ConLike=False, WorkFree=False,
                                                      Expandable=False,
                                                      Guidance=IF_ARGS [] 1 0}]
                                             x_abks = GHC.Prim.+# bx2_abkv 1# } in
                                           case GHC.Prim.<# x_abks 0# of {
                                             __DEFAULT ->
                                               case GHC.Prim.newPinnedByteArray#
                                                      @GHC.Prim.RealWorld x_abks s_abkr
                                               of
                                               { (# ipv_abkA, ipv1_abkB #) ->
                                               let {
                                                 ipv2_abkz :: GHC.Prim.Addr#
                                                 [LclId,
                                                  Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                          Value=False, ConLike=False,
                                                          WorkFree=False, Expandable=False,
                                                          Guidance=IF_ARGS [] 1 0}]
                                                 ipv2_abkz
                                                   = GHC.Prim.mutableByteArrayContents#
                                                       @GHC.Prim.RealWorld ipv1_abkB } in
                                               let {
                                                 ipv3_abkD :: GHC.ForeignPtr.ForeignPtrContents
                                                 [LclId,
                                                  Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                          Value=True, ConLike=True, WorkFree=True,
                                                          Expandable=True,
                                                          Guidance=IF_ARGS [] 10 10}]
                                                 ipv3_abkD = GHC.ForeignPtr.PlainPtr ipv1_abkB } in
                                               case ds_abkg of { GHC.Word.W8# x1_ablV ->
                                               case GHC.Prim.writeWord8OffAddr#
                                                      @GHC.Prim.RealWorld
                                                      ipv2_abkz
                                                      0#
                                                      x1_ablV
                                                      ipv_abkA
                                               of s2_ablX
                                               { __DEFAULT ->
                                               case GHC.Prim.touch#
                                                      @'GHC.Types.Lifted
                                                      @GHC.ForeignPtr.ForeignPtrContents
                                                      ipv3_abkD
                                                      s2_ablX
                                               of s'_ablY
                                               { __DEFAULT ->
                                               case {__ffi_static_ccall_unsafe base:memcpy :: Addr#
                                          -> Addr#
                                          -> Word64#
                                          -> State# RealWorld
                                          -> (# State# RealWorld, Addr# #)}_ablZ
                                                      (GHC.Prim.plusAddr# ipv2_abkz 1#)
                                                      bx_abkt
                                                      (GHC.Prim.int64ToWord64#
                                                         (GHC.Prim.intToInt64# bx2_abkv))
                                                      s'_ablY
                                               of
                                               { (# ds4_abm1, ds5_abm2 #) ->
                                               case GHC.Prim.touch#
                                                      @'GHC.Types.Lifted
                                                      @GHC.ForeignPtr.ForeignPtrContents
                                                      bx1_abku
                                                      ds4_abm1
                                               of s'1_abm4
                                               { __DEFAULT ->
                                               case GHC.Prim.touch#
                                                      @'GHC.Types.Lifted
                                                      @GHC.ForeignPtr.ForeignPtrContents
                                                      ipv3_abkD
                                                      s'1_abm4
                                               of s'2_abm5
                                               { __DEFAULT ->
                                               case GHC.Magic.lazy
                                                      @((GHC.Prim.State# GHC.Prim.RealWorld
                                                         -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                               GHC.Prim.Addr# #))
                                                        -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                              GHC.Prim.Addr# #))
                                                      (GHC.Magic.runRW#
                                                         @('GHC.Types.TupleRep
                                                             '[GHC.Types.ZeroBitRep,
                                                               'GHC.Types.AddrRep])
                                                         @(# GHC.Prim.State# GHC.Prim.RealWorld,
                                                             GHC.Prim.Addr# #))
                                                      (\ _ [Occ=Dead] -> (# s'2_abm5, ipv2_abkz #))
                                               of
                                               { (# ipv6_abm8, ipv7_abm9 #) ->
                                               Data.ByteString.Internal.Type.BS
                                                 ipv7_abm9 ipv3_abkD x_abks
                                               }
                                               }
                                               }
                                               }
                                               }
                                               }
                                               }
                                               };
                                             1# ->
                                               case GHC.ForeignPtr.mallocPlainForeignPtrBytes2
                                               of wild_00 {
                                               }
                                           })
                                      }
                                      }) } in
                           \ (ds3_abmc
                                :: Data.Either.Either
                                     Data.ByteString.Internal.Type.ByteString
                                     (f_abjU
                                        (GHC.Word.Word8,
                                         Data.ByteString.Internal.Type.ByteString))) ->
                             case ds3_abmc of {
                               Data.Either.Left x_abme -> f2_abkc x_abme;
                               Data.Either.Right y_abmg -> ds2_abkd y_abmg
                             }) } in
                  let {
                    g_abmi
                      :: p_abjT
                           (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                           (f_abjU (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                         -> p_abjT
                              (Data.Either.Either
                                 Data.ByteString.Internal.Type.ByteString
                                 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                              (Data.Either.Either
                                 Data.ByteString.Internal.Type.ByteString
                                 (f_abjU
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abmi
                      = Data.Profunctor.Choice.right'
                          @p_abjT
                          $dChoice_abjV
                          @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                          @(f_abjU
                              (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                          @Data.ByteString.Internal.Type.ByteString } in
                  \ (x_abmj
                       :: p_abjT
                            (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                            (f_abjU
                               (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))) ->
                    f1_abjX (g_abmi x_abmj))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <Data.ByteString.Internal.Type.ByteString>_N
                                <Data.ByteString.Internal.Type.ByteString>_N
                                <GHC.Word.Word8>_N
                                <GHC.Word.Word8>_N)
                       :: Control.Lens.Type.Prism
                            Data.ByteString.Internal.Type.ByteString
                            Data.ByteString.Internal.Type.ByteString
                            (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                            (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                          ~R# Control.Lens.Cons.Cons
                                Data.ByteString.Internal.Type.ByteString
                                Data.ByteString.Internal.Type.ByteString
                                GHC.Word.Word8
                                GHC.Word.Word8))
              ((\ (@(p_abmq :: * -> * -> *))
                  (@(f_abmr :: * -> *))
                  ($dChoice_abms :: Data.Profunctor.Choice.Choice p_abmq)
                  ($dApplicative_abmt :: GHC.Base.Applicative f_abmr) ->
                  let {
                    f1_abmu
                      :: p_abmq
                           (Data.Either.Either Data.ByteString.Internal.Type.ByteString ())
                           (Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString (f_abmr ()))
                         -> p_abmq
                              Data.ByteString.Internal.Type.ByteString
                              (f_abmr Data.ByteString.Internal.Type.ByteString)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 350 0}]
                    f1_abmu
                      = Data.Profunctor.Unsafe.dimap
                          @p_abmq
                          (Data.Profunctor.Choice.$p1Choice @p_abmq $dChoice_abms)
                          @Data.ByteString.Internal.Type.ByteString
                          @(Data.Either.Either Data.ByteString.Internal.Type.ByteString ())
                          @(Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString (f_abmr ()))
                          @(f_abmr Data.ByteString.Internal.Type.ByteString)
                          (\ (s_abmv :: Data.ByteString.Internal.Type.ByteString) ->
                             case s_abmv of wild_abmw
                             { Data.ByteString.Internal.Type.BS bx_abmx bx1_abmy bx2_abmz ->
                             case GHC.Classes.leInt (GHC.Types.I# bx2_abmz) (GHC.Types.I# 0#)
                             of {
                               GHC.Types.False ->
                                 Data.Either.Left
                                   @Data.ByteString.Internal.Type.ByteString @() wild_abmw;
                               GHC.Types.True ->
                                 Data.Either.Right
                                   @Data.ByteString.Internal.Type.ByteString @() GHC.Tuple.Prim.()
                             }
                             })
                          (let {
                             f2_abmD
                               :: Data.ByteString.Internal.Type.ByteString
                                  -> f_abmr Data.ByteString.Internal.Type.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abmD
                               = GHC.Base.pure
                                   @f_abmr
                                   $dApplicative_abmt
                                   @Data.ByteString.Internal.Type.ByteString } in
                           let {
                             ds2_abmE
                               :: f_abmr () -> f_abmr Data.ByteString.Internal.Type.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 70 0}]
                             ds2_abmE
                               = GHC.Base.fmap
                                   @f_abmr
                                   (GHC.Base.$p1Applicative @f_abmr $dApplicative_abmt)
                                   @()
                                   @Data.ByteString.Internal.Type.ByteString
                                   (\ (ds3_abmF :: ()) ->
                                      case ds3_abmF of { () ->
                                      Data.ByteString.Internal.Type.empty
                                      }) } in
                           \ (ds3_abmH
                                :: Data.Either.Either
                                     Data.ByteString.Internal.Type.ByteString (f_abmr ())) ->
                             case ds3_abmH of {
                               Data.Either.Left x_abmJ -> f2_abmD x_abmJ;
                               Data.Either.Right y_abmL -> ds2_abmE y_abmL
                             }) } in
                  let {
                    g_abmN
                      :: p_abmq () (f_abmr ())
                         -> p_abmq
                              (Data.Either.Either Data.ByteString.Internal.Type.ByteString ())
                              (Data.Either.Either
                                 Data.ByteString.Internal.Type.ByteString (f_abmr ()))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abmN
                      = Data.Profunctor.Choice.right'
                          @p_abmq
                          $dChoice_abms
                          @()
                          @(f_abmr ())
                          @Data.ByteString.Internal.Type.ByteString } in
                  \ (x_abmO :: p_abmq () (f_abmr ())) -> f1_abmu (g_abmN x_abmO))
               `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                <Data.ByteString.Internal.Type.ByteString>_N)
                       :: Control.Lens.Type.Prism'
                            Data.ByteString.Internal.Type.ByteString ()
                          ~R# Control.Lens.Empty.AsEmpty
                                Data.ByteString.Internal.Type.ByteString))
              (Data.Functor.Contravariant.$fContravariantConst
                 @Data.ByteString.Internal.Type.ByteString)
              (Data.Functor.Const.$fFunctorConst
                 @Data.ByteString.Internal.Type.ByteString)
    Cont:   ApplyToVal nodup hole Control.Lens.Getter.Getting
                                    Data.ByteString.Internal.Type.ByteString
                                    Data.ByteString.Lazy.Internal.ByteString
                                    Data.ByteString.Internal.Type.ByteString
              ((\ (ds_abe3 [Occ=Once1] :: a_abe0) -> ds_abe3)
               `cast` (<a_abe0>_R
                       %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                          <*>_N <a_abe0>_R <a_abe0>_P)
                       :: (a_abe0 -> a_abe0)
                          ~R# (a_abe0 -> Data.Functor.Const.Const a_abe0 a_abe0)))
            ApplyToVal nodup hole Data.ByteString.Lazy.Internal.ByteString
                                  -> Data.Functor.Const.Const
                                       Data.ByteString.Internal.Type.ByteString
                                       Data.ByteString.Lazy.Internal.ByteString
              (Control.Lens.Getter.view
                 @Data.ByteString.Internal.Type.ByteString
                 @((->) Data.ByteString.Internal.Type.ByteString)
                 @Data.ByteString.Lazy.Internal.ByteString
                 (Control.Monad.Reader.Class.$fMonadReaderrFUN
                    @Data.ByteString.Internal.Type.ByteString)
                 (Control.Lens.Cons.Extras.recons
                    @Data.ByteString.Internal.Type.ByteString
                    @GHC.Word.Word8
                    @Data.ByteString.Lazy.Internal.ByteString
                    Control.Lens.Cons.$fConsByteStringByteStringWord8Word80
                    Control.Lens.Cons.$fConsByteStringByteStringWord8Word8
                    Control.Lens.Empty.$fAsEmptyByteString
                    @(Data.Functor.Const.Const
                        Data.ByteString.Lazy.Internal.ByteString)
                    (Data.Functor.Contravariant.$fContravariantConst
                       @Data.ByteString.Lazy.Internal.ByteString)
                    (Data.Functor.Const.$fFunctorConst
                       @Data.ByteString.Lazy.Internal.ByteString))
                 s_a8OH)
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N
                        <Data.ByteString.Internal.Type.ByteString>_R
                        <Data.ByteString.Lazy.Internal.ByteString>_P
                    :: Data.Functor.Const.Const
                         Data.ByteString.Internal.Type.ByteString
                         Data.ByteString.Lazy.Internal.ByteString
                       ~R# Data.ByteString.Internal.Type.ByteString)
            Stop[RuleArgCtxt] Data.ByteString.Internal.Type.ByteString
Rule fired
    Rule: Class op fmap
    Module: (BUILTIN)
    Before: GHC.Base.fmap
              TyArg Data.Functor.Const.Const
                      Data.ByteString.Internal.Type.ByteString
              ValArg Data.Functor.Const.$fFunctorConst
                       @Data.ByteString.Internal.Type.ByteString
    After:  (Data.Functor.Const.$fFunctorConst2
               @Data.ByteString.Internal.Type.ByteString)
            `cast` (forall (a :: <*>_N) (b :: <*>_N).
                    <a -> b>_R
                    %<'GHC.Types.Many>_N ->_R <Data.Functor.Const.Const
                                                 Data.ByteString.Internal.Type.ByteString a>_R
                    %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                  <*>_N
                                                  <Data.ByteString.Internal.Type.ByteString>_R
                                                  <a>_P
                                              ; Sym (Data.Functor.Const.N:Const[0]
                                                         <*>_N
                                                         <Data.ByteString.Internal.Type.ByteString>_R
                                                         <b>_P)
                    :: (forall {a} {b}.
                        (a -> b)
                        -> Data.Functor.Const.Const
                             Data.ByteString.Internal.Type.ByteString a
                        -> Data.Functor.Const.Const
                             Data.ByteString.Internal.Type.ByteString a)
                       ~R# (forall {a} {b}.
                            (a -> b)
                            -> Data.Functor.Const.Const
                                 Data.ByteString.Internal.Type.ByteString a
                            -> Data.Functor.Const.Const
                                 Data.ByteString.Internal.Type.ByteString b))
    Cont:   ApplyToTy Data.ByteString.Internal.Type.ByteString
            ApplyToTy Data.ByteString.Lazy.Internal.ByteString
            ApplyToVal nodup hole (Data.ByteString.Internal.Type.ByteString
                                   -> Data.ByteString.Lazy.Internal.ByteString)
                                  -> Data.Functor.Const.Const
                                       Data.ByteString.Internal.Type.ByteString
                                       Data.ByteString.Internal.Type.ByteString
                                  -> Data.Functor.Const.Const
                                       Data.ByteString.Internal.Type.ByteString
                                       Data.ByteString.Lazy.Internal.ByteString
              Data.ByteString.Lazy.Internal.fromStrict
            ApplyToVal nodup hole Data.Functor.Const.Const
                                    Data.ByteString.Internal.Type.ByteString
                                    Data.ByteString.Internal.Type.ByteString
                                  -> Data.Functor.Const.Const
                                       Data.ByteString.Internal.Type.ByteString
                                       Data.ByteString.Lazy.Internal.ByteString
              (bc_aboj (ab_aboh x_abok))
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N
                        <Data.ByteString.Internal.Type.ByteString>_R
                        <Data.ByteString.Lazy.Internal.ByteString>_P
                    :: Data.Functor.Const.Const
                         Data.ByteString.Internal.Type.ByteString
                         Data.ByteString.Lazy.Internal.ByteString
                       ~R# Data.ByteString.Internal.Type.ByteString)
            Stop[RuleArgCtxt] Data.ByteString.Internal.Type.ByteString
Rule fired
    Rule: Class op reader
    Module: (BUILTIN)
    Before: Control.Monad.Reader.Class.reader
              TyArg Data.ByteString.Internal.Type.ByteString
              TyArg (->) Data.ByteString.Internal.Type.ByteString
              ValArg Control.Monad.Reader.Class.$fMonadReaderrFUN
                       @Data.ByteString.Internal.Type.ByteString
    After:  \ (@a_abe8) ->
              GHC.Base.id @(Data.ByteString.Internal.Type.ByteString -> a_abe8)
    Cont:   ApplyToTy Data.ByteString.Lazy.Internal.ByteString
            ApplyToVal nodup hole (Data.ByteString.Internal.Type.ByteString
                                   -> Data.ByteString.Lazy.Internal.ByteString)
                                  -> Data.ByteString.Internal.Type.ByteString
                                  -> Data.ByteString.Lazy.Internal.ByteString
              ((l_abe2
                  ((\ (ds_abe3 [Occ=Once1] :: a_abe0) -> ds_abe3)
                   `cast` (<a_abe0>_R
                           %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                              <*>_N <a_abe0>_R <a_abe0>_P)
                           :: (a_abe0 -> a_abe0)
                              ~R# (a_abe0 -> Data.Functor.Const.Const a_abe0 a_abe0))))
               `cast` (<s_abdY>_R
                       %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                     <*>_N <a_abe0>_R <s_abdY>_P
                       :: (s_abdY -> Data.Functor.Const.Const a_abe0 s_abdY)
                          ~R# (s_abdY -> a_abe0)))
            ApplyToVal nodup hole Data.ByteString.Internal.Type.ByteString
                                  -> Data.ByteString.Lazy.Internal.ByteString
              s_a8OH
            Stop[RuleArgCtxt] Data.ByteString.Lazy.Internal.ByteString
Rule fired
    Rule: recons/bs-lazy
    Module: (Control.Lens.Cons.Extras)
    Before: Control.Lens.Cons.Extras.recons
              TyArg Data.ByteString.Internal.Type.ByteString
              TyArg GHC.Word.Word8
              TyArg Data.ByteString.Lazy.Internal.ByteString
              ValArg (\ (@(p_abjT :: * -> * -> *))
                        (@(f_abjU :: * -> *))
                        ($dChoice_abjV :: Data.Profunctor.Choice.Choice p_abjT)
                        ($dApplicative_abjW :: GHC.Base.Applicative f_abjU) ->
                        let {
                          f1_abjX
                            :: p_abjT
                                 (Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                                 (Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString
                                    (f_abjU
                                       (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                               -> p_abjT
                                    Data.ByteString.Internal.Type.ByteString
                                    (f_abjU Data.ByteString.Internal.Type.ByteString)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 612 0}]
                          f1_abjX
                            = Data.Profunctor.Unsafe.dimap
                                @p_abjT
                                (Data.Profunctor.Choice.$p1Choice @p_abjT $dChoice_abjV)
                                @Data.ByteString.Internal.Type.ByteString
                                @(Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                                @(Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString
                                    (f_abjU
                                       (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                                @(f_abjU Data.ByteString.Internal.Type.ByteString)
                                (\ (s1_abjY :: Data.ByteString.Internal.Type.ByteString) ->
                                   case s1_abjY of wild_abjZ
                                   { Data.ByteString.Internal.Type.BS bx_abk0 bx1_abk1 bx2_abk2 ->
                                   case GHC.Classes.leInt (GHC.Types.I# bx2_abk2) (GHC.Types.I# 0#)
                                   of {
                                     GHC.Types.False ->
                                       Data.Either.Right
                                         @Data.ByteString.Internal.Type.ByteString
                                         @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                         (case GHC.Prim.readWord8OffAddr#
                                                 @GHC.Prim.RealWorld bx_abk0 0# GHC.Prim.realWorld#
                                          of
                                          { (# ipv_abk7, ipv1_abk8 #) ->
                                          case GHC.Prim.touch#
                                                 @'GHC.Types.Lifted
                                                 @GHC.ForeignPtr.ForeignPtrContents
                                                 bx1_abk1
                                                 ipv_abk7
                                          of
                                          { __DEFAULT ->
                                          GHC.Word.W8# ipv1_abk8
                                          }
                                          },
                                          Data.ByteString.Internal.Type.$WBS
                                            (GHC.ForeignPtr.ForeignPtr
                                               @GHC.Word.Word8
                                               (GHC.Prim.plusAddr# bx_abk0 1#)
                                               bx1_abk1)
                                            (GHC.Types.I# (GHC.Prim.-# bx2_abk2 1#)));
                                     GHC.Types.True ->
                                       Data.Either.Left
                                         @Data.ByteString.Internal.Type.ByteString
                                         @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                         wild_abjZ
                                   }
                                   })
                                (let {
                                   f2_abkc
                                     :: Data.ByteString.Internal.Type.ByteString
                                        -> f_abjU Data.ByteString.Internal.Type.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abkc
                                     = GHC.Base.pure
                                         @f_abjU
                                         $dApplicative_abjW
                                         @Data.ByteString.Internal.Type.ByteString } in
                                 let {
                                   ds2_abkd
                                     :: f_abjU
                                          (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                        -> f_abjU Data.ByteString.Internal.Type.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 259 0}]
                                   ds2_abkd
                                     = GHC.Base.fmap
                                         @f_abjU
                                         (GHC.Base.$p1Applicative @f_abjU $dApplicative_abjW)
                                         @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                         @Data.ByteString.Internal.Type.ByteString
                                         (\ (p1_abke
                                               :: (GHC.Word.Word8,
                                                   Data.ByteString.Internal.Type.ByteString)) ->
                                            case p1_abke of { (ds_abkg, y_abkh) ->
                                            case y_abkh of
                                            { Data.ByteString.Internal.Type.BS bx_abkt bx1_abku
                                                                               bx2_abkv ->
                                            GHC.Magic.runRW#
                                              @GHC.Types.LiftedRep
                                              @Data.ByteString.Internal.Type.ByteString
                                              (\ (s_abkr [OS=OneShot]
                                                    :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                                                 let {
                                                   x_abks :: GHC.Prim.Int#
                                                   [LclId,
                                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                            Value=False, ConLike=False,
                                                            WorkFree=False, Expandable=False,
                                                            Guidance=IF_ARGS [] 1 0}]
                                                   x_abks = GHC.Prim.+# bx2_abkv 1# } in
                                                 case GHC.Prim.<# x_abks 0# of {
                                                   __DEFAULT ->
                                                     case GHC.Prim.newPinnedByteArray#
                                                            @GHC.Prim.RealWorld x_abks s_abkr
                                                     of
                                                     { (# ipv_abkA, ipv1_abkB #) ->
                                                     let {
                                                       ipv2_abkz :: GHC.Prim.Addr#
                                                       [LclId,
                                                        Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                                Value=False, ConLike=False,
                                                                WorkFree=False, Expandable=False,
                                                                Guidance=IF_ARGS [] 1 0}]
                                                       ipv2_abkz
                                                         = GHC.Prim.mutableByteArrayContents#
                                                             @GHC.Prim.RealWorld ipv1_abkB } in
                                                     let {
                                                       ipv3_abkD
                                                         :: GHC.ForeignPtr.ForeignPtrContents
                                                       [LclId,
                                                        Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                                Value=True, ConLike=True,
                                                                WorkFree=True, Expandable=True,
                                                                Guidance=IF_ARGS [] 10 10}]
                                                       ipv3_abkD
                                                         = GHC.ForeignPtr.PlainPtr ipv1_abkB } in
                                                     case ds_abkg of { GHC.Word.W8# x1_ablV ->
                                                     case GHC.Prim.writeWord8OffAddr#
                                                            @GHC.Prim.RealWorld
                                                            ipv2_abkz
                                                            0#
                                                            x1_ablV
                                                            ipv_abkA
                                                     of s2_ablX
                                                     { __DEFAULT ->
                                                     case GHC.Prim.touch#
                                                            @'GHC.Types.Lifted
                                                            @GHC.ForeignPtr.ForeignPtrContents
                                                            ipv3_abkD
                                                            s2_ablX
                                                     of s'_ablY
                                                     { __DEFAULT ->
                                                     case {__ffi_static_ccall_unsafe base:memcpy :: Addr#
                                          -> Addr#
                                          -> Word64#
                                          -> State# RealWorld
                                          -> (# State# RealWorld, Addr# #)}_ablZ
                                                            (GHC.Prim.plusAddr# ipv2_abkz 1#)
                                                            bx_abkt
                                                            (GHC.Prim.int64ToWord64#
                                                               (GHC.Prim.intToInt64# bx2_abkv))
                                                            s'_ablY
                                                     of
                                                     { (# ds4_abm1, ds5_abm2 #) ->
                                                     case GHC.Prim.touch#
                                                            @'GHC.Types.Lifted
                                                            @GHC.ForeignPtr.ForeignPtrContents
                                                            bx1_abku
                                                            ds4_abm1
                                                     of s'1_abm4
                                                     { __DEFAULT ->
                                                     case GHC.Prim.touch#
                                                            @'GHC.Types.Lifted
                                                            @GHC.ForeignPtr.ForeignPtrContents
                                                            ipv3_abkD
                                                            s'1_abm4
                                                     of s'2_abm5
                                                     { __DEFAULT ->
                                                     case GHC.Magic.lazy
                                                            @((GHC.Prim.State# GHC.Prim.RealWorld
                                                               -> (# GHC.Prim.State#
                                                                       GHC.Prim.RealWorld,
                                                                     GHC.Prim.Addr# #))
                                                              -> (# GHC.Prim.State#
                                                                      GHC.Prim.RealWorld,
                                                                    GHC.Prim.Addr# #))
                                                            (GHC.Magic.runRW#
                                                               @('GHC.Types.TupleRep
                                                                   '[GHC.Types.ZeroBitRep,
                                                                     'GHC.Types.AddrRep])
                                                               @(# GHC.Prim.State#
                                                                     GHC.Prim.RealWorld,
                                                                   GHC.Prim.Addr# #))
                                                            (\ _ [Occ=Dead] ->
                                                               (# s'2_abm5, ipv2_abkz #))
                                                     of
                                                     { (# ipv6_abm8, ipv7_abm9 #) ->
                                                     Data.ByteString.Internal.Type.BS
                                                       ipv7_abm9 ipv3_abkD x_abks
                                                     }
                                                     }
                                                     }
                                                     }
                                                     }
                                                     }
                                                     }
                                                     };
                                                   1# ->
                                                     case GHC.ForeignPtr.mallocPlainForeignPtrBytes2
                                                     of wild_00 {
                                                     }
                                                 })
                                            }
                                            }) } in
                                 \ (ds3_abmc
                                      :: Data.Either.Either
                                           Data.ByteString.Internal.Type.ByteString
                                           (f_abjU
                                              (GHC.Word.Word8,
                                               Data.ByteString.Internal.Type.ByteString))) ->
                                   case ds3_abmc of {
                                     Data.Either.Left x_abme -> f2_abkc x_abme;
                                     Data.Either.Right y_abmg -> ds2_abkd y_abmg
                                   }) } in
                        let {
                          g_abmi
                            :: p_abjT
                                 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                 (f_abjU (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                               -> p_abjT
                                    (Data.Either.Either
                                       Data.ByteString.Internal.Type.ByteString
                                       (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                                    (Data.Either.Either
                                       Data.ByteString.Internal.Type.ByteString
                                       (f_abjU
                                          (GHC.Word.Word8,
                                           Data.ByteString.Internal.Type.ByteString)))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abmi
                            = Data.Profunctor.Choice.right'
                                @p_abjT
                                $dChoice_abjV
                                @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                @(f_abjU
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                                @Data.ByteString.Internal.Type.ByteString } in
                        \ (x_abmj
                             :: p_abjT
                                  (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                  (f_abjU
                                     (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))) ->
                          f1_abjX (g_abmi x_abmj))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <Data.ByteString.Internal.Type.ByteString>_N
                                      <Data.ByteString.Internal.Type.ByteString>_N
                                      <GHC.Word.Word8>_N
                                      <GHC.Word.Word8>_N)
                             :: Control.Lens.Type.Prism
                                  Data.ByteString.Internal.Type.ByteString
                                  Data.ByteString.Internal.Type.ByteString
                                  (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                  (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                ~R# Control.Lens.Cons.Cons
                                      Data.ByteString.Internal.Type.ByteString
                                      Data.ByteString.Internal.Type.ByteString
                                      GHC.Word.Word8
                                      GHC.Word.Word8)
              ValArg (\ (@(p_abmT :: * -> * -> *))
                        (@(f_abmU :: * -> *))
                        ($dChoice_abmV :: Data.Profunctor.Choice.Choice p_abmT)
                        ($dApplicative_abmW :: GHC.Base.Applicative f_abmU) ->
                        let {
                          f1_abmX
                            :: p_abmT
                                 (Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                                 (Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (f_abmU
                                       (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                               -> p_abmT
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (f_abmU Data.ByteString.Lazy.Internal.ByteString)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 536 0}]
                          f1_abmX
                            = Data.Profunctor.Unsafe.dimap
                                @p_abmT
                                (Data.Profunctor.Choice.$p1Choice @p_abmT $dChoice_abmV)
                                @Data.ByteString.Lazy.Internal.ByteString
                                @(Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                                @(Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (f_abmU
                                       (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                                @(f_abmU Data.ByteString.Lazy.Internal.ByteString)
                                (\ (s1_abmY :: Data.ByteString.Lazy.Internal.ByteString) ->
                                   case s1_abmY of {
                                     Data.ByteString.Lazy.Internal.Empty ->
                                       Data.Either.Left
                                         @Data.ByteString.Lazy.Internal.ByteString
                                         @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                         Data.ByteString.Lazy.Internal.Empty;
                                     Data.ByteString.Lazy.Internal.Chunk bx_abn5 bx1_abn6 bx2_abn7
                                                                         cs_abn8 ->
                                       case bx2_abn7 of ds1_abna {
                                         __DEFAULT ->
                                           Data.Either.Right
                                             @Data.ByteString.Lazy.Internal.ByteString
                                             @(GHC.Word.Word8,
                                               Data.ByteString.Lazy.Internal.ByteString)
                                             (case GHC.Prim.readWord8OffAddr#
                                                     @GHC.Prim.RealWorld
                                                     bx_abn5
                                                     0#
                                                     GHC.Prim.realWorld#
                                              of
                                              { (# ipv_abnc, ipv1_abnd #) ->
                                              case GHC.Prim.touch#
                                                     @'GHC.Types.Lifted
                                                     @GHC.ForeignPtr.ForeignPtrContents
                                                     bx1_abn6
                                                     ipv_abnc
                                              of
                                              { __DEFAULT ->
                                              GHC.Word.W8# ipv1_abnd
                                              }
                                              },
                                              Data.ByteString.Lazy.Internal.$WChunk
                                                (Data.ByteString.Internal.Type.$WBS
                                                   (GHC.ForeignPtr.ForeignPtr
                                                      @GHC.Word.Word8
                                                      (GHC.Prim.plusAddr# bx_abn5 1#)
                                                      bx1_abn6)
                                                   (GHC.Types.I# (GHC.Prim.-# ds1_abna 1#)))
                                                cs_abn8);
                                         1# ->
                                           Data.Either.Right
                                             @Data.ByteString.Lazy.Internal.ByteString
                                             @(GHC.Word.Word8,
                                               Data.ByteString.Lazy.Internal.ByteString)
                                             (case GHC.Prim.readWord8OffAddr#
                                                     @GHC.Prim.RealWorld
                                                     bx_abn5
                                                     0#
                                                     GHC.Prim.realWorld#
                                              of
                                              { (# ipv_abnh, ipv1_abni #) ->
                                              case GHC.Prim.touch#
                                                     @'GHC.Types.Lifted
                                                     @GHC.ForeignPtr.ForeignPtrContents
                                                     bx1_abn6
                                                     ipv_abnh
                                              of
                                              { __DEFAULT ->
                                              GHC.Word.W8# ipv1_abni
                                              }
                                              },
                                              cs_abn8)
                                       }
                                   })
                                (let {
                                   f2_abnl
                                     :: Data.ByteString.Lazy.Internal.ByteString
                                        -> f_abmU Data.ByteString.Lazy.Internal.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abnl
                                     = GHC.Base.pure
                                         @f_abmU
                                         $dApplicative_abmW
                                         @Data.ByteString.Lazy.Internal.ByteString } in
                                 let {
                                   ds2_abnm
                                     :: f_abmU
                                          (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                        -> f_abmU Data.ByteString.Lazy.Internal.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 162 0}]
                                   ds2_abnm
                                     = GHC.Base.fmap
                                         @f_abmU
                                         (GHC.Base.$p1Applicative @f_abmU $dApplicative_abmW)
                                         @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                         @Data.ByteString.Lazy.Internal.ByteString
                                         (\ (p1_abnn
                                               :: (GHC.Word.Word8,
                                                   Data.ByteString.Lazy.Internal.ByteString)) ->
                                            case p1_abnn of { (x_abnp, ds_abnq) ->
                                            case x_abnp of { GHC.Word.W8# x#_abnt ->
                                            Data.ByteString.Lazy.Internal.$WChunk
                                              (Data.ByteString.Internal.Type.$WBS
                                                 (GHC.ForeignPtr.ForeignPtr
                                                    @GHC.Word.Word8
                                                    (GHC.Prim.plusAddr#
                                                       Data.ByteString.singleton1
                                                       (GHC.Prim.word2Int#
                                                          (GHC.Prim.word8ToWord# x#_abnt)))
                                                    GHC.ForeignPtr.FinalPtr)
                                                 (GHC.Types.I# 1#))
                                              ds_abnq
                                            }
                                            }) } in
                                 \ (ds3_abnv
                                      :: Data.Either.Either
                                           Data.ByteString.Lazy.Internal.ByteString
                                           (f_abmU
                                              (GHC.Word.Word8,
                                               Data.ByteString.Lazy.Internal.ByteString))) ->
                                   case ds3_abnv of {
                                     Data.Either.Left x_abnx -> f2_abnl x_abnx;
                                     Data.Either.Right y_abnz -> ds2_abnm y_abnz
                                   }) } in
                        let {
                          g_abnB
                            :: p_abmT
                                 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                 (f_abmU (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                               -> p_abmT
                                    (Data.Either.Either
                                       Data.ByteString.Lazy.Internal.ByteString
                                       (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                                    (Data.Either.Either
                                       Data.ByteString.Lazy.Internal.ByteString
                                       (f_abmU
                                          (GHC.Word.Word8,
                                           Data.ByteString.Lazy.Internal.ByteString)))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abnB
                            = Data.Profunctor.Choice.right'
                                @p_abmT
                                $dChoice_abmV
                                @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                @(f_abmU
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                                @Data.ByteString.Lazy.Internal.ByteString } in
                        \ (x_abnC
                             :: p_abmT
                                  (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                  (f_abmU
                                     (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))) ->
                          f1_abmX (g_abnB x_abnC))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <Data.ByteString.Lazy.Internal.ByteString>_N
                                      <Data.ByteString.Lazy.Internal.ByteString>_N
                                      <GHC.Word.Word8>_N
                                      <GHC.Word.Word8>_N)
                             :: Control.Lens.Type.Prism
                                  Data.ByteString.Lazy.Internal.ByteString
                                  Data.ByteString.Lazy.Internal.ByteString
                                  (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                  (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                ~R# Control.Lens.Cons.Cons
                                      Data.ByteString.Lazy.Internal.ByteString
                                      Data.ByteString.Lazy.Internal.ByteString
                                      GHC.Word.Word8
                                      GHC.Word.Word8)
              ValArg (\ (@(p_abnE :: * -> * -> *))
                        (@(f_abnF :: * -> *))
                        ($dChoice_abnG :: Data.Profunctor.Choice.Choice p_abnE)
                        ($dApplicative_abnH :: GHC.Base.Applicative f_abnF) ->
                        let {
                          f1_abnI
                            :: p_abnE
                                 (Data.Either.Either Data.ByteString.Lazy.Internal.ByteString ())
                                 (Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString (f_abnF ()))
                               -> p_abnE
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (f_abnF Data.ByteString.Lazy.Internal.ByteString)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 290 0}]
                          f1_abnI
                            = Data.Profunctor.Unsafe.dimap
                                @p_abnE
                                (Data.Profunctor.Choice.$p1Choice @p_abnE $dChoice_abnG)
                                @Data.ByteString.Lazy.Internal.ByteString
                                @(Data.Either.Either Data.ByteString.Lazy.Internal.ByteString ())
                                @(Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString (f_abnF ()))
                                @(f_abnF Data.ByteString.Lazy.Internal.ByteString)
                                (\ (s_abnJ :: Data.ByteString.Lazy.Internal.ByteString) ->
                                   case s_abnJ of wild_abnK {
                                     Data.ByteString.Lazy.Internal.Empty ->
                                       Data.Either.Right
                                         @Data.ByteString.Lazy.Internal.ByteString
                                         @()
                                         GHC.Tuple.Prim.();
                                     Data.ByteString.Lazy.Internal.Chunk ipv_abnL ipv1_abnM
                                                                         ipv2_abnN ipv3_abnO ->
                                       Data.Either.Left
                                         @Data.ByteString.Lazy.Internal.ByteString @() wild_abnK
                                   })
                                (let {
                                   f2_abnQ
                                     :: Data.ByteString.Lazy.Internal.ByteString
                                        -> f_abnF Data.ByteString.Lazy.Internal.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abnQ
                                     = GHC.Base.pure
                                         @f_abnF
                                         $dApplicative_abnH
                                         @Data.ByteString.Lazy.Internal.ByteString } in
                                 let {
                                   ds2_abnR
                                     :: f_abnF () -> f_abnF Data.ByteString.Lazy.Internal.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 70 0}]
                                   ds2_abnR
                                     = GHC.Base.fmap
                                         @f_abnF
                                         (GHC.Base.$p1Applicative @f_abnF $dApplicative_abnH)
                                         @()
                                         @Data.ByteString.Lazy.Internal.ByteString
                                         (\ (ds3_abnS :: ()) ->
                                            case ds3_abnS of { () ->
                                            Data.ByteString.Lazy.Internal.Empty
                                            }) } in
                                 \ (ds3_abnU
                                      :: Data.Either.Either
                                           Data.ByteString.Lazy.Internal.ByteString (f_abnF ())) ->
                                   case ds3_abnU of {
                                     Data.Either.Left x_abnW -> f2_abnQ x_abnW;
                                     Data.Either.Right y_abnY -> ds2_abnR y_abnY
                                   }) } in
                        let {
                          g_abo0
                            :: p_abnE () (f_abnF ())
                               -> p_abnE
                                    (Data.Either.Either Data.ByteString.Lazy.Internal.ByteString ())
                                    (Data.Either.Either
                                       Data.ByteString.Lazy.Internal.ByteString (f_abnF ()))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abo0
                            = Data.Profunctor.Choice.right'
                                @p_abnE
                                $dChoice_abnG
                                @()
                                @(f_abnF ())
                                @Data.ByteString.Lazy.Internal.ByteString } in
                        \ (x_abo1 :: p_abnE () (f_abnF ())) -> f1_abnI (g_abo0 x_abo1))
                     `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                      <Data.ByteString.Lazy.Internal.ByteString>_N)
                             :: Control.Lens.Type.Prism'
                                  Data.ByteString.Lazy.Internal.ByteString ()
                                ~R# Control.Lens.Empty.AsEmpty
                                      Data.ByteString.Lazy.Internal.ByteString)
              TyArg Data.Functor.Const.Const
                      Data.ByteString.Lazy.Internal.ByteString
              ValArg Data.Functor.Contravariant.$fContravariantConst
                       @Data.ByteString.Lazy.Internal.ByteString
              ValArg Data.Functor.Const.$fFunctorConst
                       @Data.ByteString.Lazy.Internal.ByteString
    After:  (\ (@(f_abfr :: * -> *))
               ($dCons_abfs
                  :: Control.Lens.Cons.Cons
                       Data.ByteString.Internal.Type.ByteString
                       Data.ByteString.Internal.Type.ByteString
                       GHC.Word.Word8
                       GHC.Word.Word8)
               ($dCons1_abft
                  :: Control.Lens.Cons.Cons
                       Data.ByteString.Lazy.Internal.ByteString
                       Data.ByteString.Lazy.Internal.ByteString
                       GHC.Word.Word8
                       GHC.Word.Word8)
               ($dAsEmpty_abfu
                  :: Control.Lens.Empty.AsEmpty
                       Data.ByteString.Lazy.Internal.ByteString)
               ($dContravariant_abfv
                  :: Data.Functor.Contravariant.Contravariant f_abfr)
               ($dFunctor_abfw :: GHC.Base.Functor f_abfr) ->
               Data.Profunctor.Unsafe.$fProfunctorFUN_$cdimap
                 @Data.ByteString.Internal.Type.ByteString
                 @Data.ByteString.Lazy.Internal.ByteString
                 @(f_abfr Data.ByteString.Lazy.Internal.ByteString)
                 @(f_abfr Data.ByteString.Internal.Type.ByteString)
                 Data.ByteString.Lazy.Internal.fromStrict
                 (GHC.Base.fmap
                    @f_abfr
                    $dFunctor_abfw
                    @Data.ByteString.Lazy.Internal.ByteString
                    @Data.ByteString.Internal.Type.ByteString
                    Data.ByteString.Lazy.Internal.toStrict))
              @(Data.Functor.Const.Const
                  Data.ByteString.Lazy.Internal.ByteString)
              ((\ (@(p_abjT :: * -> * -> *))
                  (@(f_abjU :: * -> *))
                  ($dChoice_abjV :: Data.Profunctor.Choice.Choice p_abjT)
                  ($dApplicative_abjW :: GHC.Base.Applicative f_abjU) ->
                  let {
                    f1_abjX
                      :: p_abjT
                           (Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString
                              (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                           (Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString
                              (f_abjU
                                 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                         -> p_abjT
                              Data.ByteString.Internal.Type.ByteString
                              (f_abjU Data.ByteString.Internal.Type.ByteString)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 612 0}]
                    f1_abjX
                      = Data.Profunctor.Unsafe.dimap
                          @p_abjT
                          (Data.Profunctor.Choice.$p1Choice @p_abjT $dChoice_abjV)
                          @Data.ByteString.Internal.Type.ByteString
                          @(Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString
                              (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                          @(Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString
                              (f_abjU
                                 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                          @(f_abjU Data.ByteString.Internal.Type.ByteString)
                          (\ (s1_abjY :: Data.ByteString.Internal.Type.ByteString) ->
                             case s1_abjY of wild_abjZ
                             { Data.ByteString.Internal.Type.BS bx_abk0 bx1_abk1 bx2_abk2 ->
                             case GHC.Classes.leInt (GHC.Types.I# bx2_abk2) (GHC.Types.I# 0#)
                             of {
                               GHC.Types.False ->
                                 Data.Either.Right
                                   @Data.ByteString.Internal.Type.ByteString
                                   @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                   (case GHC.Prim.readWord8OffAddr#
                                           @GHC.Prim.RealWorld bx_abk0 0# GHC.Prim.realWorld#
                                    of
                                    { (# ipv_abk7, ipv1_abk8 #) ->
                                    case GHC.Prim.touch#
                                           @'GHC.Types.Lifted
                                           @GHC.ForeignPtr.ForeignPtrContents
                                           bx1_abk1
                                           ipv_abk7
                                    of
                                    { __DEFAULT ->
                                    GHC.Word.W8# ipv1_abk8
                                    }
                                    },
                                    Data.ByteString.Internal.Type.$WBS
                                      (GHC.ForeignPtr.ForeignPtr
                                         @GHC.Word.Word8 (GHC.Prim.plusAddr# bx_abk0 1#) bx1_abk1)
                                      (GHC.Types.I# (GHC.Prim.-# bx2_abk2 1#)));
                               GHC.Types.True ->
                                 Data.Either.Left
                                   @Data.ByteString.Internal.Type.ByteString
                                   @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                   wild_abjZ
                             }
                             })
                          (let {
                             f2_abkc
                               :: Data.ByteString.Internal.Type.ByteString
                                  -> f_abjU Data.ByteString.Internal.Type.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abkc
                               = GHC.Base.pure
                                   @f_abjU
                                   $dApplicative_abjW
                                   @Data.ByteString.Internal.Type.ByteString } in
                           let {
                             ds2_abkd
                               :: f_abjU
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                  -> f_abjU Data.ByteString.Internal.Type.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 259 0}]
                             ds2_abkd
                               = GHC.Base.fmap
                                   @f_abjU
                                   (GHC.Base.$p1Applicative @f_abjU $dApplicative_abjW)
                                   @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                   @Data.ByteString.Internal.Type.ByteString
                                   (\ (p1_abke
                                         :: (GHC.Word.Word8,
                                             Data.ByteString.Internal.Type.ByteString)) ->
                                      case p1_abke of { (ds_abkg, y_abkh) ->
                                      case y_abkh of
                                      { Data.ByteString.Internal.Type.BS bx_abkt bx1_abku
                                                                         bx2_abkv ->
                                      GHC.Magic.runRW#
                                        @GHC.Types.LiftedRep
                                        @Data.ByteString.Internal.Type.ByteString
                                        (\ (s_abkr [OS=OneShot]
                                              :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                                           let {
                                             x_abks :: GHC.Prim.Int#
                                             [LclId,
                                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                      Value=False, ConLike=False, WorkFree=False,
                                                      Expandable=False,
                                                      Guidance=IF_ARGS [] 1 0}]
                                             x_abks = GHC.Prim.+# bx2_abkv 1# } in
                                           case GHC.Prim.<# x_abks 0# of {
                                             __DEFAULT ->
                                               case GHC.Prim.newPinnedByteArray#
                                                      @GHC.Prim.RealWorld x_abks s_abkr
                                               of
                                               { (# ipv_abkA, ipv1_abkB #) ->
                                               let {
                                                 ipv2_abkz :: GHC.Prim.Addr#
                                                 [LclId,
                                                  Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                          Value=False, ConLike=False,
                                                          WorkFree=False, Expandable=False,
                                                          Guidance=IF_ARGS [] 1 0}]
                                                 ipv2_abkz
                                                   = GHC.Prim.mutableByteArrayContents#
                                                       @GHC.Prim.RealWorld ipv1_abkB } in
                                               let {
                                                 ipv3_abkD :: GHC.ForeignPtr.ForeignPtrContents
                                                 [LclId,
                                                  Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                          Value=True, ConLike=True, WorkFree=True,
                                                          Expandable=True,
                                                          Guidance=IF_ARGS [] 10 10}]
                                                 ipv3_abkD = GHC.ForeignPtr.PlainPtr ipv1_abkB } in
                                               case ds_abkg of { GHC.Word.W8# x1_ablV ->
                                               case GHC.Prim.writeWord8OffAddr#
                                                      @GHC.Prim.RealWorld
                                                      ipv2_abkz
                                                      0#
                                                      x1_ablV
                                                      ipv_abkA
                                               of s2_ablX
                                               { __DEFAULT ->
                                               case GHC.Prim.touch#
                                                      @'GHC.Types.Lifted
                                                      @GHC.ForeignPtr.ForeignPtrContents
                                                      ipv3_abkD
                                                      s2_ablX
                                               of s'_ablY
                                               { __DEFAULT ->
                                               case {__ffi_static_ccall_unsafe base:memcpy :: Addr#
                                          -> Addr#
                                          -> Word64#
                                          -> State# RealWorld
                                          -> (# State# RealWorld, Addr# #)}_ablZ
                                                      (GHC.Prim.plusAddr# ipv2_abkz 1#)
                                                      bx_abkt
                                                      (GHC.Prim.int64ToWord64#
                                                         (GHC.Prim.intToInt64# bx2_abkv))
                                                      s'_ablY
                                               of
                                               { (# ds4_abm1, ds5_abm2 #) ->
                                               case GHC.Prim.touch#
                                                      @'GHC.Types.Lifted
                                                      @GHC.ForeignPtr.ForeignPtrContents
                                                      bx1_abku
                                                      ds4_abm1
                                               of s'1_abm4
                                               { __DEFAULT ->
                                               case GHC.Prim.touch#
                                                      @'GHC.Types.Lifted
                                                      @GHC.ForeignPtr.ForeignPtrContents
                                                      ipv3_abkD
                                                      s'1_abm4
                                               of s'2_abm5
                                               { __DEFAULT ->
                                               case GHC.Magic.lazy
                                                      @((GHC.Prim.State# GHC.Prim.RealWorld
                                                         -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                               GHC.Prim.Addr# #))
                                                        -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                              GHC.Prim.Addr# #))
                                                      (GHC.Magic.runRW#
                                                         @('GHC.Types.TupleRep
                                                             '[GHC.Types.ZeroBitRep,
                                                               'GHC.Types.AddrRep])
                                                         @(# GHC.Prim.State# GHC.Prim.RealWorld,
                                                             GHC.Prim.Addr# #))
                                                      (\ _ [Occ=Dead] -> (# s'2_abm5, ipv2_abkz #))
                                               of
                                               { (# ipv6_abm8, ipv7_abm9 #) ->
                                               Data.ByteString.Internal.Type.BS
                                                 ipv7_abm9 ipv3_abkD x_abks
                                               }
                                               }
                                               }
                                               }
                                               }
                                               }
                                               }
                                               };
                                             1# ->
                                               case GHC.ForeignPtr.mallocPlainForeignPtrBytes2
                                               of wild_00 {
                                               }
                                           })
                                      }
                                      }) } in
                           \ (ds3_abmc
                                :: Data.Either.Either
                                     Data.ByteString.Internal.Type.ByteString
                                     (f_abjU
                                        (GHC.Word.Word8,
                                         Data.ByteString.Internal.Type.ByteString))) ->
                             case ds3_abmc of {
                               Data.Either.Left x_abme -> f2_abkc x_abme;
                               Data.Either.Right y_abmg -> ds2_abkd y_abmg
                             }) } in
                  let {
                    g_abmi
                      :: p_abjT
                           (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                           (f_abjU (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                         -> p_abjT
                              (Data.Either.Either
                                 Data.ByteString.Internal.Type.ByteString
                                 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                              (Data.Either.Either
                                 Data.ByteString.Internal.Type.ByteString
                                 (f_abjU
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abmi
                      = Data.Profunctor.Choice.right'
                          @p_abjT
                          $dChoice_abjV
                          @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                          @(f_abjU
                              (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                          @Data.ByteString.Internal.Type.ByteString } in
                  \ (x_abmj
                       :: p_abjT
                            (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                            (f_abjU
                               (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))) ->
                    f1_abjX (g_abmi x_abmj))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <Data.ByteString.Internal.Type.ByteString>_N
                                <Data.ByteString.Internal.Type.ByteString>_N
                                <GHC.Word.Word8>_N
                                <GHC.Word.Word8>_N)
                       :: Control.Lens.Type.Prism
                            Data.ByteString.Internal.Type.ByteString
                            Data.ByteString.Internal.Type.ByteString
                            (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                            (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                          ~R# Control.Lens.Cons.Cons
                                Data.ByteString.Internal.Type.ByteString
                                Data.ByteString.Internal.Type.ByteString
                                GHC.Word.Word8
                                GHC.Word.Word8))
              ((\ (@(p_abmT :: * -> * -> *))
                  (@(f_abmU :: * -> *))
                  ($dChoice_abmV :: Data.Profunctor.Choice.Choice p_abmT)
                  ($dApplicative_abmW :: GHC.Base.Applicative f_abmU) ->
                  let {
                    f1_abmX
                      :: p_abmT
                           (Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString
                              (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                           (Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString
                              (f_abmU
                                 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                         -> p_abmT
                              Data.ByteString.Lazy.Internal.ByteString
                              (f_abmU Data.ByteString.Lazy.Internal.ByteString)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 536 0}]
                    f1_abmX
                      = Data.Profunctor.Unsafe.dimap
                          @p_abmT
                          (Data.Profunctor.Choice.$p1Choice @p_abmT $dChoice_abmV)
                          @Data.ByteString.Lazy.Internal.ByteString
                          @(Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString
                              (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                          @(Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString
                              (f_abmU
                                 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                          @(f_abmU Data.ByteString.Lazy.Internal.ByteString)
                          (\ (s1_abmY :: Data.ByteString.Lazy.Internal.ByteString) ->
                             case s1_abmY of {
                               Data.ByteString.Lazy.Internal.Empty ->
                                 Data.Either.Left
                                   @Data.ByteString.Lazy.Internal.ByteString
                                   @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                   Data.ByteString.Lazy.Internal.Empty;
                               Data.ByteString.Lazy.Internal.Chunk bx_abn5 bx1_abn6 bx2_abn7
                                                                   cs_abn8 ->
                                 case bx2_abn7 of ds1_abna {
                                   __DEFAULT ->
                                     Data.Either.Right
                                       @Data.ByteString.Lazy.Internal.ByteString
                                       @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                       (case GHC.Prim.readWord8OffAddr#
                                               @GHC.Prim.RealWorld bx_abn5 0# GHC.Prim.realWorld#
                                        of
                                        { (# ipv_abnc, ipv1_abnd #) ->
                                        case GHC.Prim.touch#
                                               @'GHC.Types.Lifted
                                               @GHC.ForeignPtr.ForeignPtrContents
                                               bx1_abn6
                                               ipv_abnc
                                        of
                                        { __DEFAULT ->
                                        GHC.Word.W8# ipv1_abnd
                                        }
                                        },
                                        Data.ByteString.Lazy.Internal.$WChunk
                                          (Data.ByteString.Internal.Type.$WBS
                                             (GHC.ForeignPtr.ForeignPtr
                                                @GHC.Word.Word8
                                                (GHC.Prim.plusAddr# bx_abn5 1#)
                                                bx1_abn6)
                                             (GHC.Types.I# (GHC.Prim.-# ds1_abna 1#)))
                                          cs_abn8);
                                   1# ->
                                     Data.Either.Right
                                       @Data.ByteString.Lazy.Internal.ByteString
                                       @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                       (case GHC.Prim.readWord8OffAddr#
                                               @GHC.Prim.RealWorld bx_abn5 0# GHC.Prim.realWorld#
                                        of
                                        { (# ipv_abnh, ipv1_abni #) ->
                                        case GHC.Prim.touch#
                                               @'GHC.Types.Lifted
                                               @GHC.ForeignPtr.ForeignPtrContents
                                               bx1_abn6
                                               ipv_abnh
                                        of
                                        { __DEFAULT ->
                                        GHC.Word.W8# ipv1_abni
                                        }
                                        },
                                        cs_abn8)
                                 }
                             })
                          (let {
                             f2_abnl
                               :: Data.ByteString.Lazy.Internal.ByteString
                                  -> f_abmU Data.ByteString.Lazy.Internal.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abnl
                               = GHC.Base.pure
                                   @f_abmU
                                   $dApplicative_abmW
                                   @Data.ByteString.Lazy.Internal.ByteString } in
                           let {
                             ds2_abnm
                               :: f_abmU
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                  -> f_abmU Data.ByteString.Lazy.Internal.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 162 0}]
                             ds2_abnm
                               = GHC.Base.fmap
                                   @f_abmU
                                   (GHC.Base.$p1Applicative @f_abmU $dApplicative_abmW)
                                   @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                   @Data.ByteString.Lazy.Internal.ByteString
                                   (\ (p1_abnn
                                         :: (GHC.Word.Word8,
                                             Data.ByteString.Lazy.Internal.ByteString)) ->
                                      case p1_abnn of { (x_abnp, ds_abnq) ->
                                      case x_abnp of { GHC.Word.W8# x#_abnt ->
                                      Data.ByteString.Lazy.Internal.$WChunk
                                        (Data.ByteString.Internal.Type.$WBS
                                           (GHC.ForeignPtr.ForeignPtr
                                              @GHC.Word.Word8
                                              (GHC.Prim.plusAddr#
                                                 Data.ByteString.singleton1
                                                 (GHC.Prim.word2Int#
                                                    (GHC.Prim.word8ToWord# x#_abnt)))
                                              GHC.ForeignPtr.FinalPtr)
                                           (GHC.Types.I# 1#))
                                        ds_abnq
                                      }
                                      }) } in
                           \ (ds3_abnv
                                :: Data.Either.Either
                                     Data.ByteString.Lazy.Internal.ByteString
                                     (f_abmU
                                        (GHC.Word.Word8,
                                         Data.ByteString.Lazy.Internal.ByteString))) ->
                             case ds3_abnv of {
                               Data.Either.Left x_abnx -> f2_abnl x_abnx;
                               Data.Either.Right y_abnz -> ds2_abnm y_abnz
                             }) } in
                  let {
                    g_abnB
                      :: p_abmT
                           (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                           (f_abmU (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                         -> p_abmT
                              (Data.Either.Either
                                 Data.ByteString.Lazy.Internal.ByteString
                                 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                              (Data.Either.Either
                                 Data.ByteString.Lazy.Internal.ByteString
                                 (f_abmU
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abnB
                      = Data.Profunctor.Choice.right'
                          @p_abmT
                          $dChoice_abmV
                          @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                          @(f_abmU
                              (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                          @Data.ByteString.Lazy.Internal.ByteString } in
                  \ (x_abnC
                       :: p_abmT
                            (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                            (f_abmU
                               (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))) ->
                    f1_abmX (g_abnB x_abnC))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <Data.ByteString.Lazy.Internal.ByteString>_N
                                <Data.ByteString.Lazy.Internal.ByteString>_N
                                <GHC.Word.Word8>_N
                                <GHC.Word.Word8>_N)
                       :: Control.Lens.Type.Prism
                            Data.ByteString.Lazy.Internal.ByteString
                            Data.ByteString.Lazy.Internal.ByteString
                            (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                            (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                          ~R# Control.Lens.Cons.Cons
                                Data.ByteString.Lazy.Internal.ByteString
                                Data.ByteString.Lazy.Internal.ByteString
                                GHC.Word.Word8
                                GHC.Word.Word8))
              ((\ (@(p_abnE :: * -> * -> *))
                  (@(f_abnF :: * -> *))
                  ($dChoice_abnG :: Data.Profunctor.Choice.Choice p_abnE)
                  ($dApplicative_abnH :: GHC.Base.Applicative f_abnF) ->
                  let {
                    f1_abnI
                      :: p_abnE
                           (Data.Either.Either Data.ByteString.Lazy.Internal.ByteString ())
                           (Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString (f_abnF ()))
                         -> p_abnE
                              Data.ByteString.Lazy.Internal.ByteString
                              (f_abnF Data.ByteString.Lazy.Internal.ByteString)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 290 0}]
                    f1_abnI
                      = Data.Profunctor.Unsafe.dimap
                          @p_abnE
                          (Data.Profunctor.Choice.$p1Choice @p_abnE $dChoice_abnG)
                          @Data.ByteString.Lazy.Internal.ByteString
                          @(Data.Either.Either Data.ByteString.Lazy.Internal.ByteString ())
                          @(Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString (f_abnF ()))
                          @(f_abnF Data.ByteString.Lazy.Internal.ByteString)
                          (\ (s_abnJ :: Data.ByteString.Lazy.Internal.ByteString) ->
                             case s_abnJ of wild_abnK {
                               Data.ByteString.Lazy.Internal.Empty ->
                                 Data.Either.Right
                                   @Data.ByteString.Lazy.Internal.ByteString @() GHC.Tuple.Prim.();
                               Data.ByteString.Lazy.Internal.Chunk ipv_abnL ipv1_abnM ipv2_abnN
                                                                   ipv3_abnO ->
                                 Data.Either.Left
                                   @Data.ByteString.Lazy.Internal.ByteString @() wild_abnK
                             })
                          (let {
                             f2_abnQ
                               :: Data.ByteString.Lazy.Internal.ByteString
                                  -> f_abnF Data.ByteString.Lazy.Internal.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abnQ
                               = GHC.Base.pure
                                   @f_abnF
                                   $dApplicative_abnH
                                   @Data.ByteString.Lazy.Internal.ByteString } in
                           let {
                             ds2_abnR
                               :: f_abnF () -> f_abnF Data.ByteString.Lazy.Internal.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 70 0}]
                             ds2_abnR
                               = GHC.Base.fmap
                                   @f_abnF
                                   (GHC.Base.$p1Applicative @f_abnF $dApplicative_abnH)
                                   @()
                                   @Data.ByteString.Lazy.Internal.ByteString
                                   (\ (ds3_abnS :: ()) ->
                                      case ds3_abnS of { () ->
                                      Data.ByteString.Lazy.Internal.Empty
                                      }) } in
                           \ (ds3_abnU
                                :: Data.Either.Either
                                     Data.ByteString.Lazy.Internal.ByteString (f_abnF ())) ->
                             case ds3_abnU of {
                               Data.Either.Left x_abnW -> f2_abnQ x_abnW;
                               Data.Either.Right y_abnY -> ds2_abnR y_abnY
                             }) } in
                  let {
                    g_abo0
                      :: p_abnE () (f_abnF ())
                         -> p_abnE
                              (Data.Either.Either Data.ByteString.Lazy.Internal.ByteString ())
                              (Data.Either.Either
                                 Data.ByteString.Lazy.Internal.ByteString (f_abnF ()))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abo0
                      = Data.Profunctor.Choice.right'
                          @p_abnE
                          $dChoice_abnG
                          @()
                          @(f_abnF ())
                          @Data.ByteString.Lazy.Internal.ByteString } in
                  \ (x_abo1 :: p_abnE () (f_abnF ())) -> f1_abnI (g_abo0 x_abo1))
               `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                <Data.ByteString.Lazy.Internal.ByteString>_N)
                       :: Control.Lens.Type.Prism'
                            Data.ByteString.Lazy.Internal.ByteString ()
                          ~R# Control.Lens.Empty.AsEmpty
                                Data.ByteString.Lazy.Internal.ByteString))
              (Data.Functor.Contravariant.$fContravariantConst
                 @Data.ByteString.Lazy.Internal.ByteString)
              (Data.Functor.Const.$fFunctorConst
                 @Data.ByteString.Lazy.Internal.ByteString)
    Cont:   ApplyToVal nodup hole Control.Lens.Getter.Getting
                                    Data.ByteString.Lazy.Internal.ByteString
                                    Data.ByteString.Internal.Type.ByteString
                                    Data.ByteString.Lazy.Internal.ByteString
              ((\ (ds_abe3 [Occ=Once1] :: a_abe0) -> ds_abe3)
               `cast` (<a_abe0>_R
                       %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                          <*>_N <a_abe0>_R <a_abe0>_P)
                       :: (a_abe0 -> a_abe0)
                          ~R# (a_abe0 -> Data.Functor.Const.Const a_abe0 a_abe0)))
            ApplyToVal nodup hole Data.ByteString.Internal.Type.ByteString
                                  -> Data.Functor.Const.Const
                                       Data.ByteString.Lazy.Internal.ByteString
                                       Data.ByteString.Internal.Type.ByteString
              s_a8OH
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N
                        <Data.ByteString.Lazy.Internal.ByteString>_R
                        <Data.ByteString.Internal.Type.ByteString>_P
                    :: Data.Functor.Const.Const
                         Data.ByteString.Lazy.Internal.ByteString
                         Data.ByteString.Internal.Type.ByteString
                       ~R# Data.ByteString.Lazy.Internal.ByteString)
            Stop[RuleArgCtxt] Data.ByteString.Lazy.Internal.ByteString
Rule fired
    Rule: Class op fmap
    Module: (BUILTIN)
    Before: GHC.Base.fmap
              TyArg Data.Functor.Const.Const
                      Data.ByteString.Lazy.Internal.ByteString
              ValArg Data.Functor.Const.$fFunctorConst
                       @Data.ByteString.Lazy.Internal.ByteString
    After:  (Data.Functor.Const.$fFunctorConst2
               @Data.ByteString.Lazy.Internal.ByteString)
            `cast` (forall (a :: <*>_N) (b :: <*>_N).
                    <a -> b>_R
                    %<'GHC.Types.Many>_N ->_R <Data.Functor.Const.Const
                                                 Data.ByteString.Lazy.Internal.ByteString a>_R
                    %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                  <*>_N
                                                  <Data.ByteString.Lazy.Internal.ByteString>_R
                                                  <a>_P
                                              ; Sym (Data.Functor.Const.N:Const[0]
                                                         <*>_N
                                                         <Data.ByteString.Lazy.Internal.ByteString>_R
                                                         <b>_P)
                    :: (forall {a} {b}.
                        (a -> b)
                        -> Data.Functor.Const.Const
                             Data.ByteString.Lazy.Internal.ByteString a
                        -> Data.Functor.Const.Const
                             Data.ByteString.Lazy.Internal.ByteString a)
                       ~R# (forall {a} {b}.
                            (a -> b)
                            -> Data.Functor.Const.Const
                                 Data.ByteString.Lazy.Internal.ByteString a
                            -> Data.Functor.Const.Const
                                 Data.ByteString.Lazy.Internal.ByteString b))
    Cont:   ApplyToTy Data.ByteString.Lazy.Internal.ByteString
            ApplyToTy Data.ByteString.Internal.Type.ByteString
            ApplyToVal nodup hole (Data.ByteString.Lazy.Internal.ByteString
                                   -> Data.ByteString.Internal.Type.ByteString)
                                  -> Data.Functor.Const.Const
                                       Data.ByteString.Lazy.Internal.ByteString
                                       Data.ByteString.Lazy.Internal.ByteString
                                  -> Data.Functor.Const.Const
                                       Data.ByteString.Lazy.Internal.ByteString
                                       Data.ByteString.Internal.Type.ByteString
              Data.ByteString.Lazy.Internal.toStrict
            ApplyToVal nodup hole Data.Functor.Const.Const
                                    Data.ByteString.Lazy.Internal.ByteString
                                    Data.ByteString.Lazy.Internal.ByteString
                                  -> Data.Functor.Const.Const
                                       Data.ByteString.Lazy.Internal.ByteString
                                       Data.ByteString.Internal.Type.ByteString
              (bc_aboj (ab_aboh x_abok))
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N
                        <Data.ByteString.Lazy.Internal.ByteString>_R
                        <Data.ByteString.Internal.Type.ByteString>_P
                    :: Data.Functor.Const.Const
                         Data.ByteString.Lazy.Internal.ByteString
                         Data.ByteString.Internal.Type.ByteString
                       ~R# Data.ByteString.Lazy.Internal.ByteString)
            Stop[RuleArgCtxt] Data.ByteString.Lazy.Internal.ByteString
Rule fired
    Rule: Class op ==
    Module: (BUILTIN)
    Before: GHC.Classes.==
              TyArg Data.ByteString.Internal.Type.ByteString
              ValArg Data.ByteString.Internal.Type.$fEqByteString
              ValArg Data.ByteString.Lazy.Internal.toStrict
                       (case s_a8OH of
                        { Data.ByteString.Internal.Type.BS bx_abrB bx1_abrC bx2_abrD ->
                        case bx2_abrD of ds1_abrF {
                          __DEFAULT ->
                            Data.ByteString.Lazy.Internal.Chunk
                              bx_abrB bx1_abrC ds1_abrF Data.ByteString.Lazy.Internal.Empty;
                          0# -> Data.ByteString.Lazy.Internal.Empty
                        }
                        })
              ValArg s_a8OH
    After:  Data.ByteString.Internal.Type.eq
              ValArg Data.ByteString.Lazy.Internal.toStrict
                       (case s_a8OH of
                        { Data.ByteString.Internal.Type.BS bx_abrB bx1_abrC bx2_abrD ->
                        case bx2_abrD of ds1_abrF {
                          __DEFAULT ->
                            Data.ByteString.Lazy.Internal.Chunk
                              bx_abrB bx1_abrC ds1_abrF Data.ByteString.Lazy.Internal.Empty;
                          0# -> Data.ByteString.Lazy.Internal.Empty
                        }
                        })
              ValArg s_a8OH
    Cont:   Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: unpack
    Module: (GHC.Base)
    Before: GHC.CString.unpackCString# ValArg "[a] -> List a -> [a]"#
    After:  (\ (a_ab6H :: GHC.Prim.Addr#) ->
               GHC.Base.build
                 @GHC.Types.Char
                 (\ (@b_ab6I) -> GHC.CString.unpackFoldrCString# @b_ab6I a_ab6H))
              "[a] -> List a -> [a]"#
    Cont:   Stop[BoringCtxt] Test.Tasty.Core.TestName
Rule fired
    Rule: USPEC $fShowList @Int
    Module: (GHC.Show)
    Before: GHC.Show.$fShowList
              TyArg GHC.Types.Int ValArg GHC.Show.$fShowInt
    After:  (\ ($dShow_ab6w :: GHC.Show.Show GHC.Types.Int) ->
               GHC.Show.$fShowList_$s$fShowList)
              GHC.Show.$fShowInt
    Cont:   Stop[RuleArgCtxt, P(A,L,A)] GHC.Show.Show [GHC.Types.Int]
Rule fired
    Rule: Class op property
    Module: (BUILTIN)
    Before: Test.QuickCheck.Property.property
              TyArg [GHC.Types.Int] -> GHC.Types.Bool
              ValArg Test.QuickCheck.Property.$fTestableFUN
                       @[GHC.Types.Int]
                       @GHC.Types.Bool
                       (Test.QuickCheck.Arbitrary.$fArbitraryList
                          @GHC.Types.Int Test.QuickCheck.Arbitrary.$fArbitraryInt)
                       GHC.Show.$fShowList_$s$fShowList
                       Test.QuickCheck.Property.$fTestableBool
    After:  Test.QuickCheck.Property.$fTestableFUN_$cproperty
              @[GHC.Types.Int]
              @GHC.Types.Bool
              (Test.QuickCheck.Arbitrary.$fArbitraryList
                 @GHC.Types.Int Test.QuickCheck.Arbitrary.$fArbitraryInt)
              GHC.Show.$fShowList_$s$fShowList
              Test.QuickCheck.Property.$fTestableBool
    Cont:   ApplyToVal nodup hole ([GHC.Types.Int] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              prop_ab6U
            CastIt (Sym (Test.Tasty.QuickCheck.N:QC[0])
                    :: Test.QuickCheck.Property.Property ~R# Test.Tasty.QuickCheck.QC)
            Stop[BoringCtxt] Test.Tasty.QuickCheck.QC
Rule fired
    Rule: Class op propertyForAllShrinkShow
    Module: (BUILTIN)
    Before: Test.QuickCheck.Property.propertyForAllShrinkShow
              TyArg GHC.Types.Bool ValArg Test.QuickCheck.Property.$fTestableBool
    After:  Test.QuickCheck.Property.$fTestableBool1
            `cast` (forall (a :: <*>_N).
                    <Test.QuickCheck.Gen.Gen a>_R
                    %<'GHC.Types.Many>_N ->_R <a -> [a]>_R
                    %<'GHC.Types.Many>_N ->_R <a -> [GHC.Base.String]>_R
                    %<'GHC.Types.Many>_N ->_R <a -> GHC.Types.Bool>_R
                    %<'GHC.Types.Many>_N ->_R Sym (Test.QuickCheck.Gen.N:Gen[0]
                                                       (Test.QuickCheck.Property.N:Prop[0]))
                                              ; Sym (Test.QuickCheck.Property.N:Property[0])
                    :: (forall {a}.
                        Test.QuickCheck.Gen.Gen a
                        -> (a -> [a])
                        -> (a -> [GHC.Base.String])
                        -> (a -> GHC.Types.Bool)
                        -> Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int
                        -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result)
                       ~R# (forall {a}.
                            Test.QuickCheck.Gen.Gen a
                            -> (a -> [a])
                            -> (a -> [GHC.Base.String])
                            -> (a -> GHC.Types.Bool)
                            -> Test.QuickCheck.Property.Property))
    Cont:   ApplyToTy [GHC.Types.Int]
            ApplyToVal nodup hole Test.QuickCheck.Gen.Gen [GHC.Types.Int]
                                  -> ([GHC.Types.Int] -> [[GHC.Types.Int]])
                                  -> ([GHC.Types.Int] -> [GHC.Base.String])
                                  -> ([GHC.Types.Int] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (Test.QuickCheck.Arbitrary.arbitrary @a_ab8C $dArbitrary_ab8E)
            ApplyToVal nodup hole ([GHC.Types.Int] -> [[GHC.Types.Int]])
                                  -> ([GHC.Types.Int] -> [GHC.Base.String])
                                  -> ([GHC.Types.Int] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (Test.QuickCheck.Arbitrary.shrink @a_ab8C $dArbitrary_ab8E)
            ApplyToVal nodup hole ([GHC.Types.Int] -> [GHC.Base.String])
                                  -> ([GHC.Types.Int] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (let {
                 g_ab8I [Occ=OnceL1!] :: a_ab8C -> GHC.Base.String
                 [LclId]
                 g_ab8I = GHC.Show.show @a_ab8C $dShow_ab8F } in
               \ (x_ab8J [Occ=Once1] :: a_ab8C) ->
                 GHC.Types.:
                   @GHC.Base.String (g_ab8I x_ab8J) (GHC.Types.[] @GHC.Base.String))
            ApplyToVal nodup hole ([GHC.Types.Int] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              f_ab8H
            CastIt (Sym (Test.Tasty.QuickCheck.N:QC[0])
                    :: Test.QuickCheck.Property.Property ~R# Test.Tasty.QuickCheck.QC)
            Stop[BoringCtxt] Test.Tasty.QuickCheck.QC
Rule fired
    Rule: Class op arbitrary
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.arbitrary
              TyArg [GHC.Types.Int] ValArg $dArbitrary_ab8E
    After:  (Test.QuickCheck.Arbitrary.$fArbitraryList1
               @GHC.Types.Int Test.QuickCheck.Arbitrary.$fArbitraryInt)
            `cast` (Sym (Test.QuickCheck.Gen.N:Gen[0] <[GHC.Types.Int]>_R)
                    :: (Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int -> [GHC.Types.Int])
                       ~R# Test.QuickCheck.Gen.Gen [GHC.Types.Int])
    Cont:   Stop[BoringCtxt] Test.QuickCheck.Gen.Gen [GHC.Types.Int]
Rule fired
    Rule: Class op arbitrary
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.arbitrary
              TyArg GHC.Types.Int ValArg Test.QuickCheck.Arbitrary.$fArbitraryInt
    After:  Test.QuickCheck.Arbitrary.$fArbitraryInt_$sarbitrarySizedIntegral
            `cast` (Sym (Test.QuickCheck.Gen.N:Gen[0] <GHC.Types.Int>_R)
                    :: (Test.QuickCheck.Random.QCGen -> GHC.Types.Int -> GHC.Types.Int)
                       ~R# Test.QuickCheck.Gen.Gen GHC.Types.Int)
    Cont:   Stop[BoringCtxt, C(S,C(1,L))] Test.QuickCheck.Gen.Gen
                                            GHC.Types.Int
Rule fired
    Rule: Class op shrink
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.shrink
              TyArg [GHC.Types.Int] ValArg $dArbitrary_ab8E
    After:  Test.QuickCheck.Arbitrary.$fArbitraryList_$cshrink
              @GHC.Types.Int Test.QuickCheck.Arbitrary.$fArbitraryInt
    Cont:   Stop[BoringCtxt] [GHC.Types.Int] -> [[GHC.Types.Int]]
Rule fired
    Rule: Class op shrink
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.shrink
              TyArg GHC.Types.Int ValArg Test.QuickCheck.Arbitrary.$fArbitraryInt
    After:  Test.QuickCheck.Arbitrary.$fArbitrary1IntMap_$sshrinkIntegral
    Cont:   Stop[DiscArgCtxt, C(S,L)] GHC.Types.Int -> [GHC.Types.Int]
Rule fired
    Rule: Class op show
    Module: (BUILTIN)
    Before: GHC.Show.show
              TyArg [GHC.Types.Int] ValArg GHC.Show.$fShowList_$s$fShowList
    After:  GHC.Show.$fShowList_$s$cshow
    Cont:   Stop[RhsCtxt(NonRecursive)] [GHC.Types.Int]
                                        -> GHC.Base.String
Rule fired
    Rule: Class op reader
    Module: (BUILTIN)
    Before: Control.Monad.Reader.Class.reader
              TyArg Main.List GHC.Types.Int
              TyArg (->) (Main.List GHC.Types.Int)
              ValArg Control.Monad.Reader.Class.$fMonadReaderrFUN
                       @(Main.List GHC.Types.Int)
    After:  \ (@a_abe8) ->
              GHC.Base.id @(Main.List GHC.Types.Int -> a_abe8)
    Cont:   ApplyToTy [GHC.Types.Int]
            ApplyToVal nodup hole (Main.List GHC.Types.Int -> [GHC.Types.Int])
                                  -> Main.List GHC.Types.Int -> [GHC.Types.Int]
              ((l_abe2
                  ((\ (ds_abe3 [Occ=Once1] :: a_abe0) -> ds_abe3)
                   `cast` (<a_abe0>_R
                           %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                              <*>_N <a_abe0>_R <a_abe0>_P)
                           :: (a_abe0 -> a_abe0)
                              ~R# (a_abe0 -> Data.Functor.Const.Const a_abe0 a_abe0))))
               `cast` (<s_abdY>_R
                       %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                     <*>_N <a_abe0>_R <s_abdY>_P
                       :: (s_abdY -> Data.Functor.Const.Const a_abe0 s_abdY)
                          ~R# (s_abdY -> a_abe0)))
            ApplyToVal nodup hole Main.List GHC.Types.Int -> [GHC.Types.Int]
              (Control.Lens.Getter.view
                 @[GHC.Types.Int]
                 @((->) [GHC.Types.Int])
                 @(Main.List GHC.Types.Int)
                 (Control.Monad.Reader.Class.$fMonadReaderrFUN @[GHC.Types.Int])
                 (Control.Lens.Cons.Extras.recons
                    @[GHC.Types.Int]
                    @GHC.Types.Int
                    @(Main.List GHC.Types.Int)
                    (Control.Lens.Cons.$fConsListListab @GHC.Types.Int @GHC.Types.Int)
                    (Main.$fConsListListab @GHC.Types.Int @GHC.Types.Int)
                    (Main.$fAsEmptyList @GHC.Types.Int)
                    @(Data.Functor.Const.Const (Main.List GHC.Types.Int))
                    (Data.Functor.Contravariant.$fContravariantConst
                       @(Main.List GHC.Types.Int))
                    (Data.Functor.Const.$fFunctorConst @(Main.List GHC.Types.Int)))
                 s_a8OI)
            Stop[RuleArgCtxt] [GHC.Types.Int]
Rule fired
    Rule: Class op reader
    Module: (BUILTIN)
    Before: Control.Monad.Reader.Class.reader
              TyArg [GHC.Types.Int]
              TyArg (->) [GHC.Types.Int]
              ValArg Control.Monad.Reader.Class.$fMonadReaderrFUN
                       @[GHC.Types.Int]
    After:  \ (@a_abe8) -> GHC.Base.id @([GHC.Types.Int] -> a_abe8)
    Cont:   ApplyToTy (Main.List GHC.Types.Int)
            ApplyToVal nodup hole ([GHC.Types.Int] -> Main.List GHC.Types.Int)
                                  -> [GHC.Types.Int] -> Main.List GHC.Types.Int
              ((l_abe2
                  ((\ (ds_abe3 [Occ=Once1] :: a_abe0) -> ds_abe3)
                   `cast` (<a_abe0>_R
                           %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                              <*>_N <a_abe0>_R <a_abe0>_P)
                           :: (a_abe0 -> a_abe0)
                              ~R# (a_abe0 -> Data.Functor.Const.Const a_abe0 a_abe0))))
               `cast` (<s_abdY>_R
                       %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                     <*>_N <a_abe0>_R <s_abdY>_P
                       :: (s_abdY -> Data.Functor.Const.Const a_abe0 s_abdY)
                          ~R# (s_abdY -> a_abe0)))
            ApplyToVal nodup hole [GHC.Types.Int] -> Main.List GHC.Types.Int
              s_a8OI
            Stop[RuleArgCtxt] Main.List GHC.Types.Int
Rule fired
    Rule: Class op ==
    Module: (BUILTIN)
    Before: GHC.Classes.==
              TyArg [GHC.Types.Int]
              ValArg GHC.Classes.$fEqList_$s$fEqList
              ValArg (Control.Lens.Cons.Extras.recons
                        @(Main.List GHC.Types.Int)
                        @GHC.Types.Int
                        @[GHC.Types.Int]
                        (($c_Cons_a9ik @GHC.Types.Int @GHC.Types.Int)
                         `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                          <Main.List GHC.Types.Int>_N
                                          <Main.List GHC.Types.Int>_N
                                          <GHC.Types.Int>_N
                                          <GHC.Types.Int>_N)
                                 :: Control.Lens.Type.Prism
                                      (Main.List GHC.Types.Int)
                                      (Main.List GHC.Types.Int)
                                      (GHC.Types.Int, Main.List GHC.Types.Int)
                                      (GHC.Types.Int, Main.List GHC.Types.Int)
                                    ~R# Control.Lens.Cons.Cons
                                          (Main.List GHC.Types.Int)
                                          (Main.List GHC.Types.Int)
                                          GHC.Types.Int
                                          GHC.Types.Int))
                        ((\ (@(p_abfz :: * -> * -> *))
                            (@(f_abfA :: * -> *))
                            ($dChoice_abfB :: Data.Profunctor.Choice.Choice p_abfz)
                            ($dApplicative_abfC :: GHC.Base.Applicative f_abfA) ->
                            let {
                              f1_abfD
                                :: p_abfz
                                     (Data.Either.Either
                                        [GHC.Types.Int] (GHC.Types.Int, [GHC.Types.Int]))
                                     (Data.Either.Either
                                        [GHC.Types.Int] (f_abfA (GHC.Types.Int, [GHC.Types.Int])))
                                   -> p_abfz [GHC.Types.Int] (f_abfA [GHC.Types.Int])
                              [LclId,
                               Unf=Unf{Src=<vanilla>, TopLvl=False,
                                       Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                       Guidance=IF_ARGS [] 320 0}]
                              f1_abfD
                                = Data.Profunctor.Unsafe.dimap
                                    @p_abfz
                                    (Data.Profunctor.Choice.$p1Choice @p_abfz $dChoice_abfB)
                                    @[GHC.Types.Int]
                                    @(Data.Either.Either
                                        [GHC.Types.Int] (GHC.Types.Int, [GHC.Types.Int]))
                                    @(Data.Either.Either
                                        [GHC.Types.Int] (f_abfA (GHC.Types.Int, [GHC.Types.Int])))
                                    @(f_abfA [GHC.Types.Int])
                                    (\ (aas_abfE :: [GHC.Types.Int]) ->
                                       case aas_abfE of {
                                         [] ->
                                           Data.Either.Left
                                             @[GHC.Types.Int]
                                             @(GHC.Types.Int, [GHC.Types.Int])
                                             (GHC.Types.[] @GHC.Types.Int);
                                         : a1_abfG as_abfH ->
                                           Data.Either.Right
                                             @[GHC.Types.Int]
                                             @(GHC.Types.Int, [GHC.Types.Int])
                                             (a1_abfG, as_abfH)
                                       })
                                    (let {
                                       f2_abfJ :: [GHC.Types.Int] -> f_abfA [GHC.Types.Int]
                                       [LclId,
                                        Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                Value=False, ConLike=False, WorkFree=False,
                                                Expandable=True,
                                                Guidance=IF_ARGS [] 20 0}]
                                       f2_abfJ
                                         = GHC.Base.pure
                                             @f_abfA $dApplicative_abfC @[GHC.Types.Int] } in
                                     let {
                                       ds2_abfK
                                         :: f_abfA (GHC.Types.Int, [GHC.Types.Int])
                                            -> f_abfA [GHC.Types.Int]
                                       [LclId,
                                        Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                Value=False, ConLike=False, WorkFree=False,
                                                Expandable=False,
                                                Guidance=IF_ARGS [] 90 0}]
                                       ds2_abfK
                                         = GHC.Base.fmap
                                             @f_abfA
                                             (GHC.Base.$p1Applicative @f_abfA $dApplicative_abfC)
                                             @(GHC.Types.Int, [GHC.Types.Int])
                                             @[GHC.Types.Int]
                                             (\ (p1_abfL :: (GHC.Types.Int, [GHC.Types.Int])) ->
                                                GHC.Types.:
                                                  @GHC.Types.Int
                                                  (case p1_abfL of { (x_abfN, ds_abfO) -> x_abfN })
                                                  (case p1_abfL of { (ds_abfR, y_abfS) ->
                                                   y_abfS
                                                   })) } in
                                     \ (ds3_abfU
                                          :: Data.Either.Either
                                               [GHC.Types.Int]
                                               (f_abfA (GHC.Types.Int, [GHC.Types.Int]))) ->
                                       case ds3_abfU of {
                                         Data.Either.Left x_abfW -> f2_abfJ x_abfW;
                                         Data.Either.Right y_abfY -> ds2_abfK y_abfY
                                       }) } in
                            let {
                              g_abg0
                                :: p_abfz
                                     (GHC.Types.Int, [GHC.Types.Int])
                                     (f_abfA (GHC.Types.Int, [GHC.Types.Int]))
                                   -> p_abfz
                                        (Data.Either.Either
                                           [GHC.Types.Int] (GHC.Types.Int, [GHC.Types.Int]))
                                        (Data.Either.Either
                                           [GHC.Types.Int]
                                           (f_abfA (GHC.Types.Int, [GHC.Types.Int])))
                              [LclId,
                               Unf=Unf{Src=<vanilla>, TopLvl=False,
                                       Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                       Guidance=IF_ARGS [] 20 0}]
                              g_abg0
                                = Data.Profunctor.Choice.right'
                                    @p_abfz
                                    $dChoice_abfB
                                    @(GHC.Types.Int, [GHC.Types.Int])
                                    @(f_abfA (GHC.Types.Int, [GHC.Types.Int]))
                                    @[GHC.Types.Int] } in
                            \ (x_abg1
                                 :: p_abfz
                                      (GHC.Types.Int, [GHC.Types.Int])
                                      (f_abfA (GHC.Types.Int, [GHC.Types.Int]))) ->
                              f1_abfD (g_abg0 x_abg1))
                         `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                          <[GHC.Types.Int]>_N
                                          <[GHC.Types.Int]>_N
                                          <GHC.Types.Int>_N
                                          <GHC.Types.Int>_N)
                                 :: Control.Lens.Type.Prism
                                      [GHC.Types.Int]
                                      [GHC.Types.Int]
                                      (GHC.Types.Int, [GHC.Types.Int])
                                      (GHC.Types.Int, [GHC.Types.Int])
                                    ~R# Control.Lens.Cons.Cons
                                          [GHC.Types.Int]
                                          [GHC.Types.Int]
                                          GHC.Types.Int
                                          GHC.Types.Int))
                        ((\ (@(p_abg6 :: * -> * -> *))
                            (@(f_abg7 :: * -> *))
                            ($dChoice_abg8 :: Data.Profunctor.Choice.Choice p_abg6)
                            ($dApplicative_abg9 :: GHC.Base.Applicative f_abg7) ->
                            let {
                              f1_abga
                                :: p_abg6
                                     (Data.Either.Either [GHC.Types.Int] ())
                                     (Data.Either.Either [GHC.Types.Int] (f_abg7 ()))
                                   -> p_abg6 [GHC.Types.Int] (f_abg7 [GHC.Types.Int])
                              [LclId,
                               Unf=Unf{Src=<vanilla>, TopLvl=False,
                                       Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                       Guidance=IF_ARGS [] 290 0}]
                              f1_abga
                                = Data.Profunctor.Unsafe.dimap
                                    @p_abg6
                                    (Data.Profunctor.Choice.$p1Choice @p_abg6 $dChoice_abg8)
                                    @[GHC.Types.Int]
                                    @(Data.Either.Either [GHC.Types.Int] ())
                                    @(Data.Either.Either [GHC.Types.Int] (f_abg7 ()))
                                    @(f_abg7 [GHC.Types.Int])
                                    (\ (s_abgb :: [GHC.Types.Int]) ->
                                       case s_abgb of wild_abgc {
                                         [] ->
                                           Data.Either.Right @[GHC.Types.Int] @() GHC.Tuple.Prim.();
                                         : ds1_abgd ds2_abge ->
                                           Data.Either.Left @[GHC.Types.Int] @() wild_abgc
                                       })
                                    (let {
                                       f2_abgg :: [GHC.Types.Int] -> f_abg7 [GHC.Types.Int]
                                       [LclId,
                                        Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                Value=False, ConLike=False, WorkFree=False,
                                                Expandable=True,
                                                Guidance=IF_ARGS [] 20 0}]
                                       f2_abgg
                                         = GHC.Base.pure
                                             @f_abg7 $dApplicative_abg9 @[GHC.Types.Int] } in
                                     let {
                                       ds2_abgh :: f_abg7 () -> f_abg7 [GHC.Types.Int]
                                       [LclId,
                                        Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                Value=False, ConLike=False, WorkFree=False,
                                                Expandable=False,
                                                Guidance=IF_ARGS [] 70 0}]
                                       ds2_abgh
                                         = GHC.Base.fmap
                                             @f_abg7
                                             (GHC.Base.$p1Applicative @f_abg7 $dApplicative_abg9)
                                             @()
                                             @[GHC.Types.Int]
                                             (\ (ds3_abgi :: ()) ->
                                                case ds3_abgi of { () ->
                                                GHC.Types.[] @GHC.Types.Int
                                                }) } in
                                     \ (ds3_abgk
                                          :: Data.Either.Either [GHC.Types.Int] (f_abg7 ())) ->
                                       case ds3_abgk of {
                                         Data.Either.Left x_abgm -> f2_abgg x_abgm;
                                         Data.Either.Right y_abgo -> ds2_abgh y_abgo
                                       }) } in
                            let {
                              g_abgq
                                :: p_abg6 () (f_abg7 ())
                                   -> p_abg6
                                        (Data.Either.Either [GHC.Types.Int] ())
                                        (Data.Either.Either [GHC.Types.Int] (f_abg7 ()))
                              [LclId,
                               Unf=Unf{Src=<vanilla>, TopLvl=False,
                                       Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                       Guidance=IF_ARGS [] 20 0}]
                              g_abgq
                                = Data.Profunctor.Choice.right'
                                    @p_abg6 $dChoice_abg8 @() @(f_abg7 ()) @[GHC.Types.Int] } in
                            \ (x_abgr :: p_abg6 () (f_abg7 ())) -> f1_abga (g_abgq x_abgr))
                         `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0] <[GHC.Types.Int]>_N)
                                 :: Control.Lens.Type.Prism' [GHC.Types.Int] ()
                                    ~R# Control.Lens.Empty.AsEmpty [GHC.Types.Int]))
                        @(Data.Functor.Const.Const [GHC.Types.Int])
                        (Data.Functor.Contravariant.$fContravariantConst @[GHC.Types.Int])
                        (Data.Functor.Const.$fFunctorConst @[GHC.Types.Int])
                        ((\ (ds_abe3 :: [GHC.Types.Int]) -> ds_abe3)
                         `cast` (<[GHC.Types.Int]>_R
                                 %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                                    <*>_N
                                                                    <[GHC.Types.Int]>_R
                                                                    <[GHC.Types.Int]>_P)
                                 :: ([GHC.Types.Int] -> [GHC.Types.Int])
                                    ~R# ([GHC.Types.Int]
                                         -> Data.Functor.Const.Const
                                              [GHC.Types.Int] [GHC.Types.Int])))
                        ((Control.Lens.Cons.Extras.recons
                            @[GHC.Types.Int]
                            @GHC.Types.Int
                            @(Main.List GHC.Types.Int)
                            ((\ (@(p_abfz :: * -> * -> *))
                                (@(f_abfA :: * -> *))
                                ($dChoice_abfB :: Data.Profunctor.Choice.Choice p_abfz)
                                ($dApplicative_abfC :: GHC.Base.Applicative f_abfA) ->
                                let {
                                  f1_abfD
                                    :: p_abfz
                                         (Data.Either.Either
                                            [GHC.Types.Int] (GHC.Types.Int, [GHC.Types.Int]))
                                         (Data.Either.Either
                                            [GHC.Types.Int]
                                            (f_abfA (GHC.Types.Int, [GHC.Types.Int])))
                                       -> p_abfz [GHC.Types.Int] (f_abfA [GHC.Types.Int])
                                  [LclId,
                                   Unf=Unf{Src=<vanilla>, TopLvl=False,
                                           Value=False, ConLike=False, WorkFree=False,
                                           Expandable=False,
                                           Guidance=IF_ARGS [] 320 0}]
                                  f1_abfD
                                    = Data.Profunctor.Unsafe.dimap
                                        @p_abfz
                                        (Data.Profunctor.Choice.$p1Choice @p_abfz $dChoice_abfB)
                                        @[GHC.Types.Int]
                                        @(Data.Either.Either
                                            [GHC.Types.Int] (GHC.Types.Int, [GHC.Types.Int]))
                                        @(Data.Either.Either
                                            [GHC.Types.Int]
                                            (f_abfA (GHC.Types.Int, [GHC.Types.Int])))
                                        @(f_abfA [GHC.Types.Int])
                                        (\ (aas_abfE :: [GHC.Types.Int]) ->
                                           case aas_abfE of {
                                             [] ->
                                               Data.Either.Left
                                                 @[GHC.Types.Int]
                                                 @(GHC.Types.Int, [GHC.Types.Int])
                                                 (GHC.Types.[] @GHC.Types.Int);
                                             : a1_abfG as_abfH ->
                                               Data.Either.Right
                                                 @[GHC.Types.Int]
                                                 @(GHC.Types.Int, [GHC.Types.Int])
                                                 (a1_abfG, as_abfH)
                                           })
                                        (let {
                                           f2_abfJ :: [GHC.Types.Int] -> f_abfA [GHC.Types.Int]
                                           [LclId,
                                            Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                    Value=False, ConLike=False, WorkFree=False,
                                                    Expandable=True,
                                                    Guidance=IF_ARGS [] 20 0}]
                                           f2_abfJ
                                             = GHC.Base.pure
                                                 @f_abfA $dApplicative_abfC @[GHC.Types.Int] } in
                                         let {
                                           ds2_abfK
                                             :: f_abfA (GHC.Types.Int, [GHC.Types.Int])
                                                -> f_abfA [GHC.Types.Int]
                                           [LclId,
                                            Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                    Value=False, ConLike=False, WorkFree=False,
                                                    Expandable=False,
                                                    Guidance=IF_ARGS [] 90 0}]
                                           ds2_abfK
                                             = GHC.Base.fmap
                                                 @f_abfA
                                                 (GHC.Base.$p1Applicative
                                                    @f_abfA $dApplicative_abfC)
                                                 @(GHC.Types.Int, [GHC.Types.Int])
                                                 @[GHC.Types.Int]
                                                 (\ (p1_abfL :: (GHC.Types.Int, [GHC.Types.Int])) ->
                                                    GHC.Types.:
                                                      @GHC.Types.Int
                                                      (case p1_abfL of { (x_abfN, ds_abfO) ->
                                                       x_abfN
                                                       })
                                                      (case p1_abfL of { (ds_abfR, y_abfS) ->
                                                       y_abfS
                                                       })) } in
                                         \ (ds3_abfU
                                              :: Data.Either.Either
                                                   [GHC.Types.Int]
                                                   (f_abfA (GHC.Types.Int, [GHC.Types.Int]))) ->
                                           case ds3_abfU of {
                                             Data.Either.Left x_abfW -> f2_abfJ x_abfW;
                                             Data.Either.Right y_abfY -> ds2_abfK y_abfY
                                           }) } in
                                let {
                                  g_abg0
                                    :: p_abfz
                                         (GHC.Types.Int, [GHC.Types.Int])
                                         (f_abfA (GHC.Types.Int, [GHC.Types.Int]))
                                       -> p_abfz
                                            (Data.Either.Either
                                               [GHC.Types.Int] (GHC.Types.Int, [GHC.Types.Int]))
                                            (Data.Either.Either
                                               [GHC.Types.Int]
                                               (f_abfA (GHC.Types.Int, [GHC.Types.Int])))
                                  [LclId,
                                   Unf=Unf{Src=<vanilla>, TopLvl=False,
                                           Value=False, ConLike=False, WorkFree=False,
                                           Expandable=True,
                                           Guidance=IF_ARGS [] 20 0}]
                                  g_abg0
                                    = Data.Profunctor.Choice.right'
                                        @p_abfz
                                        $dChoice_abfB
                                        @(GHC.Types.Int, [GHC.Types.Int])
                                        @(f_abfA (GHC.Types.Int, [GHC.Types.Int]))
                                        @[GHC.Types.Int] } in
                                \ (x_abg1
                                     :: p_abfz
                                          (GHC.Types.Int, [GHC.Types.Int])
                                          (f_abfA (GHC.Types.Int, [GHC.Types.Int]))) ->
                                  f1_abfD (g_abg0 x_abg1))
                             `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                              <[GHC.Types.Int]>_N
                                              <[GHC.Types.Int]>_N
                                              <GHC.Types.Int>_N
                                              <GHC.Types.Int>_N)
                                     :: Control.Lens.Type.Prism
                                          [GHC.Types.Int]
                                          [GHC.Types.Int]
                                          (GHC.Types.Int, [GHC.Types.Int])
                                          (GHC.Types.Int, [GHC.Types.Int])
                                        ~R# Control.Lens.Cons.Cons
                                              [GHC.Types.Int]
                                              [GHC.Types.Int]
                                              GHC.Types.Int
                                              GHC.Types.Int))
                            (($c_Cons_a9ik @GHC.Types.Int @GHC.Types.Int)
                             `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                              <Main.List GHC.Types.Int>_N
                                              <Main.List GHC.Types.Int>_N
                                              <GHC.Types.Int>_N
                                              <GHC.Types.Int>_N)
                                     :: Control.Lens.Type.Prism
                                          (Main.List GHC.Types.Int)
                                          (Main.List GHC.Types.Int)
                                          (GHC.Types.Int, Main.List GHC.Types.Int)
                                          (GHC.Types.Int, Main.List GHC.Types.Int)
                                        ~R# Control.Lens.Cons.Cons
                                              (Main.List GHC.Types.Int)
                                              (Main.List GHC.Types.Int)
                                              GHC.Types.Int
                                              GHC.Types.Int))
                            (($c_Empty_a9nj @GHC.Types.Int)
                             `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                              <Main.List GHC.Types.Int>_N)
                                     :: Control.Lens.Type.Prism' (Main.List GHC.Types.Int) ()
                                        ~R# Control.Lens.Empty.AsEmpty (Main.List GHC.Types.Int)))
                            @(Data.Functor.Const.Const (Main.List GHC.Types.Int))
                            (Data.Functor.Contravariant.$fContravariantConst
                               @(Main.List GHC.Types.Int))
                            (Data.Functor.Const.$fFunctorConst @(Main.List GHC.Types.Int))
                            ((\ (ds_abe3 :: Main.List GHC.Types.Int) -> ds_abe3)
                             `cast` (<Main.List GHC.Types.Int>_R
                                     %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                                        <*>_N
                                                                        <Main.List GHC.Types.Int>_R
                                                                        <Main.List GHC.Types.Int>_P)
                                     :: (Main.List GHC.Types.Int -> Main.List GHC.Types.Int)
                                        ~R# (Main.List GHC.Types.Int
                                             -> Data.Functor.Const.Const
                                                  (Main.List GHC.Types.Int)
                                                  (Main.List GHC.Types.Int))))
                            s_a8OI)
                         `cast` (Data.Functor.Const.N:Const[0]
                                     <*>_N <Main.List GHC.Types.Int>_R <[GHC.Types.Int]>_P
                                 :: Data.Functor.Const.Const
                                      (Main.List GHC.Types.Int) [GHC.Types.Int]
                                    ~R# Main.List GHC.Types.Int)))
                     `cast` (Data.Functor.Const.N:Const[0]
                                 <*>_N <[GHC.Types.Int]>_R <Main.List GHC.Types.Int>_P
                             :: Data.Functor.Const.Const
                                  [GHC.Types.Int] (Main.List GHC.Types.Int)
                                ~R# [GHC.Types.Int])
              ValArg s_a8OI
    After:  GHC.Classes.$fEqList_$s$c==
              ValArg (Control.Lens.Cons.Extras.recons
                        @(Main.List GHC.Types.Int)
                        @GHC.Types.Int
                        @[GHC.Types.Int]
                        (($c_Cons_a9ik @GHC.Types.Int @GHC.Types.Int)
                         `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                          <Main.List GHC.Types.Int>_N
                                          <Main.List GHC.Types.Int>_N
                                          <GHC.Types.Int>_N
                                          <GHC.Types.Int>_N)
                                 :: Control.Lens.Type.Prism
                                      (Main.List GHC.Types.Int)
                                      (Main.List GHC.Types.Int)
                                      (GHC.Types.Int, Main.List GHC.Types.Int)
                                      (GHC.Types.Int, Main.List GHC.Types.Int)
                                    ~R# Control.Lens.Cons.Cons
                                          (Main.List GHC.Types.Int)
                                          (Main.List GHC.Types.Int)
                                          GHC.Types.Int
                                          GHC.Types.Int))
                        ((\ (@(p_abfz :: * -> * -> *))
                            (@(f_abfA :: * -> *))
                            ($dChoice_abfB :: Data.Profunctor.Choice.Choice p_abfz)
                            ($dApplicative_abfC :: GHC.Base.Applicative f_abfA) ->
                            let {
                              f1_abfD
                                :: p_abfz
                                     (Data.Either.Either
                                        [GHC.Types.Int] (GHC.Types.Int, [GHC.Types.Int]))
                                     (Data.Either.Either
                                        [GHC.Types.Int] (f_abfA (GHC.Types.Int, [GHC.Types.Int])))
                                   -> p_abfz [GHC.Types.Int] (f_abfA [GHC.Types.Int])
                              [LclId,
                               Unf=Unf{Src=<vanilla>, TopLvl=False,
                                       Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                       Guidance=IF_ARGS [] 320 0}]
                              f1_abfD
                                = Data.Profunctor.Unsafe.dimap
                                    @p_abfz
                                    (Data.Profunctor.Choice.$p1Choice @p_abfz $dChoice_abfB)
                                    @[GHC.Types.Int]
                                    @(Data.Either.Either
                                        [GHC.Types.Int] (GHC.Types.Int, [GHC.Types.Int]))
                                    @(Data.Either.Either
                                        [GHC.Types.Int] (f_abfA (GHC.Types.Int, [GHC.Types.Int])))
                                    @(f_abfA [GHC.Types.Int])
                                    (\ (aas_abfE :: [GHC.Types.Int]) ->
                                       case aas_abfE of {
                                         [] ->
                                           Data.Either.Left
                                             @[GHC.Types.Int]
                                             @(GHC.Types.Int, [GHC.Types.Int])
                                             (GHC.Types.[] @GHC.Types.Int);
                                         : a1_abfG as_abfH ->
                                           Data.Either.Right
                                             @[GHC.Types.Int]
                                             @(GHC.Types.Int, [GHC.Types.Int])
                                             (a1_abfG, as_abfH)
                                       })
                                    (let {
                                       f2_abfJ :: [GHC.Types.Int] -> f_abfA [GHC.Types.Int]
                                       [LclId,
                                        Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                Value=False, ConLike=False, WorkFree=False,
                                                Expandable=True,
                                                Guidance=IF_ARGS [] 20 0}]
                                       f2_abfJ
                                         = GHC.Base.pure
                                             @f_abfA $dApplicative_abfC @[GHC.Types.Int] } in
                                     let {
                                       ds2_abfK
                                         :: f_abfA (GHC.Types.Int, [GHC.Types.Int])
                                            -> f_abfA [GHC.Types.Int]
                                       [LclId,
                                        Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                Value=False, ConLike=False, WorkFree=False,
                                                Expandable=False,
                                                Guidance=IF_ARGS [] 90 0}]
                                       ds2_abfK
                                         = GHC.Base.fmap
                                             @f_abfA
                                             (GHC.Base.$p1Applicative @f_abfA $dApplicative_abfC)
                                             @(GHC.Types.Int, [GHC.Types.Int])
                                             @[GHC.Types.Int]
                                             (\ (p1_abfL :: (GHC.Types.Int, [GHC.Types.Int])) ->
                                                GHC.Types.:
                                                  @GHC.Types.Int
                                                  (case p1_abfL of { (x_abfN, ds_abfO) -> x_abfN })
                                                  (case p1_abfL of { (ds_abfR, y_abfS) ->
                                                   y_abfS
                                                   })) } in
                                     \ (ds3_abfU
                                          :: Data.Either.Either
                                               [GHC.Types.Int]
                                               (f_abfA (GHC.Types.Int, [GHC.Types.Int]))) ->
                                       case ds3_abfU of {
                                         Data.Either.Left x_abfW -> f2_abfJ x_abfW;
                                         Data.Either.Right y_abfY -> ds2_abfK y_abfY
                                       }) } in
                            let {
                              g_abg0
                                :: p_abfz
                                     (GHC.Types.Int, [GHC.Types.Int])
                                     (f_abfA (GHC.Types.Int, [GHC.Types.Int]))
                                   -> p_abfz
                                        (Data.Either.Either
                                           [GHC.Types.Int] (GHC.Types.Int, [GHC.Types.Int]))
                                        (Data.Either.Either
                                           [GHC.Types.Int]
                                           (f_abfA (GHC.Types.Int, [GHC.Types.Int])))
                              [LclId,
                               Unf=Unf{Src=<vanilla>, TopLvl=False,
                                       Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                       Guidance=IF_ARGS [] 20 0}]
                              g_abg0
                                = Data.Profunctor.Choice.right'
                                    @p_abfz
                                    $dChoice_abfB
                                    @(GHC.Types.Int, [GHC.Types.Int])
                                    @(f_abfA (GHC.Types.Int, [GHC.Types.Int]))
                                    @[GHC.Types.Int] } in
                            \ (x_abg1
                                 :: p_abfz
                                      (GHC.Types.Int, [GHC.Types.Int])
                                      (f_abfA (GHC.Types.Int, [GHC.Types.Int]))) ->
                              f1_abfD (g_abg0 x_abg1))
                         `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                          <[GHC.Types.Int]>_N
                                          <[GHC.Types.Int]>_N
                                          <GHC.Types.Int>_N
                                          <GHC.Types.Int>_N)
                                 :: Control.Lens.Type.Prism
                                      [GHC.Types.Int]
                                      [GHC.Types.Int]
                                      (GHC.Types.Int, [GHC.Types.Int])
                                      (GHC.Types.Int, [GHC.Types.Int])
                                    ~R# Control.Lens.Cons.Cons
                                          [GHC.Types.Int]
                                          [GHC.Types.Int]
                                          GHC.Types.Int
                                          GHC.Types.Int))
                        ((\ (@(p_abg6 :: * -> * -> *))
                            (@(f_abg7 :: * -> *))
                            ($dChoice_abg8 :: Data.Profunctor.Choice.Choice p_abg6)
                            ($dApplicative_abg9 :: GHC.Base.Applicative f_abg7) ->
                            let {
                              f1_abga
                                :: p_abg6
                                     (Data.Either.Either [GHC.Types.Int] ())
                                     (Data.Either.Either [GHC.Types.Int] (f_abg7 ()))
                                   -> p_abg6 [GHC.Types.Int] (f_abg7 [GHC.Types.Int])
                              [LclId,
                               Unf=Unf{Src=<vanilla>, TopLvl=False,
                                       Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                       Guidance=IF_ARGS [] 290 0}]
                              f1_abga
                                = Data.Profunctor.Unsafe.dimap
                                    @p_abg6
                                    (Data.Profunctor.Choice.$p1Choice @p_abg6 $dChoice_abg8)
                                    @[GHC.Types.Int]
                                    @(Data.Either.Either [GHC.Types.Int] ())
                                    @(Data.Either.Either [GHC.Types.Int] (f_abg7 ()))
                                    @(f_abg7 [GHC.Types.Int])
                                    (\ (s_abgb :: [GHC.Types.Int]) ->
                                       case s_abgb of wild_abgc {
                                         [] ->
                                           Data.Either.Right @[GHC.Types.Int] @() GHC.Tuple.Prim.();
                                         : ds1_abgd ds2_abge ->
                                           Data.Either.Left @[GHC.Types.Int] @() wild_abgc
                                       })
                                    (let {
                                       f2_abgg :: [GHC.Types.Int] -> f_abg7 [GHC.Types.Int]
                                       [LclId,
                                        Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                Value=False, ConLike=False, WorkFree=False,
                                                Expandable=True,
                                                Guidance=IF_ARGS [] 20 0}]
                                       f2_abgg
                                         = GHC.Base.pure
                                             @f_abg7 $dApplicative_abg9 @[GHC.Types.Int] } in
                                     let {
                                       ds2_abgh :: f_abg7 () -> f_abg7 [GHC.Types.Int]
                                       [LclId,
                                        Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                Value=False, ConLike=False, WorkFree=False,
                                                Expandable=False,
                                                Guidance=IF_ARGS [] 70 0}]
                                       ds2_abgh
                                         = GHC.Base.fmap
                                             @f_abg7
                                             (GHC.Base.$p1Applicative @f_abg7 $dApplicative_abg9)
                                             @()
                                             @[GHC.Types.Int]
                                             (\ (ds3_abgi :: ()) ->
                                                case ds3_abgi of { () ->
                                                GHC.Types.[] @GHC.Types.Int
                                                }) } in
                                     \ (ds3_abgk
                                          :: Data.Either.Either [GHC.Types.Int] (f_abg7 ())) ->
                                       case ds3_abgk of {
                                         Data.Either.Left x_abgm -> f2_abgg x_abgm;
                                         Data.Either.Right y_abgo -> ds2_abgh y_abgo
                                       }) } in
                            let {
                              g_abgq
                                :: p_abg6 () (f_abg7 ())
                                   -> p_abg6
                                        (Data.Either.Either [GHC.Types.Int] ())
                                        (Data.Either.Either [GHC.Types.Int] (f_abg7 ()))
                              [LclId,
                               Unf=Unf{Src=<vanilla>, TopLvl=False,
                                       Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                       Guidance=IF_ARGS [] 20 0}]
                              g_abgq
                                = Data.Profunctor.Choice.right'
                                    @p_abg6 $dChoice_abg8 @() @(f_abg7 ()) @[GHC.Types.Int] } in
                            \ (x_abgr :: p_abg6 () (f_abg7 ())) -> f1_abga (g_abgq x_abgr))
                         `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0] <[GHC.Types.Int]>_N)
                                 :: Control.Lens.Type.Prism' [GHC.Types.Int] ()
                                    ~R# Control.Lens.Empty.AsEmpty [GHC.Types.Int]))
                        @(Data.Functor.Const.Const [GHC.Types.Int])
                        (Data.Functor.Contravariant.$fContravariantConst @[GHC.Types.Int])
                        (Data.Functor.Const.$fFunctorConst @[GHC.Types.Int])
                        ((\ (ds_abe3 :: [GHC.Types.Int]) -> ds_abe3)
                         `cast` (<[GHC.Types.Int]>_R
                                 %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                                    <*>_N
                                                                    <[GHC.Types.Int]>_R
                                                                    <[GHC.Types.Int]>_P)
                                 :: ([GHC.Types.Int] -> [GHC.Types.Int])
                                    ~R# ([GHC.Types.Int]
                                         -> Data.Functor.Const.Const
                                              [GHC.Types.Int] [GHC.Types.Int])))
                        ((Control.Lens.Cons.Extras.recons
                            @[GHC.Types.Int]
                            @GHC.Types.Int
                            @(Main.List GHC.Types.Int)
                            ((\ (@(p_abfz :: * -> * -> *))
                                (@(f_abfA :: * -> *))
                                ($dChoice_abfB :: Data.Profunctor.Choice.Choice p_abfz)
                                ($dApplicative_abfC :: GHC.Base.Applicative f_abfA) ->
                                let {
                                  f1_abfD
                                    :: p_abfz
                                         (Data.Either.Either
                                            [GHC.Types.Int] (GHC.Types.Int, [GHC.Types.Int]))
                                         (Data.Either.Either
                                            [GHC.Types.Int]
                                            (f_abfA (GHC.Types.Int, [GHC.Types.Int])))
                                       -> p_abfz [GHC.Types.Int] (f_abfA [GHC.Types.Int])
                                  [LclId,
                                   Unf=Unf{Src=<vanilla>, TopLvl=False,
                                           Value=False, ConLike=False, WorkFree=False,
                                           Expandable=False,
                                           Guidance=IF_ARGS [] 320 0}]
                                  f1_abfD
                                    = Data.Profunctor.Unsafe.dimap
                                        @p_abfz
                                        (Data.Profunctor.Choice.$p1Choice @p_abfz $dChoice_abfB)
                                        @[GHC.Types.Int]
                                        @(Data.Either.Either
                                            [GHC.Types.Int] (GHC.Types.Int, [GHC.Types.Int]))
                                        @(Data.Either.Either
                                            [GHC.Types.Int]
                                            (f_abfA (GHC.Types.Int, [GHC.Types.Int])))
                                        @(f_abfA [GHC.Types.Int])
                                        (\ (aas_abfE :: [GHC.Types.Int]) ->
                                           case aas_abfE of {
                                             [] ->
                                               Data.Either.Left
                                                 @[GHC.Types.Int]
                                                 @(GHC.Types.Int, [GHC.Types.Int])
                                                 (GHC.Types.[] @GHC.Types.Int);
                                             : a1_abfG as_abfH ->
                                               Data.Either.Right
                                                 @[GHC.Types.Int]
                                                 @(GHC.Types.Int, [GHC.Types.Int])
                                                 (a1_abfG, as_abfH)
                                           })
                                        (let {
                                           f2_abfJ :: [GHC.Types.Int] -> f_abfA [GHC.Types.Int]
                                           [LclId,
                                            Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                    Value=False, ConLike=False, WorkFree=False,
                                                    Expandable=True,
                                                    Guidance=IF_ARGS [] 20 0}]
                                           f2_abfJ
                                             = GHC.Base.pure
                                                 @f_abfA $dApplicative_abfC @[GHC.Types.Int] } in
                                         let {
                                           ds2_abfK
                                             :: f_abfA (GHC.Types.Int, [GHC.Types.Int])
                                                -> f_abfA [GHC.Types.Int]
                                           [LclId,
                                            Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                    Value=False, ConLike=False, WorkFree=False,
                                                    Expandable=False,
                                                    Guidance=IF_ARGS [] 90 0}]
                                           ds2_abfK
                                             = GHC.Base.fmap
                                                 @f_abfA
                                                 (GHC.Base.$p1Applicative
                                                    @f_abfA $dApplicative_abfC)
                                                 @(GHC.Types.Int, [GHC.Types.Int])
                                                 @[GHC.Types.Int]
                                                 (\ (p1_abfL :: (GHC.Types.Int, [GHC.Types.Int])) ->
                                                    GHC.Types.:
                                                      @GHC.Types.Int
                                                      (case p1_abfL of { (x_abfN, ds_abfO) ->
                                                       x_abfN
                                                       })
                                                      (case p1_abfL of { (ds_abfR, y_abfS) ->
                                                       y_abfS
                                                       })) } in
                                         \ (ds3_abfU
                                              :: Data.Either.Either
                                                   [GHC.Types.Int]
                                                   (f_abfA (GHC.Types.Int, [GHC.Types.Int]))) ->
                                           case ds3_abfU of {
                                             Data.Either.Left x_abfW -> f2_abfJ x_abfW;
                                             Data.Either.Right y_abfY -> ds2_abfK y_abfY
                                           }) } in
                                let {
                                  g_abg0
                                    :: p_abfz
                                         (GHC.Types.Int, [GHC.Types.Int])
                                         (f_abfA (GHC.Types.Int, [GHC.Types.Int]))
                                       -> p_abfz
                                            (Data.Either.Either
                                               [GHC.Types.Int] (GHC.Types.Int, [GHC.Types.Int]))
                                            (Data.Either.Either
                                               [GHC.Types.Int]
                                               (f_abfA (GHC.Types.Int, [GHC.Types.Int])))
                                  [LclId,
                                   Unf=Unf{Src=<vanilla>, TopLvl=False,
                                           Value=False, ConLike=False, WorkFree=False,
                                           Expandable=True,
                                           Guidance=IF_ARGS [] 20 0}]
                                  g_abg0
                                    = Data.Profunctor.Choice.right'
                                        @p_abfz
                                        $dChoice_abfB
                                        @(GHC.Types.Int, [GHC.Types.Int])
                                        @(f_abfA (GHC.Types.Int, [GHC.Types.Int]))
                                        @[GHC.Types.Int] } in
                                \ (x_abg1
                                     :: p_abfz
                                          (GHC.Types.Int, [GHC.Types.Int])
                                          (f_abfA (GHC.Types.Int, [GHC.Types.Int]))) ->
                                  f1_abfD (g_abg0 x_abg1))
                             `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                              <[GHC.Types.Int]>_N
                                              <[GHC.Types.Int]>_N
                                              <GHC.Types.Int>_N
                                              <GHC.Types.Int>_N)
                                     :: Control.Lens.Type.Prism
                                          [GHC.Types.Int]
                                          [GHC.Types.Int]
                                          (GHC.Types.Int, [GHC.Types.Int])
                                          (GHC.Types.Int, [GHC.Types.Int])
                                        ~R# Control.Lens.Cons.Cons
                                              [GHC.Types.Int]
                                              [GHC.Types.Int]
                                              GHC.Types.Int
                                              GHC.Types.Int))
                            (($c_Cons_a9ik @GHC.Types.Int @GHC.Types.Int)
                             `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                              <Main.List GHC.Types.Int>_N
                                              <Main.List GHC.Types.Int>_N
                                              <GHC.Types.Int>_N
                                              <GHC.Types.Int>_N)
                                     :: Control.Lens.Type.Prism
                                          (Main.List GHC.Types.Int)
                                          (Main.List GHC.Types.Int)
                                          (GHC.Types.Int, Main.List GHC.Types.Int)
                                          (GHC.Types.Int, Main.List GHC.Types.Int)
                                        ~R# Control.Lens.Cons.Cons
                                              (Main.List GHC.Types.Int)
                                              (Main.List GHC.Types.Int)
                                              GHC.Types.Int
                                              GHC.Types.Int))
                            (($c_Empty_a9nj @GHC.Types.Int)
                             `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                              <Main.List GHC.Types.Int>_N)
                                     :: Control.Lens.Type.Prism' (Main.List GHC.Types.Int) ()
                                        ~R# Control.Lens.Empty.AsEmpty (Main.List GHC.Types.Int)))
                            @(Data.Functor.Const.Const (Main.List GHC.Types.Int))
                            (Data.Functor.Contravariant.$fContravariantConst
                               @(Main.List GHC.Types.Int))
                            (Data.Functor.Const.$fFunctorConst @(Main.List GHC.Types.Int))
                            ((\ (ds_abe3 :: Main.List GHC.Types.Int) -> ds_abe3)
                             `cast` (<Main.List GHC.Types.Int>_R
                                     %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                                        <*>_N
                                                                        <Main.List GHC.Types.Int>_R
                                                                        <Main.List GHC.Types.Int>_P)
                                     :: (Main.List GHC.Types.Int -> Main.List GHC.Types.Int)
                                        ~R# (Main.List GHC.Types.Int
                                             -> Data.Functor.Const.Const
                                                  (Main.List GHC.Types.Int)
                                                  (Main.List GHC.Types.Int))))
                            s_a8OI)
                         `cast` (Data.Functor.Const.N:Const[0]
                                     <*>_N <Main.List GHC.Types.Int>_R <[GHC.Types.Int]>_P
                                 :: Data.Functor.Const.Const
                                      (Main.List GHC.Types.Int) [GHC.Types.Int]
                                    ~R# Main.List GHC.Types.Int)))
                     `cast` (Data.Functor.Const.N:Const[0]
                                 <*>_N <[GHC.Types.Int]>_R <Main.List GHC.Types.Int>_P
                             :: Data.Functor.Const.Const
                                  [GHC.Types.Int] (Main.List GHC.Types.Int)
                                ~R# [GHC.Types.Int])
              ValArg s_a8OI
    Cont:   Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: unpack-list
    Module: (GHC.Base)
    Before: GHC.CString.unpackFoldrCString#
              TyArg [GHC.Types.Char]
              ValArg "Properties"#
              ValArg \ (ds_abUy :: GHC.Types.Char)
                       (ds1_abUz :: [GHC.Types.Char]) ->
                       GHC.Types.: @GHC.Types.Char ds_abUy ds1_abUz
              ValArg GHC.Types.[] @GHC.Types.Char
    After:  (\ (a_ab6K :: GHC.Prim.Addr#) ->
               GHC.CString.unpackCString# a_ab6K)
              "Properties"#
    Cont:   Stop[RhsCtxt(NonRecursive)] [GHC.Types.Char]
Rule fired
    Rule: unpack-list
    Module: (GHC.Base)
    Before: GHC.CString.unpackFoldrCString#
              TyArg [GHC.Types.Char]
              ValArg "[a] -> [a]"#
              ValArg \ (ds_abUy :: GHC.Types.Char)
                       (ds1_abUz :: [GHC.Types.Char]) ->
                       GHC.Types.: @GHC.Types.Char ds_abUy ds1_abUz
              ValArg GHC.Types.[] @GHC.Types.Char
    After:  (\ (a_ab6K :: GHC.Prim.Addr#) ->
               GHC.CString.unpackCString# a_ab6K)
              "[a] -> [a]"#
    Cont:   Stop[BoringCtxt] Test.Tasty.Core.TestName
Rule fired
    Rule: unpack-list
    Module: (GHC.Base)
    Before: GHC.CString.unpackFoldrCString#
              TyArg [GHC.Types.Char]
              ValArg "T -> T"#
              ValArg \ (ds_abUy :: GHC.Types.Char)
                       (ds1_abUz :: [GHC.Types.Char]) ->
                       GHC.Types.: @GHC.Types.Char ds_abUy ds1_abUz
              ValArg GHC.Types.[] @GHC.Types.Char
    After:  (\ (a_ab6K :: GHC.Prim.Addr#) ->
               GHC.CString.unpackCString# a_ab6K)
              "T -> T"#
    Cont:   Stop[BoringCtxt] Test.Tasty.Core.TestName
Rule fired
    Rule: unpack-list
    Module: (GHC.Base)
    Before: GHC.CString.unpackFoldrCString#
              TyArg [GHC.Types.Char]
              ValArg "TL -> TL"#
              ValArg \ (ds_abUy :: GHC.Types.Char)
                       (ds1_abUz :: [GHC.Types.Char]) ->
                       GHC.Types.: @GHC.Types.Char ds_abUy ds1_abUz
              ValArg GHC.Types.[] @GHC.Types.Char
    After:  (\ (a_ab6K :: GHC.Prim.Addr#) ->
               GHC.CString.unpackCString# a_ab6K)
              "TL -> TL"#
    Cont:   Stop[BoringCtxt] Test.Tasty.Core.TestName
Rule fired
    Rule: unpack-list
    Module: (GHC.Base)
    Before: GHC.CString.unpackFoldrCString#
              TyArg [GHC.Types.Char]
              ValArg "B -> B"#
              ValArg \ (ds_abUy :: GHC.Types.Char)
                       (ds1_abUz :: [GHC.Types.Char]) ->
                       GHC.Types.: @GHC.Types.Char ds_abUy ds1_abUz
              ValArg GHC.Types.[] @GHC.Types.Char
    After:  (\ (a_ab6K :: GHC.Prim.Addr#) ->
               GHC.CString.unpackCString# a_ab6K)
              "B -> B"#
    Cont:   Stop[BoringCtxt] Test.Tasty.Core.TestName
Rule fired
    Rule: unpack-list
    Module: (GHC.Base)
    Before: GHC.CString.unpackFoldrCString#
              TyArg [GHC.Types.Char]
              ValArg "L -> L"#
              ValArg \ (ds_abUy :: GHC.Types.Char)
                       (ds1_abUz :: [GHC.Types.Char]) ->
                       GHC.Types.: @GHC.Types.Char ds_abUy ds1_abUz
              ValArg GHC.Types.[] @GHC.Types.Char
    After:  (\ (a_ab6K :: GHC.Prim.Addr#) ->
               GHC.CString.unpackCString# a_ab6K)
              "L -> L"#
    Cont:   Stop[BoringCtxt] Test.Tasty.Core.TestName
Rule fired
    Rule: unpack-list
    Module: (GHC.Base)
    Before: GHC.CString.unpackFoldrCString#
              TyArg [GHC.Types.Char]
              ValArg "Str -> T -> Str"#
              ValArg \ (ds_abUy :: GHC.Types.Char)
                       (ds1_abUz :: [GHC.Types.Char]) ->
                       GHC.Types.: @GHC.Types.Char ds_abUy ds1_abUz
              ValArg GHC.Types.[] @GHC.Types.Char
    After:  (\ (a_ab6K :: GHC.Prim.Addr#) ->
               GHC.CString.unpackCString# a_ab6K)
              "Str -> T -> Str"#
    Cont:   Stop[BoringCtxt] Test.Tasty.Core.TestName
Rule fired
    Rule: unpack-list
    Module: (GHC.Base)
    Before: GHC.CString.unpackFoldrCString#
              TyArg [GHC.Types.Char]
              ValArg "Str -> TL -> Str"#
              ValArg \ (ds_abUy :: GHC.Types.Char)
                       (ds1_abUz :: [GHC.Types.Char]) ->
                       GHC.Types.: @GHC.Types.Char ds_abUy ds1_abUz
              ValArg GHC.Types.[] @GHC.Types.Char
    After:  (\ (a_ab6K :: GHC.Prim.Addr#) ->
               GHC.CString.unpackCString# a_ab6K)
              "Str -> TL -> Str"#
    Cont:   Stop[BoringCtxt] Test.Tasty.Core.TestName
Rule fired
    Rule: LAZY STREAM stream/unstream fusion
    Module: (Data.Text.Internal.Lazy.Fusion)
    Before: Data.Text.Internal.Lazy.Fusion.stream
              ValArg Data.Text.Internal.Lazy.Fusion.unstream
                       (Data.Text.Internal.Fusion.Common.streamList
                          @GHC.Types.Char
                          (GHC.Base.map
                             @GHC.Types.Char @GHC.Types.Char Data.Text.Internal.safe s_a8OD))
    After:  (\ (s_ac04
                  :: Data.Text.Internal.Fusion.Types.Stream GHC.Types.Char) ->
               s_ac04)
              (Data.Text.Internal.Fusion.Common.streamList
                 @GHC.Types.Char
                 (GHC.Base.map
                    @GHC.Types.Char @GHC.Types.Char Data.Text.Internal.safe s_a8OD))
    Cont:   StrictArg Data.Text.Internal.Fusion.Common.unstreamList
            StrictArg GHC.Base.eqString
            ApplyToVal nodup hole GHC.Base.String -> GHC.Types.Bool s_a8OD
            Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: unpack-list
    Module: (GHC.Base)
    Before: GHC.CString.unpackFoldrCString#
              TyArg [GHC.Types.Char]
              ValArg "T -> TL -> T"#
              ValArg \ (ds_abUy :: GHC.Types.Char)
                       (ds1_abUz :: [GHC.Types.Char]) ->
                       GHC.Types.: @GHC.Types.Char ds_abUy ds1_abUz
              ValArg GHC.Types.[] @GHC.Types.Char
    After:  (\ (a_ab6K :: GHC.Prim.Addr#) ->
               GHC.CString.unpackCString# a_ab6K)
              "T -> TL -> T"#
    Cont:   Stop[BoringCtxt] Test.Tasty.Core.TestName
Rule fired
    Rule: ==#
    Module: (BUILTIN)
    Before: GHC.Prim.==# ValArg ds2_aboR ValArg 0#
    After:  case ds2_aboR of wild_00 {
              __DEFAULT -> 0#;
              0# -> 1#
            }
    Cont:   StrictArg GHC.Prim.tagToEnum#
            Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: tagToEnum#
    Module: (BUILTIN)
    Before: GHC.Prim.tagToEnum# TyArg GHC.Types.Bool ValArg 0#
    After:  GHC.Types.False
    Cont:   Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: tagToEnum#
    Module: (BUILTIN)
    Before: GHC.Prim.tagToEnum# TyArg GHC.Types.Bool ValArg 1#
    After:  GHC.Types.True
    Cont:   Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: unpack-list
    Module: (GHC.Base)
    Before: GHC.CString.unpackFoldrCString#
              TyArg [GHC.Types.Char]
              ValArg "[W8] -> B -> [W8]"#
              ValArg \ (ds_abUy :: GHC.Types.Char)
                       (ds1_abUz :: [GHC.Types.Char]) ->
                       GHC.Types.: @GHC.Types.Char ds_abUy ds1_abUz
              ValArg GHC.Types.[] @GHC.Types.Char
    After:  (\ (a_ab6K :: GHC.Prim.Addr#) ->
               GHC.CString.unpackCString# a_ab6K)
              "[W8] -> B -> [W8]"#
    Cont:   Stop[BoringCtxt] Test.Tasty.Core.TestName
Rule fired
    Rule: ByteString unpack-list
    Module: (Data.ByteString)
    Before: Data.ByteString.unpackFoldr
              TyArg [GHC.Word.Word8]
              ValArg Data.ByteString.Internal.Type.BS
                       ww1_ac27 (GHC.ForeignPtr.PlainPtr ww2_ac28) ww3_ac29
              ValArg \ (ds_abUy :: GHC.Word.Word8)
                       (ds1_abUz :: [GHC.Word.Word8]) ->
                       GHC.Types.: @GHC.Word.Word8 ds_abUy ds1_abUz
              ValArg GHC.Types.[] @GHC.Word.Word8
    After:  (\ (bs_abrq :: Data.ByteString.Internal.Type.ByteString) ->
               Data.ByteString.Internal.Type.unpackBytes bs_abrq)
              (Data.ByteString.Internal.Type.BS
                 ww1_ac27 (GHC.ForeignPtr.PlainPtr ww2_ac28) ww3_ac29)
    Cont:   StrictArg GHC.Classes.$fEqList_$c==
            ApplyToVal nodup hole [GHC.Word.Word8] -> GHC.Types.Bool s_a8OF
            Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: unpack-list
    Module: (GHC.Base)
    Before: GHC.CString.unpackFoldrCString#
              TyArg [GHC.Types.Char]
              ValArg "[W8] -> L -> [W8]"#
              ValArg \ (ds_abUy :: GHC.Types.Char)
                       (ds1_abUz :: [GHC.Types.Char]) ->
                       GHC.Types.: @GHC.Types.Char ds_abUy ds1_abUz
              ValArg GHC.Types.[] @GHC.Types.Char
    After:  (\ (a_ab6K :: GHC.Prim.Addr#) ->
               GHC.CString.unpackCString# a_ab6K)
              "[W8] -> L -> [W8]"#
    Cont:   Stop[BoringCtxt] Test.Tasty.Core.TestName
Rule fired
    Rule: unpack-list
    Module: (GHC.Base)
    Before: GHC.CString.unpackFoldrCString#
              TyArg [GHC.Types.Char]
              ValArg "B -> L -> B"#
              ValArg \ (ds_abUy :: GHC.Types.Char)
                       (ds1_abUz :: [GHC.Types.Char]) ->
                       GHC.Types.: @GHC.Types.Char ds_abUy ds1_abUz
              ValArg GHC.Types.[] @GHC.Types.Char
    After:  (\ (a_ab6K :: GHC.Prim.Addr#) ->
               GHC.CString.unpackCString# a_ab6K)
              "B -> L -> B"#
    Cont:   Stop[BoringCtxt] Test.Tasty.Core.TestName
Rule fired
    Rule: /=#
    Module: (BUILTIN)
    Before: GHC.Prim./=# ValArg 0# ValArg 0#
    After:  0#
    Cont:   Select nodup lwild_sc2G
            Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: <#
    Module: (BUILTIN)
    Before: GHC.Prim.<# ValArg 0# ValArg 0#
    After:  0#
    Cont:   Select nodup lwild_ac2J
            Select ok lwild1_abrV
            Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: ==#
    Module: (BUILTIN)
    Before: GHC.Prim.==# ValArg 0# ValArg 0#
    After:  1#
    Cont:   Select nodup lwild1_ac2K
            Select ok lwild1_abrV
            Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: <=#
    Module: (BUILTIN)
    Before: GHC.Prim.<=# ValArg 0# ValArg 0#
    After:  1#
    Cont:   Select nodup lwild_abUl
            Select ok lwild1_abrV
            Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: intToInt64#
    Module: (BUILTIN)
    Before: GHC.Prim.intToInt64# ValArg 0#
    After:  0#Int64
    Cont:   StrictArg GHC.Prim.int64ToWord64#
            StrictArg {__ffi_static_ccall_unsafe bytestring-0.11.5.3:memcmp :: Addr#
                                                         -> Addr#
                                                         -> Word64#
                                                         -> State# RealWorld
                                                         -> (# State# RealWorld, Int32# #)}_abU8
            ApplyToVal nodup hole GHC.Prim.State# GHC.Prim.RealWorld
                                  -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Prim.Int32# #)
              GHC.Prim.realWorld#
            Select nodup wild_abU9
            Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: int64ToWord64#
    Module: (BUILTIN)
    Before: GHC.Prim.int64ToWord64# ValArg 0#Int64
    After:  0#Word64
    Cont:   StrictArg {__ffi_static_ccall_unsafe bytestring-0.11.5.3:memcmp :: Addr#
                                                         -> Addr#
                                                         -> Word64#
                                                         -> State# RealWorld
                                                         -> (# State# RealWorld, Int32# #)}_abU8
            ApplyToVal nodup hole GHC.Prim.State# GHC.Prim.RealWorld
                                  -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Prim.Int32# #)
              GHC.Prim.realWorld#
            Select nodup wild_abU9
            Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: unpack-list
    Module: (GHC.Base)
    Before: GHC.CString.unpackFoldrCString#
              TyArg [GHC.Types.Char]
              ValArg "[a] -> List a -> [a]"#
              ValArg \ (ds_abUy :: GHC.Types.Char)
                       (ds1_abUz :: [GHC.Types.Char]) ->
                       GHC.Types.: @GHC.Types.Char ds_abUy ds1_abUz
              ValArg GHC.Types.[] @GHC.Types.Char
    After:  (\ (a_ab6K :: GHC.Prim.Addr#) ->
               GHC.CString.unpackCString# a_ab6K)
              "[a] -> List a -> [a]"#
    Cont:   Stop[BoringCtxt] Test.Tasty.Core.TestName
Rule fired
    Rule: ==#
    Module: (BUILTIN)
    Before: GHC.Prim.==# ValArg bx2_aboI ValArg 0#
    After:  case bx2_aboI of wild_00 {
              __DEFAULT -> 0#;
              0# -> 1#
            }
    Cont:   Select nodup lwild_sc1X
            Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: /=#
    Module: (BUILTIN)
    Before: GHC.Prim./=# ValArg ds1_abrF ValArg ds1_abrF
    After:  0#
    Cont:   Select nodup lwild_sc2G
            Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: <#
    Module: (BUILTIN)
    Before: GHC.Prim.<# ValArg ds1_abrF ValArg ds1_abrF
    After:  0#
    Cont:   Select nodup lwild_ac2J
            Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: ==#
    Module: (BUILTIN)
    Before: GHC.Prim.==# ValArg ds1_abrF ValArg ds1_abrF
    After:  1#
    Cont:   Select nodup lwild1_ac2K
            Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: <=#
    Module: (BUILTIN)
    Before: GHC.Prim.<=# ValArg ds1_abrF ValArg ds1_abrF
    After:  1#
    Cont:   Select nodup lwild_abUl
            Stop[BoringCtxt] GHC.Types.Bool
[2 of 2] Linking /tmp/workdir-concise/concise-0.1.0.1/dist-newstyle/build/x86_64-linux/ghc-9.6.6/concise-0.1.0.1/t/tests/build/tests/tests
