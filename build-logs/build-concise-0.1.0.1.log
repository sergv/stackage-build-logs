Build profile: -w ghc-9.6.6 -O1
In order, the following will be built (use -v for more details):
 - concise-0.1.0.1 (lib) (first run)
 - concise-0.1.0.1 (test:tests) (first run)
Configuring library for concise-0.1.0.1...
Preprocessing library for concise-0.1.0.1...
Building library for concise-0.1.0.1...
[1 of 1] Compiling Control.Lens.Cons.Extras

src/Control/Lens/Cons/Extras.hs:45:1: warning: [-Wunused-imports]
    The import of ‘Control.Lens’ is redundant
      except perhaps to import instances from ‘Control.Lens’
    To import instances alone, use: import Control.Lens()
   |
45 | import Control.Lens ((#))
   | ^^^^^^^^^^^^^^^^^^^^^^^^^

src/Control/Lens/Cons/Extras.hs:46:1: warning: [-Wunused-imports]
    The import of ‘Control.Lens.Cons’ is redundant
      except perhaps to import instances from ‘Control.Lens.Cons’
    To import instances alone, use: import Control.Lens.Cons()
   |
46 | import Control.Lens.Cons (Cons, cons, uncons)
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

src/Control/Lens/Cons/Extras.hs:47:1: warning: [-Wunused-imports]
    The import of ‘Control.Lens.Empty’ is redundant
      except perhaps to import instances from ‘Control.Lens.Empty’
    To import instances alone, use: import Control.Lens.Empty()
   |
47 | import Control.Lens.Empty (AsEmpty(..))
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

src/Control/Lens/Cons/Extras.hs:48:1: warning: [-Wunused-imports]
    The import of ‘Control.Lens.Fold’ is redundant
      except perhaps to import instances from ‘Control.Lens.Fold’
    To import instances alone, use: import Control.Lens.Fold()
   |
48 | import Control.Lens.Fold (foldrOf, unfolded)
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

src/Control/Lens/Cons/Extras.hs:50:1: warning: [-Wunused-imports]
    The import of ‘Control.Lens.Iso’ is redundant
      except perhaps to import instances from ‘Control.Lens.Iso’
    To import instances alone, use: import Control.Lens.Iso()
   |
50 | import Control.Lens.Iso (lazy, strict)
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Configuring test suite 'tests' for concise-0.1.0.1...
Preprocessing test suite 'tests' for concise-0.1.0.1...
Building test suite 'tests' for concise-0.1.0.1...
[1 of 1] Compiling Main
Rule fired
    Rule: Class op ==
    Module: (BUILTIN)
    Before: GHC.Classes.==
              TyArg Main.List a_a9iA
              ValArg Main.$fEqList @a_a9iA $dEq_a9iB
              ValArg eta_B0
              ValArg eta_B1
    After:  $c==_a9iD @a_a9iA $dEq_a9iB ValArg eta_B0 ValArg eta_B1
    Cont:   Select nodup wild_aaZD
            Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: Class op ==
    Module: (BUILTIN)
    Before: GHC.Classes.==
              TyArg Main.List a_a9iA ValArg $dEq_aaZA ValArg x_aaZB ValArg y_aaZC
    After:  $c==_a9iD @a_a9iA $dEq_a9iB ValArg x_aaZB ValArg y_aaZC
    Cont:   Select nodup wild_aaZD
            Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: Class op ==
    Module: (BUILTIN)
    Before: GHC.Classes.==
              TyArg Main.List a_a9iA
              ValArg $dEq_a9iY
              ValArg a2_a8QY
              ValArg b2_a8R0
    After:  $c==_a9iD @a_a9iA $dEq_a9iB ValArg a2_a8QY ValArg b2_a8R0
    Cont:   Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: USPEC $fEqList @Int
    Module: (GHC.Classes)
    Before: GHC.Classes.$fEqList
              TyArg GHC.Types.Int ValArg GHC.Classes.$fEqInt
    After:  (\ ($dEq_ab7l :: GHC.Classes.Eq GHC.Types.Int) ->
               GHC.Classes.$fEqList_$s$fEqList)
              GHC.Classes.$fEqInt
    Cont:   Stop[RhsCtxt(NonRecursive)] GHC.Classes.Eq [GHC.Types.Int]
Rule fired
    Rule: USPEC $fEqList @Char
    Module: (GHC.Classes)
    Before: GHC.Classes.$fEqList
              TyArg GHC.Types.Char ValArg GHC.Classes.$fEqChar
    After:  (\ ($dEq_ab7m :: GHC.Classes.Eq GHC.Types.Char) ->
               GHC.Classes.$fEqList_$s$fEqList1)
              GHC.Classes.$fEqChar
    Cont:   Stop[RhsCtxt(NonRecursive)] GHC.Classes.Eq [GHC.Types.Char]
Rule fired
    Rule: USPEC $fShowList @Char
    Module: (GHC.Show)
    Before: GHC.Show.$fShowList
              TyArg GHC.Types.Char ValArg GHC.Show.$fShowChar
    After:  (\ ($dShow_ab7p :: GHC.Show.Show GHC.Types.Char) ->
               GHC.Show.$fShowList_$s$fShowList1)
              GHC.Show.$fShowChar
    Cont:   Stop[RhsCtxt(NonRecursive)] GHC.Show.Show [GHC.Types.Char]
Rule fired
    Rule: unpack
    Module: (GHC.Base)
    Before: GHC.CString.unpackCString# ValArg "Properties"#
    After:  (\ (a_ab7z :: GHC.Prim.Addr#) ->
               GHC.Base.build
                 @GHC.Types.Char
                 (\ (@b_ab7A) -> GHC.CString.unpackFoldrCString# @b_ab7A a_ab7z))
              "Properties"#
    Cont:   Stop[BoringCtxt] Test.Tasty.Core.TestName
Rule fired
    Rule: unpack
    Module: (GHC.Base)
    Before: GHC.CString.unpackCString# ValArg "[a] -> [a]"#
    After:  (\ (a_ab7z :: GHC.Prim.Addr#) ->
               GHC.Base.build
                 @GHC.Types.Char
                 (\ (@b_ab7A) -> GHC.CString.unpackFoldrCString# @b_ab7A a_ab7z))
              "[a] -> [a]"#
    Cont:   Stop[BoringCtxt] Test.Tasty.Core.TestName
Rule fired
    Rule: Class op property
    Module: (BUILTIN)
    Before: Test.QuickCheck.Property.property
              TyArg GHC.Base.String -> GHC.Types.Bool ValArg $dTestable_a92k
    After:  Test.QuickCheck.Property.$fTestableFUN_$cproperty
              @[GHC.Types.Char]
              @GHC.Types.Bool
              $dArbitrary_a9JV
              GHC.Show.$fShowList_$s$fShowList1
              Test.QuickCheck.Property.$fTestableBool
    Cont:   ApplyToVal nodup hole (GHC.Base.String -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              prop_ab7M
            CastIt (Sym (Test.Tasty.QuickCheck.N:QC[0])
                    :: Test.QuickCheck.Property.Property ~R# Test.Tasty.QuickCheck.QC)
            Stop[BoringCtxt] Test.Tasty.QuickCheck.QC
Rule fired
    Rule: Class op propertyForAllShrinkShow
    Module: (BUILTIN)
    Before: Test.QuickCheck.Property.propertyForAllShrinkShow
              TyArg GHC.Types.Bool ValArg Test.QuickCheck.Property.$fTestableBool
    After:  Test.QuickCheck.Property.$fTestableBool1
            `cast` (forall (a :: <*>_N).
                    <Test.QuickCheck.Gen.Gen a>_R
                    %<'GHC.Types.Many>_N ->_R <a -> [a]>_R
                    %<'GHC.Types.Many>_N ->_R <a -> [GHC.Base.String]>_R
                    %<'GHC.Types.Many>_N ->_R <a -> GHC.Types.Bool>_R
                    %<'GHC.Types.Many>_N ->_R Sym (Test.QuickCheck.Gen.N:Gen[0]
                                                       (Test.QuickCheck.Property.N:Prop[0]))
                                              ; Sym (Test.QuickCheck.Property.N:Property[0])
                    :: (forall {a}.
                        Test.QuickCheck.Gen.Gen a
                        -> (a -> [a])
                        -> (a -> [GHC.Base.String])
                        -> (a -> GHC.Types.Bool)
                        -> Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int
                        -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result)
                       ~R# (forall {a}.
                            Test.QuickCheck.Gen.Gen a
                            -> (a -> [a])
                            -> (a -> [GHC.Base.String])
                            -> (a -> GHC.Types.Bool)
                            -> Test.QuickCheck.Property.Property))
    Cont:   ApplyToTy [GHC.Types.Char]
            ApplyToVal nodup hole Test.QuickCheck.Gen.Gen [GHC.Types.Char]
                                  -> ([GHC.Types.Char] -> [[GHC.Types.Char]])
                                  -> ([GHC.Types.Char] -> [GHC.Base.String])
                                  -> ([GHC.Types.Char] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (Test.QuickCheck.Arbitrary.arbitrary @a_ab9u $dArbitrary_ab9w)
            ApplyToVal nodup hole ([GHC.Types.Char] -> [[GHC.Types.Char]])
                                  -> ([GHC.Types.Char] -> [GHC.Base.String])
                                  -> ([GHC.Types.Char] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (Test.QuickCheck.Arbitrary.shrink @a_ab9u $dArbitrary_ab9w)
            ApplyToVal nodup hole ([GHC.Types.Char] -> [GHC.Base.String])
                                  -> ([GHC.Types.Char] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (let {
                 g_ab9A [Occ=OnceL1!] :: a_ab9u -> GHC.Base.String
                 [LclId]
                 g_ab9A = GHC.Show.show @a_ab9u $dShow_ab9x } in
               \ (x_ab9B [Occ=Once1] :: a_ab9u) ->
                 GHC.Types.:
                   @GHC.Base.String (g_ab9A x_ab9B) (GHC.Types.[] @GHC.Base.String))
            ApplyToVal nodup hole ([GHC.Types.Char] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              f_ab9z
            CastIt (Sym (Test.Tasty.QuickCheck.N:QC[0])
                    :: Test.QuickCheck.Property.Property ~R# Test.Tasty.QuickCheck.QC)
            Stop[BoringCtxt] Test.Tasty.QuickCheck.QC
Rule fired
    Rule: Class op arbitrary
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.arbitrary
              TyArg [GHC.Types.Char] ValArg $dArbitrary_a9JV
    After:  (Test.QuickCheck.Arbitrary.$fArbitraryList1
               @GHC.Types.Char Test.QuickCheck.Arbitrary.$fArbitraryChar)
            `cast` (Sym (Test.QuickCheck.Gen.N:Gen[0] <[GHC.Types.Char]>_R)
                    :: (Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int -> [GHC.Types.Char])
                       ~R# Test.QuickCheck.Gen.Gen [GHC.Types.Char])
    Cont:   Stop[BoringCtxt] Test.QuickCheck.Gen.Gen [GHC.Types.Char]
Rule fired
    Rule: Class op arbitrary
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.arbitrary
              TyArg GHC.Types.Char
              ValArg Test.QuickCheck.Arbitrary.$fArbitraryChar
    After:  Test.QuickCheck.Arbitrary.$fArbitraryChar_$carbitrary
    Cont:   Stop[BoringCtxt, C(S,C(1,L))] Test.QuickCheck.Gen.Gen
                                            GHC.Types.Char
Rule fired
    Rule: Class op shrink
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.shrink
              TyArg [GHC.Types.Char] ValArg $dArbitrary_a9JV
    After:  Test.QuickCheck.Arbitrary.$fArbitraryList_$cshrink
              @GHC.Types.Char Test.QuickCheck.Arbitrary.$fArbitraryChar
    Cont:   Stop[BoringCtxt] [GHC.Types.Char] -> [[GHC.Types.Char]]
Rule fired
    Rule: Class op shrink
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.shrink
              TyArg GHC.Types.Char
              ValArg Test.QuickCheck.Arbitrary.$fArbitraryChar
    After:  Test.QuickCheck.Arbitrary.$fArbitraryChar_$cshrink
    Cont:   Stop[DiscArgCtxt, C(S,L)] GHC.Types.Char
                                      -> [GHC.Types.Char]
Rule fired
    Rule: Class op show
    Module: (BUILTIN)
    Before: GHC.Show.show
              TyArg [GHC.Types.Char] ValArg GHC.Show.$fShowList_$s$fShowList1
    After:  GHC.Show.$fShowList_$s$cshow1
    Cont:   Stop[RhsCtxt(NonRecursive)] [GHC.Types.Char]
                                        -> GHC.Base.String
Rule fired
    Rule: Class op reader
    Module: (BUILTIN)
    Before: Control.Monad.Reader.Class.reader
              TyArg [GHC.Types.Char]
              TyArg (->) GHC.Base.String
              ValArg Control.Monad.Reader.Class.$fMonadReaderrFUN
                       @[GHC.Types.Char]
    After:  \ (@a_abeP) -> GHC.Base.id @([GHC.Types.Char] -> a_abeP)
    Cont:   ApplyToTy GHC.Base.String
            ApplyToVal nodup hole ([GHC.Types.Char] -> GHC.Base.String)
                                  -> GHC.Base.String -> GHC.Base.String
              ((l_abeJ
                  ((\ (ds_abeK [Occ=Once1] :: a_abeH) -> ds_abeK)
                   `cast` (<a_abeH>_R
                           %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                              <*>_N <a_abeH>_R <a_abeH>_P)
                           :: (a_abeH -> a_abeH)
                              ~R# (a_abeH -> Data.Functor.Const.Const a_abeH a_abeH))))
               `cast` (<s_abeF>_R
                       %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                     <*>_N <a_abeH>_R <s_abeF>_P
                       :: (s_abeF -> Data.Functor.Const.Const a_abeH s_abeF)
                          ~R# (s_abeF -> a_abeH)))
            ApplyToVal nodup hole GHC.Base.String -> GHC.Base.String s_a8Km
            Stop[RuleArgCtxt] GHC.Base.String
Rule fired
    Rule: recons/id
    Module: (Control.Lens.Cons.Extras)
    Before: Control.Lens.Cons.Extras.recons
              TyArg [GHC.Types.Char]
              TyArg GHC.Types.Char
              TyArg GHC.Base.String
              ValArg (\ (@(p_abgg :: * -> * -> *))
                        (@(f_abgh :: * -> *))
                        ($dChoice_abgi :: Data.Profunctor.Choice.Choice p_abgg)
                        ($dApplicative_abgj :: GHC.Base.Applicative f_abgh) ->
                        let {
                          f1_abgk
                            :: p_abgg
                                 (Data.Either.Either
                                    [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                                 (Data.Either.Either
                                    [GHC.Types.Char] (f_abgh (GHC.Types.Char, [GHC.Types.Char])))
                               -> p_abgg [GHC.Types.Char] (f_abgh [GHC.Types.Char])
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 320 0}]
                          f1_abgk
                            = Data.Profunctor.Unsafe.dimap
                                @p_abgg
                                (Data.Profunctor.Choice.$p1Choice @p_abgg $dChoice_abgi)
                                @[GHC.Types.Char]
                                @(Data.Either.Either
                                    [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                                @(Data.Either.Either
                                    [GHC.Types.Char] (f_abgh (GHC.Types.Char, [GHC.Types.Char])))
                                @(f_abgh [GHC.Types.Char])
                                (\ (aas_abgl :: [GHC.Types.Char]) ->
                                   case aas_abgl of {
                                     [] ->
                                       Data.Either.Left
                                         @[GHC.Types.Char]
                                         @(GHC.Types.Char, [GHC.Types.Char])
                                         (GHC.Types.[] @GHC.Types.Char);
                                     : a1_abgn as_abgo ->
                                       Data.Either.Right
                                         @[GHC.Types.Char]
                                         @(GHC.Types.Char, [GHC.Types.Char])
                                         (a1_abgn, as_abgo)
                                   })
                                (let {
                                   f2_abgq :: [GHC.Types.Char] -> f_abgh [GHC.Types.Char]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abgq
                                     = GHC.Base.pure
                                         @f_abgh $dApplicative_abgj @[GHC.Types.Char] } in
                                 let {
                                   ds2_abgr
                                     :: f_abgh (GHC.Types.Char, [GHC.Types.Char])
                                        -> f_abgh [GHC.Types.Char]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 90 0}]
                                   ds2_abgr
                                     = GHC.Base.fmap
                                         @f_abgh
                                         (GHC.Base.$p1Applicative @f_abgh $dApplicative_abgj)
                                         @(GHC.Types.Char, [GHC.Types.Char])
                                         @[GHC.Types.Char]
                                         (\ (p1_abgs :: (GHC.Types.Char, [GHC.Types.Char])) ->
                                            GHC.Types.:
                                              @GHC.Types.Char
                                              (case p1_abgs of { (x_abgu, ds_abgv) -> x_abgu })
                                              (case p1_abgs of { (ds_abgy, y_abgz) ->
                                               y_abgz
                                               })) } in
                                 \ (ds3_abgB
                                      :: Data.Either.Either
                                           [GHC.Types.Char]
                                           (f_abgh (GHC.Types.Char, [GHC.Types.Char]))) ->
                                   case ds3_abgB of {
                                     Data.Either.Left x_abgD -> f2_abgq x_abgD;
                                     Data.Either.Right y_abgF -> ds2_abgr y_abgF
                                   }) } in
                        let {
                          g_abgH
                            :: p_abgg
                                 (GHC.Types.Char, [GHC.Types.Char])
                                 (f_abgh (GHC.Types.Char, [GHC.Types.Char]))
                               -> p_abgg
                                    (Data.Either.Either
                                       [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                                    (Data.Either.Either
                                       [GHC.Types.Char] (f_abgh (GHC.Types.Char, [GHC.Types.Char])))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abgH
                            = Data.Profunctor.Choice.right'
                                @p_abgg
                                $dChoice_abgi
                                @(GHC.Types.Char, [GHC.Types.Char])
                                @(f_abgh (GHC.Types.Char, [GHC.Types.Char]))
                                @[GHC.Types.Char] } in
                        \ (x_abgI
                             :: p_abgg
                                  (GHC.Types.Char, [GHC.Types.Char])
                                  (f_abgh (GHC.Types.Char, [GHC.Types.Char]))) ->
                          f1_abgk (g_abgH x_abgI))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <[GHC.Types.Char]>_N
                                      <[GHC.Types.Char]>_N
                                      <GHC.Types.Char>_N
                                      <GHC.Types.Char>_N)
                             :: Control.Lens.Type.Prism
                                  [GHC.Types.Char]
                                  [GHC.Types.Char]
                                  (GHC.Types.Char, [GHC.Types.Char])
                                  (GHC.Types.Char, [GHC.Types.Char])
                                ~R# Control.Lens.Cons.Cons
                                      [GHC.Types.Char]
                                      [GHC.Types.Char]
                                      GHC.Types.Char
                                      GHC.Types.Char)
              ValArg (\ (@(p_abgg :: * -> * -> *))
                        (@(f_abgh :: * -> *))
                        ($dChoice_abgi :: Data.Profunctor.Choice.Choice p_abgg)
                        ($dApplicative_abgj :: GHC.Base.Applicative f_abgh) ->
                        let {
                          f1_abgk
                            :: p_abgg
                                 (Data.Either.Either
                                    [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                                 (Data.Either.Either
                                    [GHC.Types.Char] (f_abgh (GHC.Types.Char, [GHC.Types.Char])))
                               -> p_abgg [GHC.Types.Char] (f_abgh [GHC.Types.Char])
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 320 0}]
                          f1_abgk
                            = Data.Profunctor.Unsafe.dimap
                                @p_abgg
                                (Data.Profunctor.Choice.$p1Choice @p_abgg $dChoice_abgi)
                                @[GHC.Types.Char]
                                @(Data.Either.Either
                                    [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                                @(Data.Either.Either
                                    [GHC.Types.Char] (f_abgh (GHC.Types.Char, [GHC.Types.Char])))
                                @(f_abgh [GHC.Types.Char])
                                (\ (aas_abgl :: [GHC.Types.Char]) ->
                                   case aas_abgl of {
                                     [] ->
                                       Data.Either.Left
                                         @[GHC.Types.Char]
                                         @(GHC.Types.Char, [GHC.Types.Char])
                                         (GHC.Types.[] @GHC.Types.Char);
                                     : a1_abgn as_abgo ->
                                       Data.Either.Right
                                         @[GHC.Types.Char]
                                         @(GHC.Types.Char, [GHC.Types.Char])
                                         (a1_abgn, as_abgo)
                                   })
                                (let {
                                   f2_abgq :: [GHC.Types.Char] -> f_abgh [GHC.Types.Char]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abgq
                                     = GHC.Base.pure
                                         @f_abgh $dApplicative_abgj @[GHC.Types.Char] } in
                                 let {
                                   ds2_abgr
                                     :: f_abgh (GHC.Types.Char, [GHC.Types.Char])
                                        -> f_abgh [GHC.Types.Char]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 90 0}]
                                   ds2_abgr
                                     = GHC.Base.fmap
                                         @f_abgh
                                         (GHC.Base.$p1Applicative @f_abgh $dApplicative_abgj)
                                         @(GHC.Types.Char, [GHC.Types.Char])
                                         @[GHC.Types.Char]
                                         (\ (p1_abgs :: (GHC.Types.Char, [GHC.Types.Char])) ->
                                            GHC.Types.:
                                              @GHC.Types.Char
                                              (case p1_abgs of { (x_abgu, ds_abgv) -> x_abgu })
                                              (case p1_abgs of { (ds_abgy, y_abgz) ->
                                               y_abgz
                                               })) } in
                                 \ (ds3_abgB
                                      :: Data.Either.Either
                                           [GHC.Types.Char]
                                           (f_abgh (GHC.Types.Char, [GHC.Types.Char]))) ->
                                   case ds3_abgB of {
                                     Data.Either.Left x_abgD -> f2_abgq x_abgD;
                                     Data.Either.Right y_abgF -> ds2_abgr y_abgF
                                   }) } in
                        let {
                          g_abgH
                            :: p_abgg
                                 (GHC.Types.Char, [GHC.Types.Char])
                                 (f_abgh (GHC.Types.Char, [GHC.Types.Char]))
                               -> p_abgg
                                    (Data.Either.Either
                                       [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                                    (Data.Either.Either
                                       [GHC.Types.Char] (f_abgh (GHC.Types.Char, [GHC.Types.Char])))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abgH
                            = Data.Profunctor.Choice.right'
                                @p_abgg
                                $dChoice_abgi
                                @(GHC.Types.Char, [GHC.Types.Char])
                                @(f_abgh (GHC.Types.Char, [GHC.Types.Char]))
                                @[GHC.Types.Char] } in
                        \ (x_abgI
                             :: p_abgg
                                  (GHC.Types.Char, [GHC.Types.Char])
                                  (f_abgh (GHC.Types.Char, [GHC.Types.Char]))) ->
                          f1_abgk (g_abgH x_abgI))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <[GHC.Types.Char]>_N
                                      <[GHC.Types.Char]>_N
                                      <GHC.Types.Char>_N
                                      <GHC.Types.Char>_N)
                             :: Control.Lens.Type.Prism
                                  [GHC.Types.Char]
                                  [GHC.Types.Char]
                                  (GHC.Types.Char, [GHC.Types.Char])
                                  (GHC.Types.Char, [GHC.Types.Char])
                                ~R# Control.Lens.Cons.Cons
                                      [GHC.Types.Char]
                                      [GHC.Types.Char]
                                      GHC.Types.Char
                                      GHC.Types.Char)
              ValArg (\ (@(p_abgN :: * -> * -> *))
                        (@(f_abgO :: * -> *))
                        ($dChoice_abgP :: Data.Profunctor.Choice.Choice p_abgN)
                        ($dApplicative_abgQ :: GHC.Base.Applicative f_abgO) ->
                        let {
                          f1_abgR
                            :: p_abgN
                                 (Data.Either.Either [GHC.Types.Char] ())
                                 (Data.Either.Either [GHC.Types.Char] (f_abgO ()))
                               -> p_abgN [GHC.Types.Char] (f_abgO [GHC.Types.Char])
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 290 0}]
                          f1_abgR
                            = Data.Profunctor.Unsafe.dimap
                                @p_abgN
                                (Data.Profunctor.Choice.$p1Choice @p_abgN $dChoice_abgP)
                                @[GHC.Types.Char]
                                @(Data.Either.Either [GHC.Types.Char] ())
                                @(Data.Either.Either [GHC.Types.Char] (f_abgO ()))
                                @(f_abgO [GHC.Types.Char])
                                (\ (s_abgS :: [GHC.Types.Char]) ->
                                   case s_abgS of wild_abgT {
                                     [] ->
                                       Data.Either.Right @[GHC.Types.Char] @() GHC.Tuple.Prim.();
                                     : ds1_abgU ds2_abgV ->
                                       Data.Either.Left @[GHC.Types.Char] @() wild_abgT
                                   })
                                (let {
                                   f2_abgX :: [GHC.Types.Char] -> f_abgO [GHC.Types.Char]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abgX
                                     = GHC.Base.pure
                                         @f_abgO $dApplicative_abgQ @[GHC.Types.Char] } in
                                 let {
                                   ds2_abgY :: f_abgO () -> f_abgO [GHC.Types.Char]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 70 0}]
                                   ds2_abgY
                                     = GHC.Base.fmap
                                         @f_abgO
                                         (GHC.Base.$p1Applicative @f_abgO $dApplicative_abgQ)
                                         @()
                                         @[GHC.Types.Char]
                                         (\ (ds3_abgZ :: ()) ->
                                            case ds3_abgZ of { () ->
                                            GHC.Types.[] @GHC.Types.Char
                                            }) } in
                                 \ (ds3_abh1 :: Data.Either.Either [GHC.Types.Char] (f_abgO ())) ->
                                   case ds3_abh1 of {
                                     Data.Either.Left x_abh3 -> f2_abgX x_abh3;
                                     Data.Either.Right y_abh5 -> ds2_abgY y_abh5
                                   }) } in
                        let {
                          g_abh7
                            :: p_abgN () (f_abgO ())
                               -> p_abgN
                                    (Data.Either.Either [GHC.Types.Char] ())
                                    (Data.Either.Either [GHC.Types.Char] (f_abgO ()))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abh7
                            = Data.Profunctor.Choice.right'
                                @p_abgN $dChoice_abgP @() @(f_abgO ()) @[GHC.Types.Char] } in
                        \ (x_abh8 :: p_abgN () (f_abgO ())) -> f1_abgR (g_abh7 x_abh8))
                     `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0] <[GHC.Types.Char]>_N)
                             :: Control.Lens.Type.Prism' [GHC.Types.Char] ()
                                ~R# Control.Lens.Empty.AsEmpty [GHC.Types.Char])
              TyArg Data.Functor.Const.Const GHC.Base.String
              ValArg Data.Functor.Contravariant.$fContravariantConst
                       @[GHC.Types.Char]
              ValArg Data.Functor.Const.$fFunctorConst @[GHC.Types.Char]
    After:  (\ (@s1_abfO)
               (@(f_abfP :: * -> *))
               (@a_abfQ)
               ($dCons_abfR
                  :: Control.Lens.Cons.Cons s1_abfO s1_abfO a_abfQ a_abfQ)
               ($dCons1_abfS
                  :: Control.Lens.Cons.Cons s1_abfO s1_abfO a_abfQ a_abfQ)
               ($dAsEmpty_abfT :: Control.Lens.Empty.AsEmpty s1_abfO)
               ($dContravariant_abfU
                  :: Data.Functor.Contravariant.Contravariant f_abfP)
               ($dFunctor_abfV :: GHC.Base.Functor f_abfP) ->
               GHC.Base.id @(s1_abfO -> f_abfP s1_abfO))
              @[GHC.Types.Char]
              @(Data.Functor.Const.Const GHC.Base.String)
              @GHC.Types.Char
              ((\ (@(p_abgg :: * -> * -> *))
                  (@(f_abgh :: * -> *))
                  ($dChoice_abgi :: Data.Profunctor.Choice.Choice p_abgg)
                  ($dApplicative_abgj :: GHC.Base.Applicative f_abgh) ->
                  let {
                    f1_abgk
                      :: p_abgg
                           (Data.Either.Either
                              [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                           (Data.Either.Either
                              [GHC.Types.Char] (f_abgh (GHC.Types.Char, [GHC.Types.Char])))
                         -> p_abgg [GHC.Types.Char] (f_abgh [GHC.Types.Char])
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 320 0}]
                    f1_abgk
                      = Data.Profunctor.Unsafe.dimap
                          @p_abgg
                          (Data.Profunctor.Choice.$p1Choice @p_abgg $dChoice_abgi)
                          @[GHC.Types.Char]
                          @(Data.Either.Either
                              [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                          @(Data.Either.Either
                              [GHC.Types.Char] (f_abgh (GHC.Types.Char, [GHC.Types.Char])))
                          @(f_abgh [GHC.Types.Char])
                          (\ (aas_abgl :: [GHC.Types.Char]) ->
                             case aas_abgl of {
                               [] ->
                                 Data.Either.Left
                                   @[GHC.Types.Char]
                                   @(GHC.Types.Char, [GHC.Types.Char])
                                   (GHC.Types.[] @GHC.Types.Char);
                               : a1_abgn as_abgo ->
                                 Data.Either.Right
                                   @[GHC.Types.Char]
                                   @(GHC.Types.Char, [GHC.Types.Char])
                                   (a1_abgn, as_abgo)
                             })
                          (let {
                             f2_abgq :: [GHC.Types.Char] -> f_abgh [GHC.Types.Char]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abgq
                               = GHC.Base.pure @f_abgh $dApplicative_abgj @[GHC.Types.Char] } in
                           let {
                             ds2_abgr
                               :: f_abgh (GHC.Types.Char, [GHC.Types.Char])
                                  -> f_abgh [GHC.Types.Char]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 90 0}]
                             ds2_abgr
                               = GHC.Base.fmap
                                   @f_abgh
                                   (GHC.Base.$p1Applicative @f_abgh $dApplicative_abgj)
                                   @(GHC.Types.Char, [GHC.Types.Char])
                                   @[GHC.Types.Char]
                                   (\ (p1_abgs :: (GHC.Types.Char, [GHC.Types.Char])) ->
                                      GHC.Types.:
                                        @GHC.Types.Char
                                        (case p1_abgs of { (x_abgu, ds_abgv) -> x_abgu })
                                        (case p1_abgs of { (ds_abgy, y_abgz) -> y_abgz })) } in
                           \ (ds3_abgB
                                :: Data.Either.Either
                                     [GHC.Types.Char]
                                     (f_abgh (GHC.Types.Char, [GHC.Types.Char]))) ->
                             case ds3_abgB of {
                               Data.Either.Left x_abgD -> f2_abgq x_abgD;
                               Data.Either.Right y_abgF -> ds2_abgr y_abgF
                             }) } in
                  let {
                    g_abgH
                      :: p_abgg
                           (GHC.Types.Char, [GHC.Types.Char])
                           (f_abgh (GHC.Types.Char, [GHC.Types.Char]))
                         -> p_abgg
                              (Data.Either.Either
                                 [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                              (Data.Either.Either
                                 [GHC.Types.Char] (f_abgh (GHC.Types.Char, [GHC.Types.Char])))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abgH
                      = Data.Profunctor.Choice.right'
                          @p_abgg
                          $dChoice_abgi
                          @(GHC.Types.Char, [GHC.Types.Char])
                          @(f_abgh (GHC.Types.Char, [GHC.Types.Char]))
                          @[GHC.Types.Char] } in
                  \ (x_abgI
                       :: p_abgg
                            (GHC.Types.Char, [GHC.Types.Char])
                            (f_abgh (GHC.Types.Char, [GHC.Types.Char]))) ->
                    f1_abgk (g_abgH x_abgI))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <[GHC.Types.Char]>_N
                                <[GHC.Types.Char]>_N
                                <GHC.Types.Char>_N
                                <GHC.Types.Char>_N)
                       :: Control.Lens.Type.Prism
                            [GHC.Types.Char]
                            [GHC.Types.Char]
                            (GHC.Types.Char, [GHC.Types.Char])
                            (GHC.Types.Char, [GHC.Types.Char])
                          ~R# Control.Lens.Cons.Cons
                                [GHC.Types.Char] [GHC.Types.Char] GHC.Types.Char GHC.Types.Char))
              ((\ (@(p_abgg :: * -> * -> *))
                  (@(f_abgh :: * -> *))
                  ($dChoice_abgi :: Data.Profunctor.Choice.Choice p_abgg)
                  ($dApplicative_abgj :: GHC.Base.Applicative f_abgh) ->
                  let {
                    f1_abgk
                      :: p_abgg
                           (Data.Either.Either
                              [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                           (Data.Either.Either
                              [GHC.Types.Char] (f_abgh (GHC.Types.Char, [GHC.Types.Char])))
                         -> p_abgg [GHC.Types.Char] (f_abgh [GHC.Types.Char])
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 320 0}]
                    f1_abgk
                      = Data.Profunctor.Unsafe.dimap
                          @p_abgg
                          (Data.Profunctor.Choice.$p1Choice @p_abgg $dChoice_abgi)
                          @[GHC.Types.Char]
                          @(Data.Either.Either
                              [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                          @(Data.Either.Either
                              [GHC.Types.Char] (f_abgh (GHC.Types.Char, [GHC.Types.Char])))
                          @(f_abgh [GHC.Types.Char])
                          (\ (aas_abgl :: [GHC.Types.Char]) ->
                             case aas_abgl of {
                               [] ->
                                 Data.Either.Left
                                   @[GHC.Types.Char]
                                   @(GHC.Types.Char, [GHC.Types.Char])
                                   (GHC.Types.[] @GHC.Types.Char);
                               : a1_abgn as_abgo ->
                                 Data.Either.Right
                                   @[GHC.Types.Char]
                                   @(GHC.Types.Char, [GHC.Types.Char])
                                   (a1_abgn, as_abgo)
                             })
                          (let {
                             f2_abgq :: [GHC.Types.Char] -> f_abgh [GHC.Types.Char]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abgq
                               = GHC.Base.pure @f_abgh $dApplicative_abgj @[GHC.Types.Char] } in
                           let {
                             ds2_abgr
                               :: f_abgh (GHC.Types.Char, [GHC.Types.Char])
                                  -> f_abgh [GHC.Types.Char]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 90 0}]
                             ds2_abgr
                               = GHC.Base.fmap
                                   @f_abgh
                                   (GHC.Base.$p1Applicative @f_abgh $dApplicative_abgj)
                                   @(GHC.Types.Char, [GHC.Types.Char])
                                   @[GHC.Types.Char]
                                   (\ (p1_abgs :: (GHC.Types.Char, [GHC.Types.Char])) ->
                                      GHC.Types.:
                                        @GHC.Types.Char
                                        (case p1_abgs of { (x_abgu, ds_abgv) -> x_abgu })
                                        (case p1_abgs of { (ds_abgy, y_abgz) -> y_abgz })) } in
                           \ (ds3_abgB
                                :: Data.Either.Either
                                     [GHC.Types.Char]
                                     (f_abgh (GHC.Types.Char, [GHC.Types.Char]))) ->
                             case ds3_abgB of {
                               Data.Either.Left x_abgD -> f2_abgq x_abgD;
                               Data.Either.Right y_abgF -> ds2_abgr y_abgF
                             }) } in
                  let {
                    g_abgH
                      :: p_abgg
                           (GHC.Types.Char, [GHC.Types.Char])
                           (f_abgh (GHC.Types.Char, [GHC.Types.Char]))
                         -> p_abgg
                              (Data.Either.Either
                                 [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                              (Data.Either.Either
                                 [GHC.Types.Char] (f_abgh (GHC.Types.Char, [GHC.Types.Char])))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abgH
                      = Data.Profunctor.Choice.right'
                          @p_abgg
                          $dChoice_abgi
                          @(GHC.Types.Char, [GHC.Types.Char])
                          @(f_abgh (GHC.Types.Char, [GHC.Types.Char]))
                          @[GHC.Types.Char] } in
                  \ (x_abgI
                       :: p_abgg
                            (GHC.Types.Char, [GHC.Types.Char])
                            (f_abgh (GHC.Types.Char, [GHC.Types.Char]))) ->
                    f1_abgk (g_abgH x_abgI))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <[GHC.Types.Char]>_N
                                <[GHC.Types.Char]>_N
                                <GHC.Types.Char>_N
                                <GHC.Types.Char>_N)
                       :: Control.Lens.Type.Prism
                            [GHC.Types.Char]
                            [GHC.Types.Char]
                            (GHC.Types.Char, [GHC.Types.Char])
                            (GHC.Types.Char, [GHC.Types.Char])
                          ~R# Control.Lens.Cons.Cons
                                [GHC.Types.Char] [GHC.Types.Char] GHC.Types.Char GHC.Types.Char))
              ((\ (@(p_abgN :: * -> * -> *))
                  (@(f_abgO :: * -> *))
                  ($dChoice_abgP :: Data.Profunctor.Choice.Choice p_abgN)
                  ($dApplicative_abgQ :: GHC.Base.Applicative f_abgO) ->
                  let {
                    f1_abgR
                      :: p_abgN
                           (Data.Either.Either [GHC.Types.Char] ())
                           (Data.Either.Either [GHC.Types.Char] (f_abgO ()))
                         -> p_abgN [GHC.Types.Char] (f_abgO [GHC.Types.Char])
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 290 0}]
                    f1_abgR
                      = Data.Profunctor.Unsafe.dimap
                          @p_abgN
                          (Data.Profunctor.Choice.$p1Choice @p_abgN $dChoice_abgP)
                          @[GHC.Types.Char]
                          @(Data.Either.Either [GHC.Types.Char] ())
                          @(Data.Either.Either [GHC.Types.Char] (f_abgO ()))
                          @(f_abgO [GHC.Types.Char])
                          (\ (s_abgS :: [GHC.Types.Char]) ->
                             case s_abgS of wild_abgT {
                               [] -> Data.Either.Right @[GHC.Types.Char] @() GHC.Tuple.Prim.();
                               : ds1_abgU ds2_abgV ->
                                 Data.Either.Left @[GHC.Types.Char] @() wild_abgT
                             })
                          (let {
                             f2_abgX :: [GHC.Types.Char] -> f_abgO [GHC.Types.Char]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abgX
                               = GHC.Base.pure @f_abgO $dApplicative_abgQ @[GHC.Types.Char] } in
                           let {
                             ds2_abgY :: f_abgO () -> f_abgO [GHC.Types.Char]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 70 0}]
                             ds2_abgY
                               = GHC.Base.fmap
                                   @f_abgO
                                   (GHC.Base.$p1Applicative @f_abgO $dApplicative_abgQ)
                                   @()
                                   @[GHC.Types.Char]
                                   (\ (ds3_abgZ :: ()) ->
                                      case ds3_abgZ of { () -> GHC.Types.[] @GHC.Types.Char }) } in
                           \ (ds3_abh1 :: Data.Either.Either [GHC.Types.Char] (f_abgO ())) ->
                             case ds3_abh1 of {
                               Data.Either.Left x_abh3 -> f2_abgX x_abh3;
                               Data.Either.Right y_abh5 -> ds2_abgY y_abh5
                             }) } in
                  let {
                    g_abh7
                      :: p_abgN () (f_abgO ())
                         -> p_abgN
                              (Data.Either.Either [GHC.Types.Char] ())
                              (Data.Either.Either [GHC.Types.Char] (f_abgO ()))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abh7
                      = Data.Profunctor.Choice.right'
                          @p_abgN $dChoice_abgP @() @(f_abgO ()) @[GHC.Types.Char] } in
                  \ (x_abh8 :: p_abgN () (f_abgO ())) -> f1_abgR (g_abh7 x_abh8))
               `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0] <[GHC.Types.Char]>_N)
                       :: Control.Lens.Type.Prism' [GHC.Types.Char] ()
                          ~R# Control.Lens.Empty.AsEmpty [GHC.Types.Char]))
              (Data.Functor.Contravariant.$fContravariantConst @[GHC.Types.Char])
              (Data.Functor.Const.$fFunctorConst @[GHC.Types.Char])
    Cont:   ApplyToVal nodup hole Control.Lens.Getter.Getting
                                    GHC.Base.String [GHC.Types.Char] GHC.Base.String
              ((\ (ds_abeK [Occ=Once1] :: a_abeH) -> ds_abeK)
               `cast` (<a_abeH>_R
                       %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                          <*>_N <a_abeH>_R <a_abeH>_P)
                       :: (a_abeH -> a_abeH)
                          ~R# (a_abeH -> Data.Functor.Const.Const a_abeH a_abeH)))
            ApplyToVal nodup hole [GHC.Types.Char]
                                  -> Data.Functor.Const.Const GHC.Base.String [GHC.Types.Char]
              s_a8Km
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N <GHC.Base.String>_R <[GHC.Types.Char]>_P
                    :: Data.Functor.Const.Const GHC.Base.String [GHC.Types.Char]
                       ~R# GHC.Base.String)
            Stop[RuleArgCtxt] GHC.Base.String
Rule fired
    Rule: eqString
    Module: (GHC.Base)
    Before: GHC.Classes.==
              TyArg GHC.Base.String
              ValArg GHC.Classes.$fEqList_$s$fEqList1
              ValArg s_a8Km
              ValArg s_a8Km
    After:  (\ ($dEq_ab0v :: GHC.Classes.Eq GHC.Base.String) ->
               GHC.Base.eqString)
              GHC.Classes.$fEqList_$s$fEqList1
              ValArg s_a8Km ValArg s_a8Km
    Cont:   Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: unpack
    Module: (GHC.Base)
    Before: GHC.CString.unpackCString# ValArg "T -> T"#
    After:  (\ (a_ab7z :: GHC.Prim.Addr#) ->
               GHC.Base.build
                 @GHC.Types.Char
                 (\ (@b_ab7A) -> GHC.CString.unpackFoldrCString# @b_ab7A a_ab7z))
              "T -> T"#
    Cont:   Stop[BoringCtxt] Test.Tasty.Core.TestName
Rule fired
    Rule: Class op property
    Module: (BUILTIN)
    Before: Test.QuickCheck.Property.property
              TyArg Data.Text.Internal.Text -> GHC.Types.Bool
              ValArg $dTestable_a98O
    After:  Test.QuickCheck.Property.$fTestableFUN_$cproperty
              @Data.Text.Internal.Text
              @GHC.Types.Bool
              Test.QuickCheck.Instances.Text.$fArbitraryText0
              Data.Text.Show.$fShowText
              Test.QuickCheck.Property.$fTestableBool
    Cont:   ApplyToVal nodup hole (Data.Text.Internal.Text
                                   -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              prop_ab7M
            CastIt (Sym (Test.Tasty.QuickCheck.N:QC[0])
                    :: Test.QuickCheck.Property.Property ~R# Test.Tasty.QuickCheck.QC)
            Stop[BoringCtxt] Test.Tasty.QuickCheck.QC
Rule fired
    Rule: Class op propertyForAllShrinkShow
    Module: (BUILTIN)
    Before: Test.QuickCheck.Property.propertyForAllShrinkShow
              TyArg GHC.Types.Bool ValArg Test.QuickCheck.Property.$fTestableBool
    After:  Test.QuickCheck.Property.$fTestableBool1
            `cast` (forall (a :: <*>_N).
                    <Test.QuickCheck.Gen.Gen a>_R
                    %<'GHC.Types.Many>_N ->_R <a -> [a]>_R
                    %<'GHC.Types.Many>_N ->_R <a -> [GHC.Base.String]>_R
                    %<'GHC.Types.Many>_N ->_R <a -> GHC.Types.Bool>_R
                    %<'GHC.Types.Many>_N ->_R Sym (Test.QuickCheck.Gen.N:Gen[0]
                                                       (Test.QuickCheck.Property.N:Prop[0]))
                                              ; Sym (Test.QuickCheck.Property.N:Property[0])
                    :: (forall {a}.
                        Test.QuickCheck.Gen.Gen a
                        -> (a -> [a])
                        -> (a -> [GHC.Base.String])
                        -> (a -> GHC.Types.Bool)
                        -> Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int
                        -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result)
                       ~R# (forall {a}.
                            Test.QuickCheck.Gen.Gen a
                            -> (a -> [a])
                            -> (a -> [GHC.Base.String])
                            -> (a -> GHC.Types.Bool)
                            -> Test.QuickCheck.Property.Property))
    Cont:   ApplyToTy Data.Text.Internal.Text
            ApplyToVal nodup hole Test.QuickCheck.Gen.Gen
                                    Data.Text.Internal.Text
                                  -> (Data.Text.Internal.Text -> [Data.Text.Internal.Text])
                                  -> (Data.Text.Internal.Text -> [GHC.Base.String])
                                  -> (Data.Text.Internal.Text -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (Test.QuickCheck.Arbitrary.arbitrary @a_ab9u $dArbitrary_ab9w)
            ApplyToVal nodup hole (Data.Text.Internal.Text
                                   -> [Data.Text.Internal.Text])
                                  -> (Data.Text.Internal.Text -> [GHC.Base.String])
                                  -> (Data.Text.Internal.Text -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (Test.QuickCheck.Arbitrary.shrink @a_ab9u $dArbitrary_ab9w)
            ApplyToVal nodup hole (Data.Text.Internal.Text
                                   -> [GHC.Base.String])
                                  -> (Data.Text.Internal.Text -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (let {
                 g_ab9A [Occ=OnceL1!] :: a_ab9u -> GHC.Base.String
                 [LclId]
                 g_ab9A = GHC.Show.show @a_ab9u $dShow_ab9x } in
               \ (x_ab9B [Occ=Once1] :: a_ab9u) ->
                 GHC.Types.:
                   @GHC.Base.String (g_ab9A x_ab9B) (GHC.Types.[] @GHC.Base.String))
            ApplyToVal nodup hole (Data.Text.Internal.Text -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              f_ab9z
            CastIt (Sym (Test.Tasty.QuickCheck.N:QC[0])
                    :: Test.QuickCheck.Property.Property ~R# Test.Tasty.QuickCheck.QC)
            Stop[BoringCtxt] Test.Tasty.QuickCheck.QC
Rule fired
    Rule: Class op arbitrary
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.arbitrary
              TyArg Data.Text.Internal.Text
              ValArg Test.QuickCheck.Instances.Text.$fArbitraryText0
    After:  Test.QuickCheck.Instances.Text.$fArbitraryText3
            `cast` (Sym (Test.QuickCheck.Gen.N:Gen[0]
                             <Data.Text.Internal.Text>_R)
                    :: (Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int -> Data.Text.Internal.Text)
                       ~R# Test.QuickCheck.Gen.Gen Data.Text.Internal.Text)
    Cont:   Stop[BoringCtxt] Test.QuickCheck.Gen.Gen
                               Data.Text.Internal.Text
Rule fired
    Rule: Class op shrink
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.shrink
              TyArg Data.Text.Internal.Text
              ValArg Test.QuickCheck.Instances.Text.$fArbitraryText0
    After:  Test.QuickCheck.Instances.Text.$fArbitraryText0_$cshrink
    Cont:   Stop[BoringCtxt] Data.Text.Internal.Text
                             -> [Data.Text.Internal.Text]
Rule fired
    Rule: Class op show
    Module: (BUILTIN)
    Before: GHC.Show.show
              TyArg Data.Text.Internal.Text ValArg Data.Text.Show.$fShowText
    After:  Data.Text.Show.$fShowText_$cshow
    Cont:   Stop[RhsCtxt(NonRecursive)] Data.Text.Internal.Text
                                        -> GHC.Base.String
Rule fired
    Rule: Class op reader
    Module: (BUILTIN)
    Before: Control.Monad.Reader.Class.reader
              TyArg Data.Text.Internal.Text
              TyArg (->) Data.Text.Internal.Text
              ValArg Control.Monad.Reader.Class.$fMonadReaderrFUN
                       @Data.Text.Internal.Text
    After:  \ (@a_abeP) ->
              GHC.Base.id @(Data.Text.Internal.Text -> a_abeP)
    Cont:   ApplyToTy Data.Text.Internal.Text
            ApplyToVal nodup hole (Data.Text.Internal.Text
                                   -> Data.Text.Internal.Text)
                                  -> Data.Text.Internal.Text -> Data.Text.Internal.Text
              ((l_abeJ
                  ((\ (ds_abeK [Occ=Once1] :: a_abeH) -> ds_abeK)
                   `cast` (<a_abeH>_R
                           %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                              <*>_N <a_abeH>_R <a_abeH>_P)
                           :: (a_abeH -> a_abeH)
                              ~R# (a_abeH -> Data.Functor.Const.Const a_abeH a_abeH))))
               `cast` (<s_abeF>_R
                       %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                     <*>_N <a_abeH>_R <s_abeF>_P
                       :: (s_abeF -> Data.Functor.Const.Const a_abeH s_abeF)
                          ~R# (s_abeF -> a_abeH)))
            ApplyToVal nodup hole Data.Text.Internal.Text
                                  -> Data.Text.Internal.Text
              s_a8Kt
            Stop[RuleArgCtxt] Data.Text.Internal.Text
Rule fired
    Rule: recons/id
    Module: (Control.Lens.Cons.Extras)
    Before: Control.Lens.Cons.Extras.recons
              TyArg Data.Text.Internal.Text
              TyArg GHC.Types.Char
              TyArg Data.Text.Internal.Text
              ValArg (\ (@(p_abig :: * -> * -> *))
                        (@(f_abih :: * -> *))
                        ($dChoice_abii :: Data.Profunctor.Choice.Choice p_abig)
                        ($dApplicative_abij :: GHC.Base.Applicative f_abih) ->
                        let {
                          f1_abik
                            :: p_abig
                                 (Data.Either.Either
                                    Data.Text.Internal.Text
                                    (GHC.Types.Char, Data.Text.Internal.Text))
                                 (Data.Either.Either
                                    Data.Text.Internal.Text
                                    (f_abih (GHC.Types.Char, Data.Text.Internal.Text)))
                               -> p_abig Data.Text.Internal.Text (f_abih Data.Text.Internal.Text)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 340 0}]
                          f1_abik
                            = Data.Profunctor.Unsafe.dimap
                                @p_abig
                                (Data.Profunctor.Choice.$p1Choice @p_abig $dChoice_abii)
                                @Data.Text.Internal.Text
                                @(Data.Either.Either
                                    Data.Text.Internal.Text
                                    (GHC.Types.Char, Data.Text.Internal.Text))
                                @(Data.Either.Either
                                    Data.Text.Internal.Text
                                    (f_abih (GHC.Types.Char, Data.Text.Internal.Text)))
                                @(f_abih Data.Text.Internal.Text)
                                (\ (s1_abil :: Data.Text.Internal.Text) ->
                                   case Data.Text.uncons s1_abil of {
                                     GHC.Maybe.Nothing ->
                                       Data.Either.Left
                                         @Data.Text.Internal.Text
                                         @(GHC.Types.Char, Data.Text.Internal.Text)
                                         s1_abil;
                                     GHC.Maybe.Just x_abio ->
                                       Data.Either.Right
                                         @Data.Text.Internal.Text
                                         @(GHC.Types.Char, Data.Text.Internal.Text)
                                         x_abio
                                   })
                                (let {
                                   f2_abiq
                                     :: Data.Text.Internal.Text -> f_abih Data.Text.Internal.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abiq
                                     = GHC.Base.pure
                                         @f_abih $dApplicative_abij @Data.Text.Internal.Text } in
                                 let {
                                   ds2_abir
                                     :: f_abih (GHC.Types.Char, Data.Text.Internal.Text)
                                        -> f_abih Data.Text.Internal.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 100 0}]
                                   ds2_abir
                                     = GHC.Base.fmap
                                         @f_abih
                                         (GHC.Base.$p1Applicative @f_abih $dApplicative_abij)
                                         @(GHC.Types.Char, Data.Text.Internal.Text)
                                         @Data.Text.Internal.Text
                                         (\ (p1_abis
                                               :: (GHC.Types.Char, Data.Text.Internal.Text)) ->
                                            case p1_abis of { (x_abiu, ds_abiv) ->
                                            Data.Text.cons x_abiu ds_abiv
                                            }) } in
                                 \ (ds3_abix
                                      :: Data.Either.Either
                                           Data.Text.Internal.Text
                                           (f_abih (GHC.Types.Char, Data.Text.Internal.Text))) ->
                                   case ds3_abix of {
                                     Data.Either.Left x_abiz -> f2_abiq x_abiz;
                                     Data.Either.Right y_abiB -> ds2_abir y_abiB
                                   }) } in
                        let {
                          g_abiD
                            :: p_abig
                                 (GHC.Types.Char, Data.Text.Internal.Text)
                                 (f_abih (GHC.Types.Char, Data.Text.Internal.Text))
                               -> p_abig
                                    (Data.Either.Either
                                       Data.Text.Internal.Text
                                       (GHC.Types.Char, Data.Text.Internal.Text))
                                    (Data.Either.Either
                                       Data.Text.Internal.Text
                                       (f_abih (GHC.Types.Char, Data.Text.Internal.Text)))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abiD
                            = Data.Profunctor.Choice.right'
                                @p_abig
                                $dChoice_abii
                                @(GHC.Types.Char, Data.Text.Internal.Text)
                                @(f_abih (GHC.Types.Char, Data.Text.Internal.Text))
                                @Data.Text.Internal.Text } in
                        \ (x_abiE
                             :: p_abig
                                  (GHC.Types.Char, Data.Text.Internal.Text)
                                  (f_abih (GHC.Types.Char, Data.Text.Internal.Text))) ->
                          f1_abik (g_abiD x_abiE))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <Data.Text.Internal.Text>_N
                                      <Data.Text.Internal.Text>_N
                                      <GHC.Types.Char>_N
                                      <GHC.Types.Char>_N)
                             :: Control.Lens.Type.Prism
                                  Data.Text.Internal.Text
                                  Data.Text.Internal.Text
                                  (GHC.Types.Char, Data.Text.Internal.Text)
                                  (GHC.Types.Char, Data.Text.Internal.Text)
                                ~R# Control.Lens.Cons.Cons
                                      Data.Text.Internal.Text
                                      Data.Text.Internal.Text
                                      GHC.Types.Char
                                      GHC.Types.Char)
              ValArg (\ (@(p_abig :: * -> * -> *))
                        (@(f_abih :: * -> *))
                        ($dChoice_abii :: Data.Profunctor.Choice.Choice p_abig)
                        ($dApplicative_abij :: GHC.Base.Applicative f_abih) ->
                        let {
                          f1_abik
                            :: p_abig
                                 (Data.Either.Either
                                    Data.Text.Internal.Text
                                    (GHC.Types.Char, Data.Text.Internal.Text))
                                 (Data.Either.Either
                                    Data.Text.Internal.Text
                                    (f_abih (GHC.Types.Char, Data.Text.Internal.Text)))
                               -> p_abig Data.Text.Internal.Text (f_abih Data.Text.Internal.Text)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 340 0}]
                          f1_abik
                            = Data.Profunctor.Unsafe.dimap
                                @p_abig
                                (Data.Profunctor.Choice.$p1Choice @p_abig $dChoice_abii)
                                @Data.Text.Internal.Text
                                @(Data.Either.Either
                                    Data.Text.Internal.Text
                                    (GHC.Types.Char, Data.Text.Internal.Text))
                                @(Data.Either.Either
                                    Data.Text.Internal.Text
                                    (f_abih (GHC.Types.Char, Data.Text.Internal.Text)))
                                @(f_abih Data.Text.Internal.Text)
                                (\ (s1_abil :: Data.Text.Internal.Text) ->
                                   case Data.Text.uncons s1_abil of {
                                     GHC.Maybe.Nothing ->
                                       Data.Either.Left
                                         @Data.Text.Internal.Text
                                         @(GHC.Types.Char, Data.Text.Internal.Text)
                                         s1_abil;
                                     GHC.Maybe.Just x_abio ->
                                       Data.Either.Right
                                         @Data.Text.Internal.Text
                                         @(GHC.Types.Char, Data.Text.Internal.Text)
                                         x_abio
                                   })
                                (let {
                                   f2_abiq
                                     :: Data.Text.Internal.Text -> f_abih Data.Text.Internal.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abiq
                                     = GHC.Base.pure
                                         @f_abih $dApplicative_abij @Data.Text.Internal.Text } in
                                 let {
                                   ds2_abir
                                     :: f_abih (GHC.Types.Char, Data.Text.Internal.Text)
                                        -> f_abih Data.Text.Internal.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 100 0}]
                                   ds2_abir
                                     = GHC.Base.fmap
                                         @f_abih
                                         (GHC.Base.$p1Applicative @f_abih $dApplicative_abij)
                                         @(GHC.Types.Char, Data.Text.Internal.Text)
                                         @Data.Text.Internal.Text
                                         (\ (p1_abis
                                               :: (GHC.Types.Char, Data.Text.Internal.Text)) ->
                                            case p1_abis of { (x_abiu, ds_abiv) ->
                                            Data.Text.cons x_abiu ds_abiv
                                            }) } in
                                 \ (ds3_abix
                                      :: Data.Either.Either
                                           Data.Text.Internal.Text
                                           (f_abih (GHC.Types.Char, Data.Text.Internal.Text))) ->
                                   case ds3_abix of {
                                     Data.Either.Left x_abiz -> f2_abiq x_abiz;
                                     Data.Either.Right y_abiB -> ds2_abir y_abiB
                                   }) } in
                        let {
                          g_abiD
                            :: p_abig
                                 (GHC.Types.Char, Data.Text.Internal.Text)
                                 (f_abih (GHC.Types.Char, Data.Text.Internal.Text))
                               -> p_abig
                                    (Data.Either.Either
                                       Data.Text.Internal.Text
                                       (GHC.Types.Char, Data.Text.Internal.Text))
                                    (Data.Either.Either
                                       Data.Text.Internal.Text
                                       (f_abih (GHC.Types.Char, Data.Text.Internal.Text)))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abiD
                            = Data.Profunctor.Choice.right'
                                @p_abig
                                $dChoice_abii
                                @(GHC.Types.Char, Data.Text.Internal.Text)
                                @(f_abih (GHC.Types.Char, Data.Text.Internal.Text))
                                @Data.Text.Internal.Text } in
                        \ (x_abiE
                             :: p_abig
                                  (GHC.Types.Char, Data.Text.Internal.Text)
                                  (f_abih (GHC.Types.Char, Data.Text.Internal.Text))) ->
                          f1_abik (g_abiD x_abiE))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <Data.Text.Internal.Text>_N
                                      <Data.Text.Internal.Text>_N
                                      <GHC.Types.Char>_N
                                      <GHC.Types.Char>_N)
                             :: Control.Lens.Type.Prism
                                  Data.Text.Internal.Text
                                  Data.Text.Internal.Text
                                  (GHC.Types.Char, Data.Text.Internal.Text)
                                  (GHC.Types.Char, Data.Text.Internal.Text)
                                ~R# Control.Lens.Cons.Cons
                                      Data.Text.Internal.Text
                                      Data.Text.Internal.Text
                                      GHC.Types.Char
                                      GHC.Types.Char)
              ValArg (\ (@(p_abiF :: * -> * -> *))
                        (@(f_abiG :: * -> *))
                        ($dChoice_abiH :: Data.Profunctor.Choice.Choice p_abiF)
                        ($dApplicative_abiI :: GHC.Base.Applicative f_abiG) ->
                        let {
                          f1_abiJ
                            :: p_abiF
                                 (Data.Either.Either Data.Text.Internal.Text ())
                                 (Data.Either.Either Data.Text.Internal.Text (f_abiG ()))
                               -> p_abiF Data.Text.Internal.Text (f_abiG Data.Text.Internal.Text)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 310 0}]
                          f1_abiJ
                            = Data.Profunctor.Unsafe.dimap
                                @p_abiF
                                (Data.Profunctor.Choice.$p1Choice @p_abiF $dChoice_abiH)
                                @Data.Text.Internal.Text
                                @(Data.Either.Either Data.Text.Internal.Text ())
                                @(Data.Either.Either Data.Text.Internal.Text (f_abiG ()))
                                @(f_abiG Data.Text.Internal.Text)
                                (\ (s_abiK :: Data.Text.Internal.Text) ->
                                   case Data.Text.null s_abiK of {
                                     GHC.Types.False ->
                                       Data.Either.Left @Data.Text.Internal.Text @() s_abiK;
                                     GHC.Types.True ->
                                       Data.Either.Right
                                         @Data.Text.Internal.Text @() GHC.Tuple.Prim.()
                                   })
                                (let {
                                   f2_abiN
                                     :: Data.Text.Internal.Text -> f_abiG Data.Text.Internal.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abiN
                                     = GHC.Base.pure
                                         @f_abiG $dApplicative_abiI @Data.Text.Internal.Text } in
                                 let {
                                   ds2_abiO :: f_abiG () -> f_abiG Data.Text.Internal.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 70 0}]
                                   ds2_abiO
                                     = GHC.Base.fmap
                                         @f_abiG
                                         (GHC.Base.$p1Applicative @f_abiG $dApplicative_abiI)
                                         @()
                                         @Data.Text.Internal.Text
                                         (\ (ds3_abiP :: ()) ->
                                            case ds3_abiP of { () ->
                                            Data.Text.Internal.empty
                                            }) } in
                                 \ (ds3_abiR
                                      :: Data.Either.Either Data.Text.Internal.Text (f_abiG ())) ->
                                   case ds3_abiR of {
                                     Data.Either.Left x_abiT -> f2_abiN x_abiT;
                                     Data.Either.Right y_abiV -> ds2_abiO y_abiV
                                   }) } in
                        let {
                          g_abiX
                            :: p_abiF () (f_abiG ())
                               -> p_abiF
                                    (Data.Either.Either Data.Text.Internal.Text ())
                                    (Data.Either.Either Data.Text.Internal.Text (f_abiG ()))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abiX
                            = Data.Profunctor.Choice.right'
                                @p_abiF
                                $dChoice_abiH
                                @()
                                @(f_abiG ())
                                @Data.Text.Internal.Text } in
                        \ (x_abiY :: p_abiF () (f_abiG ())) -> f1_abiJ (g_abiX x_abiY))
                     `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                      <Data.Text.Internal.Text>_N)
                             :: Control.Lens.Type.Prism' Data.Text.Internal.Text ()
                                ~R# Control.Lens.Empty.AsEmpty Data.Text.Internal.Text)
              TyArg Data.Functor.Const.Const Data.Text.Internal.Text
              ValArg Data.Functor.Contravariant.$fContravariantConst
                       @Data.Text.Internal.Text
              ValArg Data.Functor.Const.$fFunctorConst @Data.Text.Internal.Text
    After:  (\ (@s1_abfO)
               (@(f_abfP :: * -> *))
               (@a_abfQ)
               ($dCons_abfR
                  :: Control.Lens.Cons.Cons s1_abfO s1_abfO a_abfQ a_abfQ)
               ($dCons1_abfS
                  :: Control.Lens.Cons.Cons s1_abfO s1_abfO a_abfQ a_abfQ)
               ($dAsEmpty_abfT :: Control.Lens.Empty.AsEmpty s1_abfO)
               ($dContravariant_abfU
                  :: Data.Functor.Contravariant.Contravariant f_abfP)
               ($dFunctor_abfV :: GHC.Base.Functor f_abfP) ->
               GHC.Base.id @(s1_abfO -> f_abfP s1_abfO))
              @Data.Text.Internal.Text
              @(Data.Functor.Const.Const Data.Text.Internal.Text)
              @GHC.Types.Char
              ((\ (@(p_abig :: * -> * -> *))
                  (@(f_abih :: * -> *))
                  ($dChoice_abii :: Data.Profunctor.Choice.Choice p_abig)
                  ($dApplicative_abij :: GHC.Base.Applicative f_abih) ->
                  let {
                    f1_abik
                      :: p_abig
                           (Data.Either.Either
                              Data.Text.Internal.Text (GHC.Types.Char, Data.Text.Internal.Text))
                           (Data.Either.Either
                              Data.Text.Internal.Text
                              (f_abih (GHC.Types.Char, Data.Text.Internal.Text)))
                         -> p_abig Data.Text.Internal.Text (f_abih Data.Text.Internal.Text)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 340 0}]
                    f1_abik
                      = Data.Profunctor.Unsafe.dimap
                          @p_abig
                          (Data.Profunctor.Choice.$p1Choice @p_abig $dChoice_abii)
                          @Data.Text.Internal.Text
                          @(Data.Either.Either
                              Data.Text.Internal.Text (GHC.Types.Char, Data.Text.Internal.Text))
                          @(Data.Either.Either
                              Data.Text.Internal.Text
                              (f_abih (GHC.Types.Char, Data.Text.Internal.Text)))
                          @(f_abih Data.Text.Internal.Text)
                          (\ (s1_abil :: Data.Text.Internal.Text) ->
                             case Data.Text.uncons s1_abil of {
                               GHC.Maybe.Nothing ->
                                 Data.Either.Left
                                   @Data.Text.Internal.Text
                                   @(GHC.Types.Char, Data.Text.Internal.Text)
                                   s1_abil;
                               GHC.Maybe.Just x_abio ->
                                 Data.Either.Right
                                   @Data.Text.Internal.Text
                                   @(GHC.Types.Char, Data.Text.Internal.Text)
                                   x_abio
                             })
                          (let {
                             f2_abiq
                               :: Data.Text.Internal.Text -> f_abih Data.Text.Internal.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abiq
                               = GHC.Base.pure
                                   @f_abih $dApplicative_abij @Data.Text.Internal.Text } in
                           let {
                             ds2_abir
                               :: f_abih (GHC.Types.Char, Data.Text.Internal.Text)
                                  -> f_abih Data.Text.Internal.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 100 0}]
                             ds2_abir
                               = GHC.Base.fmap
                                   @f_abih
                                   (GHC.Base.$p1Applicative @f_abih $dApplicative_abij)
                                   @(GHC.Types.Char, Data.Text.Internal.Text)
                                   @Data.Text.Internal.Text
                                   (\ (p1_abis :: (GHC.Types.Char, Data.Text.Internal.Text)) ->
                                      case p1_abis of { (x_abiu, ds_abiv) ->
                                      Data.Text.cons x_abiu ds_abiv
                                      }) } in
                           \ (ds3_abix
                                :: Data.Either.Either
                                     Data.Text.Internal.Text
                                     (f_abih (GHC.Types.Char, Data.Text.Internal.Text))) ->
                             case ds3_abix of {
                               Data.Either.Left x_abiz -> f2_abiq x_abiz;
                               Data.Either.Right y_abiB -> ds2_abir y_abiB
                             }) } in
                  let {
                    g_abiD
                      :: p_abig
                           (GHC.Types.Char, Data.Text.Internal.Text)
                           (f_abih (GHC.Types.Char, Data.Text.Internal.Text))
                         -> p_abig
                              (Data.Either.Either
                                 Data.Text.Internal.Text (GHC.Types.Char, Data.Text.Internal.Text))
                              (Data.Either.Either
                                 Data.Text.Internal.Text
                                 (f_abih (GHC.Types.Char, Data.Text.Internal.Text)))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abiD
                      = Data.Profunctor.Choice.right'
                          @p_abig
                          $dChoice_abii
                          @(GHC.Types.Char, Data.Text.Internal.Text)
                          @(f_abih (GHC.Types.Char, Data.Text.Internal.Text))
                          @Data.Text.Internal.Text } in
                  \ (x_abiE
                       :: p_abig
                            (GHC.Types.Char, Data.Text.Internal.Text)
                            (f_abih (GHC.Types.Char, Data.Text.Internal.Text))) ->
                    f1_abik (g_abiD x_abiE))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <Data.Text.Internal.Text>_N
                                <Data.Text.Internal.Text>_N
                                <GHC.Types.Char>_N
                                <GHC.Types.Char>_N)
                       :: Control.Lens.Type.Prism
                            Data.Text.Internal.Text
                            Data.Text.Internal.Text
                            (GHC.Types.Char, Data.Text.Internal.Text)
                            (GHC.Types.Char, Data.Text.Internal.Text)
                          ~R# Control.Lens.Cons.Cons
                                Data.Text.Internal.Text
                                Data.Text.Internal.Text
                                GHC.Types.Char
                                GHC.Types.Char))
              ((\ (@(p_abig :: * -> * -> *))
                  (@(f_abih :: * -> *))
                  ($dChoice_abii :: Data.Profunctor.Choice.Choice p_abig)
                  ($dApplicative_abij :: GHC.Base.Applicative f_abih) ->
                  let {
                    f1_abik
                      :: p_abig
                           (Data.Either.Either
                              Data.Text.Internal.Text (GHC.Types.Char, Data.Text.Internal.Text))
                           (Data.Either.Either
                              Data.Text.Internal.Text
                              (f_abih (GHC.Types.Char, Data.Text.Internal.Text)))
                         -> p_abig Data.Text.Internal.Text (f_abih Data.Text.Internal.Text)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 340 0}]
                    f1_abik
                      = Data.Profunctor.Unsafe.dimap
                          @p_abig
                          (Data.Profunctor.Choice.$p1Choice @p_abig $dChoice_abii)
                          @Data.Text.Internal.Text
                          @(Data.Either.Either
                              Data.Text.Internal.Text (GHC.Types.Char, Data.Text.Internal.Text))
                          @(Data.Either.Either
                              Data.Text.Internal.Text
                              (f_abih (GHC.Types.Char, Data.Text.Internal.Text)))
                          @(f_abih Data.Text.Internal.Text)
                          (\ (s1_abil :: Data.Text.Internal.Text) ->
                             case Data.Text.uncons s1_abil of {
                               GHC.Maybe.Nothing ->
                                 Data.Either.Left
                                   @Data.Text.Internal.Text
                                   @(GHC.Types.Char, Data.Text.Internal.Text)
                                   s1_abil;
                               GHC.Maybe.Just x_abio ->
                                 Data.Either.Right
                                   @Data.Text.Internal.Text
                                   @(GHC.Types.Char, Data.Text.Internal.Text)
                                   x_abio
                             })
                          (let {
                             f2_abiq
                               :: Data.Text.Internal.Text -> f_abih Data.Text.Internal.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abiq
                               = GHC.Base.pure
                                   @f_abih $dApplicative_abij @Data.Text.Internal.Text } in
                           let {
                             ds2_abir
                               :: f_abih (GHC.Types.Char, Data.Text.Internal.Text)
                                  -> f_abih Data.Text.Internal.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 100 0}]
                             ds2_abir
                               = GHC.Base.fmap
                                   @f_abih
                                   (GHC.Base.$p1Applicative @f_abih $dApplicative_abij)
                                   @(GHC.Types.Char, Data.Text.Internal.Text)
                                   @Data.Text.Internal.Text
                                   (\ (p1_abis :: (GHC.Types.Char, Data.Text.Internal.Text)) ->
                                      case p1_abis of { (x_abiu, ds_abiv) ->
                                      Data.Text.cons x_abiu ds_abiv
                                      }) } in
                           \ (ds3_abix
                                :: Data.Either.Either
                                     Data.Text.Internal.Text
                                     (f_abih (GHC.Types.Char, Data.Text.Internal.Text))) ->
                             case ds3_abix of {
                               Data.Either.Left x_abiz -> f2_abiq x_abiz;
                               Data.Either.Right y_abiB -> ds2_abir y_abiB
                             }) } in
                  let {
                    g_abiD
                      :: p_abig
                           (GHC.Types.Char, Data.Text.Internal.Text)
                           (f_abih (GHC.Types.Char, Data.Text.Internal.Text))
                         -> p_abig
                              (Data.Either.Either
                                 Data.Text.Internal.Text (GHC.Types.Char, Data.Text.Internal.Text))
                              (Data.Either.Either
                                 Data.Text.Internal.Text
                                 (f_abih (GHC.Types.Char, Data.Text.Internal.Text)))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abiD
                      = Data.Profunctor.Choice.right'
                          @p_abig
                          $dChoice_abii
                          @(GHC.Types.Char, Data.Text.Internal.Text)
                          @(f_abih (GHC.Types.Char, Data.Text.Internal.Text))
                          @Data.Text.Internal.Text } in
                  \ (x_abiE
                       :: p_abig
                            (GHC.Types.Char, Data.Text.Internal.Text)
                            (f_abih (GHC.Types.Char, Data.Text.Internal.Text))) ->
                    f1_abik (g_abiD x_abiE))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <Data.Text.Internal.Text>_N
                                <Data.Text.Internal.Text>_N
                                <GHC.Types.Char>_N
                                <GHC.Types.Char>_N)
                       :: Control.Lens.Type.Prism
                            Data.Text.Internal.Text
                            Data.Text.Internal.Text
                            (GHC.Types.Char, Data.Text.Internal.Text)
                            (GHC.Types.Char, Data.Text.Internal.Text)
                          ~R# Control.Lens.Cons.Cons
                                Data.Text.Internal.Text
                                Data.Text.Internal.Text
                                GHC.Types.Char
                                GHC.Types.Char))
              ((\ (@(p_abiF :: * -> * -> *))
                  (@(f_abiG :: * -> *))
                  ($dChoice_abiH :: Data.Profunctor.Choice.Choice p_abiF)
                  ($dApplicative_abiI :: GHC.Base.Applicative f_abiG) ->
                  let {
                    f1_abiJ
                      :: p_abiF
                           (Data.Either.Either Data.Text.Internal.Text ())
                           (Data.Either.Either Data.Text.Internal.Text (f_abiG ()))
                         -> p_abiF Data.Text.Internal.Text (f_abiG Data.Text.Internal.Text)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 310 0}]
                    f1_abiJ
                      = Data.Profunctor.Unsafe.dimap
                          @p_abiF
                          (Data.Profunctor.Choice.$p1Choice @p_abiF $dChoice_abiH)
                          @Data.Text.Internal.Text
                          @(Data.Either.Either Data.Text.Internal.Text ())
                          @(Data.Either.Either Data.Text.Internal.Text (f_abiG ()))
                          @(f_abiG Data.Text.Internal.Text)
                          (\ (s_abiK :: Data.Text.Internal.Text) ->
                             case Data.Text.null s_abiK of {
                               GHC.Types.False ->
                                 Data.Either.Left @Data.Text.Internal.Text @() s_abiK;
                               GHC.Types.True ->
                                 Data.Either.Right @Data.Text.Internal.Text @() GHC.Tuple.Prim.()
                             })
                          (let {
                             f2_abiN
                               :: Data.Text.Internal.Text -> f_abiG Data.Text.Internal.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abiN
                               = GHC.Base.pure
                                   @f_abiG $dApplicative_abiI @Data.Text.Internal.Text } in
                           let {
                             ds2_abiO :: f_abiG () -> f_abiG Data.Text.Internal.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 70 0}]
                             ds2_abiO
                               = GHC.Base.fmap
                                   @f_abiG
                                   (GHC.Base.$p1Applicative @f_abiG $dApplicative_abiI)
                                   @()
                                   @Data.Text.Internal.Text
                                   (\ (ds3_abiP :: ()) ->
                                      case ds3_abiP of { () -> Data.Text.Internal.empty }) } in
                           \ (ds3_abiR
                                :: Data.Either.Either Data.Text.Internal.Text (f_abiG ())) ->
                             case ds3_abiR of {
                               Data.Either.Left x_abiT -> f2_abiN x_abiT;
                               Data.Either.Right y_abiV -> ds2_abiO y_abiV
                             }) } in
                  let {
                    g_abiX
                      :: p_abiF () (f_abiG ())
                         -> p_abiF
                              (Data.Either.Either Data.Text.Internal.Text ())
                              (Data.Either.Either Data.Text.Internal.Text (f_abiG ()))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abiX
                      = Data.Profunctor.Choice.right'
                          @p_abiF
                          $dChoice_abiH
                          @()
                          @(f_abiG ())
                          @Data.Text.Internal.Text } in
                  \ (x_abiY :: p_abiF () (f_abiG ())) -> f1_abiJ (g_abiX x_abiY))
               `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                <Data.Text.Internal.Text>_N)
                       :: Control.Lens.Type.Prism' Data.Text.Internal.Text ()
                          ~R# Control.Lens.Empty.AsEmpty Data.Text.Internal.Text))
              (Data.Functor.Contravariant.$fContravariantConst
                 @Data.Text.Internal.Text)
              (Data.Functor.Const.$fFunctorConst @Data.Text.Internal.Text)
    Cont:   ApplyToVal nodup hole Control.Lens.Getter.Getting
                                    Data.Text.Internal.Text
                                    Data.Text.Internal.Text
                                    Data.Text.Internal.Text
              ((\ (ds_abeK [Occ=Once1] :: a_abeH) -> ds_abeK)
               `cast` (<a_abeH>_R
                       %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                          <*>_N <a_abeH>_R <a_abeH>_P)
                       :: (a_abeH -> a_abeH)
                          ~R# (a_abeH -> Data.Functor.Const.Const a_abeH a_abeH)))
            ApplyToVal nodup hole Data.Text.Internal.Text
                                  -> Data.Functor.Const.Const
                                       Data.Text.Internal.Text Data.Text.Internal.Text
              s_a8Kt
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N <Data.Text.Internal.Text>_R <Data.Text.Internal.Text>_P
                    :: Data.Functor.Const.Const
                         Data.Text.Internal.Text Data.Text.Internal.Text
                       ~R# Data.Text.Internal.Text)
            Stop[RuleArgCtxt] Data.Text.Internal.Text
Rule fired
    Rule: Class op ==
    Module: (BUILTIN)
    Before: GHC.Classes.==
              TyArg Data.Text.Internal.Text
              ValArg Data.Text.$fEqText
              ValArg s_a8Kt
              ValArg s_a8Kt
    After:  Data.Text.$fEqText_$c== ValArg s_a8Kt ValArg s_a8Kt
    Cont:   Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: unpack
    Module: (GHC.Base)
    Before: GHC.CString.unpackCString# ValArg "TL -> TL"#
    After:  (\ (a_ab7z :: GHC.Prim.Addr#) ->
               GHC.Base.build
                 @GHC.Types.Char
                 (\ (@b_ab7A) -> GHC.CString.unpackFoldrCString# @b_ab7A a_ab7z))
              "TL -> TL"#
    Cont:   Stop[BoringCtxt] Test.Tasty.Core.TestName
Rule fired
    Rule: Class op property
    Module: (BUILTIN)
    Before: Test.QuickCheck.Property.property
              TyArg Data.Text.Internal.Lazy.Text -> GHC.Types.Bool
              ValArg Test.QuickCheck.Property.$fTestableFUN
                       @Data.Text.Internal.Lazy.Text
                       @GHC.Types.Bool
                       Test.QuickCheck.Instances.Text.$fArbitraryText
                       Data.Text.Lazy.$fShowText
                       Test.QuickCheck.Property.$fTestableBool
    After:  Test.QuickCheck.Property.$fTestableFUN_$cproperty
              @Data.Text.Internal.Lazy.Text
              @GHC.Types.Bool
              Test.QuickCheck.Instances.Text.$fArbitraryText
              Data.Text.Lazy.$fShowText
              Test.QuickCheck.Property.$fTestableBool
    Cont:   ApplyToVal nodup hole (Data.Text.Internal.Lazy.Text
                                   -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              prop_ab7M
            CastIt (Sym (Test.Tasty.QuickCheck.N:QC[0])
                    :: Test.QuickCheck.Property.Property ~R# Test.Tasty.QuickCheck.QC)
            Stop[BoringCtxt] Test.Tasty.QuickCheck.QC
Rule fired
    Rule: Class op propertyForAllShrinkShow
    Module: (BUILTIN)
    Before: Test.QuickCheck.Property.propertyForAllShrinkShow
              TyArg GHC.Types.Bool ValArg Test.QuickCheck.Property.$fTestableBool
    After:  Test.QuickCheck.Property.$fTestableBool1
            `cast` (forall (a :: <*>_N).
                    <Test.QuickCheck.Gen.Gen a>_R
                    %<'GHC.Types.Many>_N ->_R <a -> [a]>_R
                    %<'GHC.Types.Many>_N ->_R <a -> [GHC.Base.String]>_R
                    %<'GHC.Types.Many>_N ->_R <a -> GHC.Types.Bool>_R
                    %<'GHC.Types.Many>_N ->_R Sym (Test.QuickCheck.Gen.N:Gen[0]
                                                       (Test.QuickCheck.Property.N:Prop[0]))
                                              ; Sym (Test.QuickCheck.Property.N:Property[0])
                    :: (forall {a}.
                        Test.QuickCheck.Gen.Gen a
                        -> (a -> [a])
                        -> (a -> [GHC.Base.String])
                        -> (a -> GHC.Types.Bool)
                        -> Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int
                        -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result)
                       ~R# (forall {a}.
                            Test.QuickCheck.Gen.Gen a
                            -> (a -> [a])
                            -> (a -> [GHC.Base.String])
                            -> (a -> GHC.Types.Bool)
                            -> Test.QuickCheck.Property.Property))
    Cont:   ApplyToTy Data.Text.Internal.Lazy.Text
            ApplyToVal nodup hole Test.QuickCheck.Gen.Gen
                                    Data.Text.Internal.Lazy.Text
                                  -> (Data.Text.Internal.Lazy.Text
                                      -> [Data.Text.Internal.Lazy.Text])
                                  -> (Data.Text.Internal.Lazy.Text -> [GHC.Base.String])
                                  -> (Data.Text.Internal.Lazy.Text -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (Test.QuickCheck.Arbitrary.arbitrary @a_ab9u $dArbitrary_ab9w)
            ApplyToVal nodup hole (Data.Text.Internal.Lazy.Text
                                   -> [Data.Text.Internal.Lazy.Text])
                                  -> (Data.Text.Internal.Lazy.Text -> [GHC.Base.String])
                                  -> (Data.Text.Internal.Lazy.Text -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (Test.QuickCheck.Arbitrary.shrink @a_ab9u $dArbitrary_ab9w)
            ApplyToVal nodup hole (Data.Text.Internal.Lazy.Text
                                   -> [GHC.Base.String])
                                  -> (Data.Text.Internal.Lazy.Text -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (let {
                 g_ab9A [Occ=OnceL1!] :: a_ab9u -> GHC.Base.String
                 [LclId]
                 g_ab9A = GHC.Show.show @a_ab9u $dShow_ab9x } in
               \ (x_ab9B [Occ=Once1] :: a_ab9u) ->
                 GHC.Types.:
                   @GHC.Base.String (g_ab9A x_ab9B) (GHC.Types.[] @GHC.Base.String))
            ApplyToVal nodup hole (Data.Text.Internal.Lazy.Text
                                   -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              f_ab9z
            CastIt (Sym (Test.Tasty.QuickCheck.N:QC[0])
                    :: Test.QuickCheck.Property.Property ~R# Test.Tasty.QuickCheck.QC)
            Stop[BoringCtxt] Test.Tasty.QuickCheck.QC
Rule fired
    Rule: Class op arbitrary
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.arbitrary
              TyArg Data.Text.Internal.Lazy.Text
              ValArg Test.QuickCheck.Instances.Text.$fArbitraryText
    After:  Test.QuickCheck.Instances.Text.$fArbitraryText2
            `cast` (Sym (Test.QuickCheck.Gen.N:Gen[0]
                             <Data.Text.Internal.Lazy.Text>_R)
                    :: (Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int -> Data.Text.Internal.Lazy.Text)
                       ~R# Test.QuickCheck.Gen.Gen Data.Text.Internal.Lazy.Text)
    Cont:   Stop[BoringCtxt] Test.QuickCheck.Gen.Gen
                               Data.Text.Internal.Lazy.Text
Rule fired
    Rule: Class op shrink
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.shrink
              TyArg Data.Text.Internal.Lazy.Text
              ValArg Test.QuickCheck.Instances.Text.$fArbitraryText
    After:  Test.QuickCheck.Instances.Text.$fArbitraryText_$cshrink
    Cont:   Stop[BoringCtxt] Data.Text.Internal.Lazy.Text
                             -> [Data.Text.Internal.Lazy.Text]
Rule fired
    Rule: Class op show
    Module: (BUILTIN)
    Before: GHC.Show.show
              TyArg Data.Text.Internal.Lazy.Text ValArg Data.Text.Lazy.$fShowText
    After:  Data.Text.Lazy.$fShowText_$cshow
    Cont:   Stop[RhsCtxt(NonRecursive)] Data.Text.Internal.Lazy.Text
                                        -> GHC.Base.String
Rule fired
    Rule: Class op reader
    Module: (BUILTIN)
    Before: Control.Monad.Reader.Class.reader
              TyArg Data.Text.Internal.Lazy.Text
              TyArg (->) Data.Text.Internal.Lazy.Text
              ValArg Control.Monad.Reader.Class.$fMonadReaderrFUN
                       @Data.Text.Internal.Lazy.Text
    After:  \ (@a_abeP) ->
              GHC.Base.id @(Data.Text.Internal.Lazy.Text -> a_abeP)
    Cont:   ApplyToTy Data.Text.Internal.Lazy.Text
            ApplyToVal nodup hole (Data.Text.Internal.Lazy.Text
                                   -> Data.Text.Internal.Lazy.Text)
                                  -> Data.Text.Internal.Lazy.Text -> Data.Text.Internal.Lazy.Text
              ((l_abeJ
                  ((\ (ds_abeK [Occ=Once1] :: a_abeH) -> ds_abeK)
                   `cast` (<a_abeH>_R
                           %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                              <*>_N <a_abeH>_R <a_abeH>_P)
                           :: (a_abeH -> a_abeH)
                              ~R# (a_abeH -> Data.Functor.Const.Const a_abeH a_abeH))))
               `cast` (<s_abeF>_R
                       %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                     <*>_N <a_abeH>_R <s_abeF>_P
                       :: (s_abeF -> Data.Functor.Const.Const a_abeH s_abeF)
                          ~R# (s_abeF -> a_abeH)))
            ApplyToVal nodup hole Data.Text.Internal.Lazy.Text
                                  -> Data.Text.Internal.Lazy.Text
              s_a8Ku
            Stop[RuleArgCtxt] Data.Text.Internal.Lazy.Text
Rule fired
    Rule: recons/id
    Module: (Control.Lens.Cons.Extras)
    Before: Control.Lens.Cons.Extras.recons
              TyArg Data.Text.Internal.Lazy.Text
              TyArg GHC.Types.Char
              TyArg Data.Text.Internal.Lazy.Text
              ValArg (\ (@(p_abj5 :: * -> * -> *))
                        (@(f_abj6 :: * -> *))
                        ($dChoice_abj7 :: Data.Profunctor.Choice.Choice p_abj5)
                        ($dApplicative_abj8 :: GHC.Base.Applicative f_abj6) ->
                        let {
                          f1_abj9
                            :: p_abj5
                                 (Data.Either.Either
                                    Data.Text.Internal.Lazy.Text
                                    (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                                 (Data.Either.Either
                                    Data.Text.Internal.Lazy.Text
                                    (f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                               -> p_abj5
                                    Data.Text.Internal.Lazy.Text
                                    (f_abj6 Data.Text.Internal.Lazy.Text)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 639 0}]
                          f1_abj9
                            = Data.Profunctor.Unsafe.dimap
                                @p_abj5
                                (Data.Profunctor.Choice.$p1Choice @p_abj5 $dChoice_abj7)
                                @Data.Text.Internal.Lazy.Text
                                @(Data.Either.Either
                                    Data.Text.Internal.Lazy.Text
                                    (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                                @(Data.Either.Either
                                    Data.Text.Internal.Lazy.Text
                                    (f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                                @(f_abj6 Data.Text.Internal.Lazy.Text)
                                (\ (s1_abja :: Data.Text.Internal.Lazy.Text) ->
                                   case s1_abja of {
                                     Data.Text.Internal.Lazy.Empty ->
                                       Data.Either.Left
                                         @Data.Text.Internal.Lazy.Text
                                         @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                         Data.Text.Internal.Lazy.Empty;
                                     Data.Text.Internal.Lazy.Chunk bx_abjh bx1_abji bx2_abjj
                                                                   ts_abjk ->
                                       Data.Either.Right
                                         @Data.Text.Internal.Lazy.Text
                                         @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                         (case GHC.Prim.indexWord8Array# bx_abjh bx1_abji of r#_abjm
                                          { __DEFAULT ->
                                          let {
                                            c#_abjn :: GHC.Prim.Int#
                                            [LclId,
                                             Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                     Value=False, ConLike=False, WorkFree=False,
                                                     Expandable=False,
                                                     Guidance=IF_ARGS [] 4 0}]
                                            c#_abjn
                                              = GHC.Prim.word2Int#
                                                  (GHC.Prim.clz8#
                                                     (GHC.Prim.and#
                                                        (GHC.Prim.not#
                                                           (GHC.Prim.word8ToWord# r#_abjm))
                                                        255##)) } in
                                          case GHC.Prim.xorI# c#_abjn (GHC.Prim.<=# c#_abjn 0#) of {
                                            __DEFAULT ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abjh (GHC.Prim.+# bx1_abji 1#)
                                              of r#1_abjp
                                              { __DEFAULT ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abjh (GHC.Prim.+# bx1_abji 2#)
                                              of r#2_abjq
                                              { __DEFAULT ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abjh (GHC.Prim.+# bx1_abji 3#)
                                              of r#3_abjr
                                              { __DEFAULT ->
                                              GHC.Types.C#
                                                (GHC.Prim.chr#
                                                   (GHC.Prim.-#
                                                      (GHC.Prim.+#
                                                         (GHC.Prim.+#
                                                            (GHC.Prim.+#
                                                               (GHC.Prim.uncheckedIShiftL#
                                                                  (GHC.Prim.-#
                                                                     (GHC.Prim.word2Int#
                                                                        (GHC.Prim.word8ToWord#
                                                                           r#_abjm))
                                                                     240#)
                                                                  18#)
                                                               (GHC.Prim.uncheckedIShiftL#
                                                                  (GHC.Prim.-#
                                                                     (GHC.Prim.word2Int#
                                                                        (GHC.Prim.word8ToWord#
                                                                           r#1_abjp))
                                                                     128#)
                                                                  12#))
                                                            (GHC.Prim.uncheckedIShiftL#
                                                               (GHC.Prim.-#
                                                                  (GHC.Prim.word2Int#
                                                                     (GHC.Prim.word8ToWord#
                                                                        r#2_abjq))
                                                                  128#)
                                                               6#))
                                                         (GHC.Prim.word2Int#
                                                            (GHC.Prim.word8ToWord# r#3_abjr)))
                                                      128#))
                                              }
                                              }
                                              };
                                            1# ->
                                              GHC.Types.C#
                                                (GHC.Prim.chr#
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.word8ToWord# r#_abjm)));
                                            2# ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abjh (GHC.Prim.+# bx1_abji 1#)
                                              of r#1_abjs
                                              { __DEFAULT ->
                                              GHC.Types.C#
                                                (GHC.Prim.chr#
                                                   (GHC.Prim.-#
                                                      (GHC.Prim.+#
                                                         (GHC.Prim.uncheckedIShiftL#
                                                            (GHC.Prim.-#
                                                               (GHC.Prim.word2Int#
                                                                  (GHC.Prim.word8ToWord# r#_abjm))
                                                               192#)
                                                            6#)
                                                         (GHC.Prim.word2Int#
                                                            (GHC.Prim.word8ToWord# r#1_abjs)))
                                                      128#))
                                              };
                                            3# ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abjh (GHC.Prim.+# bx1_abji 1#)
                                              of r#1_abjt
                                              { __DEFAULT ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abjh (GHC.Prim.+# bx1_abji 2#)
                                              of r#2_abju
                                              { __DEFAULT ->
                                              GHC.Types.C#
                                                (GHC.Prim.chr#
                                                   (GHC.Prim.-#
                                                      (GHC.Prim.+#
                                                         (GHC.Prim.+#
                                                            (GHC.Prim.uncheckedIShiftL#
                                                               (GHC.Prim.-#
                                                                  (GHC.Prim.word2Int#
                                                                     (GHC.Prim.word8ToWord#
                                                                        r#_abjm))
                                                                  224#)
                                                               12#)
                                                            (GHC.Prim.uncheckedIShiftL#
                                                               (GHC.Prim.-#
                                                                  (GHC.Prim.word2Int#
                                                                     (GHC.Prim.word8ToWord#
                                                                        r#1_abjt))
                                                                  128#)
                                                               6#))
                                                         (GHC.Prim.word2Int#
                                                            (GHC.Prim.word8ToWord# r#2_abju)))
                                                      128#))
                                              }
                                              }
                                          }
                                          },
                                          case Data.Text.compareLength
                                                 (Data.Text.Internal.Text bx_abjh bx1_abji bx2_abjj)
                                                 (GHC.Types.I# 1#)
                                          of {
                                            __DEFAULT ->
                                              case GHC.Prim.indexWord8Array# bx_abjh bx1_abji
                                              of r#_abjw
                                              { __DEFAULT ->
                                              let {
                                                c#_abjx :: GHC.Prim.Int#
                                                [LclId,
                                                 Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                         Value=False, ConLike=False, WorkFree=False,
                                                         Expandable=False,
                                                         Guidance=IF_ARGS [] 4 0}]
                                                c#_abjx
                                                  = GHC.Prim.word2Int#
                                                      (GHC.Prim.clz8#
                                                         (GHC.Prim.and#
                                                            (GHC.Prim.not#
                                                               (GHC.Prim.word8ToWord# r#_abjw))
                                                            255##)) } in
                                              let {
                                                y_abjy :: GHC.Prim.Int#
                                                [LclId,
                                                 Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                         Value=False, ConLike=False, WorkFree=False,
                                                         Expandable=False,
                                                         Guidance=IF_ARGS [] 2 0}]
                                                y_abjy
                                                  = GHC.Prim.xorI#
                                                      c#_abjx (GHC.Prim.<=# c#_abjx 0#) } in
                                              Data.Text.Internal.Lazy.$WChunk
                                                (Data.Text.Internal.$WText
                                                   (Data.Text.Array.ByteArray bx_abjh)
                                                   (GHC.Types.I# (GHC.Prim.+# bx1_abji y_abjy))
                                                   (GHC.Types.I# (GHC.Prim.-# bx2_abjj y_abjy)))
                                                ts_abjk
                                              };
                                            GHC.Types.EQ -> ts_abjk
                                          })
                                   })
                                (let {
                                   f2_abjA
                                     :: Data.Text.Internal.Lazy.Text
                                        -> f_abj6 Data.Text.Internal.Lazy.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abjA
                                     = GHC.Base.pure
                                         @f_abj6
                                         $dApplicative_abj8
                                         @Data.Text.Internal.Lazy.Text } in
                                 let {
                                   ds2_abjB
                                     :: f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                        -> f_abj6 Data.Text.Internal.Lazy.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 100 0}]
                                   ds2_abjB
                                     = GHC.Base.fmap
                                         @f_abj6
                                         (GHC.Base.$p1Applicative @f_abj6 $dApplicative_abj8)
                                         @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                         @Data.Text.Internal.Lazy.Text
                                         (\ (p1_abjC
                                               :: (GHC.Types.Char, Data.Text.Internal.Lazy.Text)) ->
                                            case p1_abjC of { (x_abjE, ds_abjF) ->
                                            Data.Text.Lazy.cons x_abjE ds_abjF
                                            }) } in
                                 \ (ds3_abjH
                                      :: Data.Either.Either
                                           Data.Text.Internal.Lazy.Text
                                           (f_abj6
                                              (GHC.Types.Char, Data.Text.Internal.Lazy.Text))) ->
                                   case ds3_abjH of {
                                     Data.Either.Left x_abjJ -> f2_abjA x_abjJ;
                                     Data.Either.Right y_abjL -> ds2_abjB y_abjL
                                   }) } in
                        let {
                          g_abjN
                            :: p_abj5
                                 (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                 (f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                               -> p_abj5
                                    (Data.Either.Either
                                       Data.Text.Internal.Lazy.Text
                                       (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                                    (Data.Either.Either
                                       Data.Text.Internal.Lazy.Text
                                       (f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abjN
                            = Data.Profunctor.Choice.right'
                                @p_abj5
                                $dChoice_abj7
                                @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                @(f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                                @Data.Text.Internal.Lazy.Text } in
                        \ (x_abjO
                             :: p_abj5
                                  (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                  (f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text))) ->
                          f1_abj9 (g_abjN x_abjO))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <Data.Text.Internal.Lazy.Text>_N
                                      <Data.Text.Internal.Lazy.Text>_N
                                      <GHC.Types.Char>_N
                                      <GHC.Types.Char>_N)
                             :: Control.Lens.Type.Prism
                                  Data.Text.Internal.Lazy.Text
                                  Data.Text.Internal.Lazy.Text
                                  (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                  (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                ~R# Control.Lens.Cons.Cons
                                      Data.Text.Internal.Lazy.Text
                                      Data.Text.Internal.Lazy.Text
                                      GHC.Types.Char
                                      GHC.Types.Char)
              ValArg (\ (@(p_abj5 :: * -> * -> *))
                        (@(f_abj6 :: * -> *))
                        ($dChoice_abj7 :: Data.Profunctor.Choice.Choice p_abj5)
                        ($dApplicative_abj8 :: GHC.Base.Applicative f_abj6) ->
                        let {
                          f1_abj9
                            :: p_abj5
                                 (Data.Either.Either
                                    Data.Text.Internal.Lazy.Text
                                    (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                                 (Data.Either.Either
                                    Data.Text.Internal.Lazy.Text
                                    (f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                               -> p_abj5
                                    Data.Text.Internal.Lazy.Text
                                    (f_abj6 Data.Text.Internal.Lazy.Text)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 639 0}]
                          f1_abj9
                            = Data.Profunctor.Unsafe.dimap
                                @p_abj5
                                (Data.Profunctor.Choice.$p1Choice @p_abj5 $dChoice_abj7)
                                @Data.Text.Internal.Lazy.Text
                                @(Data.Either.Either
                                    Data.Text.Internal.Lazy.Text
                                    (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                                @(Data.Either.Either
                                    Data.Text.Internal.Lazy.Text
                                    (f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                                @(f_abj6 Data.Text.Internal.Lazy.Text)
                                (\ (s1_abja :: Data.Text.Internal.Lazy.Text) ->
                                   case s1_abja of {
                                     Data.Text.Internal.Lazy.Empty ->
                                       Data.Either.Left
                                         @Data.Text.Internal.Lazy.Text
                                         @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                         Data.Text.Internal.Lazy.Empty;
                                     Data.Text.Internal.Lazy.Chunk bx_abjh bx1_abji bx2_abjj
                                                                   ts_abjk ->
                                       Data.Either.Right
                                         @Data.Text.Internal.Lazy.Text
                                         @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                         (case GHC.Prim.indexWord8Array# bx_abjh bx1_abji of r#_abjm
                                          { __DEFAULT ->
                                          let {
                                            c#_abjn :: GHC.Prim.Int#
                                            [LclId,
                                             Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                     Value=False, ConLike=False, WorkFree=False,
                                                     Expandable=False,
                                                     Guidance=IF_ARGS [] 4 0}]
                                            c#_abjn
                                              = GHC.Prim.word2Int#
                                                  (GHC.Prim.clz8#
                                                     (GHC.Prim.and#
                                                        (GHC.Prim.not#
                                                           (GHC.Prim.word8ToWord# r#_abjm))
                                                        255##)) } in
                                          case GHC.Prim.xorI# c#_abjn (GHC.Prim.<=# c#_abjn 0#) of {
                                            __DEFAULT ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abjh (GHC.Prim.+# bx1_abji 1#)
                                              of r#1_abjp
                                              { __DEFAULT ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abjh (GHC.Prim.+# bx1_abji 2#)
                                              of r#2_abjq
                                              { __DEFAULT ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abjh (GHC.Prim.+# bx1_abji 3#)
                                              of r#3_abjr
                                              { __DEFAULT ->
                                              GHC.Types.C#
                                                (GHC.Prim.chr#
                                                   (GHC.Prim.-#
                                                      (GHC.Prim.+#
                                                         (GHC.Prim.+#
                                                            (GHC.Prim.+#
                                                               (GHC.Prim.uncheckedIShiftL#
                                                                  (GHC.Prim.-#
                                                                     (GHC.Prim.word2Int#
                                                                        (GHC.Prim.word8ToWord#
                                                                           r#_abjm))
                                                                     240#)
                                                                  18#)
                                                               (GHC.Prim.uncheckedIShiftL#
                                                                  (GHC.Prim.-#
                                                                     (GHC.Prim.word2Int#
                                                                        (GHC.Prim.word8ToWord#
                                                                           r#1_abjp))
                                                                     128#)
                                                                  12#))
                                                            (GHC.Prim.uncheckedIShiftL#
                                                               (GHC.Prim.-#
                                                                  (GHC.Prim.word2Int#
                                                                     (GHC.Prim.word8ToWord#
                                                                        r#2_abjq))
                                                                  128#)
                                                               6#))
                                                         (GHC.Prim.word2Int#
                                                            (GHC.Prim.word8ToWord# r#3_abjr)))
                                                      128#))
                                              }
                                              }
                                              };
                                            1# ->
                                              GHC.Types.C#
                                                (GHC.Prim.chr#
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.word8ToWord# r#_abjm)));
                                            2# ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abjh (GHC.Prim.+# bx1_abji 1#)
                                              of r#1_abjs
                                              { __DEFAULT ->
                                              GHC.Types.C#
                                                (GHC.Prim.chr#
                                                   (GHC.Prim.-#
                                                      (GHC.Prim.+#
                                                         (GHC.Prim.uncheckedIShiftL#
                                                            (GHC.Prim.-#
                                                               (GHC.Prim.word2Int#
                                                                  (GHC.Prim.word8ToWord# r#_abjm))
                                                               192#)
                                                            6#)
                                                         (GHC.Prim.word2Int#
                                                            (GHC.Prim.word8ToWord# r#1_abjs)))
                                                      128#))
                                              };
                                            3# ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abjh (GHC.Prim.+# bx1_abji 1#)
                                              of r#1_abjt
                                              { __DEFAULT ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abjh (GHC.Prim.+# bx1_abji 2#)
                                              of r#2_abju
                                              { __DEFAULT ->
                                              GHC.Types.C#
                                                (GHC.Prim.chr#
                                                   (GHC.Prim.-#
                                                      (GHC.Prim.+#
                                                         (GHC.Prim.+#
                                                            (GHC.Prim.uncheckedIShiftL#
                                                               (GHC.Prim.-#
                                                                  (GHC.Prim.word2Int#
                                                                     (GHC.Prim.word8ToWord#
                                                                        r#_abjm))
                                                                  224#)
                                                               12#)
                                                            (GHC.Prim.uncheckedIShiftL#
                                                               (GHC.Prim.-#
                                                                  (GHC.Prim.word2Int#
                                                                     (GHC.Prim.word8ToWord#
                                                                        r#1_abjt))
                                                                  128#)
                                                               6#))
                                                         (GHC.Prim.word2Int#
                                                            (GHC.Prim.word8ToWord# r#2_abju)))
                                                      128#))
                                              }
                                              }
                                          }
                                          },
                                          case Data.Text.compareLength
                                                 (Data.Text.Internal.Text bx_abjh bx1_abji bx2_abjj)
                                                 (GHC.Types.I# 1#)
                                          of {
                                            __DEFAULT ->
                                              case GHC.Prim.indexWord8Array# bx_abjh bx1_abji
                                              of r#_abjw
                                              { __DEFAULT ->
                                              let {
                                                c#_abjx :: GHC.Prim.Int#
                                                [LclId,
                                                 Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                         Value=False, ConLike=False, WorkFree=False,
                                                         Expandable=False,
                                                         Guidance=IF_ARGS [] 4 0}]
                                                c#_abjx
                                                  = GHC.Prim.word2Int#
                                                      (GHC.Prim.clz8#
                                                         (GHC.Prim.and#
                                                            (GHC.Prim.not#
                                                               (GHC.Prim.word8ToWord# r#_abjw))
                                                            255##)) } in
                                              let {
                                                y_abjy :: GHC.Prim.Int#
                                                [LclId,
                                                 Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                         Value=False, ConLike=False, WorkFree=False,
                                                         Expandable=False,
                                                         Guidance=IF_ARGS [] 2 0}]
                                                y_abjy
                                                  = GHC.Prim.xorI#
                                                      c#_abjx (GHC.Prim.<=# c#_abjx 0#) } in
                                              Data.Text.Internal.Lazy.$WChunk
                                                (Data.Text.Internal.$WText
                                                   (Data.Text.Array.ByteArray bx_abjh)
                                                   (GHC.Types.I# (GHC.Prim.+# bx1_abji y_abjy))
                                                   (GHC.Types.I# (GHC.Prim.-# bx2_abjj y_abjy)))
                                                ts_abjk
                                              };
                                            GHC.Types.EQ -> ts_abjk
                                          })
                                   })
                                (let {
                                   f2_abjA
                                     :: Data.Text.Internal.Lazy.Text
                                        -> f_abj6 Data.Text.Internal.Lazy.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abjA
                                     = GHC.Base.pure
                                         @f_abj6
                                         $dApplicative_abj8
                                         @Data.Text.Internal.Lazy.Text } in
                                 let {
                                   ds2_abjB
                                     :: f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                        -> f_abj6 Data.Text.Internal.Lazy.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 100 0}]
                                   ds2_abjB
                                     = GHC.Base.fmap
                                         @f_abj6
                                         (GHC.Base.$p1Applicative @f_abj6 $dApplicative_abj8)
                                         @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                         @Data.Text.Internal.Lazy.Text
                                         (\ (p1_abjC
                                               :: (GHC.Types.Char, Data.Text.Internal.Lazy.Text)) ->
                                            case p1_abjC of { (x_abjE, ds_abjF) ->
                                            Data.Text.Lazy.cons x_abjE ds_abjF
                                            }) } in
                                 \ (ds3_abjH
                                      :: Data.Either.Either
                                           Data.Text.Internal.Lazy.Text
                                           (f_abj6
                                              (GHC.Types.Char, Data.Text.Internal.Lazy.Text))) ->
                                   case ds3_abjH of {
                                     Data.Either.Left x_abjJ -> f2_abjA x_abjJ;
                                     Data.Either.Right y_abjL -> ds2_abjB y_abjL
                                   }) } in
                        let {
                          g_abjN
                            :: p_abj5
                                 (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                 (f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                               -> p_abj5
                                    (Data.Either.Either
                                       Data.Text.Internal.Lazy.Text
                                       (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                                    (Data.Either.Either
                                       Data.Text.Internal.Lazy.Text
                                       (f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abjN
                            = Data.Profunctor.Choice.right'
                                @p_abj5
                                $dChoice_abj7
                                @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                @(f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                                @Data.Text.Internal.Lazy.Text } in
                        \ (x_abjO
                             :: p_abj5
                                  (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                  (f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text))) ->
                          f1_abj9 (g_abjN x_abjO))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <Data.Text.Internal.Lazy.Text>_N
                                      <Data.Text.Internal.Lazy.Text>_N
                                      <GHC.Types.Char>_N
                                      <GHC.Types.Char>_N)
                             :: Control.Lens.Type.Prism
                                  Data.Text.Internal.Lazy.Text
                                  Data.Text.Internal.Lazy.Text
                                  (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                  (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                ~R# Control.Lens.Cons.Cons
                                      Data.Text.Internal.Lazy.Text
                                      Data.Text.Internal.Lazy.Text
                                      GHC.Types.Char
                                      GHC.Types.Char)
              ValArg (\ (@(p_abjR :: * -> * -> *))
                        (@(f_abjS :: * -> *))
                        ($dChoice_abjT :: Data.Profunctor.Choice.Choice p_abjR)
                        ($dApplicative_abjU :: GHC.Base.Applicative f_abjS) ->
                        let {
                          f1_abjV
                            :: p_abjR
                                 (Data.Either.Either Data.Text.Internal.Lazy.Text ())
                                 (Data.Either.Either Data.Text.Internal.Lazy.Text (f_abjS ()))
                               -> p_abjR
                                    Data.Text.Internal.Lazy.Text
                                    (f_abjS Data.Text.Internal.Lazy.Text)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 310 0}]
                          f1_abjV
                            = Data.Profunctor.Unsafe.dimap
                                @p_abjR
                                (Data.Profunctor.Choice.$p1Choice @p_abjR $dChoice_abjT)
                                @Data.Text.Internal.Lazy.Text
                                @(Data.Either.Either Data.Text.Internal.Lazy.Text ())
                                @(Data.Either.Either Data.Text.Internal.Lazy.Text (f_abjS ()))
                                @(f_abjS Data.Text.Internal.Lazy.Text)
                                (\ (s_abjW :: Data.Text.Internal.Lazy.Text) ->
                                   case Data.Text.Lazy.null s_abjW of {
                                     GHC.Types.False ->
                                       Data.Either.Left @Data.Text.Internal.Lazy.Text @() s_abjW;
                                     GHC.Types.True ->
                                       Data.Either.Right
                                         @Data.Text.Internal.Lazy.Text @() GHC.Tuple.Prim.()
                                   })
                                (let {
                                   f2_abjZ
                                     :: Data.Text.Internal.Lazy.Text
                                        -> f_abjS Data.Text.Internal.Lazy.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abjZ
                                     = GHC.Base.pure
                                         @f_abjS
                                         $dApplicative_abjU
                                         @Data.Text.Internal.Lazy.Text } in
                                 let {
                                   ds2_abk0 :: f_abjS () -> f_abjS Data.Text.Internal.Lazy.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 70 0}]
                                   ds2_abk0
                                     = GHC.Base.fmap
                                         @f_abjS
                                         (GHC.Base.$p1Applicative @f_abjS $dApplicative_abjU)
                                         @()
                                         @Data.Text.Internal.Lazy.Text
                                         (\ (ds3_abk1 :: ()) ->
                                            case ds3_abk1 of { () ->
                                            Data.Text.Internal.Lazy.empty
                                            }) } in
                                 \ (ds3_abk3
                                      :: Data.Either.Either
                                           Data.Text.Internal.Lazy.Text (f_abjS ())) ->
                                   case ds3_abk3 of {
                                     Data.Either.Left x_abk5 -> f2_abjZ x_abk5;
                                     Data.Either.Right y_abk7 -> ds2_abk0 y_abk7
                                   }) } in
                        let {
                          g_abk9
                            :: p_abjR () (f_abjS ())
                               -> p_abjR
                                    (Data.Either.Either Data.Text.Internal.Lazy.Text ())
                                    (Data.Either.Either Data.Text.Internal.Lazy.Text (f_abjS ()))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abk9
                            = Data.Profunctor.Choice.right'
                                @p_abjR
                                $dChoice_abjT
                                @()
                                @(f_abjS ())
                                @Data.Text.Internal.Lazy.Text } in
                        \ (x_abka :: p_abjR () (f_abjS ())) -> f1_abjV (g_abk9 x_abka))
                     `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                      <Data.Text.Internal.Lazy.Text>_N)
                             :: Control.Lens.Type.Prism' Data.Text.Internal.Lazy.Text ()
                                ~R# Control.Lens.Empty.AsEmpty Data.Text.Internal.Lazy.Text)
              TyArg Data.Functor.Const.Const Data.Text.Internal.Lazy.Text
              ValArg Data.Functor.Contravariant.$fContravariantConst
                       @Data.Text.Internal.Lazy.Text
              ValArg Data.Functor.Const.$fFunctorConst
                       @Data.Text.Internal.Lazy.Text
    After:  (\ (@s1_abfO)
               (@(f_abfP :: * -> *))
               (@a_abfQ)
               ($dCons_abfR
                  :: Control.Lens.Cons.Cons s1_abfO s1_abfO a_abfQ a_abfQ)
               ($dCons1_abfS
                  :: Control.Lens.Cons.Cons s1_abfO s1_abfO a_abfQ a_abfQ)
               ($dAsEmpty_abfT :: Control.Lens.Empty.AsEmpty s1_abfO)
               ($dContravariant_abfU
                  :: Data.Functor.Contravariant.Contravariant f_abfP)
               ($dFunctor_abfV :: GHC.Base.Functor f_abfP) ->
               GHC.Base.id @(s1_abfO -> f_abfP s1_abfO))
              @Data.Text.Internal.Lazy.Text
              @(Data.Functor.Const.Const Data.Text.Internal.Lazy.Text)
              @GHC.Types.Char
              ((\ (@(p_abj5 :: * -> * -> *))
                  (@(f_abj6 :: * -> *))
                  ($dChoice_abj7 :: Data.Profunctor.Choice.Choice p_abj5)
                  ($dApplicative_abj8 :: GHC.Base.Applicative f_abj6) ->
                  let {
                    f1_abj9
                      :: p_abj5
                           (Data.Either.Either
                              Data.Text.Internal.Lazy.Text
                              (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                           (Data.Either.Either
                              Data.Text.Internal.Lazy.Text
                              (f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                         -> p_abj5
                              Data.Text.Internal.Lazy.Text (f_abj6 Data.Text.Internal.Lazy.Text)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 639 0}]
                    f1_abj9
                      = Data.Profunctor.Unsafe.dimap
                          @p_abj5
                          (Data.Profunctor.Choice.$p1Choice @p_abj5 $dChoice_abj7)
                          @Data.Text.Internal.Lazy.Text
                          @(Data.Either.Either
                              Data.Text.Internal.Lazy.Text
                              (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                          @(Data.Either.Either
                              Data.Text.Internal.Lazy.Text
                              (f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                          @(f_abj6 Data.Text.Internal.Lazy.Text)
                          (\ (s1_abja :: Data.Text.Internal.Lazy.Text) ->
                             case s1_abja of {
                               Data.Text.Internal.Lazy.Empty ->
                                 Data.Either.Left
                                   @Data.Text.Internal.Lazy.Text
                                   @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                   Data.Text.Internal.Lazy.Empty;
                               Data.Text.Internal.Lazy.Chunk bx_abjh bx1_abji bx2_abjj ts_abjk ->
                                 Data.Either.Right
                                   @Data.Text.Internal.Lazy.Text
                                   @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                   (case GHC.Prim.indexWord8Array# bx_abjh bx1_abji of r#_abjm
                                    { __DEFAULT ->
                                    let {
                                      c#_abjn :: GHC.Prim.Int#
                                      [LclId,
                                       Unf=Unf{Src=<vanilla>, TopLvl=False,
                                               Value=False, ConLike=False, WorkFree=False,
                                               Expandable=False,
                                               Guidance=IF_ARGS [] 4 0}]
                                      c#_abjn
                                        = GHC.Prim.word2Int#
                                            (GHC.Prim.clz8#
                                               (GHC.Prim.and#
                                                  (GHC.Prim.not# (GHC.Prim.word8ToWord# r#_abjm))
                                                  255##)) } in
                                    case GHC.Prim.xorI# c#_abjn (GHC.Prim.<=# c#_abjn 0#) of {
                                      __DEFAULT ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abjh (GHC.Prim.+# bx1_abji 1#)
                                        of r#1_abjp
                                        { __DEFAULT ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abjh (GHC.Prim.+# bx1_abji 2#)
                                        of r#2_abjq
                                        { __DEFAULT ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abjh (GHC.Prim.+# bx1_abji 3#)
                                        of r#3_abjr
                                        { __DEFAULT ->
                                        GHC.Types.C#
                                          (GHC.Prim.chr#
                                             (GHC.Prim.-#
                                                (GHC.Prim.+#
                                                   (GHC.Prim.+#
                                                      (GHC.Prim.+#
                                                         (GHC.Prim.uncheckedIShiftL#
                                                            (GHC.Prim.-#
                                                               (GHC.Prim.word2Int#
                                                                  (GHC.Prim.word8ToWord# r#_abjm))
                                                               240#)
                                                            18#)
                                                         (GHC.Prim.uncheckedIShiftL#
                                                            (GHC.Prim.-#
                                                               (GHC.Prim.word2Int#
                                                                  (GHC.Prim.word8ToWord# r#1_abjp))
                                                               128#)
                                                            12#))
                                                      (GHC.Prim.uncheckedIShiftL#
                                                         (GHC.Prim.-#
                                                            (GHC.Prim.word2Int#
                                                               (GHC.Prim.word8ToWord# r#2_abjq))
                                                            128#)
                                                         6#))
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.word8ToWord# r#3_abjr)))
                                                128#))
                                        }
                                        }
                                        };
                                      1# ->
                                        GHC.Types.C#
                                          (GHC.Prim.chr#
                                             (GHC.Prim.word2Int# (GHC.Prim.word8ToWord# r#_abjm)));
                                      2# ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abjh (GHC.Prim.+# bx1_abji 1#)
                                        of r#1_abjs
                                        { __DEFAULT ->
                                        GHC.Types.C#
                                          (GHC.Prim.chr#
                                             (GHC.Prim.-#
                                                (GHC.Prim.+#
                                                   (GHC.Prim.uncheckedIShiftL#
                                                      (GHC.Prim.-#
                                                         (GHC.Prim.word2Int#
                                                            (GHC.Prim.word8ToWord# r#_abjm))
                                                         192#)
                                                      6#)
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.word8ToWord# r#1_abjs)))
                                                128#))
                                        };
                                      3# ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abjh (GHC.Prim.+# bx1_abji 1#)
                                        of r#1_abjt
                                        { __DEFAULT ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abjh (GHC.Prim.+# bx1_abji 2#)
                                        of r#2_abju
                                        { __DEFAULT ->
                                        GHC.Types.C#
                                          (GHC.Prim.chr#
                                             (GHC.Prim.-#
                                                (GHC.Prim.+#
                                                   (GHC.Prim.+#
                                                      (GHC.Prim.uncheckedIShiftL#
                                                         (GHC.Prim.-#
                                                            (GHC.Prim.word2Int#
                                                               (GHC.Prim.word8ToWord# r#_abjm))
                                                            224#)
                                                         12#)
                                                      (GHC.Prim.uncheckedIShiftL#
                                                         (GHC.Prim.-#
                                                            (GHC.Prim.word2Int#
                                                               (GHC.Prim.word8ToWord# r#1_abjt))
                                                            128#)
                                                         6#))
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.word8ToWord# r#2_abju)))
                                                128#))
                                        }
                                        }
                                    }
                                    },
                                    case Data.Text.compareLength
                                           (Data.Text.Internal.Text bx_abjh bx1_abji bx2_abjj)
                                           (GHC.Types.I# 1#)
                                    of {
                                      __DEFAULT ->
                                        case GHC.Prim.indexWord8Array# bx_abjh bx1_abji of r#_abjw
                                        { __DEFAULT ->
                                        let {
                                          c#_abjx :: GHC.Prim.Int#
                                          [LclId,
                                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                   Value=False, ConLike=False, WorkFree=False,
                                                   Expandable=False,
                                                   Guidance=IF_ARGS [] 4 0}]
                                          c#_abjx
                                            = GHC.Prim.word2Int#
                                                (GHC.Prim.clz8#
                                                   (GHC.Prim.and#
                                                      (GHC.Prim.not#
                                                         (GHC.Prim.word8ToWord# r#_abjw))
                                                      255##)) } in
                                        let {
                                          y_abjy :: GHC.Prim.Int#
                                          [LclId,
                                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                   Value=False, ConLike=False, WorkFree=False,
                                                   Expandable=False,
                                                   Guidance=IF_ARGS [] 2 0}]
                                          y_abjy
                                            = GHC.Prim.xorI# c#_abjx (GHC.Prim.<=# c#_abjx 0#) } in
                                        Data.Text.Internal.Lazy.$WChunk
                                          (Data.Text.Internal.$WText
                                             (Data.Text.Array.ByteArray bx_abjh)
                                             (GHC.Types.I# (GHC.Prim.+# bx1_abji y_abjy))
                                             (GHC.Types.I# (GHC.Prim.-# bx2_abjj y_abjy)))
                                          ts_abjk
                                        };
                                      GHC.Types.EQ -> ts_abjk
                                    })
                             })
                          (let {
                             f2_abjA
                               :: Data.Text.Internal.Lazy.Text
                                  -> f_abj6 Data.Text.Internal.Lazy.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abjA
                               = GHC.Base.pure
                                   @f_abj6 $dApplicative_abj8 @Data.Text.Internal.Lazy.Text } in
                           let {
                             ds2_abjB
                               :: f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                  -> f_abj6 Data.Text.Internal.Lazy.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 100 0}]
                             ds2_abjB
                               = GHC.Base.fmap
                                   @f_abj6
                                   (GHC.Base.$p1Applicative @f_abj6 $dApplicative_abj8)
                                   @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                   @Data.Text.Internal.Lazy.Text
                                   (\ (p1_abjC :: (GHC.Types.Char, Data.Text.Internal.Lazy.Text)) ->
                                      case p1_abjC of { (x_abjE, ds_abjF) ->
                                      Data.Text.Lazy.cons x_abjE ds_abjF
                                      }) } in
                           \ (ds3_abjH
                                :: Data.Either.Either
                                     Data.Text.Internal.Lazy.Text
                                     (f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text))) ->
                             case ds3_abjH of {
                               Data.Either.Left x_abjJ -> f2_abjA x_abjJ;
                               Data.Either.Right y_abjL -> ds2_abjB y_abjL
                             }) } in
                  let {
                    g_abjN
                      :: p_abj5
                           (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                           (f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                         -> p_abj5
                              (Data.Either.Either
                                 Data.Text.Internal.Lazy.Text
                                 (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                              (Data.Either.Either
                                 Data.Text.Internal.Lazy.Text
                                 (f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abjN
                      = Data.Profunctor.Choice.right'
                          @p_abj5
                          $dChoice_abj7
                          @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                          @(f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                          @Data.Text.Internal.Lazy.Text } in
                  \ (x_abjO
                       :: p_abj5
                            (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                            (f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text))) ->
                    f1_abj9 (g_abjN x_abjO))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <Data.Text.Internal.Lazy.Text>_N
                                <Data.Text.Internal.Lazy.Text>_N
                                <GHC.Types.Char>_N
                                <GHC.Types.Char>_N)
                       :: Control.Lens.Type.Prism
                            Data.Text.Internal.Lazy.Text
                            Data.Text.Internal.Lazy.Text
                            (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                            (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                          ~R# Control.Lens.Cons.Cons
                                Data.Text.Internal.Lazy.Text
                                Data.Text.Internal.Lazy.Text
                                GHC.Types.Char
                                GHC.Types.Char))
              ((\ (@(p_abj5 :: * -> * -> *))
                  (@(f_abj6 :: * -> *))
                  ($dChoice_abj7 :: Data.Profunctor.Choice.Choice p_abj5)
                  ($dApplicative_abj8 :: GHC.Base.Applicative f_abj6) ->
                  let {
                    f1_abj9
                      :: p_abj5
                           (Data.Either.Either
                              Data.Text.Internal.Lazy.Text
                              (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                           (Data.Either.Either
                              Data.Text.Internal.Lazy.Text
                              (f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                         -> p_abj5
                              Data.Text.Internal.Lazy.Text (f_abj6 Data.Text.Internal.Lazy.Text)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 639 0}]
                    f1_abj9
                      = Data.Profunctor.Unsafe.dimap
                          @p_abj5
                          (Data.Profunctor.Choice.$p1Choice @p_abj5 $dChoice_abj7)
                          @Data.Text.Internal.Lazy.Text
                          @(Data.Either.Either
                              Data.Text.Internal.Lazy.Text
                              (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                          @(Data.Either.Either
                              Data.Text.Internal.Lazy.Text
                              (f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                          @(f_abj6 Data.Text.Internal.Lazy.Text)
                          (\ (s1_abja :: Data.Text.Internal.Lazy.Text) ->
                             case s1_abja of {
                               Data.Text.Internal.Lazy.Empty ->
                                 Data.Either.Left
                                   @Data.Text.Internal.Lazy.Text
                                   @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                   Data.Text.Internal.Lazy.Empty;
                               Data.Text.Internal.Lazy.Chunk bx_abjh bx1_abji bx2_abjj ts_abjk ->
                                 Data.Either.Right
                                   @Data.Text.Internal.Lazy.Text
                                   @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                   (case GHC.Prim.indexWord8Array# bx_abjh bx1_abji of r#_abjm
                                    { __DEFAULT ->
                                    let {
                                      c#_abjn :: GHC.Prim.Int#
                                      [LclId,
                                       Unf=Unf{Src=<vanilla>, TopLvl=False,
                                               Value=False, ConLike=False, WorkFree=False,
                                               Expandable=False,
                                               Guidance=IF_ARGS [] 4 0}]
                                      c#_abjn
                                        = GHC.Prim.word2Int#
                                            (GHC.Prim.clz8#
                                               (GHC.Prim.and#
                                                  (GHC.Prim.not# (GHC.Prim.word8ToWord# r#_abjm))
                                                  255##)) } in
                                    case GHC.Prim.xorI# c#_abjn (GHC.Prim.<=# c#_abjn 0#) of {
                                      __DEFAULT ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abjh (GHC.Prim.+# bx1_abji 1#)
                                        of r#1_abjp
                                        { __DEFAULT ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abjh (GHC.Prim.+# bx1_abji 2#)
                                        of r#2_abjq
                                        { __DEFAULT ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abjh (GHC.Prim.+# bx1_abji 3#)
                                        of r#3_abjr
                                        { __DEFAULT ->
                                        GHC.Types.C#
                                          (GHC.Prim.chr#
                                             (GHC.Prim.-#
                                                (GHC.Prim.+#
                                                   (GHC.Prim.+#
                                                      (GHC.Prim.+#
                                                         (GHC.Prim.uncheckedIShiftL#
                                                            (GHC.Prim.-#
                                                               (GHC.Prim.word2Int#
                                                                  (GHC.Prim.word8ToWord# r#_abjm))
                                                               240#)
                                                            18#)
                                                         (GHC.Prim.uncheckedIShiftL#
                                                            (GHC.Prim.-#
                                                               (GHC.Prim.word2Int#
                                                                  (GHC.Prim.word8ToWord# r#1_abjp))
                                                               128#)
                                                            12#))
                                                      (GHC.Prim.uncheckedIShiftL#
                                                         (GHC.Prim.-#
                                                            (GHC.Prim.word2Int#
                                                               (GHC.Prim.word8ToWord# r#2_abjq))
                                                            128#)
                                                         6#))
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.word8ToWord# r#3_abjr)))
                                                128#))
                                        }
                                        }
                                        };
                                      1# ->
                                        GHC.Types.C#
                                          (GHC.Prim.chr#
                                             (GHC.Prim.word2Int# (GHC.Prim.word8ToWord# r#_abjm)));
                                      2# ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abjh (GHC.Prim.+# bx1_abji 1#)
                                        of r#1_abjs
                                        { __DEFAULT ->
                                        GHC.Types.C#
                                          (GHC.Prim.chr#
                                             (GHC.Prim.-#
                                                (GHC.Prim.+#
                                                   (GHC.Prim.uncheckedIShiftL#
                                                      (GHC.Prim.-#
                                                         (GHC.Prim.word2Int#
                                                            (GHC.Prim.word8ToWord# r#_abjm))
                                                         192#)
                                                      6#)
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.word8ToWord# r#1_abjs)))
                                                128#))
                                        };
                                      3# ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abjh (GHC.Prim.+# bx1_abji 1#)
                                        of r#1_abjt
                                        { __DEFAULT ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abjh (GHC.Prim.+# bx1_abji 2#)
                                        of r#2_abju
                                        { __DEFAULT ->
                                        GHC.Types.C#
                                          (GHC.Prim.chr#
                                             (GHC.Prim.-#
                                                (GHC.Prim.+#
                                                   (GHC.Prim.+#
                                                      (GHC.Prim.uncheckedIShiftL#
                                                         (GHC.Prim.-#
                                                            (GHC.Prim.word2Int#
                                                               (GHC.Prim.word8ToWord# r#_abjm))
                                                            224#)
                                                         12#)
                                                      (GHC.Prim.uncheckedIShiftL#
                                                         (GHC.Prim.-#
                                                            (GHC.Prim.word2Int#
                                                               (GHC.Prim.word8ToWord# r#1_abjt))
                                                            128#)
                                                         6#))
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.word8ToWord# r#2_abju)))
                                                128#))
                                        }
                                        }
                                    }
                                    },
                                    case Data.Text.compareLength
                                           (Data.Text.Internal.Text bx_abjh bx1_abji bx2_abjj)
                                           (GHC.Types.I# 1#)
                                    of {
                                      __DEFAULT ->
                                        case GHC.Prim.indexWord8Array# bx_abjh bx1_abji of r#_abjw
                                        { __DEFAULT ->
                                        let {
                                          c#_abjx :: GHC.Prim.Int#
                                          [LclId,
                                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                   Value=False, ConLike=False, WorkFree=False,
                                                   Expandable=False,
                                                   Guidance=IF_ARGS [] 4 0}]
                                          c#_abjx
                                            = GHC.Prim.word2Int#
                                                (GHC.Prim.clz8#
                                                   (GHC.Prim.and#
                                                      (GHC.Prim.not#
                                                         (GHC.Prim.word8ToWord# r#_abjw))
                                                      255##)) } in
                                        let {
                                          y_abjy :: GHC.Prim.Int#
                                          [LclId,
                                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                   Value=False, ConLike=False, WorkFree=False,
                                                   Expandable=False,
                                                   Guidance=IF_ARGS [] 2 0}]
                                          y_abjy
                                            = GHC.Prim.xorI# c#_abjx (GHC.Prim.<=# c#_abjx 0#) } in
                                        Data.Text.Internal.Lazy.$WChunk
                                          (Data.Text.Internal.$WText
                                             (Data.Text.Array.ByteArray bx_abjh)
                                             (GHC.Types.I# (GHC.Prim.+# bx1_abji y_abjy))
                                             (GHC.Types.I# (GHC.Prim.-# bx2_abjj y_abjy)))
                                          ts_abjk
                                        };
                                      GHC.Types.EQ -> ts_abjk
                                    })
                             })
                          (let {
                             f2_abjA
                               :: Data.Text.Internal.Lazy.Text
                                  -> f_abj6 Data.Text.Internal.Lazy.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abjA
                               = GHC.Base.pure
                                   @f_abj6 $dApplicative_abj8 @Data.Text.Internal.Lazy.Text } in
                           let {
                             ds2_abjB
                               :: f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                  -> f_abj6 Data.Text.Internal.Lazy.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 100 0}]
                             ds2_abjB
                               = GHC.Base.fmap
                                   @f_abj6
                                   (GHC.Base.$p1Applicative @f_abj6 $dApplicative_abj8)
                                   @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                   @Data.Text.Internal.Lazy.Text
                                   (\ (p1_abjC :: (GHC.Types.Char, Data.Text.Internal.Lazy.Text)) ->
                                      case p1_abjC of { (x_abjE, ds_abjF) ->
                                      Data.Text.Lazy.cons x_abjE ds_abjF
                                      }) } in
                           \ (ds3_abjH
                                :: Data.Either.Either
                                     Data.Text.Internal.Lazy.Text
                                     (f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text))) ->
                             case ds3_abjH of {
                               Data.Either.Left x_abjJ -> f2_abjA x_abjJ;
                               Data.Either.Right y_abjL -> ds2_abjB y_abjL
                             }) } in
                  let {
                    g_abjN
                      :: p_abj5
                           (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                           (f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                         -> p_abj5
                              (Data.Either.Either
                                 Data.Text.Internal.Lazy.Text
                                 (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                              (Data.Either.Either
                                 Data.Text.Internal.Lazy.Text
                                 (f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abjN
                      = Data.Profunctor.Choice.right'
                          @p_abj5
                          $dChoice_abj7
                          @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                          @(f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                          @Data.Text.Internal.Lazy.Text } in
                  \ (x_abjO
                       :: p_abj5
                            (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                            (f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text))) ->
                    f1_abj9 (g_abjN x_abjO))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <Data.Text.Internal.Lazy.Text>_N
                                <Data.Text.Internal.Lazy.Text>_N
                                <GHC.Types.Char>_N
                                <GHC.Types.Char>_N)
                       :: Control.Lens.Type.Prism
                            Data.Text.Internal.Lazy.Text
                            Data.Text.Internal.Lazy.Text
                            (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                            (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                          ~R# Control.Lens.Cons.Cons
                                Data.Text.Internal.Lazy.Text
                                Data.Text.Internal.Lazy.Text
                                GHC.Types.Char
                                GHC.Types.Char))
              ((\ (@(p_abjR :: * -> * -> *))
                  (@(f_abjS :: * -> *))
                  ($dChoice_abjT :: Data.Profunctor.Choice.Choice p_abjR)
                  ($dApplicative_abjU :: GHC.Base.Applicative f_abjS) ->
                  let {
                    f1_abjV
                      :: p_abjR
                           (Data.Either.Either Data.Text.Internal.Lazy.Text ())
                           (Data.Either.Either Data.Text.Internal.Lazy.Text (f_abjS ()))
                         -> p_abjR
                              Data.Text.Internal.Lazy.Text (f_abjS Data.Text.Internal.Lazy.Text)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 310 0}]
                    f1_abjV
                      = Data.Profunctor.Unsafe.dimap
                          @p_abjR
                          (Data.Profunctor.Choice.$p1Choice @p_abjR $dChoice_abjT)
                          @Data.Text.Internal.Lazy.Text
                          @(Data.Either.Either Data.Text.Internal.Lazy.Text ())
                          @(Data.Either.Either Data.Text.Internal.Lazy.Text (f_abjS ()))
                          @(f_abjS Data.Text.Internal.Lazy.Text)
                          (\ (s_abjW :: Data.Text.Internal.Lazy.Text) ->
                             case Data.Text.Lazy.null s_abjW of {
                               GHC.Types.False ->
                                 Data.Either.Left @Data.Text.Internal.Lazy.Text @() s_abjW;
                               GHC.Types.True ->
                                 Data.Either.Right
                                   @Data.Text.Internal.Lazy.Text @() GHC.Tuple.Prim.()
                             })
                          (let {
                             f2_abjZ
                               :: Data.Text.Internal.Lazy.Text
                                  -> f_abjS Data.Text.Internal.Lazy.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abjZ
                               = GHC.Base.pure
                                   @f_abjS $dApplicative_abjU @Data.Text.Internal.Lazy.Text } in
                           let {
                             ds2_abk0 :: f_abjS () -> f_abjS Data.Text.Internal.Lazy.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 70 0}]
                             ds2_abk0
                               = GHC.Base.fmap
                                   @f_abjS
                                   (GHC.Base.$p1Applicative @f_abjS $dApplicative_abjU)
                                   @()
                                   @Data.Text.Internal.Lazy.Text
                                   (\ (ds3_abk1 :: ()) ->
                                      case ds3_abk1 of { () -> Data.Text.Internal.Lazy.empty }) } in
                           \ (ds3_abk3
                                :: Data.Either.Either Data.Text.Internal.Lazy.Text (f_abjS ())) ->
                             case ds3_abk3 of {
                               Data.Either.Left x_abk5 -> f2_abjZ x_abk5;
                               Data.Either.Right y_abk7 -> ds2_abk0 y_abk7
                             }) } in
                  let {
                    g_abk9
                      :: p_abjR () (f_abjS ())
                         -> p_abjR
                              (Data.Either.Either Data.Text.Internal.Lazy.Text ())
                              (Data.Either.Either Data.Text.Internal.Lazy.Text (f_abjS ()))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abk9
                      = Data.Profunctor.Choice.right'
                          @p_abjR
                          $dChoice_abjT
                          @()
                          @(f_abjS ())
                          @Data.Text.Internal.Lazy.Text } in
                  \ (x_abka :: p_abjR () (f_abjS ())) -> f1_abjV (g_abk9 x_abka))
               `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                <Data.Text.Internal.Lazy.Text>_N)
                       :: Control.Lens.Type.Prism' Data.Text.Internal.Lazy.Text ()
                          ~R# Control.Lens.Empty.AsEmpty Data.Text.Internal.Lazy.Text))
              (Data.Functor.Contravariant.$fContravariantConst
                 @Data.Text.Internal.Lazy.Text)
              (Data.Functor.Const.$fFunctorConst @Data.Text.Internal.Lazy.Text)
    Cont:   ApplyToVal nodup hole Control.Lens.Getter.Getting
                                    Data.Text.Internal.Lazy.Text
                                    Data.Text.Internal.Lazy.Text
                                    Data.Text.Internal.Lazy.Text
              ((\ (ds_abeK [Occ=Once1] :: a_abeH) -> ds_abeK)
               `cast` (<a_abeH>_R
                       %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                          <*>_N <a_abeH>_R <a_abeH>_P)
                       :: (a_abeH -> a_abeH)
                          ~R# (a_abeH -> Data.Functor.Const.Const a_abeH a_abeH)))
            ApplyToVal nodup hole Data.Text.Internal.Lazy.Text
                                  -> Data.Functor.Const.Const
                                       Data.Text.Internal.Lazy.Text Data.Text.Internal.Lazy.Text
              s_a8Ku
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N
                        <Data.Text.Internal.Lazy.Text>_R
                        <Data.Text.Internal.Lazy.Text>_P
                    :: Data.Functor.Const.Const
                         Data.Text.Internal.Lazy.Text Data.Text.Internal.Lazy.Text
                       ~R# Data.Text.Internal.Lazy.Text)
            Stop[RuleArgCtxt] Data.Text.Internal.Lazy.Text
Rule fired
    Rule: Class op ==
    Module: (BUILTIN)
    Before: GHC.Classes.==
              TyArg Data.Text.Internal.Lazy.Text
              ValArg Data.Text.Lazy.$fEqText
              ValArg s_a8Ku
              ValArg s_a8Ku
    After:  Data.Text.Internal.Lazy.equal ValArg s_a8Ku ValArg s_a8Ku
    Cont:   Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: unpack
    Module: (GHC.Base)
    Before: GHC.CString.unpackCString# ValArg "B -> B"#
    After:  (\ (a_ab7z :: GHC.Prim.Addr#) ->
               GHC.Base.build
                 @GHC.Types.Char
                 (\ (@b_ab7A) -> GHC.CString.unpackFoldrCString# @b_ab7A a_ab7z))
              "B -> B"#
    Cont:   Stop[BoringCtxt] Test.Tasty.Core.TestName
Rule fired
    Rule: Class op property
    Module: (BUILTIN)
    Before: Test.QuickCheck.Property.property
              TyArg Data.ByteString.Internal.Type.ByteString -> GHC.Types.Bool
              ValArg $dTestable_a9a1
    After:  Test.QuickCheck.Property.$fTestableFUN_$cproperty
              @Data.ByteString.Internal.Type.ByteString
              @GHC.Types.Bool
              Test.QuickCheck.Instances.ByteString.$fArbitraryByteString0
              Data.ByteString.Internal.Type.$fShowByteString
              Test.QuickCheck.Property.$fTestableBool
    Cont:   ApplyToVal nodup hole (Data.ByteString.Internal.Type.ByteString
                                   -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              prop_ab7M
            CastIt (Sym (Test.Tasty.QuickCheck.N:QC[0])
                    :: Test.QuickCheck.Property.Property ~R# Test.Tasty.QuickCheck.QC)
            Stop[BoringCtxt] Test.Tasty.QuickCheck.QC
Rule fired
    Rule: Class op propertyForAllShrinkShow
    Module: (BUILTIN)
    Before: Test.QuickCheck.Property.propertyForAllShrinkShow
              TyArg GHC.Types.Bool ValArg Test.QuickCheck.Property.$fTestableBool
    After:  Test.QuickCheck.Property.$fTestableBool1
            `cast` (forall (a :: <*>_N).
                    <Test.QuickCheck.Gen.Gen a>_R
                    %<'GHC.Types.Many>_N ->_R <a -> [a]>_R
                    %<'GHC.Types.Many>_N ->_R <a -> [GHC.Base.String]>_R
                    %<'GHC.Types.Many>_N ->_R <a -> GHC.Types.Bool>_R
                    %<'GHC.Types.Many>_N ->_R Sym (Test.QuickCheck.Gen.N:Gen[0]
                                                       (Test.QuickCheck.Property.N:Prop[0]))
                                              ; Sym (Test.QuickCheck.Property.N:Property[0])
                    :: (forall {a}.
                        Test.QuickCheck.Gen.Gen a
                        -> (a -> [a])
                        -> (a -> [GHC.Base.String])
                        -> (a -> GHC.Types.Bool)
                        -> Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int
                        -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result)
                       ~R# (forall {a}.
                            Test.QuickCheck.Gen.Gen a
                            -> (a -> [a])
                            -> (a -> [GHC.Base.String])
                            -> (a -> GHC.Types.Bool)
                            -> Test.QuickCheck.Property.Property))
    Cont:   ApplyToTy Data.ByteString.Internal.Type.ByteString
            ApplyToVal nodup hole Test.QuickCheck.Gen.Gen
                                    Data.ByteString.Internal.Type.ByteString
                                  -> (Data.ByteString.Internal.Type.ByteString
                                      -> [Data.ByteString.Internal.Type.ByteString])
                                  -> (Data.ByteString.Internal.Type.ByteString -> [GHC.Base.String])
                                  -> (Data.ByteString.Internal.Type.ByteString -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (Test.QuickCheck.Arbitrary.arbitrary @a_ab9u $dArbitrary_ab9w)
            ApplyToVal nodup hole (Data.ByteString.Internal.Type.ByteString
                                   -> [Data.ByteString.Internal.Type.ByteString])
                                  -> (Data.ByteString.Internal.Type.ByteString -> [GHC.Base.String])
                                  -> (Data.ByteString.Internal.Type.ByteString -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (Test.QuickCheck.Arbitrary.shrink @a_ab9u $dArbitrary_ab9w)
            ApplyToVal nodup hole (Data.ByteString.Internal.Type.ByteString
                                   -> [GHC.Base.String])
                                  -> (Data.ByteString.Internal.Type.ByteString -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (let {
                 g_ab9A [Occ=OnceL1!] :: a_ab9u -> GHC.Base.String
                 [LclId]
                 g_ab9A = GHC.Show.show @a_ab9u $dShow_ab9x } in
               \ (x_ab9B [Occ=Once1] :: a_ab9u) ->
                 GHC.Types.:
                   @GHC.Base.String (g_ab9A x_ab9B) (GHC.Types.[] @GHC.Base.String))
            ApplyToVal nodup hole (Data.ByteString.Internal.Type.ByteString
                                   -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              f_ab9z
            CastIt (Sym (Test.Tasty.QuickCheck.N:QC[0])
                    :: Test.QuickCheck.Property.Property ~R# Test.Tasty.QuickCheck.QC)
            Stop[BoringCtxt] Test.Tasty.QuickCheck.QC
Rule fired
    Rule: Class op arbitrary
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.arbitrary
              TyArg Data.ByteString.Internal.Type.ByteString
              ValArg Test.QuickCheck.Instances.ByteString.$fArbitraryByteString0
    After:  Test.QuickCheck.Instances.ByteString.$fArbitraryByteString3
            `cast` (Sym (Test.QuickCheck.Gen.N:Gen[0]
                             <Data.ByteString.Internal.Type.ByteString>_R)
                    :: (Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int -> Data.ByteString.Internal.Type.ByteString)
                       ~R# Test.QuickCheck.Gen.Gen
                             Data.ByteString.Internal.Type.ByteString)
    Cont:   Stop[BoringCtxt] Test.QuickCheck.Gen.Gen
                               Data.ByteString.Internal.Type.ByteString
Rule fired
    Rule: Class op shrink
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.shrink
              TyArg Data.ByteString.Internal.Type.ByteString
              ValArg Test.QuickCheck.Instances.ByteString.$fArbitraryByteString0
    After:  Test.QuickCheck.Instances.ByteString.$fArbitraryByteString0_$cshrink
    Cont:   Stop[BoringCtxt] Data.ByteString.Internal.Type.ByteString
                             -> [Data.ByteString.Internal.Type.ByteString]
Rule fired
    Rule: Class op show
    Module: (BUILTIN)
    Before: GHC.Show.show
              TyArg Data.ByteString.Internal.Type.ByteString
              ValArg Data.ByteString.Internal.Type.$fShowByteString
    After:  Data.ByteString.Internal.Type.$fShowByteString_$cshow
    Cont:   Stop[RhsCtxt(NonRecursive)] Data.ByteString.Internal.Type.ByteString
                                        -> GHC.Base.String
Rule fired
    Rule: Class op reader
    Module: (BUILTIN)
    Before: Control.Monad.Reader.Class.reader
              TyArg Data.ByteString.Internal.Type.ByteString
              TyArg (->) Data.ByteString.Internal.Type.ByteString
              ValArg Control.Monad.Reader.Class.$fMonadReaderrFUN
                       @Data.ByteString.Internal.Type.ByteString
    After:  \ (@a_abeP) ->
              GHC.Base.id @(Data.ByteString.Internal.Type.ByteString -> a_abeP)
    Cont:   ApplyToTy Data.ByteString.Internal.Type.ByteString
            ApplyToVal nodup hole (Data.ByteString.Internal.Type.ByteString
                                   -> Data.ByteString.Internal.Type.ByteString)
                                  -> Data.ByteString.Internal.Type.ByteString
                                  -> Data.ByteString.Internal.Type.ByteString
              ((l_abeJ
                  ((\ (ds_abeK [Occ=Once1] :: a_abeH) -> ds_abeK)
                   `cast` (<a_abeH>_R
                           %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                              <*>_N <a_abeH>_R <a_abeH>_P)
                           :: (a_abeH -> a_abeH)
                              ~R# (a_abeH -> Data.Functor.Const.Const a_abeH a_abeH))))
               `cast` (<s_abeF>_R
                       %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                     <*>_N <a_abeH>_R <s_abeF>_P
                       :: (s_abeF -> Data.Functor.Const.Const a_abeH s_abeF)
                          ~R# (s_abeF -> a_abeH)))
            ApplyToVal nodup hole Data.ByteString.Internal.Type.ByteString
                                  -> Data.ByteString.Internal.Type.ByteString
              s_a8KR
            Stop[RuleArgCtxt] Data.ByteString.Internal.Type.ByteString
Rule fired
    Rule: recons/id
    Module: (Control.Lens.Cons.Extras)
    Before: Control.Lens.Cons.Extras.recons
              TyArg Data.ByteString.Internal.Type.ByteString
              TyArg GHC.Word.Word8
              TyArg Data.ByteString.Internal.Type.ByteString
              ValArg (\ (@(p_abkq :: * -> * -> *))
                        (@(f_abkr :: * -> *))
                        ($dChoice_abks :: Data.Profunctor.Choice.Choice p_abkq)
                        ($dApplicative_abkt :: GHC.Base.Applicative f_abkr) ->
                        let {
                          f1_abku
                            :: p_abkq
                                 (Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                                 (Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString
                                    (f_abkr
                                       (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                               -> p_abkq
                                    Data.ByteString.Internal.Type.ByteString
                                    (f_abkr Data.ByteString.Internal.Type.ByteString)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 612 0}]
                          f1_abku
                            = Data.Profunctor.Unsafe.dimap
                                @p_abkq
                                (Data.Profunctor.Choice.$p1Choice @p_abkq $dChoice_abks)
                                @Data.ByteString.Internal.Type.ByteString
                                @(Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                                @(Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString
                                    (f_abkr
                                       (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                                @(f_abkr Data.ByteString.Internal.Type.ByteString)
                                (\ (s1_abkv :: Data.ByteString.Internal.Type.ByteString) ->
                                   case s1_abkv of wild_abkw
                                   { Data.ByteString.Internal.Type.BS bx_abkx bx1_abky bx2_abkz ->
                                   case GHC.Classes.leInt (GHC.Types.I# bx2_abkz) (GHC.Types.I# 0#)
                                   of {
                                     GHC.Types.False ->
                                       Data.Either.Right
                                         @Data.ByteString.Internal.Type.ByteString
                                         @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                         (case GHC.Prim.readWord8OffAddr#
                                                 @GHC.Prim.RealWorld bx_abkx 0# GHC.Prim.realWorld#
                                          of
                                          { (# ipv_abkE, ipv1_abkF #) ->
                                          case GHC.Prim.touch#
                                                 @'GHC.Types.Lifted
                                                 @GHC.ForeignPtr.ForeignPtrContents
                                                 bx1_abky
                                                 ipv_abkE
                                          of
                                          { __DEFAULT ->
                                          GHC.Word.W8# ipv1_abkF
                                          }
                                          },
                                          Data.ByteString.Internal.Type.$WBS
                                            (GHC.ForeignPtr.ForeignPtr
                                               @GHC.Word.Word8
                                               (GHC.Prim.plusAddr# bx_abkx 1#)
                                               bx1_abky)
                                            (GHC.Types.I# (GHC.Prim.-# bx2_abkz 1#)));
                                     GHC.Types.True ->
                                       Data.Either.Left
                                         @Data.ByteString.Internal.Type.ByteString
                                         @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                         wild_abkw
                                   }
                                   })
                                (let {
                                   f2_abkJ
                                     :: Data.ByteString.Internal.Type.ByteString
                                        -> f_abkr Data.ByteString.Internal.Type.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abkJ
                                     = GHC.Base.pure
                                         @f_abkr
                                         $dApplicative_abkt
                                         @Data.ByteString.Internal.Type.ByteString } in
                                 let {
                                   ds2_abkK
                                     :: f_abkr
                                          (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                        -> f_abkr Data.ByteString.Internal.Type.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 259 0}]
                                   ds2_abkK
                                     = GHC.Base.fmap
                                         @f_abkr
                                         (GHC.Base.$p1Applicative @f_abkr $dApplicative_abkt)
                                         @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                         @Data.ByteString.Internal.Type.ByteString
                                         (\ (p1_abkL
                                               :: (GHC.Word.Word8,
                                                   Data.ByteString.Internal.Type.ByteString)) ->
                                            case p1_abkL of { (ds_abkN, y_abkO) ->
                                            case y_abkO of
                                            { Data.ByteString.Internal.Type.BS bx_abl0 bx1_abl1
                                                                               bx2_abl2 ->
                                            GHC.Magic.runRW#
                                              @GHC.Types.LiftedRep
                                              @Data.ByteString.Internal.Type.ByteString
                                              (\ (s_abkY [OS=OneShot]
                                                    :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                                                 let {
                                                   x_abkZ :: GHC.Prim.Int#
                                                   [LclId,
                                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                            Value=False, ConLike=False,
                                                            WorkFree=False, Expandable=False,
                                                            Guidance=IF_ARGS [] 1 0}]
                                                   x_abkZ = GHC.Prim.+# bx2_abl2 1# } in
                                                 case GHC.Prim.<# x_abkZ 0# of {
                                                   __DEFAULT ->
                                                     case GHC.Prim.newPinnedByteArray#
                                                            @GHC.Prim.RealWorld x_abkZ s_abkY
                                                     of
                                                     { (# ipv_abl7, ipv1_abl8 #) ->
                                                     let {
                                                       ipv2_abl6 :: GHC.Prim.Addr#
                                                       [LclId,
                                                        Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                                Value=False, ConLike=False,
                                                                WorkFree=False, Expandable=False,
                                                                Guidance=IF_ARGS [] 1 0}]
                                                       ipv2_abl6
                                                         = GHC.Prim.mutableByteArrayContents#
                                                             @GHC.Prim.RealWorld ipv1_abl8 } in
                                                     let {
                                                       ipv3_abla
                                                         :: GHC.ForeignPtr.ForeignPtrContents
                                                       [LclId,
                                                        Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                                Value=True, ConLike=True,
                                                                WorkFree=True, Expandable=True,
                                                                Guidance=IF_ARGS [] 10 10}]
                                                       ipv3_abla
                                                         = GHC.ForeignPtr.PlainPtr ipv1_abl8 } in
                                                     case ds_abkN of { GHC.Word.W8# x1_abms ->
                                                     case GHC.Prim.writeWord8OffAddr#
                                                            @GHC.Prim.RealWorld
                                                            ipv2_abl6
                                                            0#
                                                            x1_abms
                                                            ipv_abl7
                                                     of s2_abmu
                                                     { __DEFAULT ->
                                                     case GHC.Prim.touch#
                                                            @'GHC.Types.Lifted
                                                            @GHC.ForeignPtr.ForeignPtrContents
                                                            ipv3_abla
                                                            s2_abmu
                                                     of s'_abmv
                                                     { __DEFAULT ->
                                                     case {__ffi_static_ccall_unsafe base:memcpy :: Addr#
                                          -> Addr#
                                          -> Word64#
                                          -> State# RealWorld
                                          -> (# State# RealWorld, Addr# #)}_abmw
                                                            (GHC.Prim.plusAddr# ipv2_abl6 1#)
                                                            bx_abl0
                                                            (GHC.Prim.int64ToWord64#
                                                               (GHC.Prim.intToInt64# bx2_abl2))
                                                            s'_abmv
                                                     of
                                                     { (# ds4_abmy, ds5_abmz #) ->
                                                     case GHC.Prim.touch#
                                                            @'GHC.Types.Lifted
                                                            @GHC.ForeignPtr.ForeignPtrContents
                                                            bx1_abl1
                                                            ds4_abmy
                                                     of s'1_abmB
                                                     { __DEFAULT ->
                                                     case GHC.Prim.touch#
                                                            @'GHC.Types.Lifted
                                                            @GHC.ForeignPtr.ForeignPtrContents
                                                            ipv3_abla
                                                            s'1_abmB
                                                     of s'2_abmC
                                                     { __DEFAULT ->
                                                     case GHC.Magic.lazy
                                                            @((GHC.Prim.State# GHC.Prim.RealWorld
                                                               -> (# GHC.Prim.State#
                                                                       GHC.Prim.RealWorld,
                                                                     GHC.Prim.Addr# #))
                                                              -> (# GHC.Prim.State#
                                                                      GHC.Prim.RealWorld,
                                                                    GHC.Prim.Addr# #))
                                                            (GHC.Magic.runRW#
                                                               @('GHC.Types.TupleRep
                                                                   '[GHC.Types.ZeroBitRep,
                                                                     'GHC.Types.AddrRep])
                                                               @(# GHC.Prim.State#
                                                                     GHC.Prim.RealWorld,
                                                                   GHC.Prim.Addr# #))
                                                            (\ _ [Occ=Dead] ->
                                                               (# s'2_abmC, ipv2_abl6 #))
                                                     of
                                                     { (# ipv6_abmF, ipv7_abmG #) ->
                                                     Data.ByteString.Internal.Type.BS
                                                       ipv7_abmG ipv3_abla x_abkZ
                                                     }
                                                     }
                                                     }
                                                     }
                                                     }
                                                     }
                                                     }
                                                     };
                                                   1# ->
                                                     case GHC.ForeignPtr.mallocPlainForeignPtrBytes2
                                                     of wild_00 {
                                                     }
                                                 })
                                            }
                                            }) } in
                                 \ (ds3_abmJ
                                      :: Data.Either.Either
                                           Data.ByteString.Internal.Type.ByteString
                                           (f_abkr
                                              (GHC.Word.Word8,
                                               Data.ByteString.Internal.Type.ByteString))) ->
                                   case ds3_abmJ of {
                                     Data.Either.Left x_abmL -> f2_abkJ x_abmL;
                                     Data.Either.Right y_abmN -> ds2_abkK y_abmN
                                   }) } in
                        let {
                          g_abmP
                            :: p_abkq
                                 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                 (f_abkr (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                               -> p_abkq
                                    (Data.Either.Either
                                       Data.ByteString.Internal.Type.ByteString
                                       (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                                    (Data.Either.Either
                                       Data.ByteString.Internal.Type.ByteString
                                       (f_abkr
                                          (GHC.Word.Word8,
                                           Data.ByteString.Internal.Type.ByteString)))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abmP
                            = Data.Profunctor.Choice.right'
                                @p_abkq
                                $dChoice_abks
                                @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                @(f_abkr
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                                @Data.ByteString.Internal.Type.ByteString } in
                        \ (x_abmQ
                             :: p_abkq
                                  (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                  (f_abkr
                                     (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))) ->
                          f1_abku (g_abmP x_abmQ))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <Data.ByteString.Internal.Type.ByteString>_N
                                      <Data.ByteString.Internal.Type.ByteString>_N
                                      <GHC.Word.Word8>_N
                                      <GHC.Word.Word8>_N)
                             :: Control.Lens.Type.Prism
                                  Data.ByteString.Internal.Type.ByteString
                                  Data.ByteString.Internal.Type.ByteString
                                  (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                  (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                ~R# Control.Lens.Cons.Cons
                                      Data.ByteString.Internal.Type.ByteString
                                      Data.ByteString.Internal.Type.ByteString
                                      GHC.Word.Word8
                                      GHC.Word.Word8)
              ValArg (\ (@(p_abkq :: * -> * -> *))
                        (@(f_abkr :: * -> *))
                        ($dChoice_abks :: Data.Profunctor.Choice.Choice p_abkq)
                        ($dApplicative_abkt :: GHC.Base.Applicative f_abkr) ->
                        let {
                          f1_abku
                            :: p_abkq
                                 (Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                                 (Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString
                                    (f_abkr
                                       (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                               -> p_abkq
                                    Data.ByteString.Internal.Type.ByteString
                                    (f_abkr Data.ByteString.Internal.Type.ByteString)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 612 0}]
                          f1_abku
                            = Data.Profunctor.Unsafe.dimap
                                @p_abkq
                                (Data.Profunctor.Choice.$p1Choice @p_abkq $dChoice_abks)
                                @Data.ByteString.Internal.Type.ByteString
                                @(Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                                @(Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString
                                    (f_abkr
                                       (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                                @(f_abkr Data.ByteString.Internal.Type.ByteString)
                                (\ (s1_abkv :: Data.ByteString.Internal.Type.ByteString) ->
                                   case s1_abkv of wild_abkw
                                   { Data.ByteString.Internal.Type.BS bx_abkx bx1_abky bx2_abkz ->
                                   case GHC.Classes.leInt (GHC.Types.I# bx2_abkz) (GHC.Types.I# 0#)
                                   of {
                                     GHC.Types.False ->
                                       Data.Either.Right
                                         @Data.ByteString.Internal.Type.ByteString
                                         @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                         (case GHC.Prim.readWord8OffAddr#
                                                 @GHC.Prim.RealWorld bx_abkx 0# GHC.Prim.realWorld#
                                          of
                                          { (# ipv_abkE, ipv1_abkF #) ->
                                          case GHC.Prim.touch#
                                                 @'GHC.Types.Lifted
                                                 @GHC.ForeignPtr.ForeignPtrContents
                                                 bx1_abky
                                                 ipv_abkE
                                          of
                                          { __DEFAULT ->
                                          GHC.Word.W8# ipv1_abkF
                                          }
                                          },
                                          Data.ByteString.Internal.Type.$WBS
                                            (GHC.ForeignPtr.ForeignPtr
                                               @GHC.Word.Word8
                                               (GHC.Prim.plusAddr# bx_abkx 1#)
                                               bx1_abky)
                                            (GHC.Types.I# (GHC.Prim.-# bx2_abkz 1#)));
                                     GHC.Types.True ->
                                       Data.Either.Left
                                         @Data.ByteString.Internal.Type.ByteString
                                         @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                         wild_abkw
                                   }
                                   })
                                (let {
                                   f2_abkJ
                                     :: Data.ByteString.Internal.Type.ByteString
                                        -> f_abkr Data.ByteString.Internal.Type.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abkJ
                                     = GHC.Base.pure
                                         @f_abkr
                                         $dApplicative_abkt
                                         @Data.ByteString.Internal.Type.ByteString } in
                                 let {
                                   ds2_abkK
                                     :: f_abkr
                                          (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                        -> f_abkr Data.ByteString.Internal.Type.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 259 0}]
                                   ds2_abkK
                                     = GHC.Base.fmap
                                         @f_abkr
                                         (GHC.Base.$p1Applicative @f_abkr $dApplicative_abkt)
                                         @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                         @Data.ByteString.Internal.Type.ByteString
                                         (\ (p1_abkL
                                               :: (GHC.Word.Word8,
                                                   Data.ByteString.Internal.Type.ByteString)) ->
                                            case p1_abkL of { (ds_abkN, y_abkO) ->
                                            case y_abkO of
                                            { Data.ByteString.Internal.Type.BS bx_abl0 bx1_abl1
                                                                               bx2_abl2 ->
                                            GHC.Magic.runRW#
                                              @GHC.Types.LiftedRep
                                              @Data.ByteString.Internal.Type.ByteString
                                              (\ (s_abkY [OS=OneShot]
                                                    :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                                                 let {
                                                   x_abkZ :: GHC.Prim.Int#
                                                   [LclId,
                                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                            Value=False, ConLike=False,
                                                            WorkFree=False, Expandable=False,
                                                            Guidance=IF_ARGS [] 1 0}]
                                                   x_abkZ = GHC.Prim.+# bx2_abl2 1# } in
                                                 case GHC.Prim.<# x_abkZ 0# of {
                                                   __DEFAULT ->
                                                     case GHC.Prim.newPinnedByteArray#
                                                            @GHC.Prim.RealWorld x_abkZ s_abkY
                                                     of
                                                     { (# ipv_abl7, ipv1_abl8 #) ->
                                                     let {
                                                       ipv2_abl6 :: GHC.Prim.Addr#
                                                       [LclId,
                                                        Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                                Value=False, ConLike=False,
                                                                WorkFree=False, Expandable=False,
                                                                Guidance=IF_ARGS [] 1 0}]
                                                       ipv2_abl6
                                                         = GHC.Prim.mutableByteArrayContents#
                                                             @GHC.Prim.RealWorld ipv1_abl8 } in
                                                     let {
                                                       ipv3_abla
                                                         :: GHC.ForeignPtr.ForeignPtrContents
                                                       [LclId,
                                                        Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                                Value=True, ConLike=True,
                                                                WorkFree=True, Expandable=True,
                                                                Guidance=IF_ARGS [] 10 10}]
                                                       ipv3_abla
                                                         = GHC.ForeignPtr.PlainPtr ipv1_abl8 } in
                                                     case ds_abkN of { GHC.Word.W8# x1_abms ->
                                                     case GHC.Prim.writeWord8OffAddr#
                                                            @GHC.Prim.RealWorld
                                                            ipv2_abl6
                                                            0#
                                                            x1_abms
                                                            ipv_abl7
                                                     of s2_abmu
                                                     { __DEFAULT ->
                                                     case GHC.Prim.touch#
                                                            @'GHC.Types.Lifted
                                                            @GHC.ForeignPtr.ForeignPtrContents
                                                            ipv3_abla
                                                            s2_abmu
                                                     of s'_abmv
                                                     { __DEFAULT ->
                                                     case {__ffi_static_ccall_unsafe base:memcpy :: Addr#
                                          -> Addr#
                                          -> Word64#
                                          -> State# RealWorld
                                          -> (# State# RealWorld, Addr# #)}_abmw
                                                            (GHC.Prim.plusAddr# ipv2_abl6 1#)
                                                            bx_abl0
                                                            (GHC.Prim.int64ToWord64#
                                                               (GHC.Prim.intToInt64# bx2_abl2))
                                                            s'_abmv
                                                     of
                                                     { (# ds4_abmy, ds5_abmz #) ->
                                                     case GHC.Prim.touch#
                                                            @'GHC.Types.Lifted
                                                            @GHC.ForeignPtr.ForeignPtrContents
                                                            bx1_abl1
                                                            ds4_abmy
                                                     of s'1_abmB
                                                     { __DEFAULT ->
                                                     case GHC.Prim.touch#
                                                            @'GHC.Types.Lifted
                                                            @GHC.ForeignPtr.ForeignPtrContents
                                                            ipv3_abla
                                                            s'1_abmB
                                                     of s'2_abmC
                                                     { __DEFAULT ->
                                                     case GHC.Magic.lazy
                                                            @((GHC.Prim.State# GHC.Prim.RealWorld
                                                               -> (# GHC.Prim.State#
                                                                       GHC.Prim.RealWorld,
                                                                     GHC.Prim.Addr# #))
                                                              -> (# GHC.Prim.State#
                                                                      GHC.Prim.RealWorld,
                                                                    GHC.Prim.Addr# #))
                                                            (GHC.Magic.runRW#
                                                               @('GHC.Types.TupleRep
                                                                   '[GHC.Types.ZeroBitRep,
                                                                     'GHC.Types.AddrRep])
                                                               @(# GHC.Prim.State#
                                                                     GHC.Prim.RealWorld,
                                                                   GHC.Prim.Addr# #))
                                                            (\ _ [Occ=Dead] ->
                                                               (# s'2_abmC, ipv2_abl6 #))
                                                     of
                                                     { (# ipv6_abmF, ipv7_abmG #) ->
                                                     Data.ByteString.Internal.Type.BS
                                                       ipv7_abmG ipv3_abla x_abkZ
                                                     }
                                                     }
                                                     }
                                                     }
                                                     }
                                                     }
                                                     }
                                                     };
                                                   1# ->
                                                     case GHC.ForeignPtr.mallocPlainForeignPtrBytes2
                                                     of wild_00 {
                                                     }
                                                 })
                                            }
                                            }) } in
                                 \ (ds3_abmJ
                                      :: Data.Either.Either
                                           Data.ByteString.Internal.Type.ByteString
                                           (f_abkr
                                              (GHC.Word.Word8,
                                               Data.ByteString.Internal.Type.ByteString))) ->
                                   case ds3_abmJ of {
                                     Data.Either.Left x_abmL -> f2_abkJ x_abmL;
                                     Data.Either.Right y_abmN -> ds2_abkK y_abmN
                                   }) } in
                        let {
                          g_abmP
                            :: p_abkq
                                 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                 (f_abkr (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                               -> p_abkq
                                    (Data.Either.Either
                                       Data.ByteString.Internal.Type.ByteString
                                       (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                                    (Data.Either.Either
                                       Data.ByteString.Internal.Type.ByteString
                                       (f_abkr
                                          (GHC.Word.Word8,
                                           Data.ByteString.Internal.Type.ByteString)))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abmP
                            = Data.Profunctor.Choice.right'
                                @p_abkq
                                $dChoice_abks
                                @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                @(f_abkr
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                                @Data.ByteString.Internal.Type.ByteString } in
                        \ (x_abmQ
                             :: p_abkq
                                  (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                  (f_abkr
                                     (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))) ->
                          f1_abku (g_abmP x_abmQ))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <Data.ByteString.Internal.Type.ByteString>_N
                                      <Data.ByteString.Internal.Type.ByteString>_N
                                      <GHC.Word.Word8>_N
                                      <GHC.Word.Word8>_N)
                             :: Control.Lens.Type.Prism
                                  Data.ByteString.Internal.Type.ByteString
                                  Data.ByteString.Internal.Type.ByteString
                                  (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                  (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                ~R# Control.Lens.Cons.Cons
                                      Data.ByteString.Internal.Type.ByteString
                                      Data.ByteString.Internal.Type.ByteString
                                      GHC.Word.Word8
                                      GHC.Word.Word8)
              ValArg (\ (@(p_abmX :: * -> * -> *))
                        (@(f_abmY :: * -> *))
                        ($dChoice_abmZ :: Data.Profunctor.Choice.Choice p_abmX)
                        ($dApplicative_abn0 :: GHC.Base.Applicative f_abmY) ->
                        let {
                          f1_abn1
                            :: p_abmX
                                 (Data.Either.Either Data.ByteString.Internal.Type.ByteString ())
                                 (Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString (f_abmY ()))
                               -> p_abmX
                                    Data.ByteString.Internal.Type.ByteString
                                    (f_abmY Data.ByteString.Internal.Type.ByteString)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 350 0}]
                          f1_abn1
                            = Data.Profunctor.Unsafe.dimap
                                @p_abmX
                                (Data.Profunctor.Choice.$p1Choice @p_abmX $dChoice_abmZ)
                                @Data.ByteString.Internal.Type.ByteString
                                @(Data.Either.Either Data.ByteString.Internal.Type.ByteString ())
                                @(Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString (f_abmY ()))
                                @(f_abmY Data.ByteString.Internal.Type.ByteString)
                                (\ (s_abn2 :: Data.ByteString.Internal.Type.ByteString) ->
                                   case s_abn2 of wild_abn3
                                   { Data.ByteString.Internal.Type.BS bx_abn4 bx1_abn5 bx2_abn6 ->
                                   case GHC.Classes.leInt (GHC.Types.I# bx2_abn6) (GHC.Types.I# 0#)
                                   of {
                                     GHC.Types.False ->
                                       Data.Either.Left
                                         @Data.ByteString.Internal.Type.ByteString @() wild_abn3;
                                     GHC.Types.True ->
                                       Data.Either.Right
                                         @Data.ByteString.Internal.Type.ByteString
                                         @()
                                         GHC.Tuple.Prim.()
                                   }
                                   })
                                (let {
                                   f2_abna
                                     :: Data.ByteString.Internal.Type.ByteString
                                        -> f_abmY Data.ByteString.Internal.Type.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abna
                                     = GHC.Base.pure
                                         @f_abmY
                                         $dApplicative_abn0
                                         @Data.ByteString.Internal.Type.ByteString } in
                                 let {
                                   ds2_abnb
                                     :: f_abmY () -> f_abmY Data.ByteString.Internal.Type.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 70 0}]
                                   ds2_abnb
                                     = GHC.Base.fmap
                                         @f_abmY
                                         (GHC.Base.$p1Applicative @f_abmY $dApplicative_abn0)
                                         @()
                                         @Data.ByteString.Internal.Type.ByteString
                                         (\ (ds3_abnc :: ()) ->
                                            case ds3_abnc of { () ->
                                            Data.ByteString.Internal.Type.empty
                                            }) } in
                                 \ (ds3_abne
                                      :: Data.Either.Either
                                           Data.ByteString.Internal.Type.ByteString (f_abmY ())) ->
                                   case ds3_abne of {
                                     Data.Either.Left x_abng -> f2_abna x_abng;
                                     Data.Either.Right y_abni -> ds2_abnb y_abni
                                   }) } in
                        let {
                          g_abnk
                            :: p_abmX () (f_abmY ())
                               -> p_abmX
                                    (Data.Either.Either Data.ByteString.Internal.Type.ByteString ())
                                    (Data.Either.Either
                                       Data.ByteString.Internal.Type.ByteString (f_abmY ()))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abnk
                            = Data.Profunctor.Choice.right'
                                @p_abmX
                                $dChoice_abmZ
                                @()
                                @(f_abmY ())
                                @Data.ByteString.Internal.Type.ByteString } in
                        \ (x_abnl :: p_abmX () (f_abmY ())) -> f1_abn1 (g_abnk x_abnl))
                     `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                      <Data.ByteString.Internal.Type.ByteString>_N)
                             :: Control.Lens.Type.Prism'
                                  Data.ByteString.Internal.Type.ByteString ()
                                ~R# Control.Lens.Empty.AsEmpty
                                      Data.ByteString.Internal.Type.ByteString)
              TyArg Data.Functor.Const.Const
                      Data.ByteString.Internal.Type.ByteString
              ValArg Data.Functor.Contravariant.$fContravariantConst
                       @Data.ByteString.Internal.Type.ByteString
              ValArg Data.Functor.Const.$fFunctorConst
                       @Data.ByteString.Internal.Type.ByteString
    After:  (\ (@s1_abfO)
               (@(f_abfP :: * -> *))
               (@a_abfQ)
               ($dCons_abfR
                  :: Control.Lens.Cons.Cons s1_abfO s1_abfO a_abfQ a_abfQ)
               ($dCons1_abfS
                  :: Control.Lens.Cons.Cons s1_abfO s1_abfO a_abfQ a_abfQ)
               ($dAsEmpty_abfT :: Control.Lens.Empty.AsEmpty s1_abfO)
               ($dContravariant_abfU
                  :: Data.Functor.Contravariant.Contravariant f_abfP)
               ($dFunctor_abfV :: GHC.Base.Functor f_abfP) ->
               GHC.Base.id @(s1_abfO -> f_abfP s1_abfO))
              @Data.ByteString.Internal.Type.ByteString
              @(Data.Functor.Const.Const
                  Data.ByteString.Internal.Type.ByteString)
              @GHC.Word.Word8
              ((\ (@(p_abkq :: * -> * -> *))
                  (@(f_abkr :: * -> *))
                  ($dChoice_abks :: Data.Profunctor.Choice.Choice p_abkq)
                  ($dApplicative_abkt :: GHC.Base.Applicative f_abkr) ->
                  let {
                    f1_abku
                      :: p_abkq
                           (Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString
                              (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                           (Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString
                              (f_abkr
                                 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                         -> p_abkq
                              Data.ByteString.Internal.Type.ByteString
                              (f_abkr Data.ByteString.Internal.Type.ByteString)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 612 0}]
                    f1_abku
                      = Data.Profunctor.Unsafe.dimap
                          @p_abkq
                          (Data.Profunctor.Choice.$p1Choice @p_abkq $dChoice_abks)
                          @Data.ByteString.Internal.Type.ByteString
                          @(Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString
                              (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                          @(Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString
                              (f_abkr
                                 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                          @(f_abkr Data.ByteString.Internal.Type.ByteString)
                          (\ (s1_abkv :: Data.ByteString.Internal.Type.ByteString) ->
                             case s1_abkv of wild_abkw
                             { Data.ByteString.Internal.Type.BS bx_abkx bx1_abky bx2_abkz ->
                             case GHC.Classes.leInt (GHC.Types.I# bx2_abkz) (GHC.Types.I# 0#)
                             of {
                               GHC.Types.False ->
                                 Data.Either.Right
                                   @Data.ByteString.Internal.Type.ByteString
                                   @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                   (case GHC.Prim.readWord8OffAddr#
                                           @GHC.Prim.RealWorld bx_abkx 0# GHC.Prim.realWorld#
                                    of
                                    { (# ipv_abkE, ipv1_abkF #) ->
                                    case GHC.Prim.touch#
                                           @'GHC.Types.Lifted
                                           @GHC.ForeignPtr.ForeignPtrContents
                                           bx1_abky
                                           ipv_abkE
                                    of
                                    { __DEFAULT ->
                                    GHC.Word.W8# ipv1_abkF
                                    }
                                    },
                                    Data.ByteString.Internal.Type.$WBS
                                      (GHC.ForeignPtr.ForeignPtr
                                         @GHC.Word.Word8 (GHC.Prim.plusAddr# bx_abkx 1#) bx1_abky)
                                      (GHC.Types.I# (GHC.Prim.-# bx2_abkz 1#)));
                               GHC.Types.True ->
                                 Data.Either.Left
                                   @Data.ByteString.Internal.Type.ByteString
                                   @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                   wild_abkw
                             }
                             })
                          (let {
                             f2_abkJ
                               :: Data.ByteString.Internal.Type.ByteString
                                  -> f_abkr Data.ByteString.Internal.Type.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abkJ
                               = GHC.Base.pure
                                   @f_abkr
                                   $dApplicative_abkt
                                   @Data.ByteString.Internal.Type.ByteString } in
                           let {
                             ds2_abkK
                               :: f_abkr
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                  -> f_abkr Data.ByteString.Internal.Type.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 259 0}]
                             ds2_abkK
                               = GHC.Base.fmap
                                   @f_abkr
                                   (GHC.Base.$p1Applicative @f_abkr $dApplicative_abkt)
                                   @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                   @Data.ByteString.Internal.Type.ByteString
                                   (\ (p1_abkL
                                         :: (GHC.Word.Word8,
                                             Data.ByteString.Internal.Type.ByteString)) ->
                                      case p1_abkL of { (ds_abkN, y_abkO) ->
                                      case y_abkO of
                                      { Data.ByteString.Internal.Type.BS bx_abl0 bx1_abl1
                                                                         bx2_abl2 ->
                                      GHC.Magic.runRW#
                                        @GHC.Types.LiftedRep
                                        @Data.ByteString.Internal.Type.ByteString
                                        (\ (s_abkY [OS=OneShot]
                                              :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                                           let {
                                             x_abkZ :: GHC.Prim.Int#
                                             [LclId,
                                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                      Value=False, ConLike=False, WorkFree=False,
                                                      Expandable=False,
                                                      Guidance=IF_ARGS [] 1 0}]
                                             x_abkZ = GHC.Prim.+# bx2_abl2 1# } in
                                           case GHC.Prim.<# x_abkZ 0# of {
                                             __DEFAULT ->
                                               case GHC.Prim.newPinnedByteArray#
                                                      @GHC.Prim.RealWorld x_abkZ s_abkY
                                               of
                                               { (# ipv_abl7, ipv1_abl8 #) ->
                                               let {
                                                 ipv2_abl6 :: GHC.Prim.Addr#
                                                 [LclId,
                                                  Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                          Value=False, ConLike=False,
                                                          WorkFree=False, Expandable=False,
                                                          Guidance=IF_ARGS [] 1 0}]
                                                 ipv2_abl6
                                                   = GHC.Prim.mutableByteArrayContents#
                                                       @GHC.Prim.RealWorld ipv1_abl8 } in
                                               let {
                                                 ipv3_abla :: GHC.ForeignPtr.ForeignPtrContents
                                                 [LclId,
                                                  Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                          Value=True, ConLike=True, WorkFree=True,
                                                          Expandable=True,
                                                          Guidance=IF_ARGS [] 10 10}]
                                                 ipv3_abla = GHC.ForeignPtr.PlainPtr ipv1_abl8 } in
                                               case ds_abkN of { GHC.Word.W8# x1_abms ->
                                               case GHC.Prim.writeWord8OffAddr#
                                                      @GHC.Prim.RealWorld
                                                      ipv2_abl6
                                                      0#
                                                      x1_abms
                                                      ipv_abl7
                                               of s2_abmu
                                               { __DEFAULT ->
                                               case GHC.Prim.touch#
                                                      @'GHC.Types.Lifted
                                                      @GHC.ForeignPtr.ForeignPtrContents
                                                      ipv3_abla
                                                      s2_abmu
                                               of s'_abmv
                                               { __DEFAULT ->
                                               case {__ffi_static_ccall_unsafe base:memcpy :: Addr#
                                          -> Addr#
                                          -> Word64#
                                          -> State# RealWorld
                                          -> (# State# RealWorld, Addr# #)}_abmw
                                                      (GHC.Prim.plusAddr# ipv2_abl6 1#)
                                                      bx_abl0
                                                      (GHC.Prim.int64ToWord64#
                                                         (GHC.Prim.intToInt64# bx2_abl2))
                                                      s'_abmv
                                               of
                                               { (# ds4_abmy, ds5_abmz #) ->
                                               case GHC.Prim.touch#
                                                      @'GHC.Types.Lifted
                                                      @GHC.ForeignPtr.ForeignPtrContents
                                                      bx1_abl1
                                                      ds4_abmy
                                               of s'1_abmB
                                               { __DEFAULT ->
                                               case GHC.Prim.touch#
                                                      @'GHC.Types.Lifted
                                                      @GHC.ForeignPtr.ForeignPtrContents
                                                      ipv3_abla
                                                      s'1_abmB
                                               of s'2_abmC
                                               { __DEFAULT ->
                                               case GHC.Magic.lazy
                                                      @((GHC.Prim.State# GHC.Prim.RealWorld
                                                         -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                               GHC.Prim.Addr# #))
                                                        -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                              GHC.Prim.Addr# #))
                                                      (GHC.Magic.runRW#
                                                         @('GHC.Types.TupleRep
                                                             '[GHC.Types.ZeroBitRep,
                                                               'GHC.Types.AddrRep])
                                                         @(# GHC.Prim.State# GHC.Prim.RealWorld,
                                                             GHC.Prim.Addr# #))
                                                      (\ _ [Occ=Dead] -> (# s'2_abmC, ipv2_abl6 #))
                                               of
                                               { (# ipv6_abmF, ipv7_abmG #) ->
                                               Data.ByteString.Internal.Type.BS
                                                 ipv7_abmG ipv3_abla x_abkZ
                                               }
                                               }
                                               }
                                               }
                                               }
                                               }
                                               }
                                               };
                                             1# ->
                                               case GHC.ForeignPtr.mallocPlainForeignPtrBytes2
                                               of wild_00 {
                                               }
                                           })
                                      }
                                      }) } in
                           \ (ds3_abmJ
                                :: Data.Either.Either
                                     Data.ByteString.Internal.Type.ByteString
                                     (f_abkr
                                        (GHC.Word.Word8,
                                         Data.ByteString.Internal.Type.ByteString))) ->
                             case ds3_abmJ of {
                               Data.Either.Left x_abmL -> f2_abkJ x_abmL;
                               Data.Either.Right y_abmN -> ds2_abkK y_abmN
                             }) } in
                  let {
                    g_abmP
                      :: p_abkq
                           (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                           (f_abkr (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                         -> p_abkq
                              (Data.Either.Either
                                 Data.ByteString.Internal.Type.ByteString
                                 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                              (Data.Either.Either
                                 Data.ByteString.Internal.Type.ByteString
                                 (f_abkr
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abmP
                      = Data.Profunctor.Choice.right'
                          @p_abkq
                          $dChoice_abks
                          @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                          @(f_abkr
                              (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                          @Data.ByteString.Internal.Type.ByteString } in
                  \ (x_abmQ
                       :: p_abkq
                            (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                            (f_abkr
                               (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))) ->
                    f1_abku (g_abmP x_abmQ))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <Data.ByteString.Internal.Type.ByteString>_N
                                <Data.ByteString.Internal.Type.ByteString>_N
                                <GHC.Word.Word8>_N
                                <GHC.Word.Word8>_N)
                       :: Control.Lens.Type.Prism
                            Data.ByteString.Internal.Type.ByteString
                            Data.ByteString.Internal.Type.ByteString
                            (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                            (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                          ~R# Control.Lens.Cons.Cons
                                Data.ByteString.Internal.Type.ByteString
                                Data.ByteString.Internal.Type.ByteString
                                GHC.Word.Word8
                                GHC.Word.Word8))
              ((\ (@(p_abkq :: * -> * -> *))
                  (@(f_abkr :: * -> *))
                  ($dChoice_abks :: Data.Profunctor.Choice.Choice p_abkq)
                  ($dApplicative_abkt :: GHC.Base.Applicative f_abkr) ->
                  let {
                    f1_abku
                      :: p_abkq
                           (Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString
                              (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                           (Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString
                              (f_abkr
                                 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                         -> p_abkq
                              Data.ByteString.Internal.Type.ByteString
                              (f_abkr Data.ByteString.Internal.Type.ByteString)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 612 0}]
                    f1_abku
                      = Data.Profunctor.Unsafe.dimap
                          @p_abkq
                          (Data.Profunctor.Choice.$p1Choice @p_abkq $dChoice_abks)
                          @Data.ByteString.Internal.Type.ByteString
                          @(Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString
                              (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                          @(Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString
                              (f_abkr
                                 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                          @(f_abkr Data.ByteString.Internal.Type.ByteString)
                          (\ (s1_abkv :: Data.ByteString.Internal.Type.ByteString) ->
                             case s1_abkv of wild_abkw
                             { Data.ByteString.Internal.Type.BS bx_abkx bx1_abky bx2_abkz ->
                             case GHC.Classes.leInt (GHC.Types.I# bx2_abkz) (GHC.Types.I# 0#)
                             of {
                               GHC.Types.False ->
                                 Data.Either.Right
                                   @Data.ByteString.Internal.Type.ByteString
                                   @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                   (case GHC.Prim.readWord8OffAddr#
                                           @GHC.Prim.RealWorld bx_abkx 0# GHC.Prim.realWorld#
                                    of
                                    { (# ipv_abkE, ipv1_abkF #) ->
                                    case GHC.Prim.touch#
                                           @'GHC.Types.Lifted
                                           @GHC.ForeignPtr.ForeignPtrContents
                                           bx1_abky
                                           ipv_abkE
                                    of
                                    { __DEFAULT ->
                                    GHC.Word.W8# ipv1_abkF
                                    }
                                    },
                                    Data.ByteString.Internal.Type.$WBS
                                      (GHC.ForeignPtr.ForeignPtr
                                         @GHC.Word.Word8 (GHC.Prim.plusAddr# bx_abkx 1#) bx1_abky)
                                      (GHC.Types.I# (GHC.Prim.-# bx2_abkz 1#)));
                               GHC.Types.True ->
                                 Data.Either.Left
                                   @Data.ByteString.Internal.Type.ByteString
                                   @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                   wild_abkw
                             }
                             })
                          (let {
                             f2_abkJ
                               :: Data.ByteString.Internal.Type.ByteString
                                  -> f_abkr Data.ByteString.Internal.Type.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abkJ
                               = GHC.Base.pure
                                   @f_abkr
                                   $dApplicative_abkt
                                   @Data.ByteString.Internal.Type.ByteString } in
                           let {
                             ds2_abkK
                               :: f_abkr
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                  -> f_abkr Data.ByteString.Internal.Type.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 259 0}]
                             ds2_abkK
                               = GHC.Base.fmap
                                   @f_abkr
                                   (GHC.Base.$p1Applicative @f_abkr $dApplicative_abkt)
                                   @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                   @Data.ByteString.Internal.Type.ByteString
                                   (\ (p1_abkL
                                         :: (GHC.Word.Word8,
                                             Data.ByteString.Internal.Type.ByteString)) ->
                                      case p1_abkL of { (ds_abkN, y_abkO) ->
                                      case y_abkO of
                                      { Data.ByteString.Internal.Type.BS bx_abl0 bx1_abl1
                                                                         bx2_abl2 ->
                                      GHC.Magic.runRW#
                                        @GHC.Types.LiftedRep
                                        @Data.ByteString.Internal.Type.ByteString
                                        (\ (s_abkY [OS=OneShot]
                                              :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                                           let {
                                             x_abkZ :: GHC.Prim.Int#
                                             [LclId,
                                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                      Value=False, ConLike=False, WorkFree=False,
                                                      Expandable=False,
                                                      Guidance=IF_ARGS [] 1 0}]
                                             x_abkZ = GHC.Prim.+# bx2_abl2 1# } in
                                           case GHC.Prim.<# x_abkZ 0# of {
                                             __DEFAULT ->
                                               case GHC.Prim.newPinnedByteArray#
                                                      @GHC.Prim.RealWorld x_abkZ s_abkY
                                               of
                                               { (# ipv_abl7, ipv1_abl8 #) ->
                                               let {
                                                 ipv2_abl6 :: GHC.Prim.Addr#
                                                 [LclId,
                                                  Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                          Value=False, ConLike=False,
                                                          WorkFree=False, Expandable=False,
                                                          Guidance=IF_ARGS [] 1 0}]
                                                 ipv2_abl6
                                                   = GHC.Prim.mutableByteArrayContents#
                                                       @GHC.Prim.RealWorld ipv1_abl8 } in
                                               let {
                                                 ipv3_abla :: GHC.ForeignPtr.ForeignPtrContents
                                                 [LclId,
                                                  Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                          Value=True, ConLike=True, WorkFree=True,
                                                          Expandable=True,
                                                          Guidance=IF_ARGS [] 10 10}]
                                                 ipv3_abla = GHC.ForeignPtr.PlainPtr ipv1_abl8 } in
                                               case ds_abkN of { GHC.Word.W8# x1_abms ->
                                               case GHC.Prim.writeWord8OffAddr#
                                                      @GHC.Prim.RealWorld
                                                      ipv2_abl6
                                                      0#
                                                      x1_abms
                                                      ipv_abl7
                                               of s2_abmu
                                               { __DEFAULT ->
                                               case GHC.Prim.touch#
                                                      @'GHC.Types.Lifted
                                                      @GHC.ForeignPtr.ForeignPtrContents
                                                      ipv3_abla
                                                      s2_abmu
                                               of s'_abmv
                                               { __DEFAULT ->
                                               case {__ffi_static_ccall_unsafe base:memcpy :: Addr#
                                          -> Addr#
                                          -> Word64#
                                          -> State# RealWorld
                                          -> (# State# RealWorld, Addr# #)}_abmw
                                                      (GHC.Prim.plusAddr# ipv2_abl6 1#)
                                                      bx_abl0
                                                      (GHC.Prim.int64ToWord64#
                                                         (GHC.Prim.intToInt64# bx2_abl2))
                                                      s'_abmv
                                               of
                                               { (# ds4_abmy, ds5_abmz #) ->
                                               case GHC.Prim.touch#
                                                      @'GHC.Types.Lifted
                                                      @GHC.ForeignPtr.ForeignPtrContents
                                                      bx1_abl1
                                                      ds4_abmy
                                               of s'1_abmB
                                               { __DEFAULT ->
                                               case GHC.Prim.touch#
                                                      @'GHC.Types.Lifted
                                                      @GHC.ForeignPtr.ForeignPtrContents
                                                      ipv3_abla
                                                      s'1_abmB
                                               of s'2_abmC
                                               { __DEFAULT ->
                                               case GHC.Magic.lazy
                                                      @((GHC.Prim.State# GHC.Prim.RealWorld
                                                         -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                               GHC.Prim.Addr# #))
                                                        -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                              GHC.Prim.Addr# #))
                                                      (GHC.Magic.runRW#
                                                         @('GHC.Types.TupleRep
                                                             '[GHC.Types.ZeroBitRep,
                                                               'GHC.Types.AddrRep])
                                                         @(# GHC.Prim.State# GHC.Prim.RealWorld,
                                                             GHC.Prim.Addr# #))
                                                      (\ _ [Occ=Dead] -> (# s'2_abmC, ipv2_abl6 #))
                                               of
                                               { (# ipv6_abmF, ipv7_abmG #) ->
                                               Data.ByteString.Internal.Type.BS
                                                 ipv7_abmG ipv3_abla x_abkZ
                                               }
                                               }
                                               }
                                               }
                                               }
                                               }
                                               }
                                               };
                                             1# ->
                                               case GHC.ForeignPtr.mallocPlainForeignPtrBytes2
                                               of wild_00 {
                                               }
                                           })
                                      }
                                      }) } in
                           \ (ds3_abmJ
                                :: Data.Either.Either
                                     Data.ByteString.Internal.Type.ByteString
                                     (f_abkr
                                        (GHC.Word.Word8,
                                         Data.ByteString.Internal.Type.ByteString))) ->
                             case ds3_abmJ of {
                               Data.Either.Left x_abmL -> f2_abkJ x_abmL;
                               Data.Either.Right y_abmN -> ds2_abkK y_abmN
                             }) } in
                  let {
                    g_abmP
                      :: p_abkq
                           (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                           (f_abkr (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                         -> p_abkq
                              (Data.Either.Either
                                 Data.ByteString.Internal.Type.ByteString
                                 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                              (Data.Either.Either
                                 Data.ByteString.Internal.Type.ByteString
                                 (f_abkr
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abmP
                      = Data.Profunctor.Choice.right'
                          @p_abkq
                          $dChoice_abks
                          @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                          @(f_abkr
                              (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                          @Data.ByteString.Internal.Type.ByteString } in
                  \ (x_abmQ
                       :: p_abkq
                            (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                            (f_abkr
                               (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))) ->
                    f1_abku (g_abmP x_abmQ))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <Data.ByteString.Internal.Type.ByteString>_N
                                <Data.ByteString.Internal.Type.ByteString>_N
                                <GHC.Word.Word8>_N
                                <GHC.Word.Word8>_N)
                       :: Control.Lens.Type.Prism
                            Data.ByteString.Internal.Type.ByteString
                            Data.ByteString.Internal.Type.ByteString
                            (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                            (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                          ~R# Control.Lens.Cons.Cons
                                Data.ByteString.Internal.Type.ByteString
                                Data.ByteString.Internal.Type.ByteString
                                GHC.Word.Word8
                                GHC.Word.Word8))
              ((\ (@(p_abmX :: * -> * -> *))
                  (@(f_abmY :: * -> *))
                  ($dChoice_abmZ :: Data.Profunctor.Choice.Choice p_abmX)
                  ($dApplicative_abn0 :: GHC.Base.Applicative f_abmY) ->
                  let {
                    f1_abn1
                      :: p_abmX
                           (Data.Either.Either Data.ByteString.Internal.Type.ByteString ())
                           (Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString (f_abmY ()))
                         -> p_abmX
                              Data.ByteString.Internal.Type.ByteString
                              (f_abmY Data.ByteString.Internal.Type.ByteString)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 350 0}]
                    f1_abn1
                      = Data.Profunctor.Unsafe.dimap
                          @p_abmX
                          (Data.Profunctor.Choice.$p1Choice @p_abmX $dChoice_abmZ)
                          @Data.ByteString.Internal.Type.ByteString
                          @(Data.Either.Either Data.ByteString.Internal.Type.ByteString ())
                          @(Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString (f_abmY ()))
                          @(f_abmY Data.ByteString.Internal.Type.ByteString)
                          (\ (s_abn2 :: Data.ByteString.Internal.Type.ByteString) ->
                             case s_abn2 of wild_abn3
                             { Data.ByteString.Internal.Type.BS bx_abn4 bx1_abn5 bx2_abn6 ->
                             case GHC.Classes.leInt (GHC.Types.I# bx2_abn6) (GHC.Types.I# 0#)
                             of {
                               GHC.Types.False ->
                                 Data.Either.Left
                                   @Data.ByteString.Internal.Type.ByteString @() wild_abn3;
                               GHC.Types.True ->
                                 Data.Either.Right
                                   @Data.ByteString.Internal.Type.ByteString @() GHC.Tuple.Prim.()
                             }
                             })
                          (let {
                             f2_abna
                               :: Data.ByteString.Internal.Type.ByteString
                                  -> f_abmY Data.ByteString.Internal.Type.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abna
                               = GHC.Base.pure
                                   @f_abmY
                                   $dApplicative_abn0
                                   @Data.ByteString.Internal.Type.ByteString } in
                           let {
                             ds2_abnb
                               :: f_abmY () -> f_abmY Data.ByteString.Internal.Type.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 70 0}]
                             ds2_abnb
                               = GHC.Base.fmap
                                   @f_abmY
                                   (GHC.Base.$p1Applicative @f_abmY $dApplicative_abn0)
                                   @()
                                   @Data.ByteString.Internal.Type.ByteString
                                   (\ (ds3_abnc :: ()) ->
                                      case ds3_abnc of { () ->
                                      Data.ByteString.Internal.Type.empty
                                      }) } in
                           \ (ds3_abne
                                :: Data.Either.Either
                                     Data.ByteString.Internal.Type.ByteString (f_abmY ())) ->
                             case ds3_abne of {
                               Data.Either.Left x_abng -> f2_abna x_abng;
                               Data.Either.Right y_abni -> ds2_abnb y_abni
                             }) } in
                  let {
                    g_abnk
                      :: p_abmX () (f_abmY ())
                         -> p_abmX
                              (Data.Either.Either Data.ByteString.Internal.Type.ByteString ())
                              (Data.Either.Either
                                 Data.ByteString.Internal.Type.ByteString (f_abmY ()))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abnk
                      = Data.Profunctor.Choice.right'
                          @p_abmX
                          $dChoice_abmZ
                          @()
                          @(f_abmY ())
                          @Data.ByteString.Internal.Type.ByteString } in
                  \ (x_abnl :: p_abmX () (f_abmY ())) -> f1_abn1 (g_abnk x_abnl))
               `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                <Data.ByteString.Internal.Type.ByteString>_N)
                       :: Control.Lens.Type.Prism'
                            Data.ByteString.Internal.Type.ByteString ()
                          ~R# Control.Lens.Empty.AsEmpty
                                Data.ByteString.Internal.Type.ByteString))
              (Data.Functor.Contravariant.$fContravariantConst
                 @Data.ByteString.Internal.Type.ByteString)
              (Data.Functor.Const.$fFunctorConst
                 @Data.ByteString.Internal.Type.ByteString)
    Cont:   ApplyToVal nodup hole Control.Lens.Getter.Getting
                                    Data.ByteString.Internal.Type.ByteString
                                    Data.ByteString.Internal.Type.ByteString
                                    Data.ByteString.Internal.Type.ByteString
              ((\ (ds_abeK [Occ=Once1] :: a_abeH) -> ds_abeK)
               `cast` (<a_abeH>_R
                       %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                          <*>_N <a_abeH>_R <a_abeH>_P)
                       :: (a_abeH -> a_abeH)
                          ~R# (a_abeH -> Data.Functor.Const.Const a_abeH a_abeH)))
            ApplyToVal nodup hole Data.ByteString.Internal.Type.ByteString
                                  -> Data.Functor.Const.Const
                                       Data.ByteString.Internal.Type.ByteString
                                       Data.ByteString.Internal.Type.ByteString
              s_a8KR
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N
                        <Data.ByteString.Internal.Type.ByteString>_R
                        <Data.ByteString.Internal.Type.ByteString>_P
                    :: Data.Functor.Const.Const
                         Data.ByteString.Internal.Type.ByteString
                         Data.ByteString.Internal.Type.ByteString
                       ~R# Data.ByteString.Internal.Type.ByteString)
            Stop[RuleArgCtxt] Data.ByteString.Internal.Type.ByteString
Rule fired
    Rule: Class op ==
    Module: (BUILTIN)
    Before: GHC.Classes.==
              TyArg Data.ByteString.Internal.Type.ByteString
              ValArg Data.ByteString.Internal.Type.$fEqByteString
              ValArg s_a8KR
              ValArg s_a8KR
    After:  Data.ByteString.Internal.Type.eq
              ValArg s_a8KR ValArg s_a8KR
    Cont:   Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: unpack
    Module: (GHC.Base)
    Before: GHC.CString.unpackCString# ValArg "L -> L"#
    After:  (\ (a_ab7z :: GHC.Prim.Addr#) ->
               GHC.Base.build
                 @GHC.Types.Char
                 (\ (@b_ab7A) -> GHC.CString.unpackFoldrCString# @b_ab7A a_ab7z))
              "L -> L"#
    Cont:   Stop[BoringCtxt] Test.Tasty.Core.TestName
Rule fired
    Rule: Class op property
    Module: (BUILTIN)
    Before: Test.QuickCheck.Property.property
              TyArg Data.ByteString.Lazy.Internal.ByteString -> GHC.Types.Bool
              ValArg Test.QuickCheck.Property.$fTestableFUN
                       @Data.ByteString.Lazy.Internal.ByteString
                       @GHC.Types.Bool
                       Test.QuickCheck.Instances.ByteString.$fArbitraryByteString
                       Data.ByteString.Lazy.Internal.$fShowByteString
                       Test.QuickCheck.Property.$fTestableBool
    After:  Test.QuickCheck.Property.$fTestableFUN_$cproperty
              @Data.ByteString.Lazy.Internal.ByteString
              @GHC.Types.Bool
              Test.QuickCheck.Instances.ByteString.$fArbitraryByteString
              Data.ByteString.Lazy.Internal.$fShowByteString
              Test.QuickCheck.Property.$fTestableBool
    Cont:   ApplyToVal nodup hole (Data.ByteString.Lazy.Internal.ByteString
                                   -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              prop_ab7M
            CastIt (Sym (Test.Tasty.QuickCheck.N:QC[0])
                    :: Test.QuickCheck.Property.Property ~R# Test.Tasty.QuickCheck.QC)
            Stop[BoringCtxt] Test.Tasty.QuickCheck.QC
Rule fired
    Rule: Class op propertyForAllShrinkShow
    Module: (BUILTIN)
    Before: Test.QuickCheck.Property.propertyForAllShrinkShow
              TyArg GHC.Types.Bool ValArg Test.QuickCheck.Property.$fTestableBool
    After:  Test.QuickCheck.Property.$fTestableBool1
            `cast` (forall (a :: <*>_N).
                    <Test.QuickCheck.Gen.Gen a>_R
                    %<'GHC.Types.Many>_N ->_R <a -> [a]>_R
                    %<'GHC.Types.Many>_N ->_R <a -> [GHC.Base.String]>_R
                    %<'GHC.Types.Many>_N ->_R <a -> GHC.Types.Bool>_R
                    %<'GHC.Types.Many>_N ->_R Sym (Test.QuickCheck.Gen.N:Gen[0]
                                                       (Test.QuickCheck.Property.N:Prop[0]))
                                              ; Sym (Test.QuickCheck.Property.N:Property[0])
                    :: (forall {a}.
                        Test.QuickCheck.Gen.Gen a
                        -> (a -> [a])
                        -> (a -> [GHC.Base.String])
                        -> (a -> GHC.Types.Bool)
                        -> Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int
                        -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result)
                       ~R# (forall {a}.
                            Test.QuickCheck.Gen.Gen a
                            -> (a -> [a])
                            -> (a -> [GHC.Base.String])
                            -> (a -> GHC.Types.Bool)
                            -> Test.QuickCheck.Property.Property))
    Cont:   ApplyToTy Data.ByteString.Lazy.Internal.ByteString
            ApplyToVal nodup hole Test.QuickCheck.Gen.Gen
                                    Data.ByteString.Lazy.Internal.ByteString
                                  -> (Data.ByteString.Lazy.Internal.ByteString
                                      -> [Data.ByteString.Lazy.Internal.ByteString])
                                  -> (Data.ByteString.Lazy.Internal.ByteString -> [GHC.Base.String])
                                  -> (Data.ByteString.Lazy.Internal.ByteString -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (Test.QuickCheck.Arbitrary.arbitrary @a_ab9u $dArbitrary_ab9w)
            ApplyToVal nodup hole (Data.ByteString.Lazy.Internal.ByteString
                                   -> [Data.ByteString.Lazy.Internal.ByteString])
                                  -> (Data.ByteString.Lazy.Internal.ByteString -> [GHC.Base.String])
                                  -> (Data.ByteString.Lazy.Internal.ByteString -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (Test.QuickCheck.Arbitrary.shrink @a_ab9u $dArbitrary_ab9w)
            ApplyToVal nodup hole (Data.ByteString.Lazy.Internal.ByteString
                                   -> [GHC.Base.String])
                                  -> (Data.ByteString.Lazy.Internal.ByteString -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (let {
                 g_ab9A [Occ=OnceL1!] :: a_ab9u -> GHC.Base.String
                 [LclId]
                 g_ab9A = GHC.Show.show @a_ab9u $dShow_ab9x } in
               \ (x_ab9B [Occ=Once1] :: a_ab9u) ->
                 GHC.Types.:
                   @GHC.Base.String (g_ab9A x_ab9B) (GHC.Types.[] @GHC.Base.String))
            ApplyToVal nodup hole (Data.ByteString.Lazy.Internal.ByteString
                                   -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              f_ab9z
            CastIt (Sym (Test.Tasty.QuickCheck.N:QC[0])
                    :: Test.QuickCheck.Property.Property ~R# Test.Tasty.QuickCheck.QC)
            Stop[BoringCtxt] Test.Tasty.QuickCheck.QC
Rule fired
    Rule: Class op arbitrary
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.arbitrary
              TyArg Data.ByteString.Lazy.Internal.ByteString
              ValArg Test.QuickCheck.Instances.ByteString.$fArbitraryByteString
    After:  Test.QuickCheck.Instances.ByteString.$fArbitraryByteString1
            `cast` (Sym (Test.QuickCheck.Gen.N:Gen[0]
                             <Data.ByteString.Lazy.Internal.ByteString>_R)
                    :: (Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int -> Data.ByteString.Lazy.Internal.ByteString)
                       ~R# Test.QuickCheck.Gen.Gen
                             Data.ByteString.Lazy.Internal.ByteString)
    Cont:   Stop[BoringCtxt] Test.QuickCheck.Gen.Gen
                               Data.ByteString.Lazy.Internal.ByteString
Rule fired
    Rule: Class op shrink
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.shrink
              TyArg Data.ByteString.Lazy.Internal.ByteString
              ValArg Test.QuickCheck.Instances.ByteString.$fArbitraryByteString
    After:  Test.QuickCheck.Instances.ByteString.$fArbitraryByteString_$cshrink
    Cont:   Stop[BoringCtxt] Data.ByteString.Lazy.Internal.ByteString
                             -> [Data.ByteString.Lazy.Internal.ByteString]
Rule fired
    Rule: Class op show
    Module: (BUILTIN)
    Before: GHC.Show.show
              TyArg Data.ByteString.Lazy.Internal.ByteString
              ValArg Data.ByteString.Lazy.Internal.$fShowByteString
    After:  Data.ByteString.Lazy.Internal.$fShowByteString_$cshow
    Cont:   Stop[RhsCtxt(NonRecursive)] Data.ByteString.Lazy.Internal.ByteString
                                        -> GHC.Base.String
Rule fired
    Rule: Class op reader
    Module: (BUILTIN)
    Before: Control.Monad.Reader.Class.reader
              TyArg Data.ByteString.Lazy.Internal.ByteString
              TyArg (->) Data.ByteString.Lazy.Internal.ByteString
              ValArg Control.Monad.Reader.Class.$fMonadReaderrFUN
                       @Data.ByteString.Lazy.Internal.ByteString
    After:  \ (@a_abeP) ->
              GHC.Base.id @(Data.ByteString.Lazy.Internal.ByteString -> a_abeP)
    Cont:   ApplyToTy Data.ByteString.Lazy.Internal.ByteString
            ApplyToVal nodup hole (Data.ByteString.Lazy.Internal.ByteString
                                   -> Data.ByteString.Lazy.Internal.ByteString)
                                  -> Data.ByteString.Lazy.Internal.ByteString
                                  -> Data.ByteString.Lazy.Internal.ByteString
              ((l_abeJ
                  ((\ (ds_abeK [Occ=Once1] :: a_abeH) -> ds_abeK)
                   `cast` (<a_abeH>_R
                           %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                              <*>_N <a_abeH>_R <a_abeH>_P)
                           :: (a_abeH -> a_abeH)
                              ~R# (a_abeH -> Data.Functor.Const.Const a_abeH a_abeH))))
               `cast` (<s_abeF>_R
                       %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                     <*>_N <a_abeH>_R <s_abeF>_P
                       :: (s_abeF -> Data.Functor.Const.Const a_abeH s_abeF)
                          ~R# (s_abeF -> a_abeH)))
            ApplyToVal nodup hole Data.ByteString.Lazy.Internal.ByteString
                                  -> Data.ByteString.Lazy.Internal.ByteString
              s_a8NV
            Stop[RuleArgCtxt] Data.ByteString.Lazy.Internal.ByteString
Rule fired
    Rule: recons/id
    Module: (Control.Lens.Cons.Extras)
    Before: Control.Lens.Cons.Extras.recons
              TyArg Data.ByteString.Lazy.Internal.ByteString
              TyArg GHC.Word.Word8
              TyArg Data.ByteString.Lazy.Internal.ByteString
              ValArg (\ (@(p_abnq :: * -> * -> *))
                        (@(f_abnr :: * -> *))
                        ($dChoice_abns :: Data.Profunctor.Choice.Choice p_abnq)
                        ($dApplicative_abnt :: GHC.Base.Applicative f_abnr) ->
                        let {
                          f1_abnu
                            :: p_abnq
                                 (Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                                 (Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (f_abnr
                                       (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                               -> p_abnq
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (f_abnr Data.ByteString.Lazy.Internal.ByteString)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 536 0}]
                          f1_abnu
                            = Data.Profunctor.Unsafe.dimap
                                @p_abnq
                                (Data.Profunctor.Choice.$p1Choice @p_abnq $dChoice_abns)
                                @Data.ByteString.Lazy.Internal.ByteString
                                @(Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                                @(Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (f_abnr
                                       (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                                @(f_abnr Data.ByteString.Lazy.Internal.ByteString)
                                (\ (s1_abnv :: Data.ByteString.Lazy.Internal.ByteString) ->
                                   case s1_abnv of {
                                     Data.ByteString.Lazy.Internal.Empty ->
                                       Data.Either.Left
                                         @Data.ByteString.Lazy.Internal.ByteString
                                         @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                         Data.ByteString.Lazy.Internal.Empty;
                                     Data.ByteString.Lazy.Internal.Chunk bx_abnC bx1_abnD bx2_abnE
                                                                         cs_abnF ->
                                       case bx2_abnE of ds1_abnH {
                                         __DEFAULT ->
                                           Data.Either.Right
                                             @Data.ByteString.Lazy.Internal.ByteString
                                             @(GHC.Word.Word8,
                                               Data.ByteString.Lazy.Internal.ByteString)
                                             (case GHC.Prim.readWord8OffAddr#
                                                     @GHC.Prim.RealWorld
                                                     bx_abnC
                                                     0#
                                                     GHC.Prim.realWorld#
                                              of
                                              { (# ipv_abnJ, ipv1_abnK #) ->
                                              case GHC.Prim.touch#
                                                     @'GHC.Types.Lifted
                                                     @GHC.ForeignPtr.ForeignPtrContents
                                                     bx1_abnD
                                                     ipv_abnJ
                                              of
                                              { __DEFAULT ->
                                              GHC.Word.W8# ipv1_abnK
                                              }
                                              },
                                              Data.ByteString.Lazy.Internal.$WChunk
                                                (Data.ByteString.Internal.Type.$WBS
                                                   (GHC.ForeignPtr.ForeignPtr
                                                      @GHC.Word.Word8
                                                      (GHC.Prim.plusAddr# bx_abnC 1#)
                                                      bx1_abnD)
                                                   (GHC.Types.I# (GHC.Prim.-# ds1_abnH 1#)))
                                                cs_abnF);
                                         1# ->
                                           Data.Either.Right
                                             @Data.ByteString.Lazy.Internal.ByteString
                                             @(GHC.Word.Word8,
                                               Data.ByteString.Lazy.Internal.ByteString)
                                             (case GHC.Prim.readWord8OffAddr#
                                                     @GHC.Prim.RealWorld
                                                     bx_abnC
                                                     0#
                                                     GHC.Prim.realWorld#
                                              of
                                              { (# ipv_abnO, ipv1_abnP #) ->
                                              case GHC.Prim.touch#
                                                     @'GHC.Types.Lifted
                                                     @GHC.ForeignPtr.ForeignPtrContents
                                                     bx1_abnD
                                                     ipv_abnO
                                              of
                                              { __DEFAULT ->
                                              GHC.Word.W8# ipv1_abnP
                                              }
                                              },
                                              cs_abnF)
                                       }
                                   })
                                (let {
                                   f2_abnS
                                     :: Data.ByteString.Lazy.Internal.ByteString
                                        -> f_abnr Data.ByteString.Lazy.Internal.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abnS
                                     = GHC.Base.pure
                                         @f_abnr
                                         $dApplicative_abnt
                                         @Data.ByteString.Lazy.Internal.ByteString } in
                                 let {
                                   ds2_abnT
                                     :: f_abnr
                                          (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                        -> f_abnr Data.ByteString.Lazy.Internal.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 162 0}]
                                   ds2_abnT
                                     = GHC.Base.fmap
                                         @f_abnr
                                         (GHC.Base.$p1Applicative @f_abnr $dApplicative_abnt)
                                         @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                         @Data.ByteString.Lazy.Internal.ByteString
                                         (\ (p1_abnU
                                               :: (GHC.Word.Word8,
                                                   Data.ByteString.Lazy.Internal.ByteString)) ->
                                            case p1_abnU of { (x_abnW, ds_abnX) ->
                                            case x_abnW of { GHC.Word.W8# x#_abo0 ->
                                            Data.ByteString.Lazy.Internal.$WChunk
                                              (Data.ByteString.Internal.Type.$WBS
                                                 (GHC.ForeignPtr.ForeignPtr
                                                    @GHC.Word.Word8
                                                    (GHC.Prim.plusAddr#
                                                       Data.ByteString.singleton1
                                                       (GHC.Prim.word2Int#
                                                          (GHC.Prim.word8ToWord# x#_abo0)))
                                                    GHC.ForeignPtr.FinalPtr)
                                                 (GHC.Types.I# 1#))
                                              ds_abnX
                                            }
                                            }) } in
                                 \ (ds3_abo2
                                      :: Data.Either.Either
                                           Data.ByteString.Lazy.Internal.ByteString
                                           (f_abnr
                                              (GHC.Word.Word8,
                                               Data.ByteString.Lazy.Internal.ByteString))) ->
                                   case ds3_abo2 of {
                                     Data.Either.Left x_abo4 -> f2_abnS x_abo4;
                                     Data.Either.Right y_abo6 -> ds2_abnT y_abo6
                                   }) } in
                        let {
                          g_abo8
                            :: p_abnq
                                 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                 (f_abnr (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                               -> p_abnq
                                    (Data.Either.Either
                                       Data.ByteString.Lazy.Internal.ByteString
                                       (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                                    (Data.Either.Either
                                       Data.ByteString.Lazy.Internal.ByteString
                                       (f_abnr
                                          (GHC.Word.Word8,
                                           Data.ByteString.Lazy.Internal.ByteString)))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abo8
                            = Data.Profunctor.Choice.right'
                                @p_abnq
                                $dChoice_abns
                                @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                @(f_abnr
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                                @Data.ByteString.Lazy.Internal.ByteString } in
                        \ (x_abo9
                             :: p_abnq
                                  (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                  (f_abnr
                                     (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))) ->
                          f1_abnu (g_abo8 x_abo9))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <Data.ByteString.Lazy.Internal.ByteString>_N
                                      <Data.ByteString.Lazy.Internal.ByteString>_N
                                      <GHC.Word.Word8>_N
                                      <GHC.Word.Word8>_N)
                             :: Control.Lens.Type.Prism
                                  Data.ByteString.Lazy.Internal.ByteString
                                  Data.ByteString.Lazy.Internal.ByteString
                                  (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                  (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                ~R# Control.Lens.Cons.Cons
                                      Data.ByteString.Lazy.Internal.ByteString
                                      Data.ByteString.Lazy.Internal.ByteString
                                      GHC.Word.Word8
                                      GHC.Word.Word8)
              ValArg (\ (@(p_abnq :: * -> * -> *))
                        (@(f_abnr :: * -> *))
                        ($dChoice_abns :: Data.Profunctor.Choice.Choice p_abnq)
                        ($dApplicative_abnt :: GHC.Base.Applicative f_abnr) ->
                        let {
                          f1_abnu
                            :: p_abnq
                                 (Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                                 (Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (f_abnr
                                       (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                               -> p_abnq
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (f_abnr Data.ByteString.Lazy.Internal.ByteString)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 536 0}]
                          f1_abnu
                            = Data.Profunctor.Unsafe.dimap
                                @p_abnq
                                (Data.Profunctor.Choice.$p1Choice @p_abnq $dChoice_abns)
                                @Data.ByteString.Lazy.Internal.ByteString
                                @(Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                                @(Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (f_abnr
                                       (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                                @(f_abnr Data.ByteString.Lazy.Internal.ByteString)
                                (\ (s1_abnv :: Data.ByteString.Lazy.Internal.ByteString) ->
                                   case s1_abnv of {
                                     Data.ByteString.Lazy.Internal.Empty ->
                                       Data.Either.Left
                                         @Data.ByteString.Lazy.Internal.ByteString
                                         @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                         Data.ByteString.Lazy.Internal.Empty;
                                     Data.ByteString.Lazy.Internal.Chunk bx_abnC bx1_abnD bx2_abnE
                                                                         cs_abnF ->
                                       case bx2_abnE of ds1_abnH {
                                         __DEFAULT ->
                                           Data.Either.Right
                                             @Data.ByteString.Lazy.Internal.ByteString
                                             @(GHC.Word.Word8,
                                               Data.ByteString.Lazy.Internal.ByteString)
                                             (case GHC.Prim.readWord8OffAddr#
                                                     @GHC.Prim.RealWorld
                                                     bx_abnC
                                                     0#
                                                     GHC.Prim.realWorld#
                                              of
                                              { (# ipv_abnJ, ipv1_abnK #) ->
                                              case GHC.Prim.touch#
                                                     @'GHC.Types.Lifted
                                                     @GHC.ForeignPtr.ForeignPtrContents
                                                     bx1_abnD
                                                     ipv_abnJ
                                              of
                                              { __DEFAULT ->
                                              GHC.Word.W8# ipv1_abnK
                                              }
                                              },
                                              Data.ByteString.Lazy.Internal.$WChunk
                                                (Data.ByteString.Internal.Type.$WBS
                                                   (GHC.ForeignPtr.ForeignPtr
                                                      @GHC.Word.Word8
                                                      (GHC.Prim.plusAddr# bx_abnC 1#)
                                                      bx1_abnD)
                                                   (GHC.Types.I# (GHC.Prim.-# ds1_abnH 1#)))
                                                cs_abnF);
                                         1# ->
                                           Data.Either.Right
                                             @Data.ByteString.Lazy.Internal.ByteString
                                             @(GHC.Word.Word8,
                                               Data.ByteString.Lazy.Internal.ByteString)
                                             (case GHC.Prim.readWord8OffAddr#
                                                     @GHC.Prim.RealWorld
                                                     bx_abnC
                                                     0#
                                                     GHC.Prim.realWorld#
                                              of
                                              { (# ipv_abnO, ipv1_abnP #) ->
                                              case GHC.Prim.touch#
                                                     @'GHC.Types.Lifted
                                                     @GHC.ForeignPtr.ForeignPtrContents
                                                     bx1_abnD
                                                     ipv_abnO
                                              of
                                              { __DEFAULT ->
                                              GHC.Word.W8# ipv1_abnP
                                              }
                                              },
                                              cs_abnF)
                                       }
                                   })
                                (let {
                                   f2_abnS
                                     :: Data.ByteString.Lazy.Internal.ByteString
                                        -> f_abnr Data.ByteString.Lazy.Internal.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abnS
                                     = GHC.Base.pure
                                         @f_abnr
                                         $dApplicative_abnt
                                         @Data.ByteString.Lazy.Internal.ByteString } in
                                 let {
                                   ds2_abnT
                                     :: f_abnr
                                          (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                        -> f_abnr Data.ByteString.Lazy.Internal.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 162 0}]
                                   ds2_abnT
                                     = GHC.Base.fmap
                                         @f_abnr
                                         (GHC.Base.$p1Applicative @f_abnr $dApplicative_abnt)
                                         @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                         @Data.ByteString.Lazy.Internal.ByteString
                                         (\ (p1_abnU
                                               :: (GHC.Word.Word8,
                                                   Data.ByteString.Lazy.Internal.ByteString)) ->
                                            case p1_abnU of { (x_abnW, ds_abnX) ->
                                            case x_abnW of { GHC.Word.W8# x#_abo0 ->
                                            Data.ByteString.Lazy.Internal.$WChunk
                                              (Data.ByteString.Internal.Type.$WBS
                                                 (GHC.ForeignPtr.ForeignPtr
                                                    @GHC.Word.Word8
                                                    (GHC.Prim.plusAddr#
                                                       Data.ByteString.singleton1
                                                       (GHC.Prim.word2Int#
                                                          (GHC.Prim.word8ToWord# x#_abo0)))
                                                    GHC.ForeignPtr.FinalPtr)
                                                 (GHC.Types.I# 1#))
                                              ds_abnX
                                            }
                                            }) } in
                                 \ (ds3_abo2
                                      :: Data.Either.Either
                                           Data.ByteString.Lazy.Internal.ByteString
                                           (f_abnr
                                              (GHC.Word.Word8,
                                               Data.ByteString.Lazy.Internal.ByteString))) ->
                                   case ds3_abo2 of {
                                     Data.Either.Left x_abo4 -> f2_abnS x_abo4;
                                     Data.Either.Right y_abo6 -> ds2_abnT y_abo6
                                   }) } in
                        let {
                          g_abo8
                            :: p_abnq
                                 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                 (f_abnr (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                               -> p_abnq
                                    (Data.Either.Either
                                       Data.ByteString.Lazy.Internal.ByteString
                                       (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                                    (Data.Either.Either
                                       Data.ByteString.Lazy.Internal.ByteString
                                       (f_abnr
                                          (GHC.Word.Word8,
                                           Data.ByteString.Lazy.Internal.ByteString)))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abo8
                            = Data.Profunctor.Choice.right'
                                @p_abnq
                                $dChoice_abns
                                @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                @(f_abnr
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                                @Data.ByteString.Lazy.Internal.ByteString } in
                        \ (x_abo9
                             :: p_abnq
                                  (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                  (f_abnr
                                     (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))) ->
                          f1_abnu (g_abo8 x_abo9))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <Data.ByteString.Lazy.Internal.ByteString>_N
                                      <Data.ByteString.Lazy.Internal.ByteString>_N
                                      <GHC.Word.Word8>_N
                                      <GHC.Word.Word8>_N)
                             :: Control.Lens.Type.Prism
                                  Data.ByteString.Lazy.Internal.ByteString
                                  Data.ByteString.Lazy.Internal.ByteString
                                  (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                  (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                ~R# Control.Lens.Cons.Cons
                                      Data.ByteString.Lazy.Internal.ByteString
                                      Data.ByteString.Lazy.Internal.ByteString
                                      GHC.Word.Word8
                                      GHC.Word.Word8)
              ValArg (\ (@(p_abob :: * -> * -> *))
                        (@(f_aboc :: * -> *))
                        ($dChoice_abod :: Data.Profunctor.Choice.Choice p_abob)
                        ($dApplicative_aboe :: GHC.Base.Applicative f_aboc) ->
                        let {
                          f1_abof
                            :: p_abob
                                 (Data.Either.Either Data.ByteString.Lazy.Internal.ByteString ())
                                 (Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString (f_aboc ()))
                               -> p_abob
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (f_aboc Data.ByteString.Lazy.Internal.ByteString)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 290 0}]
                          f1_abof
                            = Data.Profunctor.Unsafe.dimap
                                @p_abob
                                (Data.Profunctor.Choice.$p1Choice @p_abob $dChoice_abod)
                                @Data.ByteString.Lazy.Internal.ByteString
                                @(Data.Either.Either Data.ByteString.Lazy.Internal.ByteString ())
                                @(Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString (f_aboc ()))
                                @(f_aboc Data.ByteString.Lazy.Internal.ByteString)
                                (\ (s_abog :: Data.ByteString.Lazy.Internal.ByteString) ->
                                   case s_abog of wild_aboh {
                                     Data.ByteString.Lazy.Internal.Empty ->
                                       Data.Either.Right
                                         @Data.ByteString.Lazy.Internal.ByteString
                                         @()
                                         GHC.Tuple.Prim.();
                                     Data.ByteString.Lazy.Internal.Chunk ipv_aboi ipv1_aboj
                                                                         ipv2_abok ipv3_abol ->
                                       Data.Either.Left
                                         @Data.ByteString.Lazy.Internal.ByteString @() wild_aboh
                                   })
                                (let {
                                   f2_abon
                                     :: Data.ByteString.Lazy.Internal.ByteString
                                        -> f_aboc Data.ByteString.Lazy.Internal.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abon
                                     = GHC.Base.pure
                                         @f_aboc
                                         $dApplicative_aboe
                                         @Data.ByteString.Lazy.Internal.ByteString } in
                                 let {
                                   ds2_aboo
                                     :: f_aboc () -> f_aboc Data.ByteString.Lazy.Internal.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 70 0}]
                                   ds2_aboo
                                     = GHC.Base.fmap
                                         @f_aboc
                                         (GHC.Base.$p1Applicative @f_aboc $dApplicative_aboe)
                                         @()
                                         @Data.ByteString.Lazy.Internal.ByteString
                                         (\ (ds3_abop :: ()) ->
                                            case ds3_abop of { () ->
                                            Data.ByteString.Lazy.Internal.Empty
                                            }) } in
                                 \ (ds3_abor
                                      :: Data.Either.Either
                                           Data.ByteString.Lazy.Internal.ByteString (f_aboc ())) ->
                                   case ds3_abor of {
                                     Data.Either.Left x_abot -> f2_abon x_abot;
                                     Data.Either.Right y_abov -> ds2_aboo y_abov
                                   }) } in
                        let {
                          g_abox
                            :: p_abob () (f_aboc ())
                               -> p_abob
                                    (Data.Either.Either Data.ByteString.Lazy.Internal.ByteString ())
                                    (Data.Either.Either
                                       Data.ByteString.Lazy.Internal.ByteString (f_aboc ()))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abox
                            = Data.Profunctor.Choice.right'
                                @p_abob
                                $dChoice_abod
                                @()
                                @(f_aboc ())
                                @Data.ByteString.Lazy.Internal.ByteString } in
                        \ (x_aboy :: p_abob () (f_aboc ())) -> f1_abof (g_abox x_aboy))
                     `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                      <Data.ByteString.Lazy.Internal.ByteString>_N)
                             :: Control.Lens.Type.Prism'
                                  Data.ByteString.Lazy.Internal.ByteString ()
                                ~R# Control.Lens.Empty.AsEmpty
                                      Data.ByteString.Lazy.Internal.ByteString)
              TyArg Data.Functor.Const.Const
                      Data.ByteString.Lazy.Internal.ByteString
              ValArg Data.Functor.Contravariant.$fContravariantConst
                       @Data.ByteString.Lazy.Internal.ByteString
              ValArg Data.Functor.Const.$fFunctorConst
                       @Data.ByteString.Lazy.Internal.ByteString
    After:  (\ (@s1_abfO)
               (@(f_abfP :: * -> *))
               (@a_abfQ)
               ($dCons_abfR
                  :: Control.Lens.Cons.Cons s1_abfO s1_abfO a_abfQ a_abfQ)
               ($dCons1_abfS
                  :: Control.Lens.Cons.Cons s1_abfO s1_abfO a_abfQ a_abfQ)
               ($dAsEmpty_abfT :: Control.Lens.Empty.AsEmpty s1_abfO)
               ($dContravariant_abfU
                  :: Data.Functor.Contravariant.Contravariant f_abfP)
               ($dFunctor_abfV :: GHC.Base.Functor f_abfP) ->
               GHC.Base.id @(s1_abfO -> f_abfP s1_abfO))
              @Data.ByteString.Lazy.Internal.ByteString
              @(Data.Functor.Const.Const
                  Data.ByteString.Lazy.Internal.ByteString)
              @GHC.Word.Word8
              ((\ (@(p_abnq :: * -> * -> *))
                  (@(f_abnr :: * -> *))
                  ($dChoice_abns :: Data.Profunctor.Choice.Choice p_abnq)
                  ($dApplicative_abnt :: GHC.Base.Applicative f_abnr) ->
                  let {
                    f1_abnu
                      :: p_abnq
                           (Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString
                              (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                           (Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString
                              (f_abnr
                                 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                         -> p_abnq
                              Data.ByteString.Lazy.Internal.ByteString
                              (f_abnr Data.ByteString.Lazy.Internal.ByteString)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 536 0}]
                    f1_abnu
                      = Data.Profunctor.Unsafe.dimap
                          @p_abnq
                          (Data.Profunctor.Choice.$p1Choice @p_abnq $dChoice_abns)
                          @Data.ByteString.Lazy.Internal.ByteString
                          @(Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString
                              (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                          @(Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString
                              (f_abnr
                                 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                          @(f_abnr Data.ByteString.Lazy.Internal.ByteString)
                          (\ (s1_abnv :: Data.ByteString.Lazy.Internal.ByteString) ->
                             case s1_abnv of {
                               Data.ByteString.Lazy.Internal.Empty ->
                                 Data.Either.Left
                                   @Data.ByteString.Lazy.Internal.ByteString
                                   @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                   Data.ByteString.Lazy.Internal.Empty;
                               Data.ByteString.Lazy.Internal.Chunk bx_abnC bx1_abnD bx2_abnE
                                                                   cs_abnF ->
                                 case bx2_abnE of ds1_abnH {
                                   __DEFAULT ->
                                     Data.Either.Right
                                       @Data.ByteString.Lazy.Internal.ByteString
                                       @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                       (case GHC.Prim.readWord8OffAddr#
                                               @GHC.Prim.RealWorld bx_abnC 0# GHC.Prim.realWorld#
                                        of
                                        { (# ipv_abnJ, ipv1_abnK #) ->
                                        case GHC.Prim.touch#
                                               @'GHC.Types.Lifted
                                               @GHC.ForeignPtr.ForeignPtrContents
                                               bx1_abnD
                                               ipv_abnJ
                                        of
                                        { __DEFAULT ->
                                        GHC.Word.W8# ipv1_abnK
                                        }
                                        },
                                        Data.ByteString.Lazy.Internal.$WChunk
                                          (Data.ByteString.Internal.Type.$WBS
                                             (GHC.ForeignPtr.ForeignPtr
                                                @GHC.Word.Word8
                                                (GHC.Prim.plusAddr# bx_abnC 1#)
                                                bx1_abnD)
                                             (GHC.Types.I# (GHC.Prim.-# ds1_abnH 1#)))
                                          cs_abnF);
                                   1# ->
                                     Data.Either.Right
                                       @Data.ByteString.Lazy.Internal.ByteString
                                       @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                       (case GHC.Prim.readWord8OffAddr#
                                               @GHC.Prim.RealWorld bx_abnC 0# GHC.Prim.realWorld#
                                        of
                                        { (# ipv_abnO, ipv1_abnP #) ->
                                        case GHC.Prim.touch#
                                               @'GHC.Types.Lifted
                                               @GHC.ForeignPtr.ForeignPtrContents
                                               bx1_abnD
                                               ipv_abnO
                                        of
                                        { __DEFAULT ->
                                        GHC.Word.W8# ipv1_abnP
                                        }
                                        },
                                        cs_abnF)
                                 }
                             })
                          (let {
                             f2_abnS
                               :: Data.ByteString.Lazy.Internal.ByteString
                                  -> f_abnr Data.ByteString.Lazy.Internal.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abnS
                               = GHC.Base.pure
                                   @f_abnr
                                   $dApplicative_abnt
                                   @Data.ByteString.Lazy.Internal.ByteString } in
                           let {
                             ds2_abnT
                               :: f_abnr
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                  -> f_abnr Data.ByteString.Lazy.Internal.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 162 0}]
                             ds2_abnT
                               = GHC.Base.fmap
                                   @f_abnr
                                   (GHC.Base.$p1Applicative @f_abnr $dApplicative_abnt)
                                   @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                   @Data.ByteString.Lazy.Internal.ByteString
                                   (\ (p1_abnU
                                         :: (GHC.Word.Word8,
                                             Data.ByteString.Lazy.Internal.ByteString)) ->
                                      case p1_abnU of { (x_abnW, ds_abnX) ->
                                      case x_abnW of { GHC.Word.W8# x#_abo0 ->
                                      Data.ByteString.Lazy.Internal.$WChunk
                                        (Data.ByteString.Internal.Type.$WBS
                                           (GHC.ForeignPtr.ForeignPtr
                                              @GHC.Word.Word8
                                              (GHC.Prim.plusAddr#
                                                 Data.ByteString.singleton1
                                                 (GHC.Prim.word2Int#
                                                    (GHC.Prim.word8ToWord# x#_abo0)))
                                              GHC.ForeignPtr.FinalPtr)
                                           (GHC.Types.I# 1#))
                                        ds_abnX
                                      }
                                      }) } in
                           \ (ds3_abo2
                                :: Data.Either.Either
                                     Data.ByteString.Lazy.Internal.ByteString
                                     (f_abnr
                                        (GHC.Word.Word8,
                                         Data.ByteString.Lazy.Internal.ByteString))) ->
                             case ds3_abo2 of {
                               Data.Either.Left x_abo4 -> f2_abnS x_abo4;
                               Data.Either.Right y_abo6 -> ds2_abnT y_abo6
                             }) } in
                  let {
                    g_abo8
                      :: p_abnq
                           (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                           (f_abnr (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                         -> p_abnq
                              (Data.Either.Either
                                 Data.ByteString.Lazy.Internal.ByteString
                                 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                              (Data.Either.Either
                                 Data.ByteString.Lazy.Internal.ByteString
                                 (f_abnr
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abo8
                      = Data.Profunctor.Choice.right'
                          @p_abnq
                          $dChoice_abns
                          @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                          @(f_abnr
                              (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                          @Data.ByteString.Lazy.Internal.ByteString } in
                  \ (x_abo9
                       :: p_abnq
                            (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                            (f_abnr
                               (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))) ->
                    f1_abnu (g_abo8 x_abo9))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <Data.ByteString.Lazy.Internal.ByteString>_N
                                <Data.ByteString.Lazy.Internal.ByteString>_N
                                <GHC.Word.Word8>_N
                                <GHC.Word.Word8>_N)
                       :: Control.Lens.Type.Prism
                            Data.ByteString.Lazy.Internal.ByteString
                            Data.ByteString.Lazy.Internal.ByteString
                            (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                            (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                          ~R# Control.Lens.Cons.Cons
                                Data.ByteString.Lazy.Internal.ByteString
                                Data.ByteString.Lazy.Internal.ByteString
                                GHC.Word.Word8
                                GHC.Word.Word8))
              ((\ (@(p_abnq :: * -> * -> *))
                  (@(f_abnr :: * -> *))
                  ($dChoice_abns :: Data.Profunctor.Choice.Choice p_abnq)
                  ($dApplicative_abnt :: GHC.Base.Applicative f_abnr) ->
                  let {
                    f1_abnu
                      :: p_abnq
                           (Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString
                              (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                           (Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString
                              (f_abnr
                                 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                         -> p_abnq
                              Data.ByteString.Lazy.Internal.ByteString
                              (f_abnr Data.ByteString.Lazy.Internal.ByteString)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 536 0}]
                    f1_abnu
                      = Data.Profunctor.Unsafe.dimap
                          @p_abnq
                          (Data.Profunctor.Choice.$p1Choice @p_abnq $dChoice_abns)
                          @Data.ByteString.Lazy.Internal.ByteString
                          @(Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString
                              (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                          @(Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString
                              (f_abnr
                                 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                          @(f_abnr Data.ByteString.Lazy.Internal.ByteString)
                          (\ (s1_abnv :: Data.ByteString.Lazy.Internal.ByteString) ->
                             case s1_abnv of {
                               Data.ByteString.Lazy.Internal.Empty ->
                                 Data.Either.Left
                                   @Data.ByteString.Lazy.Internal.ByteString
                                   @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                   Data.ByteString.Lazy.Internal.Empty;
                               Data.ByteString.Lazy.Internal.Chunk bx_abnC bx1_abnD bx2_abnE
                                                                   cs_abnF ->
                                 case bx2_abnE of ds1_abnH {
                                   __DEFAULT ->
                                     Data.Either.Right
                                       @Data.ByteString.Lazy.Internal.ByteString
                                       @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                       (case GHC.Prim.readWord8OffAddr#
                                               @GHC.Prim.RealWorld bx_abnC 0# GHC.Prim.realWorld#
                                        of
                                        { (# ipv_abnJ, ipv1_abnK #) ->
                                        case GHC.Prim.touch#
                                               @'GHC.Types.Lifted
                                               @GHC.ForeignPtr.ForeignPtrContents
                                               bx1_abnD
                                               ipv_abnJ
                                        of
                                        { __DEFAULT ->
                                        GHC.Word.W8# ipv1_abnK
                                        }
                                        },
                                        Data.ByteString.Lazy.Internal.$WChunk
                                          (Data.ByteString.Internal.Type.$WBS
                                             (GHC.ForeignPtr.ForeignPtr
                                                @GHC.Word.Word8
                                                (GHC.Prim.plusAddr# bx_abnC 1#)
                                                bx1_abnD)
                                             (GHC.Types.I# (GHC.Prim.-# ds1_abnH 1#)))
                                          cs_abnF);
                                   1# ->
                                     Data.Either.Right
                                       @Data.ByteString.Lazy.Internal.ByteString
                                       @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                       (case GHC.Prim.readWord8OffAddr#
                                               @GHC.Prim.RealWorld bx_abnC 0# GHC.Prim.realWorld#
                                        of
                                        { (# ipv_abnO, ipv1_abnP #) ->
                                        case GHC.Prim.touch#
                                               @'GHC.Types.Lifted
                                               @GHC.ForeignPtr.ForeignPtrContents
                                               bx1_abnD
                                               ipv_abnO
                                        of
                                        { __DEFAULT ->
                                        GHC.Word.W8# ipv1_abnP
                                        }
                                        },
                                        cs_abnF)
                                 }
                             })
                          (let {
                             f2_abnS
                               :: Data.ByteString.Lazy.Internal.ByteString
                                  -> f_abnr Data.ByteString.Lazy.Internal.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abnS
                               = GHC.Base.pure
                                   @f_abnr
                                   $dApplicative_abnt
                                   @Data.ByteString.Lazy.Internal.ByteString } in
                           let {
                             ds2_abnT
                               :: f_abnr
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                  -> f_abnr Data.ByteString.Lazy.Internal.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 162 0}]
                             ds2_abnT
                               = GHC.Base.fmap
                                   @f_abnr
                                   (GHC.Base.$p1Applicative @f_abnr $dApplicative_abnt)
                                   @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                   @Data.ByteString.Lazy.Internal.ByteString
                                   (\ (p1_abnU
                                         :: (GHC.Word.Word8,
                                             Data.ByteString.Lazy.Internal.ByteString)) ->
                                      case p1_abnU of { (x_abnW, ds_abnX) ->
                                      case x_abnW of { GHC.Word.W8# x#_abo0 ->
                                      Data.ByteString.Lazy.Internal.$WChunk
                                        (Data.ByteString.Internal.Type.$WBS
                                           (GHC.ForeignPtr.ForeignPtr
                                              @GHC.Word.Word8
                                              (GHC.Prim.plusAddr#
                                                 Data.ByteString.singleton1
                                                 (GHC.Prim.word2Int#
                                                    (GHC.Prim.word8ToWord# x#_abo0)))
                                              GHC.ForeignPtr.FinalPtr)
                                           (GHC.Types.I# 1#))
                                        ds_abnX
                                      }
                                      }) } in
                           \ (ds3_abo2
                                :: Data.Either.Either
                                     Data.ByteString.Lazy.Internal.ByteString
                                     (f_abnr
                                        (GHC.Word.Word8,
                                         Data.ByteString.Lazy.Internal.ByteString))) ->
                             case ds3_abo2 of {
                               Data.Either.Left x_abo4 -> f2_abnS x_abo4;
                               Data.Either.Right y_abo6 -> ds2_abnT y_abo6
                             }) } in
                  let {
                    g_abo8
                      :: p_abnq
                           (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                           (f_abnr (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                         -> p_abnq
                              (Data.Either.Either
                                 Data.ByteString.Lazy.Internal.ByteString
                                 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                              (Data.Either.Either
                                 Data.ByteString.Lazy.Internal.ByteString
                                 (f_abnr
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abo8
                      = Data.Profunctor.Choice.right'
                          @p_abnq
                          $dChoice_abns
                          @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                          @(f_abnr
                              (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                          @Data.ByteString.Lazy.Internal.ByteString } in
                  \ (x_abo9
                       :: p_abnq
                            (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                            (f_abnr
                               (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))) ->
                    f1_abnu (g_abo8 x_abo9))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <Data.ByteString.Lazy.Internal.ByteString>_N
                                <Data.ByteString.Lazy.Internal.ByteString>_N
                                <GHC.Word.Word8>_N
                                <GHC.Word.Word8>_N)
                       :: Control.Lens.Type.Prism
                            Data.ByteString.Lazy.Internal.ByteString
                            Data.ByteString.Lazy.Internal.ByteString
                            (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                            (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                          ~R# Control.Lens.Cons.Cons
                                Data.ByteString.Lazy.Internal.ByteString
                                Data.ByteString.Lazy.Internal.ByteString
                                GHC.Word.Word8
                                GHC.Word.Word8))
              ((\ (@(p_abob :: * -> * -> *))
                  (@(f_aboc :: * -> *))
                  ($dChoice_abod :: Data.Profunctor.Choice.Choice p_abob)
                  ($dApplicative_aboe :: GHC.Base.Applicative f_aboc) ->
                  let {
                    f1_abof
                      :: p_abob
                           (Data.Either.Either Data.ByteString.Lazy.Internal.ByteString ())
                           (Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString (f_aboc ()))
                         -> p_abob
                              Data.ByteString.Lazy.Internal.ByteString
                              (f_aboc Data.ByteString.Lazy.Internal.ByteString)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 290 0}]
                    f1_abof
                      = Data.Profunctor.Unsafe.dimap
                          @p_abob
                          (Data.Profunctor.Choice.$p1Choice @p_abob $dChoice_abod)
                          @Data.ByteString.Lazy.Internal.ByteString
                          @(Data.Either.Either Data.ByteString.Lazy.Internal.ByteString ())
                          @(Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString (f_aboc ()))
                          @(f_aboc Data.ByteString.Lazy.Internal.ByteString)
                          (\ (s_abog :: Data.ByteString.Lazy.Internal.ByteString) ->
                             case s_abog of wild_aboh {
                               Data.ByteString.Lazy.Internal.Empty ->
                                 Data.Either.Right
                                   @Data.ByteString.Lazy.Internal.ByteString @() GHC.Tuple.Prim.();
                               Data.ByteString.Lazy.Internal.Chunk ipv_aboi ipv1_aboj ipv2_abok
                                                                   ipv3_abol ->
                                 Data.Either.Left
                                   @Data.ByteString.Lazy.Internal.ByteString @() wild_aboh
                             })
                          (let {
                             f2_abon
                               :: Data.ByteString.Lazy.Internal.ByteString
                                  -> f_aboc Data.ByteString.Lazy.Internal.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abon
                               = GHC.Base.pure
                                   @f_aboc
                                   $dApplicative_aboe
                                   @Data.ByteString.Lazy.Internal.ByteString } in
                           let {
                             ds2_aboo
                               :: f_aboc () -> f_aboc Data.ByteString.Lazy.Internal.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 70 0}]
                             ds2_aboo
                               = GHC.Base.fmap
                                   @f_aboc
                                   (GHC.Base.$p1Applicative @f_aboc $dApplicative_aboe)
                                   @()
                                   @Data.ByteString.Lazy.Internal.ByteString
                                   (\ (ds3_abop :: ()) ->
                                      case ds3_abop of { () ->
                                      Data.ByteString.Lazy.Internal.Empty
                                      }) } in
                           \ (ds3_abor
                                :: Data.Either.Either
                                     Data.ByteString.Lazy.Internal.ByteString (f_aboc ())) ->
                             case ds3_abor of {
                               Data.Either.Left x_abot -> f2_abon x_abot;
                               Data.Either.Right y_abov -> ds2_aboo y_abov
                             }) } in
                  let {
                    g_abox
                      :: p_abob () (f_aboc ())
                         -> p_abob
                              (Data.Either.Either Data.ByteString.Lazy.Internal.ByteString ())
                              (Data.Either.Either
                                 Data.ByteString.Lazy.Internal.ByteString (f_aboc ()))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abox
                      = Data.Profunctor.Choice.right'
                          @p_abob
                          $dChoice_abod
                          @()
                          @(f_aboc ())
                          @Data.ByteString.Lazy.Internal.ByteString } in
                  \ (x_aboy :: p_abob () (f_aboc ())) -> f1_abof (g_abox x_aboy))
               `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                <Data.ByteString.Lazy.Internal.ByteString>_N)
                       :: Control.Lens.Type.Prism'
                            Data.ByteString.Lazy.Internal.ByteString ()
                          ~R# Control.Lens.Empty.AsEmpty
                                Data.ByteString.Lazy.Internal.ByteString))
              (Data.Functor.Contravariant.$fContravariantConst
                 @Data.ByteString.Lazy.Internal.ByteString)
              (Data.Functor.Const.$fFunctorConst
                 @Data.ByteString.Lazy.Internal.ByteString)
    Cont:   ApplyToVal nodup hole Control.Lens.Getter.Getting
                                    Data.ByteString.Lazy.Internal.ByteString
                                    Data.ByteString.Lazy.Internal.ByteString
                                    Data.ByteString.Lazy.Internal.ByteString
              ((\ (ds_abeK [Occ=Once1] :: a_abeH) -> ds_abeK)
               `cast` (<a_abeH>_R
                       %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                          <*>_N <a_abeH>_R <a_abeH>_P)
                       :: (a_abeH -> a_abeH)
                          ~R# (a_abeH -> Data.Functor.Const.Const a_abeH a_abeH)))
            ApplyToVal nodup hole Data.ByteString.Lazy.Internal.ByteString
                                  -> Data.Functor.Const.Const
                                       Data.ByteString.Lazy.Internal.ByteString
                                       Data.ByteString.Lazy.Internal.ByteString
              s_a8NV
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N
                        <Data.ByteString.Lazy.Internal.ByteString>_R
                        <Data.ByteString.Lazy.Internal.ByteString>_P
                    :: Data.Functor.Const.Const
                         Data.ByteString.Lazy.Internal.ByteString
                         Data.ByteString.Lazy.Internal.ByteString
                       ~R# Data.ByteString.Lazy.Internal.ByteString)
            Stop[RuleArgCtxt] Data.ByteString.Lazy.Internal.ByteString
Rule fired
    Rule: Class op ==
    Module: (BUILTIN)
    Before: GHC.Classes.==
              TyArg Data.ByteString.Lazy.Internal.ByteString
              ValArg Data.ByteString.Lazy.Internal.$fEqByteString
              ValArg s_a8NV
              ValArg s_a8NV
    After:  Data.ByteString.Lazy.Internal.eq
              ValArg s_a8NV ValArg s_a8NV
    Cont:   Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: unpack
    Module: (GHC.Base)
    Before: GHC.CString.unpackCString# ValArg "Str -> T -> Str"#
    After:  (\ (a_ab7z :: GHC.Prim.Addr#) ->
               GHC.Base.build
                 @GHC.Types.Char
                 (\ (@b_ab7A) -> GHC.CString.unpackFoldrCString# @b_ab7A a_ab7z))
              "Str -> T -> Str"#
    Cont:   Stop[BoringCtxt] Test.Tasty.Core.TestName
Rule fired
    Rule: Class op property
    Module: (BUILTIN)
    Before: Test.QuickCheck.Property.property
              TyArg GHC.Base.String -> GHC.Types.Bool ValArg $dTestable_a92k
    After:  Test.QuickCheck.Property.$fTestableFUN_$cproperty
              @[GHC.Types.Char]
              @GHC.Types.Bool
              $dArbitrary_a9JV
              GHC.Show.$fShowList_$s$fShowList1
              Test.QuickCheck.Property.$fTestableBool
    Cont:   ApplyToVal nodup hole (GHC.Base.String -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              prop_ab7M
            CastIt (Sym (Test.Tasty.QuickCheck.N:QC[0])
                    :: Test.QuickCheck.Property.Property ~R# Test.Tasty.QuickCheck.QC)
            Stop[BoringCtxt] Test.Tasty.QuickCheck.QC
Rule fired
    Rule: Class op propertyForAllShrinkShow
    Module: (BUILTIN)
    Before: Test.QuickCheck.Property.propertyForAllShrinkShow
              TyArg GHC.Types.Bool ValArg Test.QuickCheck.Property.$fTestableBool
    After:  Test.QuickCheck.Property.$fTestableBool1
            `cast` (forall (a :: <*>_N).
                    <Test.QuickCheck.Gen.Gen a>_R
                    %<'GHC.Types.Many>_N ->_R <a -> [a]>_R
                    %<'GHC.Types.Many>_N ->_R <a -> [GHC.Base.String]>_R
                    %<'GHC.Types.Many>_N ->_R <a -> GHC.Types.Bool>_R
                    %<'GHC.Types.Many>_N ->_R Sym (Test.QuickCheck.Gen.N:Gen[0]
                                                       (Test.QuickCheck.Property.N:Prop[0]))
                                              ; Sym (Test.QuickCheck.Property.N:Property[0])
                    :: (forall {a}.
                        Test.QuickCheck.Gen.Gen a
                        -> (a -> [a])
                        -> (a -> [GHC.Base.String])
                        -> (a -> GHC.Types.Bool)
                        -> Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int
                        -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result)
                       ~R# (forall {a}.
                            Test.QuickCheck.Gen.Gen a
                            -> (a -> [a])
                            -> (a -> [GHC.Base.String])
                            -> (a -> GHC.Types.Bool)
                            -> Test.QuickCheck.Property.Property))
    Cont:   ApplyToTy [GHC.Types.Char]
            ApplyToVal nodup hole Test.QuickCheck.Gen.Gen [GHC.Types.Char]
                                  -> ([GHC.Types.Char] -> [[GHC.Types.Char]])
                                  -> ([GHC.Types.Char] -> [GHC.Base.String])
                                  -> ([GHC.Types.Char] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (Test.QuickCheck.Arbitrary.arbitrary @a_ab9u $dArbitrary_ab9w)
            ApplyToVal nodup hole ([GHC.Types.Char] -> [[GHC.Types.Char]])
                                  -> ([GHC.Types.Char] -> [GHC.Base.String])
                                  -> ([GHC.Types.Char] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (Test.QuickCheck.Arbitrary.shrink @a_ab9u $dArbitrary_ab9w)
            ApplyToVal nodup hole ([GHC.Types.Char] -> [GHC.Base.String])
                                  -> ([GHC.Types.Char] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (let {
                 g_ab9A [Occ=OnceL1!] :: a_ab9u -> GHC.Base.String
                 [LclId]
                 g_ab9A = GHC.Show.show @a_ab9u $dShow_ab9x } in
               \ (x_ab9B [Occ=Once1] :: a_ab9u) ->
                 GHC.Types.:
                   @GHC.Base.String (g_ab9A x_ab9B) (GHC.Types.[] @GHC.Base.String))
            ApplyToVal nodup hole ([GHC.Types.Char] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              f_ab9z
            CastIt (Sym (Test.Tasty.QuickCheck.N:QC[0])
                    :: Test.QuickCheck.Property.Property ~R# Test.Tasty.QuickCheck.QC)
            Stop[BoringCtxt] Test.Tasty.QuickCheck.QC
Rule fired
    Rule: Class op arbitrary
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.arbitrary
              TyArg [GHC.Types.Char] ValArg $dArbitrary_a9JV
    After:  (Test.QuickCheck.Arbitrary.$fArbitraryList1
               @GHC.Types.Char Test.QuickCheck.Arbitrary.$fArbitraryChar)
            `cast` (Sym (Test.QuickCheck.Gen.N:Gen[0] <[GHC.Types.Char]>_R)
                    :: (Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int -> [GHC.Types.Char])
                       ~R# Test.QuickCheck.Gen.Gen [GHC.Types.Char])
    Cont:   Stop[BoringCtxt] Test.QuickCheck.Gen.Gen [GHC.Types.Char]
Rule fired
    Rule: Class op arbitrary
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.arbitrary
              TyArg GHC.Types.Char
              ValArg Test.QuickCheck.Arbitrary.$fArbitraryChar
    After:  Test.QuickCheck.Arbitrary.$fArbitraryChar_$carbitrary
    Cont:   Stop[BoringCtxt, C(S,C(1,L))] Test.QuickCheck.Gen.Gen
                                            GHC.Types.Char
Rule fired
    Rule: Class op shrink
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.shrink
              TyArg [GHC.Types.Char] ValArg $dArbitrary_a9JV
    After:  Test.QuickCheck.Arbitrary.$fArbitraryList_$cshrink
              @GHC.Types.Char Test.QuickCheck.Arbitrary.$fArbitraryChar
    Cont:   Stop[BoringCtxt] [GHC.Types.Char] -> [[GHC.Types.Char]]
Rule fired
    Rule: Class op shrink
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.shrink
              TyArg GHC.Types.Char
              ValArg Test.QuickCheck.Arbitrary.$fArbitraryChar
    After:  Test.QuickCheck.Arbitrary.$fArbitraryChar_$cshrink
    Cont:   Stop[DiscArgCtxt, C(S,L)] GHC.Types.Char
                                      -> [GHC.Types.Char]
Rule fired
    Rule: Class op show
    Module: (BUILTIN)
    Before: GHC.Show.show
              TyArg [GHC.Types.Char] ValArg GHC.Show.$fShowList_$s$fShowList1
    After:  GHC.Show.$fShowList_$s$cshow1
    Cont:   Stop[RhsCtxt(NonRecursive)] [GHC.Types.Char]
                                        -> GHC.Base.String
Rule fired
    Rule: Class op reader
    Module: (BUILTIN)
    Before: Control.Monad.Reader.Class.reader
              TyArg Data.Text.Internal.Text
              TyArg (->) Data.Text.Internal.Text
              ValArg Control.Monad.Reader.Class.$fMonadReaderrFUN
                       @Data.Text.Internal.Text
    After:  \ (@a_abeP) ->
              GHC.Base.id @(Data.Text.Internal.Text -> a_abeP)
    Cont:   ApplyToTy GHC.Base.String
            ApplyToVal nodup hole (Data.Text.Internal.Text -> GHC.Base.String)
                                  -> Data.Text.Internal.Text -> GHC.Base.String
              ((l_abeJ
                  ((\ (ds_abeK [Occ=Once1] :: a_abeH) -> ds_abeK)
                   `cast` (<a_abeH>_R
                           %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                              <*>_N <a_abeH>_R <a_abeH>_P)
                           :: (a_abeH -> a_abeH)
                              ~R# (a_abeH -> Data.Functor.Const.Const a_abeH a_abeH))))
               `cast` (<s_abeF>_R
                       %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                     <*>_N <a_abeH>_R <s_abeF>_P
                       :: (s_abeF -> Data.Functor.Const.Const a_abeH s_abeF)
                          ~R# (s_abeF -> a_abeH)))
            ApplyToVal nodup hole Data.Text.Internal.Text -> GHC.Base.String
              (Control.Lens.Getter.view
                 @[GHC.Types.Char]
                 @((->) GHC.Base.String)
                 @Data.Text.Internal.Text
                 (Control.Monad.Reader.Class.$fMonadReaderrFUN @[GHC.Types.Char])
                 (Control.Lens.Cons.Extras.recons
                    @[GHC.Types.Char]
                    @GHC.Types.Char
                    @Data.Text.Internal.Text
                    (Control.Lens.Cons.$fConsListListab
                       @GHC.Types.Char @GHC.Types.Char)
                    Control.Lens.Cons.$fConsTextTextCharChar0
                    Control.Lens.Empty.$fAsEmptyText0
                    @(Data.Functor.Const.Const Data.Text.Internal.Text)
                    (Data.Functor.Contravariant.$fContravariantConst
                       @Data.Text.Internal.Text)
                    (Data.Functor.Const.$fFunctorConst @Data.Text.Internal.Text))
                 s_a8Pu)
            Stop[RuleArgCtxt] GHC.Base.String
Rule fired
    Rule: recons/text-string
    Module: (Control.Lens.Cons.Extras)
    Before: Control.Lens.Cons.Extras.recons
              TyArg Data.Text.Internal.Text
              TyArg GHC.Types.Char
              TyArg GHC.Base.String
              ValArg (\ (@(p_abig :: * -> * -> *))
                        (@(f_abih :: * -> *))
                        ($dChoice_abii :: Data.Profunctor.Choice.Choice p_abig)
                        ($dApplicative_abij :: GHC.Base.Applicative f_abih) ->
                        let {
                          f1_abik
                            :: p_abig
                                 (Data.Either.Either
                                    Data.Text.Internal.Text
                                    (GHC.Types.Char, Data.Text.Internal.Text))
                                 (Data.Either.Either
                                    Data.Text.Internal.Text
                                    (f_abih (GHC.Types.Char, Data.Text.Internal.Text)))
                               -> p_abig Data.Text.Internal.Text (f_abih Data.Text.Internal.Text)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 340 0}]
                          f1_abik
                            = Data.Profunctor.Unsafe.dimap
                                @p_abig
                                (Data.Profunctor.Choice.$p1Choice @p_abig $dChoice_abii)
                                @Data.Text.Internal.Text
                                @(Data.Either.Either
                                    Data.Text.Internal.Text
                                    (GHC.Types.Char, Data.Text.Internal.Text))
                                @(Data.Either.Either
                                    Data.Text.Internal.Text
                                    (f_abih (GHC.Types.Char, Data.Text.Internal.Text)))
                                @(f_abih Data.Text.Internal.Text)
                                (\ (s1_abil :: Data.Text.Internal.Text) ->
                                   case Data.Text.uncons s1_abil of {
                                     GHC.Maybe.Nothing ->
                                       Data.Either.Left
                                         @Data.Text.Internal.Text
                                         @(GHC.Types.Char, Data.Text.Internal.Text)
                                         s1_abil;
                                     GHC.Maybe.Just x_abio ->
                                       Data.Either.Right
                                         @Data.Text.Internal.Text
                                         @(GHC.Types.Char, Data.Text.Internal.Text)
                                         x_abio
                                   })
                                (let {
                                   f2_abiq
                                     :: Data.Text.Internal.Text -> f_abih Data.Text.Internal.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abiq
                                     = GHC.Base.pure
                                         @f_abih $dApplicative_abij @Data.Text.Internal.Text } in
                                 let {
                                   ds2_abir
                                     :: f_abih (GHC.Types.Char, Data.Text.Internal.Text)
                                        -> f_abih Data.Text.Internal.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 100 0}]
                                   ds2_abir
                                     = GHC.Base.fmap
                                         @f_abih
                                         (GHC.Base.$p1Applicative @f_abih $dApplicative_abij)
                                         @(GHC.Types.Char, Data.Text.Internal.Text)
                                         @Data.Text.Internal.Text
                                         (\ (p1_abis
                                               :: (GHC.Types.Char, Data.Text.Internal.Text)) ->
                                            case p1_abis of { (x_abiu, ds_abiv) ->
                                            Data.Text.cons x_abiu ds_abiv
                                            }) } in
                                 \ (ds3_abix
                                      :: Data.Either.Either
                                           Data.Text.Internal.Text
                                           (f_abih (GHC.Types.Char, Data.Text.Internal.Text))) ->
                                   case ds3_abix of {
                                     Data.Either.Left x_abiz -> f2_abiq x_abiz;
                                     Data.Either.Right y_abiB -> ds2_abir y_abiB
                                   }) } in
                        let {
                          g_abiD
                            :: p_abig
                                 (GHC.Types.Char, Data.Text.Internal.Text)
                                 (f_abih (GHC.Types.Char, Data.Text.Internal.Text))
                               -> p_abig
                                    (Data.Either.Either
                                       Data.Text.Internal.Text
                                       (GHC.Types.Char, Data.Text.Internal.Text))
                                    (Data.Either.Either
                                       Data.Text.Internal.Text
                                       (f_abih (GHC.Types.Char, Data.Text.Internal.Text)))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abiD
                            = Data.Profunctor.Choice.right'
                                @p_abig
                                $dChoice_abii
                                @(GHC.Types.Char, Data.Text.Internal.Text)
                                @(f_abih (GHC.Types.Char, Data.Text.Internal.Text))
                                @Data.Text.Internal.Text } in
                        \ (x_abiE
                             :: p_abig
                                  (GHC.Types.Char, Data.Text.Internal.Text)
                                  (f_abih (GHC.Types.Char, Data.Text.Internal.Text))) ->
                          f1_abik (g_abiD x_abiE))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <Data.Text.Internal.Text>_N
                                      <Data.Text.Internal.Text>_N
                                      <GHC.Types.Char>_N
                                      <GHC.Types.Char>_N)
                             :: Control.Lens.Type.Prism
                                  Data.Text.Internal.Text
                                  Data.Text.Internal.Text
                                  (GHC.Types.Char, Data.Text.Internal.Text)
                                  (GHC.Types.Char, Data.Text.Internal.Text)
                                ~R# Control.Lens.Cons.Cons
                                      Data.Text.Internal.Text
                                      Data.Text.Internal.Text
                                      GHC.Types.Char
                                      GHC.Types.Char)
              ValArg (\ (@(p_abgg :: * -> * -> *))
                        (@(f_abgh :: * -> *))
                        ($dChoice_abgi :: Data.Profunctor.Choice.Choice p_abgg)
                        ($dApplicative_abgj :: GHC.Base.Applicative f_abgh) ->
                        let {
                          f1_abgk
                            :: p_abgg
                                 (Data.Either.Either
                                    [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                                 (Data.Either.Either
                                    [GHC.Types.Char] (f_abgh (GHC.Types.Char, [GHC.Types.Char])))
                               -> p_abgg [GHC.Types.Char] (f_abgh [GHC.Types.Char])
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 320 0}]
                          f1_abgk
                            = Data.Profunctor.Unsafe.dimap
                                @p_abgg
                                (Data.Profunctor.Choice.$p1Choice @p_abgg $dChoice_abgi)
                                @[GHC.Types.Char]
                                @(Data.Either.Either
                                    [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                                @(Data.Either.Either
                                    [GHC.Types.Char] (f_abgh (GHC.Types.Char, [GHC.Types.Char])))
                                @(f_abgh [GHC.Types.Char])
                                (\ (aas_abgl :: [GHC.Types.Char]) ->
                                   case aas_abgl of {
                                     [] ->
                                       Data.Either.Left
                                         @[GHC.Types.Char]
                                         @(GHC.Types.Char, [GHC.Types.Char])
                                         (GHC.Types.[] @GHC.Types.Char);
                                     : a1_abgn as_abgo ->
                                       Data.Either.Right
                                         @[GHC.Types.Char]
                                         @(GHC.Types.Char, [GHC.Types.Char])
                                         (a1_abgn, as_abgo)
                                   })
                                (let {
                                   f2_abgq :: [GHC.Types.Char] -> f_abgh [GHC.Types.Char]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abgq
                                     = GHC.Base.pure
                                         @f_abgh $dApplicative_abgj @[GHC.Types.Char] } in
                                 let {
                                   ds2_abgr
                                     :: f_abgh (GHC.Types.Char, [GHC.Types.Char])
                                        -> f_abgh [GHC.Types.Char]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 90 0}]
                                   ds2_abgr
                                     = GHC.Base.fmap
                                         @f_abgh
                                         (GHC.Base.$p1Applicative @f_abgh $dApplicative_abgj)
                                         @(GHC.Types.Char, [GHC.Types.Char])
                                         @[GHC.Types.Char]
                                         (\ (p1_abgs :: (GHC.Types.Char, [GHC.Types.Char])) ->
                                            GHC.Types.:
                                              @GHC.Types.Char
                                              (case p1_abgs of { (x_abgu, ds_abgv) -> x_abgu })
                                              (case p1_abgs of { (ds_abgy, y_abgz) ->
                                               y_abgz
                                               })) } in
                                 \ (ds3_abgB
                                      :: Data.Either.Either
                                           [GHC.Types.Char]
                                           (f_abgh (GHC.Types.Char, [GHC.Types.Char]))) ->
                                   case ds3_abgB of {
                                     Data.Either.Left x_abgD -> f2_abgq x_abgD;
                                     Data.Either.Right y_abgF -> ds2_abgr y_abgF
                                   }) } in
                        let {
                          g_abgH
                            :: p_abgg
                                 (GHC.Types.Char, [GHC.Types.Char])
                                 (f_abgh (GHC.Types.Char, [GHC.Types.Char]))
                               -> p_abgg
                                    (Data.Either.Either
                                       [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                                    (Data.Either.Either
                                       [GHC.Types.Char] (f_abgh (GHC.Types.Char, [GHC.Types.Char])))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abgH
                            = Data.Profunctor.Choice.right'
                                @p_abgg
                                $dChoice_abgi
                                @(GHC.Types.Char, [GHC.Types.Char])
                                @(f_abgh (GHC.Types.Char, [GHC.Types.Char]))
                                @[GHC.Types.Char] } in
                        \ (x_abgI
                             :: p_abgg
                                  (GHC.Types.Char, [GHC.Types.Char])
                                  (f_abgh (GHC.Types.Char, [GHC.Types.Char]))) ->
                          f1_abgk (g_abgH x_abgI))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <[GHC.Types.Char]>_N
                                      <[GHC.Types.Char]>_N
                                      <GHC.Types.Char>_N
                                      <GHC.Types.Char>_N)
                             :: Control.Lens.Type.Prism
                                  [GHC.Types.Char]
                                  [GHC.Types.Char]
                                  (GHC.Types.Char, [GHC.Types.Char])
                                  (GHC.Types.Char, [GHC.Types.Char])
                                ~R# Control.Lens.Cons.Cons
                                      [GHC.Types.Char]
                                      [GHC.Types.Char]
                                      GHC.Types.Char
                                      GHC.Types.Char)
              ValArg (\ (@(p_abgN :: * -> * -> *))
                        (@(f_abgO :: * -> *))
                        ($dChoice_abgP :: Data.Profunctor.Choice.Choice p_abgN)
                        ($dApplicative_abgQ :: GHC.Base.Applicative f_abgO) ->
                        let {
                          f1_abgR
                            :: p_abgN
                                 (Data.Either.Either [GHC.Types.Char] ())
                                 (Data.Either.Either [GHC.Types.Char] (f_abgO ()))
                               -> p_abgN [GHC.Types.Char] (f_abgO [GHC.Types.Char])
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 290 0}]
                          f1_abgR
                            = Data.Profunctor.Unsafe.dimap
                                @p_abgN
                                (Data.Profunctor.Choice.$p1Choice @p_abgN $dChoice_abgP)
                                @[GHC.Types.Char]
                                @(Data.Either.Either [GHC.Types.Char] ())
                                @(Data.Either.Either [GHC.Types.Char] (f_abgO ()))
                                @(f_abgO [GHC.Types.Char])
                                (\ (s_abgS :: [GHC.Types.Char]) ->
                                   case s_abgS of wild_abgT {
                                     [] ->
                                       Data.Either.Right @[GHC.Types.Char] @() GHC.Tuple.Prim.();
                                     : ds1_abgU ds2_abgV ->
                                       Data.Either.Left @[GHC.Types.Char] @() wild_abgT
                                   })
                                (let {
                                   f2_abgX :: [GHC.Types.Char] -> f_abgO [GHC.Types.Char]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abgX
                                     = GHC.Base.pure
                                         @f_abgO $dApplicative_abgQ @[GHC.Types.Char] } in
                                 let {
                                   ds2_abgY :: f_abgO () -> f_abgO [GHC.Types.Char]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 70 0}]
                                   ds2_abgY
                                     = GHC.Base.fmap
                                         @f_abgO
                                         (GHC.Base.$p1Applicative @f_abgO $dApplicative_abgQ)
                                         @()
                                         @[GHC.Types.Char]
                                         (\ (ds3_abgZ :: ()) ->
                                            case ds3_abgZ of { () ->
                                            GHC.Types.[] @GHC.Types.Char
                                            }) } in
                                 \ (ds3_abh1 :: Data.Either.Either [GHC.Types.Char] (f_abgO ())) ->
                                   case ds3_abh1 of {
                                     Data.Either.Left x_abh3 -> f2_abgX x_abh3;
                                     Data.Either.Right y_abh5 -> ds2_abgY y_abh5
                                   }) } in
                        let {
                          g_abh7
                            :: p_abgN () (f_abgO ())
                               -> p_abgN
                                    (Data.Either.Either [GHC.Types.Char] ())
                                    (Data.Either.Either [GHC.Types.Char] (f_abgO ()))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abh7
                            = Data.Profunctor.Choice.right'
                                @p_abgN $dChoice_abgP @() @(f_abgO ()) @[GHC.Types.Char] } in
                        \ (x_abh8 :: p_abgN () (f_abgO ())) -> f1_abgR (g_abh7 x_abh8))
                     `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0] <[GHC.Types.Char]>_N)
                             :: Control.Lens.Type.Prism' [GHC.Types.Char] ()
                                ~R# Control.Lens.Empty.AsEmpty [GHC.Types.Char])
              TyArg Data.Functor.Const.Const GHC.Base.String
              ValArg Data.Functor.Contravariant.$fContravariantConst
                       @[GHC.Types.Char]
              ValArg Data.Functor.Const.$fFunctorConst @[GHC.Types.Char]
    After:  (\ (@(f_abeS :: * -> *))
               ($dCons_abeT
                  :: Control.Lens.Cons.Cons
                       Data.Text.Internal.Text
                       Data.Text.Internal.Text
                       GHC.Types.Char
                       GHC.Types.Char)
               ($dCons1_abeU
                  :: Control.Lens.Cons.Cons
                       GHC.Base.String GHC.Base.String GHC.Types.Char GHC.Types.Char)
               ($dAsEmpty_abeV :: Control.Lens.Empty.AsEmpty GHC.Base.String)
               ($dContravariant_abeW
                  :: Data.Functor.Contravariant.Contravariant f_abeS)
               ($dFunctor_abeX :: GHC.Base.Functor f_abeS) ->
               Data.Profunctor.Unsafe.$fProfunctorFUN_$cdimap
                 @Data.Text.Internal.Text
                 @GHC.Base.String
                 @(f_abeS GHC.Base.String)
                 @(f_abeS Data.Text.Internal.Text)
                 Data.Text.Show.unpack
                 (GHC.Base.fmap
                    @f_abeS
                    $dFunctor_abeX
                    @GHC.Base.String
                    @Data.Text.Internal.Text
                    Data.Text.Internal.pack))
              @(Data.Functor.Const.Const GHC.Base.String)
              ((\ (@(p_abig :: * -> * -> *))
                  (@(f_abih :: * -> *))
                  ($dChoice_abii :: Data.Profunctor.Choice.Choice p_abig)
                  ($dApplicative_abij :: GHC.Base.Applicative f_abih) ->
                  let {
                    f1_abik
                      :: p_abig
                           (Data.Either.Either
                              Data.Text.Internal.Text (GHC.Types.Char, Data.Text.Internal.Text))
                           (Data.Either.Either
                              Data.Text.Internal.Text
                              (f_abih (GHC.Types.Char, Data.Text.Internal.Text)))
                         -> p_abig Data.Text.Internal.Text (f_abih Data.Text.Internal.Text)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 340 0}]
                    f1_abik
                      = Data.Profunctor.Unsafe.dimap
                          @p_abig
                          (Data.Profunctor.Choice.$p1Choice @p_abig $dChoice_abii)
                          @Data.Text.Internal.Text
                          @(Data.Either.Either
                              Data.Text.Internal.Text (GHC.Types.Char, Data.Text.Internal.Text))
                          @(Data.Either.Either
                              Data.Text.Internal.Text
                              (f_abih (GHC.Types.Char, Data.Text.Internal.Text)))
                          @(f_abih Data.Text.Internal.Text)
                          (\ (s1_abil :: Data.Text.Internal.Text) ->
                             case Data.Text.uncons s1_abil of {
                               GHC.Maybe.Nothing ->
                                 Data.Either.Left
                                   @Data.Text.Internal.Text
                                   @(GHC.Types.Char, Data.Text.Internal.Text)
                                   s1_abil;
                               GHC.Maybe.Just x_abio ->
                                 Data.Either.Right
                                   @Data.Text.Internal.Text
                                   @(GHC.Types.Char, Data.Text.Internal.Text)
                                   x_abio
                             })
                          (let {
                             f2_abiq
                               :: Data.Text.Internal.Text -> f_abih Data.Text.Internal.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abiq
                               = GHC.Base.pure
                                   @f_abih $dApplicative_abij @Data.Text.Internal.Text } in
                           let {
                             ds2_abir
                               :: f_abih (GHC.Types.Char, Data.Text.Internal.Text)
                                  -> f_abih Data.Text.Internal.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 100 0}]
                             ds2_abir
                               = GHC.Base.fmap
                                   @f_abih
                                   (GHC.Base.$p1Applicative @f_abih $dApplicative_abij)
                                   @(GHC.Types.Char, Data.Text.Internal.Text)
                                   @Data.Text.Internal.Text
                                   (\ (p1_abis :: (GHC.Types.Char, Data.Text.Internal.Text)) ->
                                      case p1_abis of { (x_abiu, ds_abiv) ->
                                      Data.Text.cons x_abiu ds_abiv
                                      }) } in
                           \ (ds3_abix
                                :: Data.Either.Either
                                     Data.Text.Internal.Text
                                     (f_abih (GHC.Types.Char, Data.Text.Internal.Text))) ->
                             case ds3_abix of {
                               Data.Either.Left x_abiz -> f2_abiq x_abiz;
                               Data.Either.Right y_abiB -> ds2_abir y_abiB
                             }) } in
                  let {
                    g_abiD
                      :: p_abig
                           (GHC.Types.Char, Data.Text.Internal.Text)
                           (f_abih (GHC.Types.Char, Data.Text.Internal.Text))
                         -> p_abig
                              (Data.Either.Either
                                 Data.Text.Internal.Text (GHC.Types.Char, Data.Text.Internal.Text))
                              (Data.Either.Either
                                 Data.Text.Internal.Text
                                 (f_abih (GHC.Types.Char, Data.Text.Internal.Text)))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abiD
                      = Data.Profunctor.Choice.right'
                          @p_abig
                          $dChoice_abii
                          @(GHC.Types.Char, Data.Text.Internal.Text)
                          @(f_abih (GHC.Types.Char, Data.Text.Internal.Text))
                          @Data.Text.Internal.Text } in
                  \ (x_abiE
                       :: p_abig
                            (GHC.Types.Char, Data.Text.Internal.Text)
                            (f_abih (GHC.Types.Char, Data.Text.Internal.Text))) ->
                    f1_abik (g_abiD x_abiE))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <Data.Text.Internal.Text>_N
                                <Data.Text.Internal.Text>_N
                                <GHC.Types.Char>_N
                                <GHC.Types.Char>_N)
                       :: Control.Lens.Type.Prism
                            Data.Text.Internal.Text
                            Data.Text.Internal.Text
                            (GHC.Types.Char, Data.Text.Internal.Text)
                            (GHC.Types.Char, Data.Text.Internal.Text)
                          ~R# Control.Lens.Cons.Cons
                                Data.Text.Internal.Text
                                Data.Text.Internal.Text
                                GHC.Types.Char
                                GHC.Types.Char))
              ((\ (@(p_abgg :: * -> * -> *))
                  (@(f_abgh :: * -> *))
                  ($dChoice_abgi :: Data.Profunctor.Choice.Choice p_abgg)
                  ($dApplicative_abgj :: GHC.Base.Applicative f_abgh) ->
                  let {
                    f1_abgk
                      :: p_abgg
                           (Data.Either.Either
                              [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                           (Data.Either.Either
                              [GHC.Types.Char] (f_abgh (GHC.Types.Char, [GHC.Types.Char])))
                         -> p_abgg [GHC.Types.Char] (f_abgh [GHC.Types.Char])
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 320 0}]
                    f1_abgk
                      = Data.Profunctor.Unsafe.dimap
                          @p_abgg
                          (Data.Profunctor.Choice.$p1Choice @p_abgg $dChoice_abgi)
                          @[GHC.Types.Char]
                          @(Data.Either.Either
                              [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                          @(Data.Either.Either
                              [GHC.Types.Char] (f_abgh (GHC.Types.Char, [GHC.Types.Char])))
                          @(f_abgh [GHC.Types.Char])
                          (\ (aas_abgl :: [GHC.Types.Char]) ->
                             case aas_abgl of {
                               [] ->
                                 Data.Either.Left
                                   @[GHC.Types.Char]
                                   @(GHC.Types.Char, [GHC.Types.Char])
                                   (GHC.Types.[] @GHC.Types.Char);
                               : a1_abgn as_abgo ->
                                 Data.Either.Right
                                   @[GHC.Types.Char]
                                   @(GHC.Types.Char, [GHC.Types.Char])
                                   (a1_abgn, as_abgo)
                             })
                          (let {
                             f2_abgq :: [GHC.Types.Char] -> f_abgh [GHC.Types.Char]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abgq
                               = GHC.Base.pure @f_abgh $dApplicative_abgj @[GHC.Types.Char] } in
                           let {
                             ds2_abgr
                               :: f_abgh (GHC.Types.Char, [GHC.Types.Char])
                                  -> f_abgh [GHC.Types.Char]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 90 0}]
                             ds2_abgr
                               = GHC.Base.fmap
                                   @f_abgh
                                   (GHC.Base.$p1Applicative @f_abgh $dApplicative_abgj)
                                   @(GHC.Types.Char, [GHC.Types.Char])
                                   @[GHC.Types.Char]
                                   (\ (p1_abgs :: (GHC.Types.Char, [GHC.Types.Char])) ->
                                      GHC.Types.:
                                        @GHC.Types.Char
                                        (case p1_abgs of { (x_abgu, ds_abgv) -> x_abgu })
                                        (case p1_abgs of { (ds_abgy, y_abgz) -> y_abgz })) } in
                           \ (ds3_abgB
                                :: Data.Either.Either
                                     [GHC.Types.Char]
                                     (f_abgh (GHC.Types.Char, [GHC.Types.Char]))) ->
                             case ds3_abgB of {
                               Data.Either.Left x_abgD -> f2_abgq x_abgD;
                               Data.Either.Right y_abgF -> ds2_abgr y_abgF
                             }) } in
                  let {
                    g_abgH
                      :: p_abgg
                           (GHC.Types.Char, [GHC.Types.Char])
                           (f_abgh (GHC.Types.Char, [GHC.Types.Char]))
                         -> p_abgg
                              (Data.Either.Either
                                 [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                              (Data.Either.Either
                                 [GHC.Types.Char] (f_abgh (GHC.Types.Char, [GHC.Types.Char])))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abgH
                      = Data.Profunctor.Choice.right'
                          @p_abgg
                          $dChoice_abgi
                          @(GHC.Types.Char, [GHC.Types.Char])
                          @(f_abgh (GHC.Types.Char, [GHC.Types.Char]))
                          @[GHC.Types.Char] } in
                  \ (x_abgI
                       :: p_abgg
                            (GHC.Types.Char, [GHC.Types.Char])
                            (f_abgh (GHC.Types.Char, [GHC.Types.Char]))) ->
                    f1_abgk (g_abgH x_abgI))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <[GHC.Types.Char]>_N
                                <[GHC.Types.Char]>_N
                                <GHC.Types.Char>_N
                                <GHC.Types.Char>_N)
                       :: Control.Lens.Type.Prism
                            [GHC.Types.Char]
                            [GHC.Types.Char]
                            (GHC.Types.Char, [GHC.Types.Char])
                            (GHC.Types.Char, [GHC.Types.Char])
                          ~R# Control.Lens.Cons.Cons
                                [GHC.Types.Char] [GHC.Types.Char] GHC.Types.Char GHC.Types.Char))
              ((\ (@(p_abgN :: * -> * -> *))
                  (@(f_abgO :: * -> *))
                  ($dChoice_abgP :: Data.Profunctor.Choice.Choice p_abgN)
                  ($dApplicative_abgQ :: GHC.Base.Applicative f_abgO) ->
                  let {
                    f1_abgR
                      :: p_abgN
                           (Data.Either.Either [GHC.Types.Char] ())
                           (Data.Either.Either [GHC.Types.Char] (f_abgO ()))
                         -> p_abgN [GHC.Types.Char] (f_abgO [GHC.Types.Char])
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 290 0}]
                    f1_abgR
                      = Data.Profunctor.Unsafe.dimap
                          @p_abgN
                          (Data.Profunctor.Choice.$p1Choice @p_abgN $dChoice_abgP)
                          @[GHC.Types.Char]
                          @(Data.Either.Either [GHC.Types.Char] ())
                          @(Data.Either.Either [GHC.Types.Char] (f_abgO ()))
                          @(f_abgO [GHC.Types.Char])
                          (\ (s_abgS :: [GHC.Types.Char]) ->
                             case s_abgS of wild_abgT {
                               [] -> Data.Either.Right @[GHC.Types.Char] @() GHC.Tuple.Prim.();
                               : ds1_abgU ds2_abgV ->
                                 Data.Either.Left @[GHC.Types.Char] @() wild_abgT
                             })
                          (let {
                             f2_abgX :: [GHC.Types.Char] -> f_abgO [GHC.Types.Char]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abgX
                               = GHC.Base.pure @f_abgO $dApplicative_abgQ @[GHC.Types.Char] } in
                           let {
                             ds2_abgY :: f_abgO () -> f_abgO [GHC.Types.Char]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 70 0}]
                             ds2_abgY
                               = GHC.Base.fmap
                                   @f_abgO
                                   (GHC.Base.$p1Applicative @f_abgO $dApplicative_abgQ)
                                   @()
                                   @[GHC.Types.Char]
                                   (\ (ds3_abgZ :: ()) ->
                                      case ds3_abgZ of { () -> GHC.Types.[] @GHC.Types.Char }) } in
                           \ (ds3_abh1 :: Data.Either.Either [GHC.Types.Char] (f_abgO ())) ->
                             case ds3_abh1 of {
                               Data.Either.Left x_abh3 -> f2_abgX x_abh3;
                               Data.Either.Right y_abh5 -> ds2_abgY y_abh5
                             }) } in
                  let {
                    g_abh7
                      :: p_abgN () (f_abgO ())
                         -> p_abgN
                              (Data.Either.Either [GHC.Types.Char] ())
                              (Data.Either.Either [GHC.Types.Char] (f_abgO ()))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abh7
                      = Data.Profunctor.Choice.right'
                          @p_abgN $dChoice_abgP @() @(f_abgO ()) @[GHC.Types.Char] } in
                  \ (x_abh8 :: p_abgN () (f_abgO ())) -> f1_abgR (g_abh7 x_abh8))
               `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0] <[GHC.Types.Char]>_N)
                       :: Control.Lens.Type.Prism' [GHC.Types.Char] ()
                          ~R# Control.Lens.Empty.AsEmpty [GHC.Types.Char]))
              (Data.Functor.Contravariant.$fContravariantConst @[GHC.Types.Char])
              (Data.Functor.Const.$fFunctorConst @[GHC.Types.Char])
    Cont:   ApplyToVal nodup hole Control.Lens.Getter.Getting
                                    GHC.Base.String Data.Text.Internal.Text GHC.Base.String
              ((\ (ds_abeK [Occ=Once1] :: a_abeH) -> ds_abeK)
               `cast` (<a_abeH>_R
                       %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                          <*>_N <a_abeH>_R <a_abeH>_P)
                       :: (a_abeH -> a_abeH)
                          ~R# (a_abeH -> Data.Functor.Const.Const a_abeH a_abeH)))
            ApplyToVal nodup hole Data.Text.Internal.Text
                                  -> Data.Functor.Const.Const
                                       GHC.Base.String Data.Text.Internal.Text
              (Control.Lens.Getter.view
                 @[GHC.Types.Char]
                 @((->) GHC.Base.String)
                 @Data.Text.Internal.Text
                 (Control.Monad.Reader.Class.$fMonadReaderrFUN @[GHC.Types.Char])
                 (Control.Lens.Cons.Extras.recons
                    @[GHC.Types.Char]
                    @GHC.Types.Char
                    @Data.Text.Internal.Text
                    (Control.Lens.Cons.$fConsListListab
                       @GHC.Types.Char @GHC.Types.Char)
                    Control.Lens.Cons.$fConsTextTextCharChar0
                    Control.Lens.Empty.$fAsEmptyText0
                    @(Data.Functor.Const.Const Data.Text.Internal.Text)
                    (Data.Functor.Contravariant.$fContravariantConst
                       @Data.Text.Internal.Text)
                    (Data.Functor.Const.$fFunctorConst @Data.Text.Internal.Text))
                 s_a8Pu)
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N <GHC.Base.String>_R <Data.Text.Internal.Text>_P
                    :: Data.Functor.Const.Const GHC.Base.String Data.Text.Internal.Text
                       ~R# GHC.Base.String)
            Stop[RuleArgCtxt] GHC.Base.String
Rule fired
    Rule: Class op fmap
    Module: (BUILTIN)
    Before: GHC.Base.fmap
              TyArg Data.Functor.Const.Const GHC.Base.String
              ValArg Data.Functor.Const.$fFunctorConst @[GHC.Types.Char]
    After:  (Data.Functor.Const.$fFunctorConst2 @[GHC.Types.Char])
            `cast` (forall (a :: <*>_N) (b :: <*>_N).
                    <a -> b>_R
                    %<'GHC.Types.Many>_N ->_R <Data.Functor.Const.Const
                                                 [GHC.Types.Char] a>_R
                    %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                  <*>_N <[GHC.Types.Char]>_R <a>_P
                                              ; Sym (Data.Functor.Const.N:Const[0]
                                                         <*>_N <[GHC.Types.Char]>_R <b>_P)
                    :: (forall {a} {b}.
                        (a -> b)
                        -> Data.Functor.Const.Const [GHC.Types.Char] a
                        -> Data.Functor.Const.Const [GHC.Types.Char] a)
                       ~R# (forall {a} {b}.
                            (a -> b)
                            -> Data.Functor.Const.Const [GHC.Types.Char] a
                            -> Data.Functor.Const.Const [GHC.Types.Char] b))
    Cont:   ApplyToTy GHC.Base.String
            ApplyToTy Data.Text.Internal.Text
            ApplyToVal nodup hole (GHC.Base.String -> Data.Text.Internal.Text)
                                  -> Data.Functor.Const.Const GHC.Base.String GHC.Base.String
                                  -> Data.Functor.Const.Const
                                       GHC.Base.String Data.Text.Internal.Text
              Data.Text.Internal.pack
            ApplyToVal nodup hole Data.Functor.Const.Const
                                    GHC.Base.String GHC.Base.String
                                  -> Data.Functor.Const.Const
                                       GHC.Base.String Data.Text.Internal.Text
              (bc_aboH (ab_aboF x_aboI))
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N <GHC.Base.String>_R <Data.Text.Internal.Text>_P
                    :: Data.Functor.Const.Const GHC.Base.String Data.Text.Internal.Text
                       ~R# GHC.Base.String)
            Stop[RuleArgCtxt] GHC.Base.String
Rule fired
    Rule: Class op reader
    Module: (BUILTIN)
    Before: Control.Monad.Reader.Class.reader
              TyArg [GHC.Types.Char]
              TyArg (->) GHC.Base.String
              ValArg Control.Monad.Reader.Class.$fMonadReaderrFUN
                       @[GHC.Types.Char]
    After:  \ (@a_abeP) -> GHC.Base.id @([GHC.Types.Char] -> a_abeP)
    Cont:   ApplyToTy Data.Text.Internal.Text
            ApplyToVal nodup hole ([GHC.Types.Char] -> Data.Text.Internal.Text)
                                  -> GHC.Base.String -> Data.Text.Internal.Text
              ((l_abeJ
                  ((\ (ds_abeK [Occ=Once1] :: a_abeH) -> ds_abeK)
                   `cast` (<a_abeH>_R
                           %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                              <*>_N <a_abeH>_R <a_abeH>_P)
                           :: (a_abeH -> a_abeH)
                              ~R# (a_abeH -> Data.Functor.Const.Const a_abeH a_abeH))))
               `cast` (<s_abeF>_R
                       %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                     <*>_N <a_abeH>_R <s_abeF>_P
                       :: (s_abeF -> Data.Functor.Const.Const a_abeH s_abeF)
                          ~R# (s_abeF -> a_abeH)))
            ApplyToVal nodup hole GHC.Base.String -> Data.Text.Internal.Text
              s_a8Pu
            Stop[RuleArgCtxt, !P(L,L,L)] Data.Text.Internal.Text
Rule fired
    Rule: recons/string-text
    Module: (Control.Lens.Cons.Extras)
    Before: Control.Lens.Cons.Extras.recons
              TyArg [GHC.Types.Char]
              TyArg GHC.Types.Char
              TyArg Data.Text.Internal.Text
              ValArg (\ (@(p_abgg :: * -> * -> *))
                        (@(f_abgh :: * -> *))
                        ($dChoice_abgi :: Data.Profunctor.Choice.Choice p_abgg)
                        ($dApplicative_abgj :: GHC.Base.Applicative f_abgh) ->
                        let {
                          f1_abgk
                            :: p_abgg
                                 (Data.Either.Either
                                    [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                                 (Data.Either.Either
                                    [GHC.Types.Char] (f_abgh (GHC.Types.Char, [GHC.Types.Char])))
                               -> p_abgg [GHC.Types.Char] (f_abgh [GHC.Types.Char])
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 320 0}]
                          f1_abgk
                            = Data.Profunctor.Unsafe.dimap
                                @p_abgg
                                (Data.Profunctor.Choice.$p1Choice @p_abgg $dChoice_abgi)
                                @[GHC.Types.Char]
                                @(Data.Either.Either
                                    [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                                @(Data.Either.Either
                                    [GHC.Types.Char] (f_abgh (GHC.Types.Char, [GHC.Types.Char])))
                                @(f_abgh [GHC.Types.Char])
                                (\ (aas_abgl :: [GHC.Types.Char]) ->
                                   case aas_abgl of {
                                     [] ->
                                       Data.Either.Left
                                         @[GHC.Types.Char]
                                         @(GHC.Types.Char, [GHC.Types.Char])
                                         (GHC.Types.[] @GHC.Types.Char);
                                     : a1_abgn as_abgo ->
                                       Data.Either.Right
                                         @[GHC.Types.Char]
                                         @(GHC.Types.Char, [GHC.Types.Char])
                                         (a1_abgn, as_abgo)
                                   })
                                (let {
                                   f2_abgq :: [GHC.Types.Char] -> f_abgh [GHC.Types.Char]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abgq
                                     = GHC.Base.pure
                                         @f_abgh $dApplicative_abgj @[GHC.Types.Char] } in
                                 let {
                                   ds2_abgr
                                     :: f_abgh (GHC.Types.Char, [GHC.Types.Char])
                                        -> f_abgh [GHC.Types.Char]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 90 0}]
                                   ds2_abgr
                                     = GHC.Base.fmap
                                         @f_abgh
                                         (GHC.Base.$p1Applicative @f_abgh $dApplicative_abgj)
                                         @(GHC.Types.Char, [GHC.Types.Char])
                                         @[GHC.Types.Char]
                                         (\ (p1_abgs :: (GHC.Types.Char, [GHC.Types.Char])) ->
                                            GHC.Types.:
                                              @GHC.Types.Char
                                              (case p1_abgs of { (x_abgu, ds_abgv) -> x_abgu })
                                              (case p1_abgs of { (ds_abgy, y_abgz) ->
                                               y_abgz
                                               })) } in
                                 \ (ds3_abgB
                                      :: Data.Either.Either
                                           [GHC.Types.Char]
                                           (f_abgh (GHC.Types.Char, [GHC.Types.Char]))) ->
                                   case ds3_abgB of {
                                     Data.Either.Left x_abgD -> f2_abgq x_abgD;
                                     Data.Either.Right y_abgF -> ds2_abgr y_abgF
                                   }) } in
                        let {
                          g_abgH
                            :: p_abgg
                                 (GHC.Types.Char, [GHC.Types.Char])
                                 (f_abgh (GHC.Types.Char, [GHC.Types.Char]))
                               -> p_abgg
                                    (Data.Either.Either
                                       [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                                    (Data.Either.Either
                                       [GHC.Types.Char] (f_abgh (GHC.Types.Char, [GHC.Types.Char])))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abgH
                            = Data.Profunctor.Choice.right'
                                @p_abgg
                                $dChoice_abgi
                                @(GHC.Types.Char, [GHC.Types.Char])
                                @(f_abgh (GHC.Types.Char, [GHC.Types.Char]))
                                @[GHC.Types.Char] } in
                        \ (x_abgI
                             :: p_abgg
                                  (GHC.Types.Char, [GHC.Types.Char])
                                  (f_abgh (GHC.Types.Char, [GHC.Types.Char]))) ->
                          f1_abgk (g_abgH x_abgI))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <[GHC.Types.Char]>_N
                                      <[GHC.Types.Char]>_N
                                      <GHC.Types.Char>_N
                                      <GHC.Types.Char>_N)
                             :: Control.Lens.Type.Prism
                                  [GHC.Types.Char]
                                  [GHC.Types.Char]
                                  (GHC.Types.Char, [GHC.Types.Char])
                                  (GHC.Types.Char, [GHC.Types.Char])
                                ~R# Control.Lens.Cons.Cons
                                      [GHC.Types.Char]
                                      [GHC.Types.Char]
                                      GHC.Types.Char
                                      GHC.Types.Char)
              ValArg (\ (@(p_abig :: * -> * -> *))
                        (@(f_abih :: * -> *))
                        ($dChoice_abii :: Data.Profunctor.Choice.Choice p_abig)
                        ($dApplicative_abij :: GHC.Base.Applicative f_abih) ->
                        let {
                          f1_abik
                            :: p_abig
                                 (Data.Either.Either
                                    Data.Text.Internal.Text
                                    (GHC.Types.Char, Data.Text.Internal.Text))
                                 (Data.Either.Either
                                    Data.Text.Internal.Text
                                    (f_abih (GHC.Types.Char, Data.Text.Internal.Text)))
                               -> p_abig Data.Text.Internal.Text (f_abih Data.Text.Internal.Text)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 340 0}]
                          f1_abik
                            = Data.Profunctor.Unsafe.dimap
                                @p_abig
                                (Data.Profunctor.Choice.$p1Choice @p_abig $dChoice_abii)
                                @Data.Text.Internal.Text
                                @(Data.Either.Either
                                    Data.Text.Internal.Text
                                    (GHC.Types.Char, Data.Text.Internal.Text))
                                @(Data.Either.Either
                                    Data.Text.Internal.Text
                                    (f_abih (GHC.Types.Char, Data.Text.Internal.Text)))
                                @(f_abih Data.Text.Internal.Text)
                                (\ (s1_abil :: Data.Text.Internal.Text) ->
                                   case Data.Text.uncons s1_abil of {
                                     GHC.Maybe.Nothing ->
                                       Data.Either.Left
                                         @Data.Text.Internal.Text
                                         @(GHC.Types.Char, Data.Text.Internal.Text)
                                         s1_abil;
                                     GHC.Maybe.Just x_abio ->
                                       Data.Either.Right
                                         @Data.Text.Internal.Text
                                         @(GHC.Types.Char, Data.Text.Internal.Text)
                                         x_abio
                                   })
                                (let {
                                   f2_abiq
                                     :: Data.Text.Internal.Text -> f_abih Data.Text.Internal.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abiq
                                     = GHC.Base.pure
                                         @f_abih $dApplicative_abij @Data.Text.Internal.Text } in
                                 let {
                                   ds2_abir
                                     :: f_abih (GHC.Types.Char, Data.Text.Internal.Text)
                                        -> f_abih Data.Text.Internal.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 100 0}]
                                   ds2_abir
                                     = GHC.Base.fmap
                                         @f_abih
                                         (GHC.Base.$p1Applicative @f_abih $dApplicative_abij)
                                         @(GHC.Types.Char, Data.Text.Internal.Text)
                                         @Data.Text.Internal.Text
                                         (\ (p1_abis
                                               :: (GHC.Types.Char, Data.Text.Internal.Text)) ->
                                            case p1_abis of { (x_abiu, ds_abiv) ->
                                            Data.Text.cons x_abiu ds_abiv
                                            }) } in
                                 \ (ds3_abix
                                      :: Data.Either.Either
                                           Data.Text.Internal.Text
                                           (f_abih (GHC.Types.Char, Data.Text.Internal.Text))) ->
                                   case ds3_abix of {
                                     Data.Either.Left x_abiz -> f2_abiq x_abiz;
                                     Data.Either.Right y_abiB -> ds2_abir y_abiB
                                   }) } in
                        let {
                          g_abiD
                            :: p_abig
                                 (GHC.Types.Char, Data.Text.Internal.Text)
                                 (f_abih (GHC.Types.Char, Data.Text.Internal.Text))
                               -> p_abig
                                    (Data.Either.Either
                                       Data.Text.Internal.Text
                                       (GHC.Types.Char, Data.Text.Internal.Text))
                                    (Data.Either.Either
                                       Data.Text.Internal.Text
                                       (f_abih (GHC.Types.Char, Data.Text.Internal.Text)))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abiD
                            = Data.Profunctor.Choice.right'
                                @p_abig
                                $dChoice_abii
                                @(GHC.Types.Char, Data.Text.Internal.Text)
                                @(f_abih (GHC.Types.Char, Data.Text.Internal.Text))
                                @Data.Text.Internal.Text } in
                        \ (x_abiE
                             :: p_abig
                                  (GHC.Types.Char, Data.Text.Internal.Text)
                                  (f_abih (GHC.Types.Char, Data.Text.Internal.Text))) ->
                          f1_abik (g_abiD x_abiE))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <Data.Text.Internal.Text>_N
                                      <Data.Text.Internal.Text>_N
                                      <GHC.Types.Char>_N
                                      <GHC.Types.Char>_N)
                             :: Control.Lens.Type.Prism
                                  Data.Text.Internal.Text
                                  Data.Text.Internal.Text
                                  (GHC.Types.Char, Data.Text.Internal.Text)
                                  (GHC.Types.Char, Data.Text.Internal.Text)
                                ~R# Control.Lens.Cons.Cons
                                      Data.Text.Internal.Text
                                      Data.Text.Internal.Text
                                      GHC.Types.Char
                                      GHC.Types.Char)
              ValArg (\ (@(p_abiF :: * -> * -> *))
                        (@(f_abiG :: * -> *))
                        ($dChoice_abiH :: Data.Profunctor.Choice.Choice p_abiF)
                        ($dApplicative_abiI :: GHC.Base.Applicative f_abiG) ->
                        let {
                          f1_abiJ
                            :: p_abiF
                                 (Data.Either.Either Data.Text.Internal.Text ())
                                 (Data.Either.Either Data.Text.Internal.Text (f_abiG ()))
                               -> p_abiF Data.Text.Internal.Text (f_abiG Data.Text.Internal.Text)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 310 0}]
                          f1_abiJ
                            = Data.Profunctor.Unsafe.dimap
                                @p_abiF
                                (Data.Profunctor.Choice.$p1Choice @p_abiF $dChoice_abiH)
                                @Data.Text.Internal.Text
                                @(Data.Either.Either Data.Text.Internal.Text ())
                                @(Data.Either.Either Data.Text.Internal.Text (f_abiG ()))
                                @(f_abiG Data.Text.Internal.Text)
                                (\ (s_abiK :: Data.Text.Internal.Text) ->
                                   case Data.Text.null s_abiK of {
                                     GHC.Types.False ->
                                       Data.Either.Left @Data.Text.Internal.Text @() s_abiK;
                                     GHC.Types.True ->
                                       Data.Either.Right
                                         @Data.Text.Internal.Text @() GHC.Tuple.Prim.()
                                   })
                                (let {
                                   f2_abiN
                                     :: Data.Text.Internal.Text -> f_abiG Data.Text.Internal.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abiN
                                     = GHC.Base.pure
                                         @f_abiG $dApplicative_abiI @Data.Text.Internal.Text } in
                                 let {
                                   ds2_abiO :: f_abiG () -> f_abiG Data.Text.Internal.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 70 0}]
                                   ds2_abiO
                                     = GHC.Base.fmap
                                         @f_abiG
                                         (GHC.Base.$p1Applicative @f_abiG $dApplicative_abiI)
                                         @()
                                         @Data.Text.Internal.Text
                                         (\ (ds3_abiP :: ()) ->
                                            case ds3_abiP of { () ->
                                            Data.Text.Internal.empty
                                            }) } in
                                 \ (ds3_abiR
                                      :: Data.Either.Either Data.Text.Internal.Text (f_abiG ())) ->
                                   case ds3_abiR of {
                                     Data.Either.Left x_abiT -> f2_abiN x_abiT;
                                     Data.Either.Right y_abiV -> ds2_abiO y_abiV
                                   }) } in
                        let {
                          g_abiX
                            :: p_abiF () (f_abiG ())
                               -> p_abiF
                                    (Data.Either.Either Data.Text.Internal.Text ())
                                    (Data.Either.Either Data.Text.Internal.Text (f_abiG ()))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abiX
                            = Data.Profunctor.Choice.right'
                                @p_abiF
                                $dChoice_abiH
                                @()
                                @(f_abiG ())
                                @Data.Text.Internal.Text } in
                        \ (x_abiY :: p_abiF () (f_abiG ())) -> f1_abiJ (g_abiX x_abiY))
                     `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                      <Data.Text.Internal.Text>_N)
                             :: Control.Lens.Type.Prism' Data.Text.Internal.Text ()
                                ~R# Control.Lens.Empty.AsEmpty Data.Text.Internal.Text)
              TyArg Data.Functor.Const.Const Data.Text.Internal.Text
              ValArg Data.Functor.Contravariant.$fContravariantConst
                       @Data.Text.Internal.Text
              ValArg Data.Functor.Const.$fFunctorConst @Data.Text.Internal.Text
    After:  (\ (@(f_abfe :: * -> *))
               ($dCons_abff
                  :: Control.Lens.Cons.Cons
                       GHC.Base.String GHC.Base.String GHC.Types.Char GHC.Types.Char)
               ($dCons1_abfg
                  :: Control.Lens.Cons.Cons
                       Data.Text.Internal.Text
                       Data.Text.Internal.Text
                       GHC.Types.Char
                       GHC.Types.Char)
               ($dAsEmpty_abfh
                  :: Control.Lens.Empty.AsEmpty Data.Text.Internal.Text)
               ($dContravariant_abfi
                  :: Data.Functor.Contravariant.Contravariant f_abfe)
               ($dFunctor_abfj :: GHC.Base.Functor f_abfe) ->
               Data.Profunctor.Unsafe.$fProfunctorFUN_$cdimap
                 @GHC.Base.String
                 @Data.Text.Internal.Text
                 @(f_abfe Data.Text.Internal.Text)
                 @(f_abfe GHC.Base.String)
                 Data.Text.Internal.pack
                 (GHC.Base.fmap
                    @f_abfe
                    $dFunctor_abfj
                    @Data.Text.Internal.Text
                    @GHC.Base.String
                    Data.Text.Show.unpack))
              @(Data.Functor.Const.Const Data.Text.Internal.Text)
              ((\ (@(p_abgg :: * -> * -> *))
                  (@(f_abgh :: * -> *))
                  ($dChoice_abgi :: Data.Profunctor.Choice.Choice p_abgg)
                  ($dApplicative_abgj :: GHC.Base.Applicative f_abgh) ->
                  let {
                    f1_abgk
                      :: p_abgg
                           (Data.Either.Either
                              [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                           (Data.Either.Either
                              [GHC.Types.Char] (f_abgh (GHC.Types.Char, [GHC.Types.Char])))
                         -> p_abgg [GHC.Types.Char] (f_abgh [GHC.Types.Char])
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 320 0}]
                    f1_abgk
                      = Data.Profunctor.Unsafe.dimap
                          @p_abgg
                          (Data.Profunctor.Choice.$p1Choice @p_abgg $dChoice_abgi)
                          @[GHC.Types.Char]
                          @(Data.Either.Either
                              [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                          @(Data.Either.Either
                              [GHC.Types.Char] (f_abgh (GHC.Types.Char, [GHC.Types.Char])))
                          @(f_abgh [GHC.Types.Char])
                          (\ (aas_abgl :: [GHC.Types.Char]) ->
                             case aas_abgl of {
                               [] ->
                                 Data.Either.Left
                                   @[GHC.Types.Char]
                                   @(GHC.Types.Char, [GHC.Types.Char])
                                   (GHC.Types.[] @GHC.Types.Char);
                               : a1_abgn as_abgo ->
                                 Data.Either.Right
                                   @[GHC.Types.Char]
                                   @(GHC.Types.Char, [GHC.Types.Char])
                                   (a1_abgn, as_abgo)
                             })
                          (let {
                             f2_abgq :: [GHC.Types.Char] -> f_abgh [GHC.Types.Char]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abgq
                               = GHC.Base.pure @f_abgh $dApplicative_abgj @[GHC.Types.Char] } in
                           let {
                             ds2_abgr
                               :: f_abgh (GHC.Types.Char, [GHC.Types.Char])
                                  -> f_abgh [GHC.Types.Char]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 90 0}]
                             ds2_abgr
                               = GHC.Base.fmap
                                   @f_abgh
                                   (GHC.Base.$p1Applicative @f_abgh $dApplicative_abgj)
                                   @(GHC.Types.Char, [GHC.Types.Char])
                                   @[GHC.Types.Char]
                                   (\ (p1_abgs :: (GHC.Types.Char, [GHC.Types.Char])) ->
                                      GHC.Types.:
                                        @GHC.Types.Char
                                        (case p1_abgs of { (x_abgu, ds_abgv) -> x_abgu })
                                        (case p1_abgs of { (ds_abgy, y_abgz) -> y_abgz })) } in
                           \ (ds3_abgB
                                :: Data.Either.Either
                                     [GHC.Types.Char]
                                     (f_abgh (GHC.Types.Char, [GHC.Types.Char]))) ->
                             case ds3_abgB of {
                               Data.Either.Left x_abgD -> f2_abgq x_abgD;
                               Data.Either.Right y_abgF -> ds2_abgr y_abgF
                             }) } in
                  let {
                    g_abgH
                      :: p_abgg
                           (GHC.Types.Char, [GHC.Types.Char])
                           (f_abgh (GHC.Types.Char, [GHC.Types.Char]))
                         -> p_abgg
                              (Data.Either.Either
                                 [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                              (Data.Either.Either
                                 [GHC.Types.Char] (f_abgh (GHC.Types.Char, [GHC.Types.Char])))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abgH
                      = Data.Profunctor.Choice.right'
                          @p_abgg
                          $dChoice_abgi
                          @(GHC.Types.Char, [GHC.Types.Char])
                          @(f_abgh (GHC.Types.Char, [GHC.Types.Char]))
                          @[GHC.Types.Char] } in
                  \ (x_abgI
                       :: p_abgg
                            (GHC.Types.Char, [GHC.Types.Char])
                            (f_abgh (GHC.Types.Char, [GHC.Types.Char]))) ->
                    f1_abgk (g_abgH x_abgI))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <[GHC.Types.Char]>_N
                                <[GHC.Types.Char]>_N
                                <GHC.Types.Char>_N
                                <GHC.Types.Char>_N)
                       :: Control.Lens.Type.Prism
                            [GHC.Types.Char]
                            [GHC.Types.Char]
                            (GHC.Types.Char, [GHC.Types.Char])
                            (GHC.Types.Char, [GHC.Types.Char])
                          ~R# Control.Lens.Cons.Cons
                                [GHC.Types.Char] [GHC.Types.Char] GHC.Types.Char GHC.Types.Char))
              ((\ (@(p_abig :: * -> * -> *))
                  (@(f_abih :: * -> *))
                  ($dChoice_abii :: Data.Profunctor.Choice.Choice p_abig)
                  ($dApplicative_abij :: GHC.Base.Applicative f_abih) ->
                  let {
                    f1_abik
                      :: p_abig
                           (Data.Either.Either
                              Data.Text.Internal.Text (GHC.Types.Char, Data.Text.Internal.Text))
                           (Data.Either.Either
                              Data.Text.Internal.Text
                              (f_abih (GHC.Types.Char, Data.Text.Internal.Text)))
                         -> p_abig Data.Text.Internal.Text (f_abih Data.Text.Internal.Text)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 340 0}]
                    f1_abik
                      = Data.Profunctor.Unsafe.dimap
                          @p_abig
                          (Data.Profunctor.Choice.$p1Choice @p_abig $dChoice_abii)
                          @Data.Text.Internal.Text
                          @(Data.Either.Either
                              Data.Text.Internal.Text (GHC.Types.Char, Data.Text.Internal.Text))
                          @(Data.Either.Either
                              Data.Text.Internal.Text
                              (f_abih (GHC.Types.Char, Data.Text.Internal.Text)))
                          @(f_abih Data.Text.Internal.Text)
                          (\ (s1_abil :: Data.Text.Internal.Text) ->
                             case Data.Text.uncons s1_abil of {
                               GHC.Maybe.Nothing ->
                                 Data.Either.Left
                                   @Data.Text.Internal.Text
                                   @(GHC.Types.Char, Data.Text.Internal.Text)
                                   s1_abil;
                               GHC.Maybe.Just x_abio ->
                                 Data.Either.Right
                                   @Data.Text.Internal.Text
                                   @(GHC.Types.Char, Data.Text.Internal.Text)
                                   x_abio
                             })
                          (let {
                             f2_abiq
                               :: Data.Text.Internal.Text -> f_abih Data.Text.Internal.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abiq
                               = GHC.Base.pure
                                   @f_abih $dApplicative_abij @Data.Text.Internal.Text } in
                           let {
                             ds2_abir
                               :: f_abih (GHC.Types.Char, Data.Text.Internal.Text)
                                  -> f_abih Data.Text.Internal.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 100 0}]
                             ds2_abir
                               = GHC.Base.fmap
                                   @f_abih
                                   (GHC.Base.$p1Applicative @f_abih $dApplicative_abij)
                                   @(GHC.Types.Char, Data.Text.Internal.Text)
                                   @Data.Text.Internal.Text
                                   (\ (p1_abis :: (GHC.Types.Char, Data.Text.Internal.Text)) ->
                                      case p1_abis of { (x_abiu, ds_abiv) ->
                                      Data.Text.cons x_abiu ds_abiv
                                      }) } in
                           \ (ds3_abix
                                :: Data.Either.Either
                                     Data.Text.Internal.Text
                                     (f_abih (GHC.Types.Char, Data.Text.Internal.Text))) ->
                             case ds3_abix of {
                               Data.Either.Left x_abiz -> f2_abiq x_abiz;
                               Data.Either.Right y_abiB -> ds2_abir y_abiB
                             }) } in
                  let {
                    g_abiD
                      :: p_abig
                           (GHC.Types.Char, Data.Text.Internal.Text)
                           (f_abih (GHC.Types.Char, Data.Text.Internal.Text))
                         -> p_abig
                              (Data.Either.Either
                                 Data.Text.Internal.Text (GHC.Types.Char, Data.Text.Internal.Text))
                              (Data.Either.Either
                                 Data.Text.Internal.Text
                                 (f_abih (GHC.Types.Char, Data.Text.Internal.Text)))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abiD
                      = Data.Profunctor.Choice.right'
                          @p_abig
                          $dChoice_abii
                          @(GHC.Types.Char, Data.Text.Internal.Text)
                          @(f_abih (GHC.Types.Char, Data.Text.Internal.Text))
                          @Data.Text.Internal.Text } in
                  \ (x_abiE
                       :: p_abig
                            (GHC.Types.Char, Data.Text.Internal.Text)
                            (f_abih (GHC.Types.Char, Data.Text.Internal.Text))) ->
                    f1_abik (g_abiD x_abiE))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <Data.Text.Internal.Text>_N
                                <Data.Text.Internal.Text>_N
                                <GHC.Types.Char>_N
                                <GHC.Types.Char>_N)
                       :: Control.Lens.Type.Prism
                            Data.Text.Internal.Text
                            Data.Text.Internal.Text
                            (GHC.Types.Char, Data.Text.Internal.Text)
                            (GHC.Types.Char, Data.Text.Internal.Text)
                          ~R# Control.Lens.Cons.Cons
                                Data.Text.Internal.Text
                                Data.Text.Internal.Text
                                GHC.Types.Char
                                GHC.Types.Char))
              ((\ (@(p_abiF :: * -> * -> *))
                  (@(f_abiG :: * -> *))
                  ($dChoice_abiH :: Data.Profunctor.Choice.Choice p_abiF)
                  ($dApplicative_abiI :: GHC.Base.Applicative f_abiG) ->
                  let {
                    f1_abiJ
                      :: p_abiF
                           (Data.Either.Either Data.Text.Internal.Text ())
                           (Data.Either.Either Data.Text.Internal.Text (f_abiG ()))
                         -> p_abiF Data.Text.Internal.Text (f_abiG Data.Text.Internal.Text)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 310 0}]
                    f1_abiJ
                      = Data.Profunctor.Unsafe.dimap
                          @p_abiF
                          (Data.Profunctor.Choice.$p1Choice @p_abiF $dChoice_abiH)
                          @Data.Text.Internal.Text
                          @(Data.Either.Either Data.Text.Internal.Text ())
                          @(Data.Either.Either Data.Text.Internal.Text (f_abiG ()))
                          @(f_abiG Data.Text.Internal.Text)
                          (\ (s_abiK :: Data.Text.Internal.Text) ->
                             case Data.Text.null s_abiK of {
                               GHC.Types.False ->
                                 Data.Either.Left @Data.Text.Internal.Text @() s_abiK;
                               GHC.Types.True ->
                                 Data.Either.Right @Data.Text.Internal.Text @() GHC.Tuple.Prim.()
                             })
                          (let {
                             f2_abiN
                               :: Data.Text.Internal.Text -> f_abiG Data.Text.Internal.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abiN
                               = GHC.Base.pure
                                   @f_abiG $dApplicative_abiI @Data.Text.Internal.Text } in
                           let {
                             ds2_abiO :: f_abiG () -> f_abiG Data.Text.Internal.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 70 0}]
                             ds2_abiO
                               = GHC.Base.fmap
                                   @f_abiG
                                   (GHC.Base.$p1Applicative @f_abiG $dApplicative_abiI)
                                   @()
                                   @Data.Text.Internal.Text
                                   (\ (ds3_abiP :: ()) ->
                                      case ds3_abiP of { () -> Data.Text.Internal.empty }) } in
                           \ (ds3_abiR
                                :: Data.Either.Either Data.Text.Internal.Text (f_abiG ())) ->
                             case ds3_abiR of {
                               Data.Either.Left x_abiT -> f2_abiN x_abiT;
                               Data.Either.Right y_abiV -> ds2_abiO y_abiV
                             }) } in
                  let {
                    g_abiX
                      :: p_abiF () (f_abiG ())
                         -> p_abiF
                              (Data.Either.Either Data.Text.Internal.Text ())
                              (Data.Either.Either Data.Text.Internal.Text (f_abiG ()))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abiX
                      = Data.Profunctor.Choice.right'
                          @p_abiF
                          $dChoice_abiH
                          @()
                          @(f_abiG ())
                          @Data.Text.Internal.Text } in
                  \ (x_abiY :: p_abiF () (f_abiG ())) -> f1_abiJ (g_abiX x_abiY))
               `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                <Data.Text.Internal.Text>_N)
                       :: Control.Lens.Type.Prism' Data.Text.Internal.Text ()
                          ~R# Control.Lens.Empty.AsEmpty Data.Text.Internal.Text))
              (Data.Functor.Contravariant.$fContravariantConst
                 @Data.Text.Internal.Text)
              (Data.Functor.Const.$fFunctorConst @Data.Text.Internal.Text)
    Cont:   ApplyToVal nodup hole Control.Lens.Getter.Getting
                                    Data.Text.Internal.Text [GHC.Types.Char] Data.Text.Internal.Text
              ((\ (ds_abeK [Occ=Once1] :: a_abeH) -> ds_abeK)
               `cast` (<a_abeH>_R
                       %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                          <*>_N <a_abeH>_R <a_abeH>_P)
                       :: (a_abeH -> a_abeH)
                          ~R# (a_abeH -> Data.Functor.Const.Const a_abeH a_abeH)))
            ApplyToVal nodup hole [GHC.Types.Char]
                                  -> Data.Functor.Const.Const
                                       Data.Text.Internal.Text [GHC.Types.Char]
              s_a8Pu
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N <Data.Text.Internal.Text>_R <[GHC.Types.Char]>_P
                    :: Data.Functor.Const.Const
                         Data.Text.Internal.Text [GHC.Types.Char]
                       ~R# Data.Text.Internal.Text)
            Stop[RuleArgCtxt, !P(L,L,L)] Data.Text.Internal.Text
Rule fired
    Rule: Class op fmap
    Module: (BUILTIN)
    Before: GHC.Base.fmap
              TyArg Data.Functor.Const.Const Data.Text.Internal.Text
              ValArg Data.Functor.Const.$fFunctorConst @Data.Text.Internal.Text
    After:  (Data.Functor.Const.$fFunctorConst2
               @Data.Text.Internal.Text)
            `cast` (forall (a :: <*>_N) (b :: <*>_N).
                    <a -> b>_R
                    %<'GHC.Types.Many>_N ->_R <Data.Functor.Const.Const
                                                 Data.Text.Internal.Text a>_R
                    %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                  <*>_N <Data.Text.Internal.Text>_R <a>_P
                                              ; Sym (Data.Functor.Const.N:Const[0]
                                                         <*>_N <Data.Text.Internal.Text>_R <b>_P)
                    :: (forall {a} {b}.
                        (a -> b)
                        -> Data.Functor.Const.Const Data.Text.Internal.Text a
                        -> Data.Functor.Const.Const Data.Text.Internal.Text a)
                       ~R# (forall {a} {b}.
                            (a -> b)
                            -> Data.Functor.Const.Const Data.Text.Internal.Text a
                            -> Data.Functor.Const.Const Data.Text.Internal.Text b))
    Cont:   ApplyToTy Data.Text.Internal.Text
            ApplyToTy GHC.Base.String
            ApplyToVal nodup hole (Data.Text.Internal.Text -> GHC.Base.String)
                                  -> Data.Functor.Const.Const
                                       Data.Text.Internal.Text Data.Text.Internal.Text
                                  -> Data.Functor.Const.Const
                                       Data.Text.Internal.Text GHC.Base.String
              Data.Text.Show.unpack
            ApplyToVal nodup hole Data.Functor.Const.Const
                                    Data.Text.Internal.Text Data.Text.Internal.Text
                                  -> Data.Functor.Const.Const
                                       Data.Text.Internal.Text GHC.Base.String
              (bc_aboH (ab_aboF x_aboI))
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N <Data.Text.Internal.Text>_R <[GHC.Types.Char]>_P
                    :: Data.Functor.Const.Const
                         Data.Text.Internal.Text [GHC.Types.Char]
                       ~R# Data.Text.Internal.Text)
            Stop[RuleArgCtxt, !P(L,L,L)] Data.Text.Internal.Text
Rule fired
    Rule: eqString
    Module: (GHC.Base)
    Before: GHC.Classes.==
              TyArg GHC.Base.String
              ValArg GHC.Classes.$fEqList_$s$fEqList1
              ValArg Data.Text.Show.unpack (Data.Text.Internal.pack s_a8Pu)
              ValArg s_a8Pu
    After:  (\ ($dEq_ab0v :: GHC.Classes.Eq GHC.Base.String) ->
               GHC.Base.eqString)
              GHC.Classes.$fEqList_$s$fEqList1
              ValArg Data.Text.Show.unpack (Data.Text.Internal.pack s_a8Pu)
              ValArg s_a8Pu
    Cont:   Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: unpack
    Module: (GHC.Base)
    Before: GHC.CString.unpackCString# ValArg "Str -> TL -> Str"#
    After:  (\ (a_ab7z :: GHC.Prim.Addr#) ->
               GHC.Base.build
                 @GHC.Types.Char
                 (\ (@b_ab7A) -> GHC.CString.unpackFoldrCString# @b_ab7A a_ab7z))
              "Str -> TL -> Str"#
    Cont:   Stop[BoringCtxt] Test.Tasty.Core.TestName
Rule fired
    Rule: Class op property
    Module: (BUILTIN)
    Before: Test.QuickCheck.Property.property
              TyArg GHC.Base.String -> GHC.Types.Bool ValArg $dTestable_a92k
    After:  Test.QuickCheck.Property.$fTestableFUN_$cproperty
              @[GHC.Types.Char]
              @GHC.Types.Bool
              $dArbitrary_a9JV
              GHC.Show.$fShowList_$s$fShowList1
              Test.QuickCheck.Property.$fTestableBool
    Cont:   ApplyToVal nodup hole (GHC.Base.String -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              prop_ab7M
            CastIt (Sym (Test.Tasty.QuickCheck.N:QC[0])
                    :: Test.QuickCheck.Property.Property ~R# Test.Tasty.QuickCheck.QC)
            Stop[BoringCtxt] Test.Tasty.QuickCheck.QC
Rule fired
    Rule: Class op propertyForAllShrinkShow
    Module: (BUILTIN)
    Before: Test.QuickCheck.Property.propertyForAllShrinkShow
              TyArg GHC.Types.Bool ValArg Test.QuickCheck.Property.$fTestableBool
    After:  Test.QuickCheck.Property.$fTestableBool1
            `cast` (forall (a :: <*>_N).
                    <Test.QuickCheck.Gen.Gen a>_R
                    %<'GHC.Types.Many>_N ->_R <a -> [a]>_R
                    %<'GHC.Types.Many>_N ->_R <a -> [GHC.Base.String]>_R
                    %<'GHC.Types.Many>_N ->_R <a -> GHC.Types.Bool>_R
                    %<'GHC.Types.Many>_N ->_R Sym (Test.QuickCheck.Gen.N:Gen[0]
                                                       (Test.QuickCheck.Property.N:Prop[0]))
                                              ; Sym (Test.QuickCheck.Property.N:Property[0])
                    :: (forall {a}.
                        Test.QuickCheck.Gen.Gen a
                        -> (a -> [a])
                        -> (a -> [GHC.Base.String])
                        -> (a -> GHC.Types.Bool)
                        -> Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int
                        -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result)
                       ~R# (forall {a}.
                            Test.QuickCheck.Gen.Gen a
                            -> (a -> [a])
                            -> (a -> [GHC.Base.String])
                            -> (a -> GHC.Types.Bool)
                            -> Test.QuickCheck.Property.Property))
    Cont:   ApplyToTy [GHC.Types.Char]
            ApplyToVal nodup hole Test.QuickCheck.Gen.Gen [GHC.Types.Char]
                                  -> ([GHC.Types.Char] -> [[GHC.Types.Char]])
                                  -> ([GHC.Types.Char] -> [GHC.Base.String])
                                  -> ([GHC.Types.Char] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (Test.QuickCheck.Arbitrary.arbitrary @a_ab9u $dArbitrary_ab9w)
            ApplyToVal nodup hole ([GHC.Types.Char] -> [[GHC.Types.Char]])
                                  -> ([GHC.Types.Char] -> [GHC.Base.String])
                                  -> ([GHC.Types.Char] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (Test.QuickCheck.Arbitrary.shrink @a_ab9u $dArbitrary_ab9w)
            ApplyToVal nodup hole ([GHC.Types.Char] -> [GHC.Base.String])
                                  -> ([GHC.Types.Char] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (let {
                 g_ab9A [Occ=OnceL1!] :: a_ab9u -> GHC.Base.String
                 [LclId]
                 g_ab9A = GHC.Show.show @a_ab9u $dShow_ab9x } in
               \ (x_ab9B [Occ=Once1] :: a_ab9u) ->
                 GHC.Types.:
                   @GHC.Base.String (g_ab9A x_ab9B) (GHC.Types.[] @GHC.Base.String))
            ApplyToVal nodup hole ([GHC.Types.Char] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              f_ab9z
            CastIt (Sym (Test.Tasty.QuickCheck.N:QC[0])
                    :: Test.QuickCheck.Property.Property ~R# Test.Tasty.QuickCheck.QC)
            Stop[BoringCtxt] Test.Tasty.QuickCheck.QC
Rule fired
    Rule: Class op arbitrary
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.arbitrary
              TyArg [GHC.Types.Char] ValArg $dArbitrary_a9JV
    After:  (Test.QuickCheck.Arbitrary.$fArbitraryList1
               @GHC.Types.Char Test.QuickCheck.Arbitrary.$fArbitraryChar)
            `cast` (Sym (Test.QuickCheck.Gen.N:Gen[0] <[GHC.Types.Char]>_R)
                    :: (Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int -> [GHC.Types.Char])
                       ~R# Test.QuickCheck.Gen.Gen [GHC.Types.Char])
    Cont:   Stop[BoringCtxt] Test.QuickCheck.Gen.Gen [GHC.Types.Char]
Rule fired
    Rule: Class op arbitrary
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.arbitrary
              TyArg GHC.Types.Char
              ValArg Test.QuickCheck.Arbitrary.$fArbitraryChar
    After:  Test.QuickCheck.Arbitrary.$fArbitraryChar_$carbitrary
    Cont:   Stop[BoringCtxt, C(S,C(1,L))] Test.QuickCheck.Gen.Gen
                                            GHC.Types.Char
Rule fired
    Rule: Class op shrink
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.shrink
              TyArg [GHC.Types.Char] ValArg $dArbitrary_a9JV
    After:  Test.QuickCheck.Arbitrary.$fArbitraryList_$cshrink
              @GHC.Types.Char Test.QuickCheck.Arbitrary.$fArbitraryChar
    Cont:   Stop[BoringCtxt] [GHC.Types.Char] -> [[GHC.Types.Char]]
Rule fired
    Rule: Class op shrink
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.shrink
              TyArg GHC.Types.Char
              ValArg Test.QuickCheck.Arbitrary.$fArbitraryChar
    After:  Test.QuickCheck.Arbitrary.$fArbitraryChar_$cshrink
    Cont:   Stop[DiscArgCtxt, C(S,L)] GHC.Types.Char
                                      -> [GHC.Types.Char]
Rule fired
    Rule: Class op show
    Module: (BUILTIN)
    Before: GHC.Show.show
              TyArg [GHC.Types.Char] ValArg GHC.Show.$fShowList_$s$fShowList1
    After:  GHC.Show.$fShowList_$s$cshow1
    Cont:   Stop[RhsCtxt(NonRecursive)] [GHC.Types.Char]
                                        -> GHC.Base.String
Rule fired
    Rule: Class op reader
    Module: (BUILTIN)
    Before: Control.Monad.Reader.Class.reader
              TyArg Data.Text.Internal.Lazy.Text
              TyArg (->) Data.Text.Internal.Lazy.Text
              ValArg Control.Monad.Reader.Class.$fMonadReaderrFUN
                       @Data.Text.Internal.Lazy.Text
    After:  \ (@a_abeP) ->
              GHC.Base.id @(Data.Text.Internal.Lazy.Text -> a_abeP)
    Cont:   ApplyToTy GHC.Base.String
            ApplyToVal nodup hole (Data.Text.Internal.Lazy.Text
                                   -> GHC.Base.String)
                                  -> Data.Text.Internal.Lazy.Text -> GHC.Base.String
              ((l_abeJ
                  ((\ (ds_abeK [Occ=Once1] :: a_abeH) -> ds_abeK)
                   `cast` (<a_abeH>_R
                           %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                              <*>_N <a_abeH>_R <a_abeH>_P)
                           :: (a_abeH -> a_abeH)
                              ~R# (a_abeH -> Data.Functor.Const.Const a_abeH a_abeH))))
               `cast` (<s_abeF>_R
                       %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                     <*>_N <a_abeH>_R <s_abeF>_P
                       :: (s_abeF -> Data.Functor.Const.Const a_abeH s_abeF)
                          ~R# (s_abeF -> a_abeH)))
            ApplyToVal nodup hole Data.Text.Internal.Lazy.Text
                                  -> GHC.Base.String
              (Control.Lens.Getter.view
                 @[GHC.Types.Char]
                 @((->) GHC.Base.String)
                 @Data.Text.Internal.Lazy.Text
                 (Control.Monad.Reader.Class.$fMonadReaderrFUN @[GHC.Types.Char])
                 (Control.Lens.Cons.Extras.recons
                    @[GHC.Types.Char]
                    @GHC.Types.Char
                    @Data.Text.Internal.Lazy.Text
                    (Control.Lens.Cons.$fConsListListab
                       @GHC.Types.Char @GHC.Types.Char)
                    Control.Lens.Cons.$fConsTextTextCharChar
                    Control.Lens.Empty.$fAsEmptyText
                    @(Data.Functor.Const.Const Data.Text.Internal.Lazy.Text)
                    (Data.Functor.Contravariant.$fContravariantConst
                       @Data.Text.Internal.Lazy.Text)
                    (Data.Functor.Const.$fFunctorConst @Data.Text.Internal.Lazy.Text))
                 s_a8Pv)
            Stop[RuleArgCtxt] GHC.Base.String
Rule fired
    Rule: recons/lazytext-string
    Module: (Control.Lens.Cons.Extras)
    Before: Control.Lens.Cons.Extras.recons
              TyArg Data.Text.Internal.Lazy.Text
              TyArg GHC.Types.Char
              TyArg GHC.Base.String
              ValArg (\ (@(p_abj5 :: * -> * -> *))
                        (@(f_abj6 :: * -> *))
                        ($dChoice_abj7 :: Data.Profunctor.Choice.Choice p_abj5)
                        ($dApplicative_abj8 :: GHC.Base.Applicative f_abj6) ->
                        let {
                          f1_abj9
                            :: p_abj5
                                 (Data.Either.Either
                                    Data.Text.Internal.Lazy.Text
                                    (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                                 (Data.Either.Either
                                    Data.Text.Internal.Lazy.Text
                                    (f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                               -> p_abj5
                                    Data.Text.Internal.Lazy.Text
                                    (f_abj6 Data.Text.Internal.Lazy.Text)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 639 0}]
                          f1_abj9
                            = Data.Profunctor.Unsafe.dimap
                                @p_abj5
                                (Data.Profunctor.Choice.$p1Choice @p_abj5 $dChoice_abj7)
                                @Data.Text.Internal.Lazy.Text
                                @(Data.Either.Either
                                    Data.Text.Internal.Lazy.Text
                                    (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                                @(Data.Either.Either
                                    Data.Text.Internal.Lazy.Text
                                    (f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                                @(f_abj6 Data.Text.Internal.Lazy.Text)
                                (\ (s1_abja :: Data.Text.Internal.Lazy.Text) ->
                                   case s1_abja of {
                                     Data.Text.Internal.Lazy.Empty ->
                                       Data.Either.Left
                                         @Data.Text.Internal.Lazy.Text
                                         @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                         Data.Text.Internal.Lazy.Empty;
                                     Data.Text.Internal.Lazy.Chunk bx_abjh bx1_abji bx2_abjj
                                                                   ts_abjk ->
                                       Data.Either.Right
                                         @Data.Text.Internal.Lazy.Text
                                         @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                         (case GHC.Prim.indexWord8Array# bx_abjh bx1_abji of r#_abjm
                                          { __DEFAULT ->
                                          let {
                                            c#_abjn :: GHC.Prim.Int#
                                            [LclId,
                                             Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                     Value=False, ConLike=False, WorkFree=False,
                                                     Expandable=False,
                                                     Guidance=IF_ARGS [] 4 0}]
                                            c#_abjn
                                              = GHC.Prim.word2Int#
                                                  (GHC.Prim.clz8#
                                                     (GHC.Prim.and#
                                                        (GHC.Prim.not#
                                                           (GHC.Prim.word8ToWord# r#_abjm))
                                                        255##)) } in
                                          case GHC.Prim.xorI# c#_abjn (GHC.Prim.<=# c#_abjn 0#) of {
                                            __DEFAULT ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abjh (GHC.Prim.+# bx1_abji 1#)
                                              of r#1_abjp
                                              { __DEFAULT ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abjh (GHC.Prim.+# bx1_abji 2#)
                                              of r#2_abjq
                                              { __DEFAULT ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abjh (GHC.Prim.+# bx1_abji 3#)
                                              of r#3_abjr
                                              { __DEFAULT ->
                                              GHC.Types.C#
                                                (GHC.Prim.chr#
                                                   (GHC.Prim.-#
                                                      (GHC.Prim.+#
                                                         (GHC.Prim.+#
                                                            (GHC.Prim.+#
                                                               (GHC.Prim.uncheckedIShiftL#
                                                                  (GHC.Prim.-#
                                                                     (GHC.Prim.word2Int#
                                                                        (GHC.Prim.word8ToWord#
                                                                           r#_abjm))
                                                                     240#)
                                                                  18#)
                                                               (GHC.Prim.uncheckedIShiftL#
                                                                  (GHC.Prim.-#
                                                                     (GHC.Prim.word2Int#
                                                                        (GHC.Prim.word8ToWord#
                                                                           r#1_abjp))
                                                                     128#)
                                                                  12#))
                                                            (GHC.Prim.uncheckedIShiftL#
                                                               (GHC.Prim.-#
                                                                  (GHC.Prim.word2Int#
                                                                     (GHC.Prim.word8ToWord#
                                                                        r#2_abjq))
                                                                  128#)
                                                               6#))
                                                         (GHC.Prim.word2Int#
                                                            (GHC.Prim.word8ToWord# r#3_abjr)))
                                                      128#))
                                              }
                                              }
                                              };
                                            1# ->
                                              GHC.Types.C#
                                                (GHC.Prim.chr#
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.word8ToWord# r#_abjm)));
                                            2# ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abjh (GHC.Prim.+# bx1_abji 1#)
                                              of r#1_abjs
                                              { __DEFAULT ->
                                              GHC.Types.C#
                                                (GHC.Prim.chr#
                                                   (GHC.Prim.-#
                                                      (GHC.Prim.+#
                                                         (GHC.Prim.uncheckedIShiftL#
                                                            (GHC.Prim.-#
                                                               (GHC.Prim.word2Int#
                                                                  (GHC.Prim.word8ToWord# r#_abjm))
                                                               192#)
                                                            6#)
                                                         (GHC.Prim.word2Int#
                                                            (GHC.Prim.word8ToWord# r#1_abjs)))
                                                      128#))
                                              };
                                            3# ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abjh (GHC.Prim.+# bx1_abji 1#)
                                              of r#1_abjt
                                              { __DEFAULT ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abjh (GHC.Prim.+# bx1_abji 2#)
                                              of r#2_abju
                                              { __DEFAULT ->
                                              GHC.Types.C#
                                                (GHC.Prim.chr#
                                                   (GHC.Prim.-#
                                                      (GHC.Prim.+#
                                                         (GHC.Prim.+#
                                                            (GHC.Prim.uncheckedIShiftL#
                                                               (GHC.Prim.-#
                                                                  (GHC.Prim.word2Int#
                                                                     (GHC.Prim.word8ToWord#
                                                                        r#_abjm))
                                                                  224#)
                                                               12#)
                                                            (GHC.Prim.uncheckedIShiftL#
                                                               (GHC.Prim.-#
                                                                  (GHC.Prim.word2Int#
                                                                     (GHC.Prim.word8ToWord#
                                                                        r#1_abjt))
                                                                  128#)
                                                               6#))
                                                         (GHC.Prim.word2Int#
                                                            (GHC.Prim.word8ToWord# r#2_abju)))
                                                      128#))
                                              }
                                              }
                                          }
                                          },
                                          case Data.Text.compareLength
                                                 (Data.Text.Internal.Text bx_abjh bx1_abji bx2_abjj)
                                                 (GHC.Types.I# 1#)
                                          of {
                                            __DEFAULT ->
                                              case GHC.Prim.indexWord8Array# bx_abjh bx1_abji
                                              of r#_abjw
                                              { __DEFAULT ->
                                              let {
                                                c#_abjx :: GHC.Prim.Int#
                                                [LclId,
                                                 Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                         Value=False, ConLike=False, WorkFree=False,
                                                         Expandable=False,
                                                         Guidance=IF_ARGS [] 4 0}]
                                                c#_abjx
                                                  = GHC.Prim.word2Int#
                                                      (GHC.Prim.clz8#
                                                         (GHC.Prim.and#
                                                            (GHC.Prim.not#
                                                               (GHC.Prim.word8ToWord# r#_abjw))
                                                            255##)) } in
                                              let {
                                                y_abjy :: GHC.Prim.Int#
                                                [LclId,
                                                 Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                         Value=False, ConLike=False, WorkFree=False,
                                                         Expandable=False,
                                                         Guidance=IF_ARGS [] 2 0}]
                                                y_abjy
                                                  = GHC.Prim.xorI#
                                                      c#_abjx (GHC.Prim.<=# c#_abjx 0#) } in
                                              Data.Text.Internal.Lazy.$WChunk
                                                (Data.Text.Internal.$WText
                                                   (Data.Text.Array.ByteArray bx_abjh)
                                                   (GHC.Types.I# (GHC.Prim.+# bx1_abji y_abjy))
                                                   (GHC.Types.I# (GHC.Prim.-# bx2_abjj y_abjy)))
                                                ts_abjk
                                              };
                                            GHC.Types.EQ -> ts_abjk
                                          })
                                   })
                                (let {
                                   f2_abjA
                                     :: Data.Text.Internal.Lazy.Text
                                        -> f_abj6 Data.Text.Internal.Lazy.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abjA
                                     = GHC.Base.pure
                                         @f_abj6
                                         $dApplicative_abj8
                                         @Data.Text.Internal.Lazy.Text } in
                                 let {
                                   ds2_abjB
                                     :: f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                        -> f_abj6 Data.Text.Internal.Lazy.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 100 0}]
                                   ds2_abjB
                                     = GHC.Base.fmap
                                         @f_abj6
                                         (GHC.Base.$p1Applicative @f_abj6 $dApplicative_abj8)
                                         @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                         @Data.Text.Internal.Lazy.Text
                                         (\ (p1_abjC
                                               :: (GHC.Types.Char, Data.Text.Internal.Lazy.Text)) ->
                                            case p1_abjC of { (x_abjE, ds_abjF) ->
                                            Data.Text.Lazy.cons x_abjE ds_abjF
                                            }) } in
                                 \ (ds3_abjH
                                      :: Data.Either.Either
                                           Data.Text.Internal.Lazy.Text
                                           (f_abj6
                                              (GHC.Types.Char, Data.Text.Internal.Lazy.Text))) ->
                                   case ds3_abjH of {
                                     Data.Either.Left x_abjJ -> f2_abjA x_abjJ;
                                     Data.Either.Right y_abjL -> ds2_abjB y_abjL
                                   }) } in
                        let {
                          g_abjN
                            :: p_abj5
                                 (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                 (f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                               -> p_abj5
                                    (Data.Either.Either
                                       Data.Text.Internal.Lazy.Text
                                       (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                                    (Data.Either.Either
                                       Data.Text.Internal.Lazy.Text
                                       (f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abjN
                            = Data.Profunctor.Choice.right'
                                @p_abj5
                                $dChoice_abj7
                                @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                @(f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                                @Data.Text.Internal.Lazy.Text } in
                        \ (x_abjO
                             :: p_abj5
                                  (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                  (f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text))) ->
                          f1_abj9 (g_abjN x_abjO))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <Data.Text.Internal.Lazy.Text>_N
                                      <Data.Text.Internal.Lazy.Text>_N
                                      <GHC.Types.Char>_N
                                      <GHC.Types.Char>_N)
                             :: Control.Lens.Type.Prism
                                  Data.Text.Internal.Lazy.Text
                                  Data.Text.Internal.Lazy.Text
                                  (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                  (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                ~R# Control.Lens.Cons.Cons
                                      Data.Text.Internal.Lazy.Text
                                      Data.Text.Internal.Lazy.Text
                                      GHC.Types.Char
                                      GHC.Types.Char)
              ValArg (\ (@(p_abgg :: * -> * -> *))
                        (@(f_abgh :: * -> *))
                        ($dChoice_abgi :: Data.Profunctor.Choice.Choice p_abgg)
                        ($dApplicative_abgj :: GHC.Base.Applicative f_abgh) ->
                        let {
                          f1_abgk
                            :: p_abgg
                                 (Data.Either.Either
                                    [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                                 (Data.Either.Either
                                    [GHC.Types.Char] (f_abgh (GHC.Types.Char, [GHC.Types.Char])))
                               -> p_abgg [GHC.Types.Char] (f_abgh [GHC.Types.Char])
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 320 0}]
                          f1_abgk
                            = Data.Profunctor.Unsafe.dimap
                                @p_abgg
                                (Data.Profunctor.Choice.$p1Choice @p_abgg $dChoice_abgi)
                                @[GHC.Types.Char]
                                @(Data.Either.Either
                                    [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                                @(Data.Either.Either
                                    [GHC.Types.Char] (f_abgh (GHC.Types.Char, [GHC.Types.Char])))
                                @(f_abgh [GHC.Types.Char])
                                (\ (aas_abgl :: [GHC.Types.Char]) ->
                                   case aas_abgl of {
                                     [] ->
                                       Data.Either.Left
                                         @[GHC.Types.Char]
                                         @(GHC.Types.Char, [GHC.Types.Char])
                                         (GHC.Types.[] @GHC.Types.Char);
                                     : a1_abgn as_abgo ->
                                       Data.Either.Right
                                         @[GHC.Types.Char]
                                         @(GHC.Types.Char, [GHC.Types.Char])
                                         (a1_abgn, as_abgo)
                                   })
                                (let {
                                   f2_abgq :: [GHC.Types.Char] -> f_abgh [GHC.Types.Char]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abgq
                                     = GHC.Base.pure
                                         @f_abgh $dApplicative_abgj @[GHC.Types.Char] } in
                                 let {
                                   ds2_abgr
                                     :: f_abgh (GHC.Types.Char, [GHC.Types.Char])
                                        -> f_abgh [GHC.Types.Char]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 90 0}]
                                   ds2_abgr
                                     = GHC.Base.fmap
                                         @f_abgh
                                         (GHC.Base.$p1Applicative @f_abgh $dApplicative_abgj)
                                         @(GHC.Types.Char, [GHC.Types.Char])
                                         @[GHC.Types.Char]
                                         (\ (p1_abgs :: (GHC.Types.Char, [GHC.Types.Char])) ->
                                            GHC.Types.:
                                              @GHC.Types.Char
                                              (case p1_abgs of { (x_abgu, ds_abgv) -> x_abgu })
                                              (case p1_abgs of { (ds_abgy, y_abgz) ->
                                               y_abgz
                                               })) } in
                                 \ (ds3_abgB
                                      :: Data.Either.Either
                                           [GHC.Types.Char]
                                           (f_abgh (GHC.Types.Char, [GHC.Types.Char]))) ->
                                   case ds3_abgB of {
                                     Data.Either.Left x_abgD -> f2_abgq x_abgD;
                                     Data.Either.Right y_abgF -> ds2_abgr y_abgF
                                   }) } in
                        let {
                          g_abgH
                            :: p_abgg
                                 (GHC.Types.Char, [GHC.Types.Char])
                                 (f_abgh (GHC.Types.Char, [GHC.Types.Char]))
                               -> p_abgg
                                    (Data.Either.Either
                                       [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                                    (Data.Either.Either
                                       [GHC.Types.Char] (f_abgh (GHC.Types.Char, [GHC.Types.Char])))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abgH
                            = Data.Profunctor.Choice.right'
                                @p_abgg
                                $dChoice_abgi
                                @(GHC.Types.Char, [GHC.Types.Char])
                                @(f_abgh (GHC.Types.Char, [GHC.Types.Char]))
                                @[GHC.Types.Char] } in
                        \ (x_abgI
                             :: p_abgg
                                  (GHC.Types.Char, [GHC.Types.Char])
                                  (f_abgh (GHC.Types.Char, [GHC.Types.Char]))) ->
                          f1_abgk (g_abgH x_abgI))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <[GHC.Types.Char]>_N
                                      <[GHC.Types.Char]>_N
                                      <GHC.Types.Char>_N
                                      <GHC.Types.Char>_N)
                             :: Control.Lens.Type.Prism
                                  [GHC.Types.Char]
                                  [GHC.Types.Char]
                                  (GHC.Types.Char, [GHC.Types.Char])
                                  (GHC.Types.Char, [GHC.Types.Char])
                                ~R# Control.Lens.Cons.Cons
                                      [GHC.Types.Char]
                                      [GHC.Types.Char]
                                      GHC.Types.Char
                                      GHC.Types.Char)
              ValArg (\ (@(p_abgN :: * -> * -> *))
                        (@(f_abgO :: * -> *))
                        ($dChoice_abgP :: Data.Profunctor.Choice.Choice p_abgN)
                        ($dApplicative_abgQ :: GHC.Base.Applicative f_abgO) ->
                        let {
                          f1_abgR
                            :: p_abgN
                                 (Data.Either.Either [GHC.Types.Char] ())
                                 (Data.Either.Either [GHC.Types.Char] (f_abgO ()))
                               -> p_abgN [GHC.Types.Char] (f_abgO [GHC.Types.Char])
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 290 0}]
                          f1_abgR
                            = Data.Profunctor.Unsafe.dimap
                                @p_abgN
                                (Data.Profunctor.Choice.$p1Choice @p_abgN $dChoice_abgP)
                                @[GHC.Types.Char]
                                @(Data.Either.Either [GHC.Types.Char] ())
                                @(Data.Either.Either [GHC.Types.Char] (f_abgO ()))
                                @(f_abgO [GHC.Types.Char])
                                (\ (s_abgS :: [GHC.Types.Char]) ->
                                   case s_abgS of wild_abgT {
                                     [] ->
                                       Data.Either.Right @[GHC.Types.Char] @() GHC.Tuple.Prim.();
                                     : ds1_abgU ds2_abgV ->
                                       Data.Either.Left @[GHC.Types.Char] @() wild_abgT
                                   })
                                (let {
                                   f2_abgX :: [GHC.Types.Char] -> f_abgO [GHC.Types.Char]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abgX
                                     = GHC.Base.pure
                                         @f_abgO $dApplicative_abgQ @[GHC.Types.Char] } in
                                 let {
                                   ds2_abgY :: f_abgO () -> f_abgO [GHC.Types.Char]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 70 0}]
                                   ds2_abgY
                                     = GHC.Base.fmap
                                         @f_abgO
                                         (GHC.Base.$p1Applicative @f_abgO $dApplicative_abgQ)
                                         @()
                                         @[GHC.Types.Char]
                                         (\ (ds3_abgZ :: ()) ->
                                            case ds3_abgZ of { () ->
                                            GHC.Types.[] @GHC.Types.Char
                                            }) } in
                                 \ (ds3_abh1 :: Data.Either.Either [GHC.Types.Char] (f_abgO ())) ->
                                   case ds3_abh1 of {
                                     Data.Either.Left x_abh3 -> f2_abgX x_abh3;
                                     Data.Either.Right y_abh5 -> ds2_abgY y_abh5
                                   }) } in
                        let {
                          g_abh7
                            :: p_abgN () (f_abgO ())
                               -> p_abgN
                                    (Data.Either.Either [GHC.Types.Char] ())
                                    (Data.Either.Either [GHC.Types.Char] (f_abgO ()))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abh7
                            = Data.Profunctor.Choice.right'
                                @p_abgN $dChoice_abgP @() @(f_abgO ()) @[GHC.Types.Char] } in
                        \ (x_abh8 :: p_abgN () (f_abgO ())) -> f1_abgR (g_abh7 x_abh8))
                     `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0] <[GHC.Types.Char]>_N)
                             :: Control.Lens.Type.Prism' [GHC.Types.Char] ()
                                ~R# Control.Lens.Empty.AsEmpty [GHC.Types.Char])
              TyArg Data.Functor.Const.Const GHC.Base.String
              ValArg Data.Functor.Contravariant.$fContravariantConst
                       @[GHC.Types.Char]
              ValArg Data.Functor.Const.$fFunctorConst @[GHC.Types.Char]
    After:  (\ (@(f_abfC :: * -> *))
               ($dCons_abfD
                  :: Control.Lens.Cons.Cons
                       Data.Text.Internal.Lazy.Text
                       Data.Text.Internal.Lazy.Text
                       GHC.Types.Char
                       GHC.Types.Char)
               ($dCons1_abfE
                  :: Control.Lens.Cons.Cons
                       GHC.Base.String GHC.Base.String GHC.Types.Char GHC.Types.Char)
               ($dAsEmpty_abfF :: Control.Lens.Empty.AsEmpty GHC.Base.String)
               ($dContravariant_abfG
                  :: Data.Functor.Contravariant.Contravariant f_abfC)
               ($dFunctor_abfH :: GHC.Base.Functor f_abfC) ->
               Data.Profunctor.Unsafe.$fProfunctorFUN_$cdimap
                 @Data.Text.Internal.Lazy.Text
                 @GHC.Base.String
                 @(f_abfC GHC.Base.String)
                 @(f_abfC Data.Text.Internal.Lazy.Text)
                 Data.Text.Lazy.unpack
                 (GHC.Base.fmap
                    @f_abfC
                    $dFunctor_abfH
                    @GHC.Base.String
                    @Data.Text.Internal.Lazy.Text
                    Data.Text.Lazy.pack))
              @(Data.Functor.Const.Const GHC.Base.String)
              ((\ (@(p_abj5 :: * -> * -> *))
                  (@(f_abj6 :: * -> *))
                  ($dChoice_abj7 :: Data.Profunctor.Choice.Choice p_abj5)
                  ($dApplicative_abj8 :: GHC.Base.Applicative f_abj6) ->
                  let {
                    f1_abj9
                      :: p_abj5
                           (Data.Either.Either
                              Data.Text.Internal.Lazy.Text
                              (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                           (Data.Either.Either
                              Data.Text.Internal.Lazy.Text
                              (f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                         -> p_abj5
                              Data.Text.Internal.Lazy.Text (f_abj6 Data.Text.Internal.Lazy.Text)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 639 0}]
                    f1_abj9
                      = Data.Profunctor.Unsafe.dimap
                          @p_abj5
                          (Data.Profunctor.Choice.$p1Choice @p_abj5 $dChoice_abj7)
                          @Data.Text.Internal.Lazy.Text
                          @(Data.Either.Either
                              Data.Text.Internal.Lazy.Text
                              (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                          @(Data.Either.Either
                              Data.Text.Internal.Lazy.Text
                              (f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                          @(f_abj6 Data.Text.Internal.Lazy.Text)
                          (\ (s1_abja :: Data.Text.Internal.Lazy.Text) ->
                             case s1_abja of {
                               Data.Text.Internal.Lazy.Empty ->
                                 Data.Either.Left
                                   @Data.Text.Internal.Lazy.Text
                                   @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                   Data.Text.Internal.Lazy.Empty;
                               Data.Text.Internal.Lazy.Chunk bx_abjh bx1_abji bx2_abjj ts_abjk ->
                                 Data.Either.Right
                                   @Data.Text.Internal.Lazy.Text
                                   @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                   (case GHC.Prim.indexWord8Array# bx_abjh bx1_abji of r#_abjm
                                    { __DEFAULT ->
                                    let {
                                      c#_abjn :: GHC.Prim.Int#
                                      [LclId,
                                       Unf=Unf{Src=<vanilla>, TopLvl=False,
                                               Value=False, ConLike=False, WorkFree=False,
                                               Expandable=False,
                                               Guidance=IF_ARGS [] 4 0}]
                                      c#_abjn
                                        = GHC.Prim.word2Int#
                                            (GHC.Prim.clz8#
                                               (GHC.Prim.and#
                                                  (GHC.Prim.not# (GHC.Prim.word8ToWord# r#_abjm))
                                                  255##)) } in
                                    case GHC.Prim.xorI# c#_abjn (GHC.Prim.<=# c#_abjn 0#) of {
                                      __DEFAULT ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abjh (GHC.Prim.+# bx1_abji 1#)
                                        of r#1_abjp
                                        { __DEFAULT ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abjh (GHC.Prim.+# bx1_abji 2#)
                                        of r#2_abjq
                                        { __DEFAULT ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abjh (GHC.Prim.+# bx1_abji 3#)
                                        of r#3_abjr
                                        { __DEFAULT ->
                                        GHC.Types.C#
                                          (GHC.Prim.chr#
                                             (GHC.Prim.-#
                                                (GHC.Prim.+#
                                                   (GHC.Prim.+#
                                                      (GHC.Prim.+#
                                                         (GHC.Prim.uncheckedIShiftL#
                                                            (GHC.Prim.-#
                                                               (GHC.Prim.word2Int#
                                                                  (GHC.Prim.word8ToWord# r#_abjm))
                                                               240#)
                                                            18#)
                                                         (GHC.Prim.uncheckedIShiftL#
                                                            (GHC.Prim.-#
                                                               (GHC.Prim.word2Int#
                                                                  (GHC.Prim.word8ToWord# r#1_abjp))
                                                               128#)
                                                            12#))
                                                      (GHC.Prim.uncheckedIShiftL#
                                                         (GHC.Prim.-#
                                                            (GHC.Prim.word2Int#
                                                               (GHC.Prim.word8ToWord# r#2_abjq))
                                                            128#)
                                                         6#))
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.word8ToWord# r#3_abjr)))
                                                128#))
                                        }
                                        }
                                        };
                                      1# ->
                                        GHC.Types.C#
                                          (GHC.Prim.chr#
                                             (GHC.Prim.word2Int# (GHC.Prim.word8ToWord# r#_abjm)));
                                      2# ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abjh (GHC.Prim.+# bx1_abji 1#)
                                        of r#1_abjs
                                        { __DEFAULT ->
                                        GHC.Types.C#
                                          (GHC.Prim.chr#
                                             (GHC.Prim.-#
                                                (GHC.Prim.+#
                                                   (GHC.Prim.uncheckedIShiftL#
                                                      (GHC.Prim.-#
                                                         (GHC.Prim.word2Int#
                                                            (GHC.Prim.word8ToWord# r#_abjm))
                                                         192#)
                                                      6#)
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.word8ToWord# r#1_abjs)))
                                                128#))
                                        };
                                      3# ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abjh (GHC.Prim.+# bx1_abji 1#)
                                        of r#1_abjt
                                        { __DEFAULT ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abjh (GHC.Prim.+# bx1_abji 2#)
                                        of r#2_abju
                                        { __DEFAULT ->
                                        GHC.Types.C#
                                          (GHC.Prim.chr#
                                             (GHC.Prim.-#
                                                (GHC.Prim.+#
                                                   (GHC.Prim.+#
                                                      (GHC.Prim.uncheckedIShiftL#
                                                         (GHC.Prim.-#
                                                            (GHC.Prim.word2Int#
                                                               (GHC.Prim.word8ToWord# r#_abjm))
                                                            224#)
                                                         12#)
                                                      (GHC.Prim.uncheckedIShiftL#
                                                         (GHC.Prim.-#
                                                            (GHC.Prim.word2Int#
                                                               (GHC.Prim.word8ToWord# r#1_abjt))
                                                            128#)
                                                         6#))
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.word8ToWord# r#2_abju)))
                                                128#))
                                        }
                                        }
                                    }
                                    },
                                    case Data.Text.compareLength
                                           (Data.Text.Internal.Text bx_abjh bx1_abji bx2_abjj)
                                           (GHC.Types.I# 1#)
                                    of {
                                      __DEFAULT ->
                                        case GHC.Prim.indexWord8Array# bx_abjh bx1_abji of r#_abjw
                                        { __DEFAULT ->
                                        let {
                                          c#_abjx :: GHC.Prim.Int#
                                          [LclId,
                                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                   Value=False, ConLike=False, WorkFree=False,
                                                   Expandable=False,
                                                   Guidance=IF_ARGS [] 4 0}]
                                          c#_abjx
                                            = GHC.Prim.word2Int#
                                                (GHC.Prim.clz8#
                                                   (GHC.Prim.and#
                                                      (GHC.Prim.not#
                                                         (GHC.Prim.word8ToWord# r#_abjw))
                                                      255##)) } in
                                        let {
                                          y_abjy :: GHC.Prim.Int#
                                          [LclId,
                                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                   Value=False, ConLike=False, WorkFree=False,
                                                   Expandable=False,
                                                   Guidance=IF_ARGS [] 2 0}]
                                          y_abjy
                                            = GHC.Prim.xorI# c#_abjx (GHC.Prim.<=# c#_abjx 0#) } in
                                        Data.Text.Internal.Lazy.$WChunk
                                          (Data.Text.Internal.$WText
                                             (Data.Text.Array.ByteArray bx_abjh)
                                             (GHC.Types.I# (GHC.Prim.+# bx1_abji y_abjy))
                                             (GHC.Types.I# (GHC.Prim.-# bx2_abjj y_abjy)))
                                          ts_abjk
                                        };
                                      GHC.Types.EQ -> ts_abjk
                                    })
                             })
                          (let {
                             f2_abjA
                               :: Data.Text.Internal.Lazy.Text
                                  -> f_abj6 Data.Text.Internal.Lazy.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abjA
                               = GHC.Base.pure
                                   @f_abj6 $dApplicative_abj8 @Data.Text.Internal.Lazy.Text } in
                           let {
                             ds2_abjB
                               :: f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                  -> f_abj6 Data.Text.Internal.Lazy.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 100 0}]
                             ds2_abjB
                               = GHC.Base.fmap
                                   @f_abj6
                                   (GHC.Base.$p1Applicative @f_abj6 $dApplicative_abj8)
                                   @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                   @Data.Text.Internal.Lazy.Text
                                   (\ (p1_abjC :: (GHC.Types.Char, Data.Text.Internal.Lazy.Text)) ->
                                      case p1_abjC of { (x_abjE, ds_abjF) ->
                                      Data.Text.Lazy.cons x_abjE ds_abjF
                                      }) } in
                           \ (ds3_abjH
                                :: Data.Either.Either
                                     Data.Text.Internal.Lazy.Text
                                     (f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text))) ->
                             case ds3_abjH of {
                               Data.Either.Left x_abjJ -> f2_abjA x_abjJ;
                               Data.Either.Right y_abjL -> ds2_abjB y_abjL
                             }) } in
                  let {
                    g_abjN
                      :: p_abj5
                           (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                           (f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                         -> p_abj5
                              (Data.Either.Either
                                 Data.Text.Internal.Lazy.Text
                                 (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                              (Data.Either.Either
                                 Data.Text.Internal.Lazy.Text
                                 (f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abjN
                      = Data.Profunctor.Choice.right'
                          @p_abj5
                          $dChoice_abj7
                          @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                          @(f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                          @Data.Text.Internal.Lazy.Text } in
                  \ (x_abjO
                       :: p_abj5
                            (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                            (f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text))) ->
                    f1_abj9 (g_abjN x_abjO))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <Data.Text.Internal.Lazy.Text>_N
                                <Data.Text.Internal.Lazy.Text>_N
                                <GHC.Types.Char>_N
                                <GHC.Types.Char>_N)
                       :: Control.Lens.Type.Prism
                            Data.Text.Internal.Lazy.Text
                            Data.Text.Internal.Lazy.Text
                            (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                            (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                          ~R# Control.Lens.Cons.Cons
                                Data.Text.Internal.Lazy.Text
                                Data.Text.Internal.Lazy.Text
                                GHC.Types.Char
                                GHC.Types.Char))
              ((\ (@(p_abgg :: * -> * -> *))
                  (@(f_abgh :: * -> *))
                  ($dChoice_abgi :: Data.Profunctor.Choice.Choice p_abgg)
                  ($dApplicative_abgj :: GHC.Base.Applicative f_abgh) ->
                  let {
                    f1_abgk
                      :: p_abgg
                           (Data.Either.Either
                              [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                           (Data.Either.Either
                              [GHC.Types.Char] (f_abgh (GHC.Types.Char, [GHC.Types.Char])))
                         -> p_abgg [GHC.Types.Char] (f_abgh [GHC.Types.Char])
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 320 0}]
                    f1_abgk
                      = Data.Profunctor.Unsafe.dimap
                          @p_abgg
                          (Data.Profunctor.Choice.$p1Choice @p_abgg $dChoice_abgi)
                          @[GHC.Types.Char]
                          @(Data.Either.Either
                              [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                          @(Data.Either.Either
                              [GHC.Types.Char] (f_abgh (GHC.Types.Char, [GHC.Types.Char])))
                          @(f_abgh [GHC.Types.Char])
                          (\ (aas_abgl :: [GHC.Types.Char]) ->
                             case aas_abgl of {
                               [] ->
                                 Data.Either.Left
                                   @[GHC.Types.Char]
                                   @(GHC.Types.Char, [GHC.Types.Char])
                                   (GHC.Types.[] @GHC.Types.Char);
                               : a1_abgn as_abgo ->
                                 Data.Either.Right
                                   @[GHC.Types.Char]
                                   @(GHC.Types.Char, [GHC.Types.Char])
                                   (a1_abgn, as_abgo)
                             })
                          (let {
                             f2_abgq :: [GHC.Types.Char] -> f_abgh [GHC.Types.Char]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abgq
                               = GHC.Base.pure @f_abgh $dApplicative_abgj @[GHC.Types.Char] } in
                           let {
                             ds2_abgr
                               :: f_abgh (GHC.Types.Char, [GHC.Types.Char])
                                  -> f_abgh [GHC.Types.Char]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 90 0}]
                             ds2_abgr
                               = GHC.Base.fmap
                                   @f_abgh
                                   (GHC.Base.$p1Applicative @f_abgh $dApplicative_abgj)
                                   @(GHC.Types.Char, [GHC.Types.Char])
                                   @[GHC.Types.Char]
                                   (\ (p1_abgs :: (GHC.Types.Char, [GHC.Types.Char])) ->
                                      GHC.Types.:
                                        @GHC.Types.Char
                                        (case p1_abgs of { (x_abgu, ds_abgv) -> x_abgu })
                                        (case p1_abgs of { (ds_abgy, y_abgz) -> y_abgz })) } in
                           \ (ds3_abgB
                                :: Data.Either.Either
                                     [GHC.Types.Char]
                                     (f_abgh (GHC.Types.Char, [GHC.Types.Char]))) ->
                             case ds3_abgB of {
                               Data.Either.Left x_abgD -> f2_abgq x_abgD;
                               Data.Either.Right y_abgF -> ds2_abgr y_abgF
                             }) } in
                  let {
                    g_abgH
                      :: p_abgg
                           (GHC.Types.Char, [GHC.Types.Char])
                           (f_abgh (GHC.Types.Char, [GHC.Types.Char]))
                         -> p_abgg
                              (Data.Either.Either
                                 [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                              (Data.Either.Either
                                 [GHC.Types.Char] (f_abgh (GHC.Types.Char, [GHC.Types.Char])))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abgH
                      = Data.Profunctor.Choice.right'
                          @p_abgg
                          $dChoice_abgi
                          @(GHC.Types.Char, [GHC.Types.Char])
                          @(f_abgh (GHC.Types.Char, [GHC.Types.Char]))
                          @[GHC.Types.Char] } in
                  \ (x_abgI
                       :: p_abgg
                            (GHC.Types.Char, [GHC.Types.Char])
                            (f_abgh (GHC.Types.Char, [GHC.Types.Char]))) ->
                    f1_abgk (g_abgH x_abgI))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <[GHC.Types.Char]>_N
                                <[GHC.Types.Char]>_N
                                <GHC.Types.Char>_N
                                <GHC.Types.Char>_N)
                       :: Control.Lens.Type.Prism
                            [GHC.Types.Char]
                            [GHC.Types.Char]
                            (GHC.Types.Char, [GHC.Types.Char])
                            (GHC.Types.Char, [GHC.Types.Char])
                          ~R# Control.Lens.Cons.Cons
                                [GHC.Types.Char] [GHC.Types.Char] GHC.Types.Char GHC.Types.Char))
              ((\ (@(p_abgN :: * -> * -> *))
                  (@(f_abgO :: * -> *))
                  ($dChoice_abgP :: Data.Profunctor.Choice.Choice p_abgN)
                  ($dApplicative_abgQ :: GHC.Base.Applicative f_abgO) ->
                  let {
                    f1_abgR
                      :: p_abgN
                           (Data.Either.Either [GHC.Types.Char] ())
                           (Data.Either.Either [GHC.Types.Char] (f_abgO ()))
                         -> p_abgN [GHC.Types.Char] (f_abgO [GHC.Types.Char])
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 290 0}]
                    f1_abgR
                      = Data.Profunctor.Unsafe.dimap
                          @p_abgN
                          (Data.Profunctor.Choice.$p1Choice @p_abgN $dChoice_abgP)
                          @[GHC.Types.Char]
                          @(Data.Either.Either [GHC.Types.Char] ())
                          @(Data.Either.Either [GHC.Types.Char] (f_abgO ()))
                          @(f_abgO [GHC.Types.Char])
                          (\ (s_abgS :: [GHC.Types.Char]) ->
                             case s_abgS of wild_abgT {
                               [] -> Data.Either.Right @[GHC.Types.Char] @() GHC.Tuple.Prim.();
                               : ds1_abgU ds2_abgV ->
                                 Data.Either.Left @[GHC.Types.Char] @() wild_abgT
                             })
                          (let {
                             f2_abgX :: [GHC.Types.Char] -> f_abgO [GHC.Types.Char]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abgX
                               = GHC.Base.pure @f_abgO $dApplicative_abgQ @[GHC.Types.Char] } in
                           let {
                             ds2_abgY :: f_abgO () -> f_abgO [GHC.Types.Char]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 70 0}]
                             ds2_abgY
                               = GHC.Base.fmap
                                   @f_abgO
                                   (GHC.Base.$p1Applicative @f_abgO $dApplicative_abgQ)
                                   @()
                                   @[GHC.Types.Char]
                                   (\ (ds3_abgZ :: ()) ->
                                      case ds3_abgZ of { () -> GHC.Types.[] @GHC.Types.Char }) } in
                           \ (ds3_abh1 :: Data.Either.Either [GHC.Types.Char] (f_abgO ())) ->
                             case ds3_abh1 of {
                               Data.Either.Left x_abh3 -> f2_abgX x_abh3;
                               Data.Either.Right y_abh5 -> ds2_abgY y_abh5
                             }) } in
                  let {
                    g_abh7
                      :: p_abgN () (f_abgO ())
                         -> p_abgN
                              (Data.Either.Either [GHC.Types.Char] ())
                              (Data.Either.Either [GHC.Types.Char] (f_abgO ()))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abh7
                      = Data.Profunctor.Choice.right'
                          @p_abgN $dChoice_abgP @() @(f_abgO ()) @[GHC.Types.Char] } in
                  \ (x_abh8 :: p_abgN () (f_abgO ())) -> f1_abgR (g_abh7 x_abh8))
               `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0] <[GHC.Types.Char]>_N)
                       :: Control.Lens.Type.Prism' [GHC.Types.Char] ()
                          ~R# Control.Lens.Empty.AsEmpty [GHC.Types.Char]))
              (Data.Functor.Contravariant.$fContravariantConst @[GHC.Types.Char])
              (Data.Functor.Const.$fFunctorConst @[GHC.Types.Char])
    Cont:   ApplyToVal nodup hole Control.Lens.Getter.Getting
                                    GHC.Base.String Data.Text.Internal.Lazy.Text GHC.Base.String
              ((\ (ds_abeK [Occ=Once1] :: a_abeH) -> ds_abeK)
               `cast` (<a_abeH>_R
                       %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                          <*>_N <a_abeH>_R <a_abeH>_P)
                       :: (a_abeH -> a_abeH)
                          ~R# (a_abeH -> Data.Functor.Const.Const a_abeH a_abeH)))
            ApplyToVal nodup hole Data.Text.Internal.Lazy.Text
                                  -> Data.Functor.Const.Const
                                       GHC.Base.String Data.Text.Internal.Lazy.Text
              (Control.Lens.Getter.view
                 @[GHC.Types.Char]
                 @((->) GHC.Base.String)
                 @Data.Text.Internal.Lazy.Text
                 (Control.Monad.Reader.Class.$fMonadReaderrFUN @[GHC.Types.Char])
                 (Control.Lens.Cons.Extras.recons
                    @[GHC.Types.Char]
                    @GHC.Types.Char
                    @Data.Text.Internal.Lazy.Text
                    (Control.Lens.Cons.$fConsListListab
                       @GHC.Types.Char @GHC.Types.Char)
                    Control.Lens.Cons.$fConsTextTextCharChar
                    Control.Lens.Empty.$fAsEmptyText
                    @(Data.Functor.Const.Const Data.Text.Internal.Lazy.Text)
                    (Data.Functor.Contravariant.$fContravariantConst
                       @Data.Text.Internal.Lazy.Text)
                    (Data.Functor.Const.$fFunctorConst @Data.Text.Internal.Lazy.Text))
                 s_a8Pv)
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N <GHC.Base.String>_R <Data.Text.Internal.Lazy.Text>_P
                    :: Data.Functor.Const.Const
                         GHC.Base.String Data.Text.Internal.Lazy.Text
                       ~R# GHC.Base.String)
            Stop[RuleArgCtxt] GHC.Base.String
Rule fired
    Rule: Class op fmap
    Module: (BUILTIN)
    Before: GHC.Base.fmap
              TyArg Data.Functor.Const.Const GHC.Base.String
              ValArg Data.Functor.Const.$fFunctorConst @[GHC.Types.Char]
    After:  (Data.Functor.Const.$fFunctorConst2 @[GHC.Types.Char])
            `cast` (forall (a :: <*>_N) (b :: <*>_N).
                    <a -> b>_R
                    %<'GHC.Types.Many>_N ->_R <Data.Functor.Const.Const
                                                 [GHC.Types.Char] a>_R
                    %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                  <*>_N <[GHC.Types.Char]>_R <a>_P
                                              ; Sym (Data.Functor.Const.N:Const[0]
                                                         <*>_N <[GHC.Types.Char]>_R <b>_P)
                    :: (forall {a} {b}.
                        (a -> b)
                        -> Data.Functor.Const.Const [GHC.Types.Char] a
                        -> Data.Functor.Const.Const [GHC.Types.Char] a)
                       ~R# (forall {a} {b}.
                            (a -> b)
                            -> Data.Functor.Const.Const [GHC.Types.Char] a
                            -> Data.Functor.Const.Const [GHC.Types.Char] b))
    Cont:   ApplyToTy GHC.Base.String
            ApplyToTy Data.Text.Internal.Lazy.Text
            ApplyToVal nodup hole (GHC.Base.String
                                   -> Data.Text.Internal.Lazy.Text)
                                  -> Data.Functor.Const.Const GHC.Base.String GHC.Base.String
                                  -> Data.Functor.Const.Const
                                       GHC.Base.String Data.Text.Internal.Lazy.Text
              Data.Text.Lazy.pack
            ApplyToVal nodup hole Data.Functor.Const.Const
                                    GHC.Base.String GHC.Base.String
                                  -> Data.Functor.Const.Const
                                       GHC.Base.String Data.Text.Internal.Lazy.Text
              (bc_aboH (ab_aboF x_aboI))
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N <GHC.Base.String>_R <Data.Text.Internal.Lazy.Text>_P
                    :: Data.Functor.Const.Const
                         GHC.Base.String Data.Text.Internal.Lazy.Text
                       ~R# GHC.Base.String)
            Stop[RuleArgCtxt] GHC.Base.String
Rule fired
    Rule: Class op reader
    Module: (BUILTIN)
    Before: Control.Monad.Reader.Class.reader
              TyArg [GHC.Types.Char]
              TyArg (->) GHC.Base.String
              ValArg Control.Monad.Reader.Class.$fMonadReaderrFUN
                       @[GHC.Types.Char]
    After:  \ (@a_abeP) -> GHC.Base.id @([GHC.Types.Char] -> a_abeP)
    Cont:   ApplyToTy Data.Text.Internal.Lazy.Text
            ApplyToVal nodup hole ([GHC.Types.Char]
                                   -> Data.Text.Internal.Lazy.Text)
                                  -> GHC.Base.String -> Data.Text.Internal.Lazy.Text
              ((l_abeJ
                  ((\ (ds_abeK [Occ=Once1] :: a_abeH) -> ds_abeK)
                   `cast` (<a_abeH>_R
                           %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                              <*>_N <a_abeH>_R <a_abeH>_P)
                           :: (a_abeH -> a_abeH)
                              ~R# (a_abeH -> Data.Functor.Const.Const a_abeH a_abeH))))
               `cast` (<s_abeF>_R
                       %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                     <*>_N <a_abeH>_R <s_abeF>_P
                       :: (s_abeF -> Data.Functor.Const.Const a_abeH s_abeF)
                          ~R# (s_abeF -> a_abeH)))
            ApplyToVal nodup hole GHC.Base.String
                                  -> Data.Text.Internal.Lazy.Text
              s_a8Pv
            Stop[RuleArgCtxt] Data.Text.Internal.Lazy.Text
Rule fired
    Rule: recons/string-lazytext
    Module: (Control.Lens.Cons.Extras)
    Before: Control.Lens.Cons.Extras.recons
              TyArg [GHC.Types.Char]
              TyArg GHC.Types.Char
              TyArg Data.Text.Internal.Lazy.Text
              ValArg (\ (@(p_abgg :: * -> * -> *))
                        (@(f_abgh :: * -> *))
                        ($dChoice_abgi :: Data.Profunctor.Choice.Choice p_abgg)
                        ($dApplicative_abgj :: GHC.Base.Applicative f_abgh) ->
                        let {
                          f1_abgk
                            :: p_abgg
                                 (Data.Either.Either
                                    [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                                 (Data.Either.Either
                                    [GHC.Types.Char] (f_abgh (GHC.Types.Char, [GHC.Types.Char])))
                               -> p_abgg [GHC.Types.Char] (f_abgh [GHC.Types.Char])
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 320 0}]
                          f1_abgk
                            = Data.Profunctor.Unsafe.dimap
                                @p_abgg
                                (Data.Profunctor.Choice.$p1Choice @p_abgg $dChoice_abgi)
                                @[GHC.Types.Char]
                                @(Data.Either.Either
                                    [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                                @(Data.Either.Either
                                    [GHC.Types.Char] (f_abgh (GHC.Types.Char, [GHC.Types.Char])))
                                @(f_abgh [GHC.Types.Char])
                                (\ (aas_abgl :: [GHC.Types.Char]) ->
                                   case aas_abgl of {
                                     [] ->
                                       Data.Either.Left
                                         @[GHC.Types.Char]
                                         @(GHC.Types.Char, [GHC.Types.Char])
                                         (GHC.Types.[] @GHC.Types.Char);
                                     : a1_abgn as_abgo ->
                                       Data.Either.Right
                                         @[GHC.Types.Char]
                                         @(GHC.Types.Char, [GHC.Types.Char])
                                         (a1_abgn, as_abgo)
                                   })
                                (let {
                                   f2_abgq :: [GHC.Types.Char] -> f_abgh [GHC.Types.Char]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abgq
                                     = GHC.Base.pure
                                         @f_abgh $dApplicative_abgj @[GHC.Types.Char] } in
                                 let {
                                   ds2_abgr
                                     :: f_abgh (GHC.Types.Char, [GHC.Types.Char])
                                        -> f_abgh [GHC.Types.Char]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 90 0}]
                                   ds2_abgr
                                     = GHC.Base.fmap
                                         @f_abgh
                                         (GHC.Base.$p1Applicative @f_abgh $dApplicative_abgj)
                                         @(GHC.Types.Char, [GHC.Types.Char])
                                         @[GHC.Types.Char]
                                         (\ (p1_abgs :: (GHC.Types.Char, [GHC.Types.Char])) ->
                                            GHC.Types.:
                                              @GHC.Types.Char
                                              (case p1_abgs of { (x_abgu, ds_abgv) -> x_abgu })
                                              (case p1_abgs of { (ds_abgy, y_abgz) ->
                                               y_abgz
                                               })) } in
                                 \ (ds3_abgB
                                      :: Data.Either.Either
                                           [GHC.Types.Char]
                                           (f_abgh (GHC.Types.Char, [GHC.Types.Char]))) ->
                                   case ds3_abgB of {
                                     Data.Either.Left x_abgD -> f2_abgq x_abgD;
                                     Data.Either.Right y_abgF -> ds2_abgr y_abgF
                                   }) } in
                        let {
                          g_abgH
                            :: p_abgg
                                 (GHC.Types.Char, [GHC.Types.Char])
                                 (f_abgh (GHC.Types.Char, [GHC.Types.Char]))
                               -> p_abgg
                                    (Data.Either.Either
                                       [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                                    (Data.Either.Either
                                       [GHC.Types.Char] (f_abgh (GHC.Types.Char, [GHC.Types.Char])))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abgH
                            = Data.Profunctor.Choice.right'
                                @p_abgg
                                $dChoice_abgi
                                @(GHC.Types.Char, [GHC.Types.Char])
                                @(f_abgh (GHC.Types.Char, [GHC.Types.Char]))
                                @[GHC.Types.Char] } in
                        \ (x_abgI
                             :: p_abgg
                                  (GHC.Types.Char, [GHC.Types.Char])
                                  (f_abgh (GHC.Types.Char, [GHC.Types.Char]))) ->
                          f1_abgk (g_abgH x_abgI))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <[GHC.Types.Char]>_N
                                      <[GHC.Types.Char]>_N
                                      <GHC.Types.Char>_N
                                      <GHC.Types.Char>_N)
                             :: Control.Lens.Type.Prism
                                  [GHC.Types.Char]
                                  [GHC.Types.Char]
                                  (GHC.Types.Char, [GHC.Types.Char])
                                  (GHC.Types.Char, [GHC.Types.Char])
                                ~R# Control.Lens.Cons.Cons
                                      [GHC.Types.Char]
                                      [GHC.Types.Char]
                                      GHC.Types.Char
                                      GHC.Types.Char)
              ValArg (\ (@(p_abj5 :: * -> * -> *))
                        (@(f_abj6 :: * -> *))
                        ($dChoice_abj7 :: Data.Profunctor.Choice.Choice p_abj5)
                        ($dApplicative_abj8 :: GHC.Base.Applicative f_abj6) ->
                        let {
                          f1_abj9
                            :: p_abj5
                                 (Data.Either.Either
                                    Data.Text.Internal.Lazy.Text
                                    (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                                 (Data.Either.Either
                                    Data.Text.Internal.Lazy.Text
                                    (f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                               -> p_abj5
                                    Data.Text.Internal.Lazy.Text
                                    (f_abj6 Data.Text.Internal.Lazy.Text)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 639 0}]
                          f1_abj9
                            = Data.Profunctor.Unsafe.dimap
                                @p_abj5
                                (Data.Profunctor.Choice.$p1Choice @p_abj5 $dChoice_abj7)
                                @Data.Text.Internal.Lazy.Text
                                @(Data.Either.Either
                                    Data.Text.Internal.Lazy.Text
                                    (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                                @(Data.Either.Either
                                    Data.Text.Internal.Lazy.Text
                                    (f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                                @(f_abj6 Data.Text.Internal.Lazy.Text)
                                (\ (s1_abja :: Data.Text.Internal.Lazy.Text) ->
                                   case s1_abja of {
                                     Data.Text.Internal.Lazy.Empty ->
                                       Data.Either.Left
                                         @Data.Text.Internal.Lazy.Text
                                         @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                         Data.Text.Internal.Lazy.Empty;
                                     Data.Text.Internal.Lazy.Chunk bx_abjh bx1_abji bx2_abjj
                                                                   ts_abjk ->
                                       Data.Either.Right
                                         @Data.Text.Internal.Lazy.Text
                                         @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                         (case GHC.Prim.indexWord8Array# bx_abjh bx1_abji of r#_abjm
                                          { __DEFAULT ->
                                          let {
                                            c#_abjn :: GHC.Prim.Int#
                                            [LclId,
                                             Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                     Value=False, ConLike=False, WorkFree=False,
                                                     Expandable=False,
                                                     Guidance=IF_ARGS [] 4 0}]
                                            c#_abjn
                                              = GHC.Prim.word2Int#
                                                  (GHC.Prim.clz8#
                                                     (GHC.Prim.and#
                                                        (GHC.Prim.not#
                                                           (GHC.Prim.word8ToWord# r#_abjm))
                                                        255##)) } in
                                          case GHC.Prim.xorI# c#_abjn (GHC.Prim.<=# c#_abjn 0#) of {
                                            __DEFAULT ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abjh (GHC.Prim.+# bx1_abji 1#)
                                              of r#1_abjp
                                              { __DEFAULT ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abjh (GHC.Prim.+# bx1_abji 2#)
                                              of r#2_abjq
                                              { __DEFAULT ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abjh (GHC.Prim.+# bx1_abji 3#)
                                              of r#3_abjr
                                              { __DEFAULT ->
                                              GHC.Types.C#
                                                (GHC.Prim.chr#
                                                   (GHC.Prim.-#
                                                      (GHC.Prim.+#
                                                         (GHC.Prim.+#
                                                            (GHC.Prim.+#
                                                               (GHC.Prim.uncheckedIShiftL#
                                                                  (GHC.Prim.-#
                                                                     (GHC.Prim.word2Int#
                                                                        (GHC.Prim.word8ToWord#
                                                                           r#_abjm))
                                                                     240#)
                                                                  18#)
                                                               (GHC.Prim.uncheckedIShiftL#
                                                                  (GHC.Prim.-#
                                                                     (GHC.Prim.word2Int#
                                                                        (GHC.Prim.word8ToWord#
                                                                           r#1_abjp))
                                                                     128#)
                                                                  12#))
                                                            (GHC.Prim.uncheckedIShiftL#
                                                               (GHC.Prim.-#
                                                                  (GHC.Prim.word2Int#
                                                                     (GHC.Prim.word8ToWord#
                                                                        r#2_abjq))
                                                                  128#)
                                                               6#))
                                                         (GHC.Prim.word2Int#
                                                            (GHC.Prim.word8ToWord# r#3_abjr)))
                                                      128#))
                                              }
                                              }
                                              };
                                            1# ->
                                              GHC.Types.C#
                                                (GHC.Prim.chr#
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.word8ToWord# r#_abjm)));
                                            2# ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abjh (GHC.Prim.+# bx1_abji 1#)
                                              of r#1_abjs
                                              { __DEFAULT ->
                                              GHC.Types.C#
                                                (GHC.Prim.chr#
                                                   (GHC.Prim.-#
                                                      (GHC.Prim.+#
                                                         (GHC.Prim.uncheckedIShiftL#
                                                            (GHC.Prim.-#
                                                               (GHC.Prim.word2Int#
                                                                  (GHC.Prim.word8ToWord# r#_abjm))
                                                               192#)
                                                            6#)
                                                         (GHC.Prim.word2Int#
                                                            (GHC.Prim.word8ToWord# r#1_abjs)))
                                                      128#))
                                              };
                                            3# ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abjh (GHC.Prim.+# bx1_abji 1#)
                                              of r#1_abjt
                                              { __DEFAULT ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abjh (GHC.Prim.+# bx1_abji 2#)
                                              of r#2_abju
                                              { __DEFAULT ->
                                              GHC.Types.C#
                                                (GHC.Prim.chr#
                                                   (GHC.Prim.-#
                                                      (GHC.Prim.+#
                                                         (GHC.Prim.+#
                                                            (GHC.Prim.uncheckedIShiftL#
                                                               (GHC.Prim.-#
                                                                  (GHC.Prim.word2Int#
                                                                     (GHC.Prim.word8ToWord#
                                                                        r#_abjm))
                                                                  224#)
                                                               12#)
                                                            (GHC.Prim.uncheckedIShiftL#
                                                               (GHC.Prim.-#
                                                                  (GHC.Prim.word2Int#
                                                                     (GHC.Prim.word8ToWord#
                                                                        r#1_abjt))
                                                                  128#)
                                                               6#))
                                                         (GHC.Prim.word2Int#
                                                            (GHC.Prim.word8ToWord# r#2_abju)))
                                                      128#))
                                              }
                                              }
                                          }
                                          },
                                          case Data.Text.compareLength
                                                 (Data.Text.Internal.Text bx_abjh bx1_abji bx2_abjj)
                                                 (GHC.Types.I# 1#)
                                          of {
                                            __DEFAULT ->
                                              case GHC.Prim.indexWord8Array# bx_abjh bx1_abji
                                              of r#_abjw
                                              { __DEFAULT ->
                                              let {
                                                c#_abjx :: GHC.Prim.Int#
                                                [LclId,
                                                 Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                         Value=False, ConLike=False, WorkFree=False,
                                                         Expandable=False,
                                                         Guidance=IF_ARGS [] 4 0}]
                                                c#_abjx
                                                  = GHC.Prim.word2Int#
                                                      (GHC.Prim.clz8#
                                                         (GHC.Prim.and#
                                                            (GHC.Prim.not#
                                                               (GHC.Prim.word8ToWord# r#_abjw))
                                                            255##)) } in
                                              let {
                                                y_abjy :: GHC.Prim.Int#
                                                [LclId,
                                                 Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                         Value=False, ConLike=False, WorkFree=False,
                                                         Expandable=False,
                                                         Guidance=IF_ARGS [] 2 0}]
                                                y_abjy
                                                  = GHC.Prim.xorI#
                                                      c#_abjx (GHC.Prim.<=# c#_abjx 0#) } in
                                              Data.Text.Internal.Lazy.$WChunk
                                                (Data.Text.Internal.$WText
                                                   (Data.Text.Array.ByteArray bx_abjh)
                                                   (GHC.Types.I# (GHC.Prim.+# bx1_abji y_abjy))
                                                   (GHC.Types.I# (GHC.Prim.-# bx2_abjj y_abjy)))
                                                ts_abjk
                                              };
                                            GHC.Types.EQ -> ts_abjk
                                          })
                                   })
                                (let {
                                   f2_abjA
                                     :: Data.Text.Internal.Lazy.Text
                                        -> f_abj6 Data.Text.Internal.Lazy.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abjA
                                     = GHC.Base.pure
                                         @f_abj6
                                         $dApplicative_abj8
                                         @Data.Text.Internal.Lazy.Text } in
                                 let {
                                   ds2_abjB
                                     :: f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                        -> f_abj6 Data.Text.Internal.Lazy.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 100 0}]
                                   ds2_abjB
                                     = GHC.Base.fmap
                                         @f_abj6
                                         (GHC.Base.$p1Applicative @f_abj6 $dApplicative_abj8)
                                         @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                         @Data.Text.Internal.Lazy.Text
                                         (\ (p1_abjC
                                               :: (GHC.Types.Char, Data.Text.Internal.Lazy.Text)) ->
                                            case p1_abjC of { (x_abjE, ds_abjF) ->
                                            Data.Text.Lazy.cons x_abjE ds_abjF
                                            }) } in
                                 \ (ds3_abjH
                                      :: Data.Either.Either
                                           Data.Text.Internal.Lazy.Text
                                           (f_abj6
                                              (GHC.Types.Char, Data.Text.Internal.Lazy.Text))) ->
                                   case ds3_abjH of {
                                     Data.Either.Left x_abjJ -> f2_abjA x_abjJ;
                                     Data.Either.Right y_abjL -> ds2_abjB y_abjL
                                   }) } in
                        let {
                          g_abjN
                            :: p_abj5
                                 (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                 (f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                               -> p_abj5
                                    (Data.Either.Either
                                       Data.Text.Internal.Lazy.Text
                                       (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                                    (Data.Either.Either
                                       Data.Text.Internal.Lazy.Text
                                       (f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abjN
                            = Data.Profunctor.Choice.right'
                                @p_abj5
                                $dChoice_abj7
                                @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                @(f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                                @Data.Text.Internal.Lazy.Text } in
                        \ (x_abjO
                             :: p_abj5
                                  (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                  (f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text))) ->
                          f1_abj9 (g_abjN x_abjO))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <Data.Text.Internal.Lazy.Text>_N
                                      <Data.Text.Internal.Lazy.Text>_N
                                      <GHC.Types.Char>_N
                                      <GHC.Types.Char>_N)
                             :: Control.Lens.Type.Prism
                                  Data.Text.Internal.Lazy.Text
                                  Data.Text.Internal.Lazy.Text
                                  (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                  (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                ~R# Control.Lens.Cons.Cons
                                      Data.Text.Internal.Lazy.Text
                                      Data.Text.Internal.Lazy.Text
                                      GHC.Types.Char
                                      GHC.Types.Char)
              ValArg (\ (@(p_abjR :: * -> * -> *))
                        (@(f_abjS :: * -> *))
                        ($dChoice_abjT :: Data.Profunctor.Choice.Choice p_abjR)
                        ($dApplicative_abjU :: GHC.Base.Applicative f_abjS) ->
                        let {
                          f1_abjV
                            :: p_abjR
                                 (Data.Either.Either Data.Text.Internal.Lazy.Text ())
                                 (Data.Either.Either Data.Text.Internal.Lazy.Text (f_abjS ()))
                               -> p_abjR
                                    Data.Text.Internal.Lazy.Text
                                    (f_abjS Data.Text.Internal.Lazy.Text)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 310 0}]
                          f1_abjV
                            = Data.Profunctor.Unsafe.dimap
                                @p_abjR
                                (Data.Profunctor.Choice.$p1Choice @p_abjR $dChoice_abjT)
                                @Data.Text.Internal.Lazy.Text
                                @(Data.Either.Either Data.Text.Internal.Lazy.Text ())
                                @(Data.Either.Either Data.Text.Internal.Lazy.Text (f_abjS ()))
                                @(f_abjS Data.Text.Internal.Lazy.Text)
                                (\ (s_abjW :: Data.Text.Internal.Lazy.Text) ->
                                   case Data.Text.Lazy.null s_abjW of {
                                     GHC.Types.False ->
                                       Data.Either.Left @Data.Text.Internal.Lazy.Text @() s_abjW;
                                     GHC.Types.True ->
                                       Data.Either.Right
                                         @Data.Text.Internal.Lazy.Text @() GHC.Tuple.Prim.()
                                   })
                                (let {
                                   f2_abjZ
                                     :: Data.Text.Internal.Lazy.Text
                                        -> f_abjS Data.Text.Internal.Lazy.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abjZ
                                     = GHC.Base.pure
                                         @f_abjS
                                         $dApplicative_abjU
                                         @Data.Text.Internal.Lazy.Text } in
                                 let {
                                   ds2_abk0 :: f_abjS () -> f_abjS Data.Text.Internal.Lazy.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 70 0}]
                                   ds2_abk0
                                     = GHC.Base.fmap
                                         @f_abjS
                                         (GHC.Base.$p1Applicative @f_abjS $dApplicative_abjU)
                                         @()
                                         @Data.Text.Internal.Lazy.Text
                                         (\ (ds3_abk1 :: ()) ->
                                            case ds3_abk1 of { () ->
                                            Data.Text.Internal.Lazy.empty
                                            }) } in
                                 \ (ds3_abk3
                                      :: Data.Either.Either
                                           Data.Text.Internal.Lazy.Text (f_abjS ())) ->
                                   case ds3_abk3 of {
                                     Data.Either.Left x_abk5 -> f2_abjZ x_abk5;
                                     Data.Either.Right y_abk7 -> ds2_abk0 y_abk7
                                   }) } in
                        let {
                          g_abk9
                            :: p_abjR () (f_abjS ())
                               -> p_abjR
                                    (Data.Either.Either Data.Text.Internal.Lazy.Text ())
                                    (Data.Either.Either Data.Text.Internal.Lazy.Text (f_abjS ()))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abk9
                            = Data.Profunctor.Choice.right'
                                @p_abjR
                                $dChoice_abjT
                                @()
                                @(f_abjS ())
                                @Data.Text.Internal.Lazy.Text } in
                        \ (x_abka :: p_abjR () (f_abjS ())) -> f1_abjV (g_abk9 x_abka))
                     `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                      <Data.Text.Internal.Lazy.Text>_N)
                             :: Control.Lens.Type.Prism' Data.Text.Internal.Lazy.Text ()
                                ~R# Control.Lens.Empty.AsEmpty Data.Text.Internal.Lazy.Text)
              TyArg Data.Functor.Const.Const Data.Text.Internal.Lazy.Text
              ValArg Data.Functor.Contravariant.$fContravariantConst
                       @Data.Text.Internal.Lazy.Text
              ValArg Data.Functor.Const.$fFunctorConst
                       @Data.Text.Internal.Lazy.Text
    After:  (\ (@(f_abfk :: * -> *))
               ($dCons_abfl
                  :: Control.Lens.Cons.Cons
                       GHC.Base.String GHC.Base.String GHC.Types.Char GHC.Types.Char)
               ($dCons1_abfm
                  :: Control.Lens.Cons.Cons
                       Data.Text.Internal.Lazy.Text
                       Data.Text.Internal.Lazy.Text
                       GHC.Types.Char
                       GHC.Types.Char)
               ($dAsEmpty_abfn
                  :: Control.Lens.Empty.AsEmpty Data.Text.Internal.Lazy.Text)
               ($dContravariant_abfo
                  :: Data.Functor.Contravariant.Contravariant f_abfk)
               ($dFunctor_abfp :: GHC.Base.Functor f_abfk) ->
               Data.Profunctor.Unsafe.$fProfunctorFUN_$cdimap
                 @GHC.Base.String
                 @Data.Text.Internal.Lazy.Text
                 @(f_abfk Data.Text.Internal.Lazy.Text)
                 @(f_abfk GHC.Base.String)
                 Data.Text.Lazy.pack
                 (GHC.Base.fmap
                    @f_abfk
                    $dFunctor_abfp
                    @Data.Text.Internal.Lazy.Text
                    @GHC.Base.String
                    Data.Text.Lazy.unpack))
              @(Data.Functor.Const.Const Data.Text.Internal.Lazy.Text)
              ((\ (@(p_abgg :: * -> * -> *))
                  (@(f_abgh :: * -> *))
                  ($dChoice_abgi :: Data.Profunctor.Choice.Choice p_abgg)
                  ($dApplicative_abgj :: GHC.Base.Applicative f_abgh) ->
                  let {
                    f1_abgk
                      :: p_abgg
                           (Data.Either.Either
                              [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                           (Data.Either.Either
                              [GHC.Types.Char] (f_abgh (GHC.Types.Char, [GHC.Types.Char])))
                         -> p_abgg [GHC.Types.Char] (f_abgh [GHC.Types.Char])
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 320 0}]
                    f1_abgk
                      = Data.Profunctor.Unsafe.dimap
                          @p_abgg
                          (Data.Profunctor.Choice.$p1Choice @p_abgg $dChoice_abgi)
                          @[GHC.Types.Char]
                          @(Data.Either.Either
                              [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                          @(Data.Either.Either
                              [GHC.Types.Char] (f_abgh (GHC.Types.Char, [GHC.Types.Char])))
                          @(f_abgh [GHC.Types.Char])
                          (\ (aas_abgl :: [GHC.Types.Char]) ->
                             case aas_abgl of {
                               [] ->
                                 Data.Either.Left
                                   @[GHC.Types.Char]
                                   @(GHC.Types.Char, [GHC.Types.Char])
                                   (GHC.Types.[] @GHC.Types.Char);
                               : a1_abgn as_abgo ->
                                 Data.Either.Right
                                   @[GHC.Types.Char]
                                   @(GHC.Types.Char, [GHC.Types.Char])
                                   (a1_abgn, as_abgo)
                             })
                          (let {
                             f2_abgq :: [GHC.Types.Char] -> f_abgh [GHC.Types.Char]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abgq
                               = GHC.Base.pure @f_abgh $dApplicative_abgj @[GHC.Types.Char] } in
                           let {
                             ds2_abgr
                               :: f_abgh (GHC.Types.Char, [GHC.Types.Char])
                                  -> f_abgh [GHC.Types.Char]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 90 0}]
                             ds2_abgr
                               = GHC.Base.fmap
                                   @f_abgh
                                   (GHC.Base.$p1Applicative @f_abgh $dApplicative_abgj)
                                   @(GHC.Types.Char, [GHC.Types.Char])
                                   @[GHC.Types.Char]
                                   (\ (p1_abgs :: (GHC.Types.Char, [GHC.Types.Char])) ->
                                      GHC.Types.:
                                        @GHC.Types.Char
                                        (case p1_abgs of { (x_abgu, ds_abgv) -> x_abgu })
                                        (case p1_abgs of { (ds_abgy, y_abgz) -> y_abgz })) } in
                           \ (ds3_abgB
                                :: Data.Either.Either
                                     [GHC.Types.Char]
                                     (f_abgh (GHC.Types.Char, [GHC.Types.Char]))) ->
                             case ds3_abgB of {
                               Data.Either.Left x_abgD -> f2_abgq x_abgD;
                               Data.Either.Right y_abgF -> ds2_abgr y_abgF
                             }) } in
                  let {
                    g_abgH
                      :: p_abgg
                           (GHC.Types.Char, [GHC.Types.Char])
                           (f_abgh (GHC.Types.Char, [GHC.Types.Char]))
                         -> p_abgg
                              (Data.Either.Either
                                 [GHC.Types.Char] (GHC.Types.Char, [GHC.Types.Char]))
                              (Data.Either.Either
                                 [GHC.Types.Char] (f_abgh (GHC.Types.Char, [GHC.Types.Char])))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abgH
                      = Data.Profunctor.Choice.right'
                          @p_abgg
                          $dChoice_abgi
                          @(GHC.Types.Char, [GHC.Types.Char])
                          @(f_abgh (GHC.Types.Char, [GHC.Types.Char]))
                          @[GHC.Types.Char] } in
                  \ (x_abgI
                       :: p_abgg
                            (GHC.Types.Char, [GHC.Types.Char])
                            (f_abgh (GHC.Types.Char, [GHC.Types.Char]))) ->
                    f1_abgk (g_abgH x_abgI))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <[GHC.Types.Char]>_N
                                <[GHC.Types.Char]>_N
                                <GHC.Types.Char>_N
                                <GHC.Types.Char>_N)
                       :: Control.Lens.Type.Prism
                            [GHC.Types.Char]
                            [GHC.Types.Char]
                            (GHC.Types.Char, [GHC.Types.Char])
                            (GHC.Types.Char, [GHC.Types.Char])
                          ~R# Control.Lens.Cons.Cons
                                [GHC.Types.Char] [GHC.Types.Char] GHC.Types.Char GHC.Types.Char))
              ((\ (@(p_abj5 :: * -> * -> *))
                  (@(f_abj6 :: * -> *))
                  ($dChoice_abj7 :: Data.Profunctor.Choice.Choice p_abj5)
                  ($dApplicative_abj8 :: GHC.Base.Applicative f_abj6) ->
                  let {
                    f1_abj9
                      :: p_abj5
                           (Data.Either.Either
                              Data.Text.Internal.Lazy.Text
                              (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                           (Data.Either.Either
                              Data.Text.Internal.Lazy.Text
                              (f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                         -> p_abj5
                              Data.Text.Internal.Lazy.Text (f_abj6 Data.Text.Internal.Lazy.Text)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 639 0}]
                    f1_abj9
                      = Data.Profunctor.Unsafe.dimap
                          @p_abj5
                          (Data.Profunctor.Choice.$p1Choice @p_abj5 $dChoice_abj7)
                          @Data.Text.Internal.Lazy.Text
                          @(Data.Either.Either
                              Data.Text.Internal.Lazy.Text
                              (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                          @(Data.Either.Either
                              Data.Text.Internal.Lazy.Text
                              (f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                          @(f_abj6 Data.Text.Internal.Lazy.Text)
                          (\ (s1_abja :: Data.Text.Internal.Lazy.Text) ->
                             case s1_abja of {
                               Data.Text.Internal.Lazy.Empty ->
                                 Data.Either.Left
                                   @Data.Text.Internal.Lazy.Text
                                   @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                   Data.Text.Internal.Lazy.Empty;
                               Data.Text.Internal.Lazy.Chunk bx_abjh bx1_abji bx2_abjj ts_abjk ->
                                 Data.Either.Right
                                   @Data.Text.Internal.Lazy.Text
                                   @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                   (case GHC.Prim.indexWord8Array# bx_abjh bx1_abji of r#_abjm
                                    { __DEFAULT ->
                                    let {
                                      c#_abjn :: GHC.Prim.Int#
                                      [LclId,
                                       Unf=Unf{Src=<vanilla>, TopLvl=False,
                                               Value=False, ConLike=False, WorkFree=False,
                                               Expandable=False,
                                               Guidance=IF_ARGS [] 4 0}]
                                      c#_abjn
                                        = GHC.Prim.word2Int#
                                            (GHC.Prim.clz8#
                                               (GHC.Prim.and#
                                                  (GHC.Prim.not# (GHC.Prim.word8ToWord# r#_abjm))
                                                  255##)) } in
                                    case GHC.Prim.xorI# c#_abjn (GHC.Prim.<=# c#_abjn 0#) of {
                                      __DEFAULT ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abjh (GHC.Prim.+# bx1_abji 1#)
                                        of r#1_abjp
                                        { __DEFAULT ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abjh (GHC.Prim.+# bx1_abji 2#)
                                        of r#2_abjq
                                        { __DEFAULT ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abjh (GHC.Prim.+# bx1_abji 3#)
                                        of r#3_abjr
                                        { __DEFAULT ->
                                        GHC.Types.C#
                                          (GHC.Prim.chr#
                                             (GHC.Prim.-#
                                                (GHC.Prim.+#
                                                   (GHC.Prim.+#
                                                      (GHC.Prim.+#
                                                         (GHC.Prim.uncheckedIShiftL#
                                                            (GHC.Prim.-#
                                                               (GHC.Prim.word2Int#
                                                                  (GHC.Prim.word8ToWord# r#_abjm))
                                                               240#)
                                                            18#)
                                                         (GHC.Prim.uncheckedIShiftL#
                                                            (GHC.Prim.-#
                                                               (GHC.Prim.word2Int#
                                                                  (GHC.Prim.word8ToWord# r#1_abjp))
                                                               128#)
                                                            12#))
                                                      (GHC.Prim.uncheckedIShiftL#
                                                         (GHC.Prim.-#
                                                            (GHC.Prim.word2Int#
                                                               (GHC.Prim.word8ToWord# r#2_abjq))
                                                            128#)
                                                         6#))
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.word8ToWord# r#3_abjr)))
                                                128#))
                                        }
                                        }
                                        };
                                      1# ->
                                        GHC.Types.C#
                                          (GHC.Prim.chr#
                                             (GHC.Prim.word2Int# (GHC.Prim.word8ToWord# r#_abjm)));
                                      2# ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abjh (GHC.Prim.+# bx1_abji 1#)
                                        of r#1_abjs
                                        { __DEFAULT ->
                                        GHC.Types.C#
                                          (GHC.Prim.chr#
                                             (GHC.Prim.-#
                                                (GHC.Prim.+#
                                                   (GHC.Prim.uncheckedIShiftL#
                                                      (GHC.Prim.-#
                                                         (GHC.Prim.word2Int#
                                                            (GHC.Prim.word8ToWord# r#_abjm))
                                                         192#)
                                                      6#)
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.word8ToWord# r#1_abjs)))
                                                128#))
                                        };
                                      3# ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abjh (GHC.Prim.+# bx1_abji 1#)
                                        of r#1_abjt
                                        { __DEFAULT ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abjh (GHC.Prim.+# bx1_abji 2#)
                                        of r#2_abju
                                        { __DEFAULT ->
                                        GHC.Types.C#
                                          (GHC.Prim.chr#
                                             (GHC.Prim.-#
                                                (GHC.Prim.+#
                                                   (GHC.Prim.+#
                                                      (GHC.Prim.uncheckedIShiftL#
                                                         (GHC.Prim.-#
                                                            (GHC.Prim.word2Int#
                                                               (GHC.Prim.word8ToWord# r#_abjm))
                                                            224#)
                                                         12#)
                                                      (GHC.Prim.uncheckedIShiftL#
                                                         (GHC.Prim.-#
                                                            (GHC.Prim.word2Int#
                                                               (GHC.Prim.word8ToWord# r#1_abjt))
                                                            128#)
                                                         6#))
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.word8ToWord# r#2_abju)))
                                                128#))
                                        }
                                        }
                                    }
                                    },
                                    case Data.Text.compareLength
                                           (Data.Text.Internal.Text bx_abjh bx1_abji bx2_abjj)
                                           (GHC.Types.I# 1#)
                                    of {
                                      __DEFAULT ->
                                        case GHC.Prim.indexWord8Array# bx_abjh bx1_abji of r#_abjw
                                        { __DEFAULT ->
                                        let {
                                          c#_abjx :: GHC.Prim.Int#
                                          [LclId,
                                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                   Value=False, ConLike=False, WorkFree=False,
                                                   Expandable=False,
                                                   Guidance=IF_ARGS [] 4 0}]
                                          c#_abjx
                                            = GHC.Prim.word2Int#
                                                (GHC.Prim.clz8#
                                                   (GHC.Prim.and#
                                                      (GHC.Prim.not#
                                                         (GHC.Prim.word8ToWord# r#_abjw))
                                                      255##)) } in
                                        let {
                                          y_abjy :: GHC.Prim.Int#
                                          [LclId,
                                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                   Value=False, ConLike=False, WorkFree=False,
                                                   Expandable=False,
                                                   Guidance=IF_ARGS [] 2 0}]
                                          y_abjy
                                            = GHC.Prim.xorI# c#_abjx (GHC.Prim.<=# c#_abjx 0#) } in
                                        Data.Text.Internal.Lazy.$WChunk
                                          (Data.Text.Internal.$WText
                                             (Data.Text.Array.ByteArray bx_abjh)
                                             (GHC.Types.I# (GHC.Prim.+# bx1_abji y_abjy))
                                             (GHC.Types.I# (GHC.Prim.-# bx2_abjj y_abjy)))
                                          ts_abjk
                                        };
                                      GHC.Types.EQ -> ts_abjk
                                    })
                             })
                          (let {
                             f2_abjA
                               :: Data.Text.Internal.Lazy.Text
                                  -> f_abj6 Data.Text.Internal.Lazy.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abjA
                               = GHC.Base.pure
                                   @f_abj6 $dApplicative_abj8 @Data.Text.Internal.Lazy.Text } in
                           let {
                             ds2_abjB
                               :: f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                  -> f_abj6 Data.Text.Internal.Lazy.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 100 0}]
                             ds2_abjB
                               = GHC.Base.fmap
                                   @f_abj6
                                   (GHC.Base.$p1Applicative @f_abj6 $dApplicative_abj8)
                                   @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                   @Data.Text.Internal.Lazy.Text
                                   (\ (p1_abjC :: (GHC.Types.Char, Data.Text.Internal.Lazy.Text)) ->
                                      case p1_abjC of { (x_abjE, ds_abjF) ->
                                      Data.Text.Lazy.cons x_abjE ds_abjF
                                      }) } in
                           \ (ds3_abjH
                                :: Data.Either.Either
                                     Data.Text.Internal.Lazy.Text
                                     (f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text))) ->
                             case ds3_abjH of {
                               Data.Either.Left x_abjJ -> f2_abjA x_abjJ;
                               Data.Either.Right y_abjL -> ds2_abjB y_abjL
                             }) } in
                  let {
                    g_abjN
                      :: p_abj5
                           (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                           (f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                         -> p_abj5
                              (Data.Either.Either
                                 Data.Text.Internal.Lazy.Text
                                 (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                              (Data.Either.Either
                                 Data.Text.Internal.Lazy.Text
                                 (f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abjN
                      = Data.Profunctor.Choice.right'
                          @p_abj5
                          $dChoice_abj7
                          @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                          @(f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                          @Data.Text.Internal.Lazy.Text } in
                  \ (x_abjO
                       :: p_abj5
                            (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                            (f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text))) ->
                    f1_abj9 (g_abjN x_abjO))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <Data.Text.Internal.Lazy.Text>_N
                                <Data.Text.Internal.Lazy.Text>_N
                                <GHC.Types.Char>_N
                                <GHC.Types.Char>_N)
                       :: Control.Lens.Type.Prism
                            Data.Text.Internal.Lazy.Text
                            Data.Text.Internal.Lazy.Text
                            (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                            (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                          ~R# Control.Lens.Cons.Cons
                                Data.Text.Internal.Lazy.Text
                                Data.Text.Internal.Lazy.Text
                                GHC.Types.Char
                                GHC.Types.Char))
              ((\ (@(p_abjR :: * -> * -> *))
                  (@(f_abjS :: * -> *))
                  ($dChoice_abjT :: Data.Profunctor.Choice.Choice p_abjR)
                  ($dApplicative_abjU :: GHC.Base.Applicative f_abjS) ->
                  let {
                    f1_abjV
                      :: p_abjR
                           (Data.Either.Either Data.Text.Internal.Lazy.Text ())
                           (Data.Either.Either Data.Text.Internal.Lazy.Text (f_abjS ()))
                         -> p_abjR
                              Data.Text.Internal.Lazy.Text (f_abjS Data.Text.Internal.Lazy.Text)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 310 0}]
                    f1_abjV
                      = Data.Profunctor.Unsafe.dimap
                          @p_abjR
                          (Data.Profunctor.Choice.$p1Choice @p_abjR $dChoice_abjT)
                          @Data.Text.Internal.Lazy.Text
                          @(Data.Either.Either Data.Text.Internal.Lazy.Text ())
                          @(Data.Either.Either Data.Text.Internal.Lazy.Text (f_abjS ()))
                          @(f_abjS Data.Text.Internal.Lazy.Text)
                          (\ (s_abjW :: Data.Text.Internal.Lazy.Text) ->
                             case Data.Text.Lazy.null s_abjW of {
                               GHC.Types.False ->
                                 Data.Either.Left @Data.Text.Internal.Lazy.Text @() s_abjW;
                               GHC.Types.True ->
                                 Data.Either.Right
                                   @Data.Text.Internal.Lazy.Text @() GHC.Tuple.Prim.()
                             })
                          (let {
                             f2_abjZ
                               :: Data.Text.Internal.Lazy.Text
                                  -> f_abjS Data.Text.Internal.Lazy.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abjZ
                               = GHC.Base.pure
                                   @f_abjS $dApplicative_abjU @Data.Text.Internal.Lazy.Text } in
                           let {
                             ds2_abk0 :: f_abjS () -> f_abjS Data.Text.Internal.Lazy.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 70 0}]
                             ds2_abk0
                               = GHC.Base.fmap
                                   @f_abjS
                                   (GHC.Base.$p1Applicative @f_abjS $dApplicative_abjU)
                                   @()
                                   @Data.Text.Internal.Lazy.Text
                                   (\ (ds3_abk1 :: ()) ->
                                      case ds3_abk1 of { () -> Data.Text.Internal.Lazy.empty }) } in
                           \ (ds3_abk3
                                :: Data.Either.Either Data.Text.Internal.Lazy.Text (f_abjS ())) ->
                             case ds3_abk3 of {
                               Data.Either.Left x_abk5 -> f2_abjZ x_abk5;
                               Data.Either.Right y_abk7 -> ds2_abk0 y_abk7
                             }) } in
                  let {
                    g_abk9
                      :: p_abjR () (f_abjS ())
                         -> p_abjR
                              (Data.Either.Either Data.Text.Internal.Lazy.Text ())
                              (Data.Either.Either Data.Text.Internal.Lazy.Text (f_abjS ()))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abk9
                      = Data.Profunctor.Choice.right'
                          @p_abjR
                          $dChoice_abjT
                          @()
                          @(f_abjS ())
                          @Data.Text.Internal.Lazy.Text } in
                  \ (x_abka :: p_abjR () (f_abjS ())) -> f1_abjV (g_abk9 x_abka))
               `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                <Data.Text.Internal.Lazy.Text>_N)
                       :: Control.Lens.Type.Prism' Data.Text.Internal.Lazy.Text ()
                          ~R# Control.Lens.Empty.AsEmpty Data.Text.Internal.Lazy.Text))
              (Data.Functor.Contravariant.$fContravariantConst
                 @Data.Text.Internal.Lazy.Text)
              (Data.Functor.Const.$fFunctorConst @Data.Text.Internal.Lazy.Text)
    Cont:   ApplyToVal nodup hole Control.Lens.Getter.Getting
                                    Data.Text.Internal.Lazy.Text
                                    [GHC.Types.Char]
                                    Data.Text.Internal.Lazy.Text
              ((\ (ds_abeK [Occ=Once1] :: a_abeH) -> ds_abeK)
               `cast` (<a_abeH>_R
                       %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                          <*>_N <a_abeH>_R <a_abeH>_P)
                       :: (a_abeH -> a_abeH)
                          ~R# (a_abeH -> Data.Functor.Const.Const a_abeH a_abeH)))
            ApplyToVal nodup hole [GHC.Types.Char]
                                  -> Data.Functor.Const.Const
                                       Data.Text.Internal.Lazy.Text [GHC.Types.Char]
              s_a8Pv
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N <Data.Text.Internal.Lazy.Text>_R <[GHC.Types.Char]>_P
                    :: Data.Functor.Const.Const
                         Data.Text.Internal.Lazy.Text [GHC.Types.Char]
                       ~R# Data.Text.Internal.Lazy.Text)
            Stop[RuleArgCtxt] Data.Text.Internal.Lazy.Text
Rule fired
    Rule: Class op fmap
    Module: (BUILTIN)
    Before: GHC.Base.fmap
              TyArg Data.Functor.Const.Const Data.Text.Internal.Lazy.Text
              ValArg Data.Functor.Const.$fFunctorConst
                       @Data.Text.Internal.Lazy.Text
    After:  (Data.Functor.Const.$fFunctorConst2
               @Data.Text.Internal.Lazy.Text)
            `cast` (forall (a :: <*>_N) (b :: <*>_N).
                    <a -> b>_R
                    %<'GHC.Types.Many>_N ->_R <Data.Functor.Const.Const
                                                 Data.Text.Internal.Lazy.Text a>_R
                    %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                  <*>_N <Data.Text.Internal.Lazy.Text>_R <a>_P
                                              ; Sym (Data.Functor.Const.N:Const[0]
                                                         <*>_N
                                                         <Data.Text.Internal.Lazy.Text>_R
                                                         <b>_P)
                    :: (forall {a} {b}.
                        (a -> b)
                        -> Data.Functor.Const.Const Data.Text.Internal.Lazy.Text a
                        -> Data.Functor.Const.Const Data.Text.Internal.Lazy.Text a)
                       ~R# (forall {a} {b}.
                            (a -> b)
                            -> Data.Functor.Const.Const Data.Text.Internal.Lazy.Text a
                            -> Data.Functor.Const.Const Data.Text.Internal.Lazy.Text b))
    Cont:   ApplyToTy Data.Text.Internal.Lazy.Text
            ApplyToTy GHC.Base.String
            ApplyToVal nodup hole (Data.Text.Internal.Lazy.Text
                                   -> GHC.Base.String)
                                  -> Data.Functor.Const.Const
                                       Data.Text.Internal.Lazy.Text Data.Text.Internal.Lazy.Text
                                  -> Data.Functor.Const.Const
                                       Data.Text.Internal.Lazy.Text GHC.Base.String
              Data.Text.Lazy.unpack
            ApplyToVal nodup hole Data.Functor.Const.Const
                                    Data.Text.Internal.Lazy.Text Data.Text.Internal.Lazy.Text
                                  -> Data.Functor.Const.Const
                                       Data.Text.Internal.Lazy.Text GHC.Base.String
              (bc_aboH (ab_aboF x_aboI))
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N <Data.Text.Internal.Lazy.Text>_R <[GHC.Types.Char]>_P
                    :: Data.Functor.Const.Const
                         Data.Text.Internal.Lazy.Text [GHC.Types.Char]
                       ~R# Data.Text.Internal.Lazy.Text)
            Stop[RuleArgCtxt] Data.Text.Internal.Lazy.Text
Rule fired
    Rule: eqString
    Module: (GHC.Base)
    Before: GHC.Classes.==
              TyArg GHC.Base.String
              ValArg GHC.Classes.$fEqList_$s$fEqList1
              ValArg Data.Text.Lazy.unpack (Data.Text.Lazy.pack s_a8Pv)
              ValArg s_a8Pv
    After:  (\ ($dEq_ab0v :: GHC.Classes.Eq GHC.Base.String) ->
               GHC.Base.eqString)
              GHC.Classes.$fEqList_$s$fEqList1
              ValArg Data.Text.Lazy.unpack (Data.Text.Lazy.pack s_a8Pv)
              ValArg s_a8Pv
    Cont:   Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: unpack
    Module: (GHC.Base)
    Before: GHC.CString.unpackCString# ValArg "T -> TL -> T"#
    After:  (\ (a_ab7z :: GHC.Prim.Addr#) ->
               GHC.Base.build
                 @GHC.Types.Char
                 (\ (@b_ab7A) -> GHC.CString.unpackFoldrCString# @b_ab7A a_ab7z))
              "T -> TL -> T"#
    Cont:   Stop[BoringCtxt] Test.Tasty.Core.TestName
Rule fired
    Rule: Class op property
    Module: (BUILTIN)
    Before: Test.QuickCheck.Property.property
              TyArg Data.Text.Internal.Text -> GHC.Types.Bool
              ValArg $dTestable_a98O
    After:  Test.QuickCheck.Property.$fTestableFUN_$cproperty
              @Data.Text.Internal.Text
              @GHC.Types.Bool
              Test.QuickCheck.Instances.Text.$fArbitraryText0
              Data.Text.Show.$fShowText
              Test.QuickCheck.Property.$fTestableBool
    Cont:   ApplyToVal nodup hole (Data.Text.Internal.Text
                                   -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              prop_ab7M
            CastIt (Sym (Test.Tasty.QuickCheck.N:QC[0])
                    :: Test.QuickCheck.Property.Property ~R# Test.Tasty.QuickCheck.QC)
            Stop[BoringCtxt] Test.Tasty.QuickCheck.QC
Rule fired
    Rule: Class op propertyForAllShrinkShow
    Module: (BUILTIN)
    Before: Test.QuickCheck.Property.propertyForAllShrinkShow
              TyArg GHC.Types.Bool ValArg Test.QuickCheck.Property.$fTestableBool
    After:  Test.QuickCheck.Property.$fTestableBool1
            `cast` (forall (a :: <*>_N).
                    <Test.QuickCheck.Gen.Gen a>_R
                    %<'GHC.Types.Many>_N ->_R <a -> [a]>_R
                    %<'GHC.Types.Many>_N ->_R <a -> [GHC.Base.String]>_R
                    %<'GHC.Types.Many>_N ->_R <a -> GHC.Types.Bool>_R
                    %<'GHC.Types.Many>_N ->_R Sym (Test.QuickCheck.Gen.N:Gen[0]
                                                       (Test.QuickCheck.Property.N:Prop[0]))
                                              ; Sym (Test.QuickCheck.Property.N:Property[0])
                    :: (forall {a}.
                        Test.QuickCheck.Gen.Gen a
                        -> (a -> [a])
                        -> (a -> [GHC.Base.String])
                        -> (a -> GHC.Types.Bool)
                        -> Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int
                        -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result)
                       ~R# (forall {a}.
                            Test.QuickCheck.Gen.Gen a
                            -> (a -> [a])
                            -> (a -> [GHC.Base.String])
                            -> (a -> GHC.Types.Bool)
                            -> Test.QuickCheck.Property.Property))
    Cont:   ApplyToTy Data.Text.Internal.Text
            ApplyToVal nodup hole Test.QuickCheck.Gen.Gen
                                    Data.Text.Internal.Text
                                  -> (Data.Text.Internal.Text -> [Data.Text.Internal.Text])
                                  -> (Data.Text.Internal.Text -> [GHC.Base.String])
                                  -> (Data.Text.Internal.Text -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (Test.QuickCheck.Arbitrary.arbitrary @a_ab9u $dArbitrary_ab9w)
            ApplyToVal nodup hole (Data.Text.Internal.Text
                                   -> [Data.Text.Internal.Text])
                                  -> (Data.Text.Internal.Text -> [GHC.Base.String])
                                  -> (Data.Text.Internal.Text -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (Test.QuickCheck.Arbitrary.shrink @a_ab9u $dArbitrary_ab9w)
            ApplyToVal nodup hole (Data.Text.Internal.Text
                                   -> [GHC.Base.String])
                                  -> (Data.Text.Internal.Text -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (let {
                 g_ab9A [Occ=OnceL1!] :: a_ab9u -> GHC.Base.String
                 [LclId]
                 g_ab9A = GHC.Show.show @a_ab9u $dShow_ab9x } in
               \ (x_ab9B [Occ=Once1] :: a_ab9u) ->
                 GHC.Types.:
                   @GHC.Base.String (g_ab9A x_ab9B) (GHC.Types.[] @GHC.Base.String))
            ApplyToVal nodup hole (Data.Text.Internal.Text -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              f_ab9z
            CastIt (Sym (Test.Tasty.QuickCheck.N:QC[0])
                    :: Test.QuickCheck.Property.Property ~R# Test.Tasty.QuickCheck.QC)
            Stop[BoringCtxt] Test.Tasty.QuickCheck.QC
Rule fired
    Rule: Class op arbitrary
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.arbitrary
              TyArg Data.Text.Internal.Text
              ValArg Test.QuickCheck.Instances.Text.$fArbitraryText0
    After:  Test.QuickCheck.Instances.Text.$fArbitraryText3
            `cast` (Sym (Test.QuickCheck.Gen.N:Gen[0]
                             <Data.Text.Internal.Text>_R)
                    :: (Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int -> Data.Text.Internal.Text)
                       ~R# Test.QuickCheck.Gen.Gen Data.Text.Internal.Text)
    Cont:   Stop[BoringCtxt] Test.QuickCheck.Gen.Gen
                               Data.Text.Internal.Text
Rule fired
    Rule: Class op shrink
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.shrink
              TyArg Data.Text.Internal.Text
              ValArg Test.QuickCheck.Instances.Text.$fArbitraryText0
    After:  Test.QuickCheck.Instances.Text.$fArbitraryText0_$cshrink
    Cont:   Stop[BoringCtxt] Data.Text.Internal.Text
                             -> [Data.Text.Internal.Text]
Rule fired
    Rule: Class op show
    Module: (BUILTIN)
    Before: GHC.Show.show
              TyArg Data.Text.Internal.Text ValArg Data.Text.Show.$fShowText
    After:  Data.Text.Show.$fShowText_$cshow
    Cont:   Stop[RhsCtxt(NonRecursive)] Data.Text.Internal.Text
                                        -> GHC.Base.String
Rule fired
    Rule: Class op reader
    Module: (BUILTIN)
    Before: Control.Monad.Reader.Class.reader
              TyArg Data.Text.Internal.Lazy.Text
              TyArg (->) Data.Text.Internal.Lazy.Text
              ValArg Control.Monad.Reader.Class.$fMonadReaderrFUN
                       @Data.Text.Internal.Lazy.Text
    After:  \ (@a_abeP) ->
              GHC.Base.id @(Data.Text.Internal.Lazy.Text -> a_abeP)
    Cont:   ApplyToTy Data.Text.Internal.Text
            ApplyToVal nodup hole (Data.Text.Internal.Lazy.Text
                                   -> Data.Text.Internal.Text)
                                  -> Data.Text.Internal.Lazy.Text -> Data.Text.Internal.Text
              ((l_abeJ
                  ((\ (ds_abeK [Occ=Once1] :: a_abeH) -> ds_abeK)
                   `cast` (<a_abeH>_R
                           %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                              <*>_N <a_abeH>_R <a_abeH>_P)
                           :: (a_abeH -> a_abeH)
                              ~R# (a_abeH -> Data.Functor.Const.Const a_abeH a_abeH))))
               `cast` (<s_abeF>_R
                       %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                     <*>_N <a_abeH>_R <s_abeF>_P
                       :: (s_abeF -> Data.Functor.Const.Const a_abeH s_abeF)
                          ~R# (s_abeF -> a_abeH)))
            ApplyToVal nodup hole Data.Text.Internal.Lazy.Text
                                  -> Data.Text.Internal.Text
              (Control.Lens.Getter.view
                 @Data.Text.Internal.Text
                 @((->) Data.Text.Internal.Text)
                 @Data.Text.Internal.Lazy.Text
                 (Control.Monad.Reader.Class.$fMonadReaderrFUN
                    @Data.Text.Internal.Text)
                 (Control.Lens.Cons.Extras.recons
                    @Data.Text.Internal.Text
                    @GHC.Types.Char
                    @Data.Text.Internal.Lazy.Text
                    Control.Lens.Cons.$fConsTextTextCharChar0
                    Control.Lens.Cons.$fConsTextTextCharChar
                    Control.Lens.Empty.$fAsEmptyText
                    @(Data.Functor.Const.Const Data.Text.Internal.Lazy.Text)
                    (Data.Functor.Contravariant.$fContravariantConst
                       @Data.Text.Internal.Lazy.Text)
                    (Data.Functor.Const.$fFunctorConst @Data.Text.Internal.Lazy.Text))
                 s_a8Pw)
            Stop[RuleArgCtxt] Data.Text.Internal.Text
Rule fired
    Rule: recons/text-strict
    Module: (Control.Lens.Cons.Extras)
    Before: Control.Lens.Cons.Extras.recons
              TyArg Data.Text.Internal.Lazy.Text
              TyArg GHC.Types.Char
              TyArg Data.Text.Internal.Text
              ValArg (\ (@(p_abj5 :: * -> * -> *))
                        (@(f_abj6 :: * -> *))
                        ($dChoice_abj7 :: Data.Profunctor.Choice.Choice p_abj5)
                        ($dApplicative_abj8 :: GHC.Base.Applicative f_abj6) ->
                        let {
                          f1_abj9
                            :: p_abj5
                                 (Data.Either.Either
                                    Data.Text.Internal.Lazy.Text
                                    (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                                 (Data.Either.Either
                                    Data.Text.Internal.Lazy.Text
                                    (f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                               -> p_abj5
                                    Data.Text.Internal.Lazy.Text
                                    (f_abj6 Data.Text.Internal.Lazy.Text)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 639 0}]
                          f1_abj9
                            = Data.Profunctor.Unsafe.dimap
                                @p_abj5
                                (Data.Profunctor.Choice.$p1Choice @p_abj5 $dChoice_abj7)
                                @Data.Text.Internal.Lazy.Text
                                @(Data.Either.Either
                                    Data.Text.Internal.Lazy.Text
                                    (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                                @(Data.Either.Either
                                    Data.Text.Internal.Lazy.Text
                                    (f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                                @(f_abj6 Data.Text.Internal.Lazy.Text)
                                (\ (s1_abja :: Data.Text.Internal.Lazy.Text) ->
                                   case s1_abja of {
                                     Data.Text.Internal.Lazy.Empty ->
                                       Data.Either.Left
                                         @Data.Text.Internal.Lazy.Text
                                         @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                         Data.Text.Internal.Lazy.Empty;
                                     Data.Text.Internal.Lazy.Chunk bx_abjh bx1_abji bx2_abjj
                                                                   ts_abjk ->
                                       Data.Either.Right
                                         @Data.Text.Internal.Lazy.Text
                                         @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                         (case GHC.Prim.indexWord8Array# bx_abjh bx1_abji of r#_abjm
                                          { __DEFAULT ->
                                          let {
                                            c#_abjn :: GHC.Prim.Int#
                                            [LclId,
                                             Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                     Value=False, ConLike=False, WorkFree=False,
                                                     Expandable=False,
                                                     Guidance=IF_ARGS [] 4 0}]
                                            c#_abjn
                                              = GHC.Prim.word2Int#
                                                  (GHC.Prim.clz8#
                                                     (GHC.Prim.and#
                                                        (GHC.Prim.not#
                                                           (GHC.Prim.word8ToWord# r#_abjm))
                                                        255##)) } in
                                          case GHC.Prim.xorI# c#_abjn (GHC.Prim.<=# c#_abjn 0#) of {
                                            __DEFAULT ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abjh (GHC.Prim.+# bx1_abji 1#)
                                              of r#1_abjp
                                              { __DEFAULT ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abjh (GHC.Prim.+# bx1_abji 2#)
                                              of r#2_abjq
                                              { __DEFAULT ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abjh (GHC.Prim.+# bx1_abji 3#)
                                              of r#3_abjr
                                              { __DEFAULT ->
                                              GHC.Types.C#
                                                (GHC.Prim.chr#
                                                   (GHC.Prim.-#
                                                      (GHC.Prim.+#
                                                         (GHC.Prim.+#
                                                            (GHC.Prim.+#
                                                               (GHC.Prim.uncheckedIShiftL#
                                                                  (GHC.Prim.-#
                                                                     (GHC.Prim.word2Int#
                                                                        (GHC.Prim.word8ToWord#
                                                                           r#_abjm))
                                                                     240#)
                                                                  18#)
                                                               (GHC.Prim.uncheckedIShiftL#
                                                                  (GHC.Prim.-#
                                                                     (GHC.Prim.word2Int#
                                                                        (GHC.Prim.word8ToWord#
                                                                           r#1_abjp))
                                                                     128#)
                                                                  12#))
                                                            (GHC.Prim.uncheckedIShiftL#
                                                               (GHC.Prim.-#
                                                                  (GHC.Prim.word2Int#
                                                                     (GHC.Prim.word8ToWord#
                                                                        r#2_abjq))
                                                                  128#)
                                                               6#))
                                                         (GHC.Prim.word2Int#
                                                            (GHC.Prim.word8ToWord# r#3_abjr)))
                                                      128#))
                                              }
                                              }
                                              };
                                            1# ->
                                              GHC.Types.C#
                                                (GHC.Prim.chr#
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.word8ToWord# r#_abjm)));
                                            2# ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abjh (GHC.Prim.+# bx1_abji 1#)
                                              of r#1_abjs
                                              { __DEFAULT ->
                                              GHC.Types.C#
                                                (GHC.Prim.chr#
                                                   (GHC.Prim.-#
                                                      (GHC.Prim.+#
                                                         (GHC.Prim.uncheckedIShiftL#
                                                            (GHC.Prim.-#
                                                               (GHC.Prim.word2Int#
                                                                  (GHC.Prim.word8ToWord# r#_abjm))
                                                               192#)
                                                            6#)
                                                         (GHC.Prim.word2Int#
                                                            (GHC.Prim.word8ToWord# r#1_abjs)))
                                                      128#))
                                              };
                                            3# ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abjh (GHC.Prim.+# bx1_abji 1#)
                                              of r#1_abjt
                                              { __DEFAULT ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abjh (GHC.Prim.+# bx1_abji 2#)
                                              of r#2_abju
                                              { __DEFAULT ->
                                              GHC.Types.C#
                                                (GHC.Prim.chr#
                                                   (GHC.Prim.-#
                                                      (GHC.Prim.+#
                                                         (GHC.Prim.+#
                                                            (GHC.Prim.uncheckedIShiftL#
                                                               (GHC.Prim.-#
                                                                  (GHC.Prim.word2Int#
                                                                     (GHC.Prim.word8ToWord#
                                                                        r#_abjm))
                                                                  224#)
                                                               12#)
                                                            (GHC.Prim.uncheckedIShiftL#
                                                               (GHC.Prim.-#
                                                                  (GHC.Prim.word2Int#
                                                                     (GHC.Prim.word8ToWord#
                                                                        r#1_abjt))
                                                                  128#)
                                                               6#))
                                                         (GHC.Prim.word2Int#
                                                            (GHC.Prim.word8ToWord# r#2_abju)))
                                                      128#))
                                              }
                                              }
                                          }
                                          },
                                          case Data.Text.compareLength
                                                 (Data.Text.Internal.Text bx_abjh bx1_abji bx2_abjj)
                                                 (GHC.Types.I# 1#)
                                          of {
                                            __DEFAULT ->
                                              case GHC.Prim.indexWord8Array# bx_abjh bx1_abji
                                              of r#_abjw
                                              { __DEFAULT ->
                                              let {
                                                c#_abjx :: GHC.Prim.Int#
                                                [LclId,
                                                 Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                         Value=False, ConLike=False, WorkFree=False,
                                                         Expandable=False,
                                                         Guidance=IF_ARGS [] 4 0}]
                                                c#_abjx
                                                  = GHC.Prim.word2Int#
                                                      (GHC.Prim.clz8#
                                                         (GHC.Prim.and#
                                                            (GHC.Prim.not#
                                                               (GHC.Prim.word8ToWord# r#_abjw))
                                                            255##)) } in
                                              let {
                                                y_abjy :: GHC.Prim.Int#
                                                [LclId,
                                                 Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                         Value=False, ConLike=False, WorkFree=False,
                                                         Expandable=False,
                                                         Guidance=IF_ARGS [] 2 0}]
                                                y_abjy
                                                  = GHC.Prim.xorI#
                                                      c#_abjx (GHC.Prim.<=# c#_abjx 0#) } in
                                              Data.Text.Internal.Lazy.$WChunk
                                                (Data.Text.Internal.$WText
                                                   (Data.Text.Array.ByteArray bx_abjh)
                                                   (GHC.Types.I# (GHC.Prim.+# bx1_abji y_abjy))
                                                   (GHC.Types.I# (GHC.Prim.-# bx2_abjj y_abjy)))
                                                ts_abjk
                                              };
                                            GHC.Types.EQ -> ts_abjk
                                          })
                                   })
                                (let {
                                   f2_abjA
                                     :: Data.Text.Internal.Lazy.Text
                                        -> f_abj6 Data.Text.Internal.Lazy.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abjA
                                     = GHC.Base.pure
                                         @f_abj6
                                         $dApplicative_abj8
                                         @Data.Text.Internal.Lazy.Text } in
                                 let {
                                   ds2_abjB
                                     :: f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                        -> f_abj6 Data.Text.Internal.Lazy.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 100 0}]
                                   ds2_abjB
                                     = GHC.Base.fmap
                                         @f_abj6
                                         (GHC.Base.$p1Applicative @f_abj6 $dApplicative_abj8)
                                         @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                         @Data.Text.Internal.Lazy.Text
                                         (\ (p1_abjC
                                               :: (GHC.Types.Char, Data.Text.Internal.Lazy.Text)) ->
                                            case p1_abjC of { (x_abjE, ds_abjF) ->
                                            Data.Text.Lazy.cons x_abjE ds_abjF
                                            }) } in
                                 \ (ds3_abjH
                                      :: Data.Either.Either
                                           Data.Text.Internal.Lazy.Text
                                           (f_abj6
                                              (GHC.Types.Char, Data.Text.Internal.Lazy.Text))) ->
                                   case ds3_abjH of {
                                     Data.Either.Left x_abjJ -> f2_abjA x_abjJ;
                                     Data.Either.Right y_abjL -> ds2_abjB y_abjL
                                   }) } in
                        let {
                          g_abjN
                            :: p_abj5
                                 (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                 (f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                               -> p_abj5
                                    (Data.Either.Either
                                       Data.Text.Internal.Lazy.Text
                                       (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                                    (Data.Either.Either
                                       Data.Text.Internal.Lazy.Text
                                       (f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abjN
                            = Data.Profunctor.Choice.right'
                                @p_abj5
                                $dChoice_abj7
                                @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                @(f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                                @Data.Text.Internal.Lazy.Text } in
                        \ (x_abjO
                             :: p_abj5
                                  (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                  (f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text))) ->
                          f1_abj9 (g_abjN x_abjO))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <Data.Text.Internal.Lazy.Text>_N
                                      <Data.Text.Internal.Lazy.Text>_N
                                      <GHC.Types.Char>_N
                                      <GHC.Types.Char>_N)
                             :: Control.Lens.Type.Prism
                                  Data.Text.Internal.Lazy.Text
                                  Data.Text.Internal.Lazy.Text
                                  (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                  (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                ~R# Control.Lens.Cons.Cons
                                      Data.Text.Internal.Lazy.Text
                                      Data.Text.Internal.Lazy.Text
                                      GHC.Types.Char
                                      GHC.Types.Char)
              ValArg (\ (@(p_abig :: * -> * -> *))
                        (@(f_abih :: * -> *))
                        ($dChoice_abii :: Data.Profunctor.Choice.Choice p_abig)
                        ($dApplicative_abij :: GHC.Base.Applicative f_abih) ->
                        let {
                          f1_abik
                            :: p_abig
                                 (Data.Either.Either
                                    Data.Text.Internal.Text
                                    (GHC.Types.Char, Data.Text.Internal.Text))
                                 (Data.Either.Either
                                    Data.Text.Internal.Text
                                    (f_abih (GHC.Types.Char, Data.Text.Internal.Text)))
                               -> p_abig Data.Text.Internal.Text (f_abih Data.Text.Internal.Text)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 340 0}]
                          f1_abik
                            = Data.Profunctor.Unsafe.dimap
                                @p_abig
                                (Data.Profunctor.Choice.$p1Choice @p_abig $dChoice_abii)
                                @Data.Text.Internal.Text
                                @(Data.Either.Either
                                    Data.Text.Internal.Text
                                    (GHC.Types.Char, Data.Text.Internal.Text))
                                @(Data.Either.Either
                                    Data.Text.Internal.Text
                                    (f_abih (GHC.Types.Char, Data.Text.Internal.Text)))
                                @(f_abih Data.Text.Internal.Text)
                                (\ (s1_abil :: Data.Text.Internal.Text) ->
                                   case Data.Text.uncons s1_abil of {
                                     GHC.Maybe.Nothing ->
                                       Data.Either.Left
                                         @Data.Text.Internal.Text
                                         @(GHC.Types.Char, Data.Text.Internal.Text)
                                         s1_abil;
                                     GHC.Maybe.Just x_abio ->
                                       Data.Either.Right
                                         @Data.Text.Internal.Text
                                         @(GHC.Types.Char, Data.Text.Internal.Text)
                                         x_abio
                                   })
                                (let {
                                   f2_abiq
                                     :: Data.Text.Internal.Text -> f_abih Data.Text.Internal.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abiq
                                     = GHC.Base.pure
                                         @f_abih $dApplicative_abij @Data.Text.Internal.Text } in
                                 let {
                                   ds2_abir
                                     :: f_abih (GHC.Types.Char, Data.Text.Internal.Text)
                                        -> f_abih Data.Text.Internal.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 100 0}]
                                   ds2_abir
                                     = GHC.Base.fmap
                                         @f_abih
                                         (GHC.Base.$p1Applicative @f_abih $dApplicative_abij)
                                         @(GHC.Types.Char, Data.Text.Internal.Text)
                                         @Data.Text.Internal.Text
                                         (\ (p1_abis
                                               :: (GHC.Types.Char, Data.Text.Internal.Text)) ->
                                            case p1_abis of { (x_abiu, ds_abiv) ->
                                            Data.Text.cons x_abiu ds_abiv
                                            }) } in
                                 \ (ds3_abix
                                      :: Data.Either.Either
                                           Data.Text.Internal.Text
                                           (f_abih (GHC.Types.Char, Data.Text.Internal.Text))) ->
                                   case ds3_abix of {
                                     Data.Either.Left x_abiz -> f2_abiq x_abiz;
                                     Data.Either.Right y_abiB -> ds2_abir y_abiB
                                   }) } in
                        let {
                          g_abiD
                            :: p_abig
                                 (GHC.Types.Char, Data.Text.Internal.Text)
                                 (f_abih (GHC.Types.Char, Data.Text.Internal.Text))
                               -> p_abig
                                    (Data.Either.Either
                                       Data.Text.Internal.Text
                                       (GHC.Types.Char, Data.Text.Internal.Text))
                                    (Data.Either.Either
                                       Data.Text.Internal.Text
                                       (f_abih (GHC.Types.Char, Data.Text.Internal.Text)))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abiD
                            = Data.Profunctor.Choice.right'
                                @p_abig
                                $dChoice_abii
                                @(GHC.Types.Char, Data.Text.Internal.Text)
                                @(f_abih (GHC.Types.Char, Data.Text.Internal.Text))
                                @Data.Text.Internal.Text } in
                        \ (x_abiE
                             :: p_abig
                                  (GHC.Types.Char, Data.Text.Internal.Text)
                                  (f_abih (GHC.Types.Char, Data.Text.Internal.Text))) ->
                          f1_abik (g_abiD x_abiE))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <Data.Text.Internal.Text>_N
                                      <Data.Text.Internal.Text>_N
                                      <GHC.Types.Char>_N
                                      <GHC.Types.Char>_N)
                             :: Control.Lens.Type.Prism
                                  Data.Text.Internal.Text
                                  Data.Text.Internal.Text
                                  (GHC.Types.Char, Data.Text.Internal.Text)
                                  (GHC.Types.Char, Data.Text.Internal.Text)
                                ~R# Control.Lens.Cons.Cons
                                      Data.Text.Internal.Text
                                      Data.Text.Internal.Text
                                      GHC.Types.Char
                                      GHC.Types.Char)
              ValArg (\ (@(p_abiF :: * -> * -> *))
                        (@(f_abiG :: * -> *))
                        ($dChoice_abiH :: Data.Profunctor.Choice.Choice p_abiF)
                        ($dApplicative_abiI :: GHC.Base.Applicative f_abiG) ->
                        let {
                          f1_abiJ
                            :: p_abiF
                                 (Data.Either.Either Data.Text.Internal.Text ())
                                 (Data.Either.Either Data.Text.Internal.Text (f_abiG ()))
                               -> p_abiF Data.Text.Internal.Text (f_abiG Data.Text.Internal.Text)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 310 0}]
                          f1_abiJ
                            = Data.Profunctor.Unsafe.dimap
                                @p_abiF
                                (Data.Profunctor.Choice.$p1Choice @p_abiF $dChoice_abiH)
                                @Data.Text.Internal.Text
                                @(Data.Either.Either Data.Text.Internal.Text ())
                                @(Data.Either.Either Data.Text.Internal.Text (f_abiG ()))
                                @(f_abiG Data.Text.Internal.Text)
                                (\ (s_abiK :: Data.Text.Internal.Text) ->
                                   case Data.Text.null s_abiK of {
                                     GHC.Types.False ->
                                       Data.Either.Left @Data.Text.Internal.Text @() s_abiK;
                                     GHC.Types.True ->
                                       Data.Either.Right
                                         @Data.Text.Internal.Text @() GHC.Tuple.Prim.()
                                   })
                                (let {
                                   f2_abiN
                                     :: Data.Text.Internal.Text -> f_abiG Data.Text.Internal.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abiN
                                     = GHC.Base.pure
                                         @f_abiG $dApplicative_abiI @Data.Text.Internal.Text } in
                                 let {
                                   ds2_abiO :: f_abiG () -> f_abiG Data.Text.Internal.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 70 0}]
                                   ds2_abiO
                                     = GHC.Base.fmap
                                         @f_abiG
                                         (GHC.Base.$p1Applicative @f_abiG $dApplicative_abiI)
                                         @()
                                         @Data.Text.Internal.Text
                                         (\ (ds3_abiP :: ()) ->
                                            case ds3_abiP of { () ->
                                            Data.Text.Internal.empty
                                            }) } in
                                 \ (ds3_abiR
                                      :: Data.Either.Either Data.Text.Internal.Text (f_abiG ())) ->
                                   case ds3_abiR of {
                                     Data.Either.Left x_abiT -> f2_abiN x_abiT;
                                     Data.Either.Right y_abiV -> ds2_abiO y_abiV
                                   }) } in
                        let {
                          g_abiX
                            :: p_abiF () (f_abiG ())
                               -> p_abiF
                                    (Data.Either.Either Data.Text.Internal.Text ())
                                    (Data.Either.Either Data.Text.Internal.Text (f_abiG ()))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abiX
                            = Data.Profunctor.Choice.right'
                                @p_abiF
                                $dChoice_abiH
                                @()
                                @(f_abiG ())
                                @Data.Text.Internal.Text } in
                        \ (x_abiY :: p_abiF () (f_abiG ())) -> f1_abiJ (g_abiX x_abiY))
                     `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                      <Data.Text.Internal.Text>_N)
                             :: Control.Lens.Type.Prism' Data.Text.Internal.Text ()
                                ~R# Control.Lens.Empty.AsEmpty Data.Text.Internal.Text)
              TyArg Data.Functor.Const.Const Data.Text.Internal.Text
              ValArg Data.Functor.Contravariant.$fContravariantConst
                       @Data.Text.Internal.Text
              ValArg Data.Functor.Const.$fFunctorConst @Data.Text.Internal.Text
    After:  (\ (@(f_abf2 :: * -> *))
               ($dCons_abf3
                  :: Control.Lens.Cons.Cons
                       Data.Text.Internal.Lazy.Text
                       Data.Text.Internal.Lazy.Text
                       GHC.Types.Char
                       GHC.Types.Char)
               ($dCons1_abf4
                  :: Control.Lens.Cons.Cons
                       Data.Text.Internal.Text
                       Data.Text.Internal.Text
                       GHC.Types.Char
                       GHC.Types.Char)
               ($dAsEmpty_abf5
                  :: Control.Lens.Empty.AsEmpty Data.Text.Internal.Text)
               ($dContravariant_abf6
                  :: Data.Functor.Contravariant.Contravariant f_abf2)
               ($dFunctor_abf7 :: GHC.Base.Functor f_abf2) ->
               Data.Profunctor.Unsafe.$fProfunctorFUN_$cdimap
                 @Data.Text.Internal.Lazy.Text
                 @Data.Text.Internal.Text
                 @(f_abf2 Data.Text.Internal.Text)
                 @(f_abf2 Data.Text.Internal.Lazy.Text)
                 Data.Text.Lazy.toStrict
                 (GHC.Base.fmap
                    @f_abf2
                    $dFunctor_abf7
                    @Data.Text.Internal.Text
                    @Data.Text.Internal.Lazy.Text
                    Data.Text.Lazy.fromStrict))
              @(Data.Functor.Const.Const Data.Text.Internal.Text)
              ((\ (@(p_abj5 :: * -> * -> *))
                  (@(f_abj6 :: * -> *))
                  ($dChoice_abj7 :: Data.Profunctor.Choice.Choice p_abj5)
                  ($dApplicative_abj8 :: GHC.Base.Applicative f_abj6) ->
                  let {
                    f1_abj9
                      :: p_abj5
                           (Data.Either.Either
                              Data.Text.Internal.Lazy.Text
                              (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                           (Data.Either.Either
                              Data.Text.Internal.Lazy.Text
                              (f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                         -> p_abj5
                              Data.Text.Internal.Lazy.Text (f_abj6 Data.Text.Internal.Lazy.Text)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 639 0}]
                    f1_abj9
                      = Data.Profunctor.Unsafe.dimap
                          @p_abj5
                          (Data.Profunctor.Choice.$p1Choice @p_abj5 $dChoice_abj7)
                          @Data.Text.Internal.Lazy.Text
                          @(Data.Either.Either
                              Data.Text.Internal.Lazy.Text
                              (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                          @(Data.Either.Either
                              Data.Text.Internal.Lazy.Text
                              (f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                          @(f_abj6 Data.Text.Internal.Lazy.Text)
                          (\ (s1_abja :: Data.Text.Internal.Lazy.Text) ->
                             case s1_abja of {
                               Data.Text.Internal.Lazy.Empty ->
                                 Data.Either.Left
                                   @Data.Text.Internal.Lazy.Text
                                   @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                   Data.Text.Internal.Lazy.Empty;
                               Data.Text.Internal.Lazy.Chunk bx_abjh bx1_abji bx2_abjj ts_abjk ->
                                 Data.Either.Right
                                   @Data.Text.Internal.Lazy.Text
                                   @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                   (case GHC.Prim.indexWord8Array# bx_abjh bx1_abji of r#_abjm
                                    { __DEFAULT ->
                                    let {
                                      c#_abjn :: GHC.Prim.Int#
                                      [LclId,
                                       Unf=Unf{Src=<vanilla>, TopLvl=False,
                                               Value=False, ConLike=False, WorkFree=False,
                                               Expandable=False,
                                               Guidance=IF_ARGS [] 4 0}]
                                      c#_abjn
                                        = GHC.Prim.word2Int#
                                            (GHC.Prim.clz8#
                                               (GHC.Prim.and#
                                                  (GHC.Prim.not# (GHC.Prim.word8ToWord# r#_abjm))
                                                  255##)) } in
                                    case GHC.Prim.xorI# c#_abjn (GHC.Prim.<=# c#_abjn 0#) of {
                                      __DEFAULT ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abjh (GHC.Prim.+# bx1_abji 1#)
                                        of r#1_abjp
                                        { __DEFAULT ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abjh (GHC.Prim.+# bx1_abji 2#)
                                        of r#2_abjq
                                        { __DEFAULT ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abjh (GHC.Prim.+# bx1_abji 3#)
                                        of r#3_abjr
                                        { __DEFAULT ->
                                        GHC.Types.C#
                                          (GHC.Prim.chr#
                                             (GHC.Prim.-#
                                                (GHC.Prim.+#
                                                   (GHC.Prim.+#
                                                      (GHC.Prim.+#
                                                         (GHC.Prim.uncheckedIShiftL#
                                                            (GHC.Prim.-#
                                                               (GHC.Prim.word2Int#
                                                                  (GHC.Prim.word8ToWord# r#_abjm))
                                                               240#)
                                                            18#)
                                                         (GHC.Prim.uncheckedIShiftL#
                                                            (GHC.Prim.-#
                                                               (GHC.Prim.word2Int#
                                                                  (GHC.Prim.word8ToWord# r#1_abjp))
                                                               128#)
                                                            12#))
                                                      (GHC.Prim.uncheckedIShiftL#
                                                         (GHC.Prim.-#
                                                            (GHC.Prim.word2Int#
                                                               (GHC.Prim.word8ToWord# r#2_abjq))
                                                            128#)
                                                         6#))
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.word8ToWord# r#3_abjr)))
                                                128#))
                                        }
                                        }
                                        };
                                      1# ->
                                        GHC.Types.C#
                                          (GHC.Prim.chr#
                                             (GHC.Prim.word2Int# (GHC.Prim.word8ToWord# r#_abjm)));
                                      2# ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abjh (GHC.Prim.+# bx1_abji 1#)
                                        of r#1_abjs
                                        { __DEFAULT ->
                                        GHC.Types.C#
                                          (GHC.Prim.chr#
                                             (GHC.Prim.-#
                                                (GHC.Prim.+#
                                                   (GHC.Prim.uncheckedIShiftL#
                                                      (GHC.Prim.-#
                                                         (GHC.Prim.word2Int#
                                                            (GHC.Prim.word8ToWord# r#_abjm))
                                                         192#)
                                                      6#)
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.word8ToWord# r#1_abjs)))
                                                128#))
                                        };
                                      3# ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abjh (GHC.Prim.+# bx1_abji 1#)
                                        of r#1_abjt
                                        { __DEFAULT ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abjh (GHC.Prim.+# bx1_abji 2#)
                                        of r#2_abju
                                        { __DEFAULT ->
                                        GHC.Types.C#
                                          (GHC.Prim.chr#
                                             (GHC.Prim.-#
                                                (GHC.Prim.+#
                                                   (GHC.Prim.+#
                                                      (GHC.Prim.uncheckedIShiftL#
                                                         (GHC.Prim.-#
                                                            (GHC.Prim.word2Int#
                                                               (GHC.Prim.word8ToWord# r#_abjm))
                                                            224#)
                                                         12#)
                                                      (GHC.Prim.uncheckedIShiftL#
                                                         (GHC.Prim.-#
                                                            (GHC.Prim.word2Int#
                                                               (GHC.Prim.word8ToWord# r#1_abjt))
                                                            128#)
                                                         6#))
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.word8ToWord# r#2_abju)))
                                                128#))
                                        }
                                        }
                                    }
                                    },
                                    case Data.Text.compareLength
                                           (Data.Text.Internal.Text bx_abjh bx1_abji bx2_abjj)
                                           (GHC.Types.I# 1#)
                                    of {
                                      __DEFAULT ->
                                        case GHC.Prim.indexWord8Array# bx_abjh bx1_abji of r#_abjw
                                        { __DEFAULT ->
                                        let {
                                          c#_abjx :: GHC.Prim.Int#
                                          [LclId,
                                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                   Value=False, ConLike=False, WorkFree=False,
                                                   Expandable=False,
                                                   Guidance=IF_ARGS [] 4 0}]
                                          c#_abjx
                                            = GHC.Prim.word2Int#
                                                (GHC.Prim.clz8#
                                                   (GHC.Prim.and#
                                                      (GHC.Prim.not#
                                                         (GHC.Prim.word8ToWord# r#_abjw))
                                                      255##)) } in
                                        let {
                                          y_abjy :: GHC.Prim.Int#
                                          [LclId,
                                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                   Value=False, ConLike=False, WorkFree=False,
                                                   Expandable=False,
                                                   Guidance=IF_ARGS [] 2 0}]
                                          y_abjy
                                            = GHC.Prim.xorI# c#_abjx (GHC.Prim.<=# c#_abjx 0#) } in
                                        Data.Text.Internal.Lazy.$WChunk
                                          (Data.Text.Internal.$WText
                                             (Data.Text.Array.ByteArray bx_abjh)
                                             (GHC.Types.I# (GHC.Prim.+# bx1_abji y_abjy))
                                             (GHC.Types.I# (GHC.Prim.-# bx2_abjj y_abjy)))
                                          ts_abjk
                                        };
                                      GHC.Types.EQ -> ts_abjk
                                    })
                             })
                          (let {
                             f2_abjA
                               :: Data.Text.Internal.Lazy.Text
                                  -> f_abj6 Data.Text.Internal.Lazy.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abjA
                               = GHC.Base.pure
                                   @f_abj6 $dApplicative_abj8 @Data.Text.Internal.Lazy.Text } in
                           let {
                             ds2_abjB
                               :: f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                  -> f_abj6 Data.Text.Internal.Lazy.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 100 0}]
                             ds2_abjB
                               = GHC.Base.fmap
                                   @f_abj6
                                   (GHC.Base.$p1Applicative @f_abj6 $dApplicative_abj8)
                                   @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                   @Data.Text.Internal.Lazy.Text
                                   (\ (p1_abjC :: (GHC.Types.Char, Data.Text.Internal.Lazy.Text)) ->
                                      case p1_abjC of { (x_abjE, ds_abjF) ->
                                      Data.Text.Lazy.cons x_abjE ds_abjF
                                      }) } in
                           \ (ds3_abjH
                                :: Data.Either.Either
                                     Data.Text.Internal.Lazy.Text
                                     (f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text))) ->
                             case ds3_abjH of {
                               Data.Either.Left x_abjJ -> f2_abjA x_abjJ;
                               Data.Either.Right y_abjL -> ds2_abjB y_abjL
                             }) } in
                  let {
                    g_abjN
                      :: p_abj5
                           (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                           (f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                         -> p_abj5
                              (Data.Either.Either
                                 Data.Text.Internal.Lazy.Text
                                 (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                              (Data.Either.Either
                                 Data.Text.Internal.Lazy.Text
                                 (f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abjN
                      = Data.Profunctor.Choice.right'
                          @p_abj5
                          $dChoice_abj7
                          @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                          @(f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                          @Data.Text.Internal.Lazy.Text } in
                  \ (x_abjO
                       :: p_abj5
                            (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                            (f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text))) ->
                    f1_abj9 (g_abjN x_abjO))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <Data.Text.Internal.Lazy.Text>_N
                                <Data.Text.Internal.Lazy.Text>_N
                                <GHC.Types.Char>_N
                                <GHC.Types.Char>_N)
                       :: Control.Lens.Type.Prism
                            Data.Text.Internal.Lazy.Text
                            Data.Text.Internal.Lazy.Text
                            (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                            (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                          ~R# Control.Lens.Cons.Cons
                                Data.Text.Internal.Lazy.Text
                                Data.Text.Internal.Lazy.Text
                                GHC.Types.Char
                                GHC.Types.Char))
              ((\ (@(p_abig :: * -> * -> *))
                  (@(f_abih :: * -> *))
                  ($dChoice_abii :: Data.Profunctor.Choice.Choice p_abig)
                  ($dApplicative_abij :: GHC.Base.Applicative f_abih) ->
                  let {
                    f1_abik
                      :: p_abig
                           (Data.Either.Either
                              Data.Text.Internal.Text (GHC.Types.Char, Data.Text.Internal.Text))
                           (Data.Either.Either
                              Data.Text.Internal.Text
                              (f_abih (GHC.Types.Char, Data.Text.Internal.Text)))
                         -> p_abig Data.Text.Internal.Text (f_abih Data.Text.Internal.Text)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 340 0}]
                    f1_abik
                      = Data.Profunctor.Unsafe.dimap
                          @p_abig
                          (Data.Profunctor.Choice.$p1Choice @p_abig $dChoice_abii)
                          @Data.Text.Internal.Text
                          @(Data.Either.Either
                              Data.Text.Internal.Text (GHC.Types.Char, Data.Text.Internal.Text))
                          @(Data.Either.Either
                              Data.Text.Internal.Text
                              (f_abih (GHC.Types.Char, Data.Text.Internal.Text)))
                          @(f_abih Data.Text.Internal.Text)
                          (\ (s1_abil :: Data.Text.Internal.Text) ->
                             case Data.Text.uncons s1_abil of {
                               GHC.Maybe.Nothing ->
                                 Data.Either.Left
                                   @Data.Text.Internal.Text
                                   @(GHC.Types.Char, Data.Text.Internal.Text)
                                   s1_abil;
                               GHC.Maybe.Just x_abio ->
                                 Data.Either.Right
                                   @Data.Text.Internal.Text
                                   @(GHC.Types.Char, Data.Text.Internal.Text)
                                   x_abio
                             })
                          (let {
                             f2_abiq
                               :: Data.Text.Internal.Text -> f_abih Data.Text.Internal.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abiq
                               = GHC.Base.pure
                                   @f_abih $dApplicative_abij @Data.Text.Internal.Text } in
                           let {
                             ds2_abir
                               :: f_abih (GHC.Types.Char, Data.Text.Internal.Text)
                                  -> f_abih Data.Text.Internal.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 100 0}]
                             ds2_abir
                               = GHC.Base.fmap
                                   @f_abih
                                   (GHC.Base.$p1Applicative @f_abih $dApplicative_abij)
                                   @(GHC.Types.Char, Data.Text.Internal.Text)
                                   @Data.Text.Internal.Text
                                   (\ (p1_abis :: (GHC.Types.Char, Data.Text.Internal.Text)) ->
                                      case p1_abis of { (x_abiu, ds_abiv) ->
                                      Data.Text.cons x_abiu ds_abiv
                                      }) } in
                           \ (ds3_abix
                                :: Data.Either.Either
                                     Data.Text.Internal.Text
                                     (f_abih (GHC.Types.Char, Data.Text.Internal.Text))) ->
                             case ds3_abix of {
                               Data.Either.Left x_abiz -> f2_abiq x_abiz;
                               Data.Either.Right y_abiB -> ds2_abir y_abiB
                             }) } in
                  let {
                    g_abiD
                      :: p_abig
                           (GHC.Types.Char, Data.Text.Internal.Text)
                           (f_abih (GHC.Types.Char, Data.Text.Internal.Text))
                         -> p_abig
                              (Data.Either.Either
                                 Data.Text.Internal.Text (GHC.Types.Char, Data.Text.Internal.Text))
                              (Data.Either.Either
                                 Data.Text.Internal.Text
                                 (f_abih (GHC.Types.Char, Data.Text.Internal.Text)))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abiD
                      = Data.Profunctor.Choice.right'
                          @p_abig
                          $dChoice_abii
                          @(GHC.Types.Char, Data.Text.Internal.Text)
                          @(f_abih (GHC.Types.Char, Data.Text.Internal.Text))
                          @Data.Text.Internal.Text } in
                  \ (x_abiE
                       :: p_abig
                            (GHC.Types.Char, Data.Text.Internal.Text)
                            (f_abih (GHC.Types.Char, Data.Text.Internal.Text))) ->
                    f1_abik (g_abiD x_abiE))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <Data.Text.Internal.Text>_N
                                <Data.Text.Internal.Text>_N
                                <GHC.Types.Char>_N
                                <GHC.Types.Char>_N)
                       :: Control.Lens.Type.Prism
                            Data.Text.Internal.Text
                            Data.Text.Internal.Text
                            (GHC.Types.Char, Data.Text.Internal.Text)
                            (GHC.Types.Char, Data.Text.Internal.Text)
                          ~R# Control.Lens.Cons.Cons
                                Data.Text.Internal.Text
                                Data.Text.Internal.Text
                                GHC.Types.Char
                                GHC.Types.Char))
              ((\ (@(p_abiF :: * -> * -> *))
                  (@(f_abiG :: * -> *))
                  ($dChoice_abiH :: Data.Profunctor.Choice.Choice p_abiF)
                  ($dApplicative_abiI :: GHC.Base.Applicative f_abiG) ->
                  let {
                    f1_abiJ
                      :: p_abiF
                           (Data.Either.Either Data.Text.Internal.Text ())
                           (Data.Either.Either Data.Text.Internal.Text (f_abiG ()))
                         -> p_abiF Data.Text.Internal.Text (f_abiG Data.Text.Internal.Text)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 310 0}]
                    f1_abiJ
                      = Data.Profunctor.Unsafe.dimap
                          @p_abiF
                          (Data.Profunctor.Choice.$p1Choice @p_abiF $dChoice_abiH)
                          @Data.Text.Internal.Text
                          @(Data.Either.Either Data.Text.Internal.Text ())
                          @(Data.Either.Either Data.Text.Internal.Text (f_abiG ()))
                          @(f_abiG Data.Text.Internal.Text)
                          (\ (s_abiK :: Data.Text.Internal.Text) ->
                             case Data.Text.null s_abiK of {
                               GHC.Types.False ->
                                 Data.Either.Left @Data.Text.Internal.Text @() s_abiK;
                               GHC.Types.True ->
                                 Data.Either.Right @Data.Text.Internal.Text @() GHC.Tuple.Prim.()
                             })
                          (let {
                             f2_abiN
                               :: Data.Text.Internal.Text -> f_abiG Data.Text.Internal.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abiN
                               = GHC.Base.pure
                                   @f_abiG $dApplicative_abiI @Data.Text.Internal.Text } in
                           let {
                             ds2_abiO :: f_abiG () -> f_abiG Data.Text.Internal.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 70 0}]
                             ds2_abiO
                               = GHC.Base.fmap
                                   @f_abiG
                                   (GHC.Base.$p1Applicative @f_abiG $dApplicative_abiI)
                                   @()
                                   @Data.Text.Internal.Text
                                   (\ (ds3_abiP :: ()) ->
                                      case ds3_abiP of { () -> Data.Text.Internal.empty }) } in
                           \ (ds3_abiR
                                :: Data.Either.Either Data.Text.Internal.Text (f_abiG ())) ->
                             case ds3_abiR of {
                               Data.Either.Left x_abiT -> f2_abiN x_abiT;
                               Data.Either.Right y_abiV -> ds2_abiO y_abiV
                             }) } in
                  let {
                    g_abiX
                      :: p_abiF () (f_abiG ())
                         -> p_abiF
                              (Data.Either.Either Data.Text.Internal.Text ())
                              (Data.Either.Either Data.Text.Internal.Text (f_abiG ()))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abiX
                      = Data.Profunctor.Choice.right'
                          @p_abiF
                          $dChoice_abiH
                          @()
                          @(f_abiG ())
                          @Data.Text.Internal.Text } in
                  \ (x_abiY :: p_abiF () (f_abiG ())) -> f1_abiJ (g_abiX x_abiY))
               `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                <Data.Text.Internal.Text>_N)
                       :: Control.Lens.Type.Prism' Data.Text.Internal.Text ()
                          ~R# Control.Lens.Empty.AsEmpty Data.Text.Internal.Text))
              (Data.Functor.Contravariant.$fContravariantConst
                 @Data.Text.Internal.Text)
              (Data.Functor.Const.$fFunctorConst @Data.Text.Internal.Text)
    Cont:   ApplyToVal nodup hole Control.Lens.Getter.Getting
                                    Data.Text.Internal.Text
                                    Data.Text.Internal.Lazy.Text
                                    Data.Text.Internal.Text
              ((\ (ds_abeK [Occ=Once1] :: a_abeH) -> ds_abeK)
               `cast` (<a_abeH>_R
                       %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                          <*>_N <a_abeH>_R <a_abeH>_P)
                       :: (a_abeH -> a_abeH)
                          ~R# (a_abeH -> Data.Functor.Const.Const a_abeH a_abeH)))
            ApplyToVal nodup hole Data.Text.Internal.Lazy.Text
                                  -> Data.Functor.Const.Const
                                       Data.Text.Internal.Text Data.Text.Internal.Lazy.Text
              (Control.Lens.Getter.view
                 @Data.Text.Internal.Text
                 @((->) Data.Text.Internal.Text)
                 @Data.Text.Internal.Lazy.Text
                 (Control.Monad.Reader.Class.$fMonadReaderrFUN
                    @Data.Text.Internal.Text)
                 (Control.Lens.Cons.Extras.recons
                    @Data.Text.Internal.Text
                    @GHC.Types.Char
                    @Data.Text.Internal.Lazy.Text
                    Control.Lens.Cons.$fConsTextTextCharChar0
                    Control.Lens.Cons.$fConsTextTextCharChar
                    Control.Lens.Empty.$fAsEmptyText
                    @(Data.Functor.Const.Const Data.Text.Internal.Lazy.Text)
                    (Data.Functor.Contravariant.$fContravariantConst
                       @Data.Text.Internal.Lazy.Text)
                    (Data.Functor.Const.$fFunctorConst @Data.Text.Internal.Lazy.Text))
                 s_a8Pw)
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N <Data.Text.Internal.Text>_R <Data.Text.Internal.Lazy.Text>_P
                    :: Data.Functor.Const.Const
                         Data.Text.Internal.Text Data.Text.Internal.Lazy.Text
                       ~R# Data.Text.Internal.Text)
            Stop[RuleArgCtxt] Data.Text.Internal.Text
Rule fired
    Rule: Class op fmap
    Module: (BUILTIN)
    Before: GHC.Base.fmap
              TyArg Data.Functor.Const.Const Data.Text.Internal.Text
              ValArg Data.Functor.Const.$fFunctorConst @Data.Text.Internal.Text
    After:  (Data.Functor.Const.$fFunctorConst2
               @Data.Text.Internal.Text)
            `cast` (forall (a :: <*>_N) (b :: <*>_N).
                    <a -> b>_R
                    %<'GHC.Types.Many>_N ->_R <Data.Functor.Const.Const
                                                 Data.Text.Internal.Text a>_R
                    %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                  <*>_N <Data.Text.Internal.Text>_R <a>_P
                                              ; Sym (Data.Functor.Const.N:Const[0]
                                                         <*>_N <Data.Text.Internal.Text>_R <b>_P)
                    :: (forall {a} {b}.
                        (a -> b)
                        -> Data.Functor.Const.Const Data.Text.Internal.Text a
                        -> Data.Functor.Const.Const Data.Text.Internal.Text a)
                       ~R# (forall {a} {b}.
                            (a -> b)
                            -> Data.Functor.Const.Const Data.Text.Internal.Text a
                            -> Data.Functor.Const.Const Data.Text.Internal.Text b))
    Cont:   ApplyToTy Data.Text.Internal.Text
            ApplyToTy Data.Text.Internal.Lazy.Text
            ApplyToVal nodup hole (Data.Text.Internal.Text
                                   -> Data.Text.Internal.Lazy.Text)
                                  -> Data.Functor.Const.Const
                                       Data.Text.Internal.Text Data.Text.Internal.Text
                                  -> Data.Functor.Const.Const
                                       Data.Text.Internal.Text Data.Text.Internal.Lazy.Text
              Data.Text.Lazy.fromStrict
            ApplyToVal nodup hole Data.Functor.Const.Const
                                    Data.Text.Internal.Text Data.Text.Internal.Text
                                  -> Data.Functor.Const.Const
                                       Data.Text.Internal.Text Data.Text.Internal.Lazy.Text
              (bc_aboH (ab_aboF x_aboI))
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N <Data.Text.Internal.Text>_R <Data.Text.Internal.Lazy.Text>_P
                    :: Data.Functor.Const.Const
                         Data.Text.Internal.Text Data.Text.Internal.Lazy.Text
                       ~R# Data.Text.Internal.Text)
            Stop[RuleArgCtxt] Data.Text.Internal.Text
Rule fired
    Rule: Class op reader
    Module: (BUILTIN)
    Before: Control.Monad.Reader.Class.reader
              TyArg Data.Text.Internal.Text
              TyArg (->) Data.Text.Internal.Text
              ValArg Control.Monad.Reader.Class.$fMonadReaderrFUN
                       @Data.Text.Internal.Text
    After:  \ (@a_abeP) ->
              GHC.Base.id @(Data.Text.Internal.Text -> a_abeP)
    Cont:   ApplyToTy Data.Text.Internal.Lazy.Text
            ApplyToVal nodup hole (Data.Text.Internal.Text
                                   -> Data.Text.Internal.Lazy.Text)
                                  -> Data.Text.Internal.Text -> Data.Text.Internal.Lazy.Text
              ((l_abeJ
                  ((\ (ds_abeK [Occ=Once1] :: a_abeH) -> ds_abeK)
                   `cast` (<a_abeH>_R
                           %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                              <*>_N <a_abeH>_R <a_abeH>_P)
                           :: (a_abeH -> a_abeH)
                              ~R# (a_abeH -> Data.Functor.Const.Const a_abeH a_abeH))))
               `cast` (<s_abeF>_R
                       %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                     <*>_N <a_abeH>_R <s_abeF>_P
                       :: (s_abeF -> Data.Functor.Const.Const a_abeH s_abeF)
                          ~R# (s_abeF -> a_abeH)))
            ApplyToVal nodup hole Data.Text.Internal.Text
                                  -> Data.Text.Internal.Lazy.Text
              s_a8Pw
            Stop[RuleArgCtxt] Data.Text.Internal.Lazy.Text
Rule fired
    Rule: recons/text-lazy
    Module: (Control.Lens.Cons.Extras)
    Before: Control.Lens.Cons.Extras.recons
              TyArg Data.Text.Internal.Text
              TyArg GHC.Types.Char
              TyArg Data.Text.Internal.Lazy.Text
              ValArg (\ (@(p_abig :: * -> * -> *))
                        (@(f_abih :: * -> *))
                        ($dChoice_abii :: Data.Profunctor.Choice.Choice p_abig)
                        ($dApplicative_abij :: GHC.Base.Applicative f_abih) ->
                        let {
                          f1_abik
                            :: p_abig
                                 (Data.Either.Either
                                    Data.Text.Internal.Text
                                    (GHC.Types.Char, Data.Text.Internal.Text))
                                 (Data.Either.Either
                                    Data.Text.Internal.Text
                                    (f_abih (GHC.Types.Char, Data.Text.Internal.Text)))
                               -> p_abig Data.Text.Internal.Text (f_abih Data.Text.Internal.Text)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 340 0}]
                          f1_abik
                            = Data.Profunctor.Unsafe.dimap
                                @p_abig
                                (Data.Profunctor.Choice.$p1Choice @p_abig $dChoice_abii)
                                @Data.Text.Internal.Text
                                @(Data.Either.Either
                                    Data.Text.Internal.Text
                                    (GHC.Types.Char, Data.Text.Internal.Text))
                                @(Data.Either.Either
                                    Data.Text.Internal.Text
                                    (f_abih (GHC.Types.Char, Data.Text.Internal.Text)))
                                @(f_abih Data.Text.Internal.Text)
                                (\ (s1_abil :: Data.Text.Internal.Text) ->
                                   case Data.Text.uncons s1_abil of {
                                     GHC.Maybe.Nothing ->
                                       Data.Either.Left
                                         @Data.Text.Internal.Text
                                         @(GHC.Types.Char, Data.Text.Internal.Text)
                                         s1_abil;
                                     GHC.Maybe.Just x_abio ->
                                       Data.Either.Right
                                         @Data.Text.Internal.Text
                                         @(GHC.Types.Char, Data.Text.Internal.Text)
                                         x_abio
                                   })
                                (let {
                                   f2_abiq
                                     :: Data.Text.Internal.Text -> f_abih Data.Text.Internal.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abiq
                                     = GHC.Base.pure
                                         @f_abih $dApplicative_abij @Data.Text.Internal.Text } in
                                 let {
                                   ds2_abir
                                     :: f_abih (GHC.Types.Char, Data.Text.Internal.Text)
                                        -> f_abih Data.Text.Internal.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 100 0}]
                                   ds2_abir
                                     = GHC.Base.fmap
                                         @f_abih
                                         (GHC.Base.$p1Applicative @f_abih $dApplicative_abij)
                                         @(GHC.Types.Char, Data.Text.Internal.Text)
                                         @Data.Text.Internal.Text
                                         (\ (p1_abis
                                               :: (GHC.Types.Char, Data.Text.Internal.Text)) ->
                                            case p1_abis of { (x_abiu, ds_abiv) ->
                                            Data.Text.cons x_abiu ds_abiv
                                            }) } in
                                 \ (ds3_abix
                                      :: Data.Either.Either
                                           Data.Text.Internal.Text
                                           (f_abih (GHC.Types.Char, Data.Text.Internal.Text))) ->
                                   case ds3_abix of {
                                     Data.Either.Left x_abiz -> f2_abiq x_abiz;
                                     Data.Either.Right y_abiB -> ds2_abir y_abiB
                                   }) } in
                        let {
                          g_abiD
                            :: p_abig
                                 (GHC.Types.Char, Data.Text.Internal.Text)
                                 (f_abih (GHC.Types.Char, Data.Text.Internal.Text))
                               -> p_abig
                                    (Data.Either.Either
                                       Data.Text.Internal.Text
                                       (GHC.Types.Char, Data.Text.Internal.Text))
                                    (Data.Either.Either
                                       Data.Text.Internal.Text
                                       (f_abih (GHC.Types.Char, Data.Text.Internal.Text)))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abiD
                            = Data.Profunctor.Choice.right'
                                @p_abig
                                $dChoice_abii
                                @(GHC.Types.Char, Data.Text.Internal.Text)
                                @(f_abih (GHC.Types.Char, Data.Text.Internal.Text))
                                @Data.Text.Internal.Text } in
                        \ (x_abiE
                             :: p_abig
                                  (GHC.Types.Char, Data.Text.Internal.Text)
                                  (f_abih (GHC.Types.Char, Data.Text.Internal.Text))) ->
                          f1_abik (g_abiD x_abiE))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <Data.Text.Internal.Text>_N
                                      <Data.Text.Internal.Text>_N
                                      <GHC.Types.Char>_N
                                      <GHC.Types.Char>_N)
                             :: Control.Lens.Type.Prism
                                  Data.Text.Internal.Text
                                  Data.Text.Internal.Text
                                  (GHC.Types.Char, Data.Text.Internal.Text)
                                  (GHC.Types.Char, Data.Text.Internal.Text)
                                ~R# Control.Lens.Cons.Cons
                                      Data.Text.Internal.Text
                                      Data.Text.Internal.Text
                                      GHC.Types.Char
                                      GHC.Types.Char)
              ValArg (\ (@(p_abj5 :: * -> * -> *))
                        (@(f_abj6 :: * -> *))
                        ($dChoice_abj7 :: Data.Profunctor.Choice.Choice p_abj5)
                        ($dApplicative_abj8 :: GHC.Base.Applicative f_abj6) ->
                        let {
                          f1_abj9
                            :: p_abj5
                                 (Data.Either.Either
                                    Data.Text.Internal.Lazy.Text
                                    (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                                 (Data.Either.Either
                                    Data.Text.Internal.Lazy.Text
                                    (f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                               -> p_abj5
                                    Data.Text.Internal.Lazy.Text
                                    (f_abj6 Data.Text.Internal.Lazy.Text)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 639 0}]
                          f1_abj9
                            = Data.Profunctor.Unsafe.dimap
                                @p_abj5
                                (Data.Profunctor.Choice.$p1Choice @p_abj5 $dChoice_abj7)
                                @Data.Text.Internal.Lazy.Text
                                @(Data.Either.Either
                                    Data.Text.Internal.Lazy.Text
                                    (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                                @(Data.Either.Either
                                    Data.Text.Internal.Lazy.Text
                                    (f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                                @(f_abj6 Data.Text.Internal.Lazy.Text)
                                (\ (s1_abja :: Data.Text.Internal.Lazy.Text) ->
                                   case s1_abja of {
                                     Data.Text.Internal.Lazy.Empty ->
                                       Data.Either.Left
                                         @Data.Text.Internal.Lazy.Text
                                         @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                         Data.Text.Internal.Lazy.Empty;
                                     Data.Text.Internal.Lazy.Chunk bx_abjh bx1_abji bx2_abjj
                                                                   ts_abjk ->
                                       Data.Either.Right
                                         @Data.Text.Internal.Lazy.Text
                                         @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                         (case GHC.Prim.indexWord8Array# bx_abjh bx1_abji of r#_abjm
                                          { __DEFAULT ->
                                          let {
                                            c#_abjn :: GHC.Prim.Int#
                                            [LclId,
                                             Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                     Value=False, ConLike=False, WorkFree=False,
                                                     Expandable=False,
                                                     Guidance=IF_ARGS [] 4 0}]
                                            c#_abjn
                                              = GHC.Prim.word2Int#
                                                  (GHC.Prim.clz8#
                                                     (GHC.Prim.and#
                                                        (GHC.Prim.not#
                                                           (GHC.Prim.word8ToWord# r#_abjm))
                                                        255##)) } in
                                          case GHC.Prim.xorI# c#_abjn (GHC.Prim.<=# c#_abjn 0#) of {
                                            __DEFAULT ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abjh (GHC.Prim.+# bx1_abji 1#)
                                              of r#1_abjp
                                              { __DEFAULT ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abjh (GHC.Prim.+# bx1_abji 2#)
                                              of r#2_abjq
                                              { __DEFAULT ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abjh (GHC.Prim.+# bx1_abji 3#)
                                              of r#3_abjr
                                              { __DEFAULT ->
                                              GHC.Types.C#
                                                (GHC.Prim.chr#
                                                   (GHC.Prim.-#
                                                      (GHC.Prim.+#
                                                         (GHC.Prim.+#
                                                            (GHC.Prim.+#
                                                               (GHC.Prim.uncheckedIShiftL#
                                                                  (GHC.Prim.-#
                                                                     (GHC.Prim.word2Int#
                                                                        (GHC.Prim.word8ToWord#
                                                                           r#_abjm))
                                                                     240#)
                                                                  18#)
                                                               (GHC.Prim.uncheckedIShiftL#
                                                                  (GHC.Prim.-#
                                                                     (GHC.Prim.word2Int#
                                                                        (GHC.Prim.word8ToWord#
                                                                           r#1_abjp))
                                                                     128#)
                                                                  12#))
                                                            (GHC.Prim.uncheckedIShiftL#
                                                               (GHC.Prim.-#
                                                                  (GHC.Prim.word2Int#
                                                                     (GHC.Prim.word8ToWord#
                                                                        r#2_abjq))
                                                                  128#)
                                                               6#))
                                                         (GHC.Prim.word2Int#
                                                            (GHC.Prim.word8ToWord# r#3_abjr)))
                                                      128#))
                                              }
                                              }
                                              };
                                            1# ->
                                              GHC.Types.C#
                                                (GHC.Prim.chr#
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.word8ToWord# r#_abjm)));
                                            2# ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abjh (GHC.Prim.+# bx1_abji 1#)
                                              of r#1_abjs
                                              { __DEFAULT ->
                                              GHC.Types.C#
                                                (GHC.Prim.chr#
                                                   (GHC.Prim.-#
                                                      (GHC.Prim.+#
                                                         (GHC.Prim.uncheckedIShiftL#
                                                            (GHC.Prim.-#
                                                               (GHC.Prim.word2Int#
                                                                  (GHC.Prim.word8ToWord# r#_abjm))
                                                               192#)
                                                            6#)
                                                         (GHC.Prim.word2Int#
                                                            (GHC.Prim.word8ToWord# r#1_abjs)))
                                                      128#))
                                              };
                                            3# ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abjh (GHC.Prim.+# bx1_abji 1#)
                                              of r#1_abjt
                                              { __DEFAULT ->
                                              case GHC.Prim.indexWord8Array#
                                                     bx_abjh (GHC.Prim.+# bx1_abji 2#)
                                              of r#2_abju
                                              { __DEFAULT ->
                                              GHC.Types.C#
                                                (GHC.Prim.chr#
                                                   (GHC.Prim.-#
                                                      (GHC.Prim.+#
                                                         (GHC.Prim.+#
                                                            (GHC.Prim.uncheckedIShiftL#
                                                               (GHC.Prim.-#
                                                                  (GHC.Prim.word2Int#
                                                                     (GHC.Prim.word8ToWord#
                                                                        r#_abjm))
                                                                  224#)
                                                               12#)
                                                            (GHC.Prim.uncheckedIShiftL#
                                                               (GHC.Prim.-#
                                                                  (GHC.Prim.word2Int#
                                                                     (GHC.Prim.word8ToWord#
                                                                        r#1_abjt))
                                                                  128#)
                                                               6#))
                                                         (GHC.Prim.word2Int#
                                                            (GHC.Prim.word8ToWord# r#2_abju)))
                                                      128#))
                                              }
                                              }
                                          }
                                          },
                                          case Data.Text.compareLength
                                                 (Data.Text.Internal.Text bx_abjh bx1_abji bx2_abjj)
                                                 (GHC.Types.I# 1#)
                                          of {
                                            __DEFAULT ->
                                              case GHC.Prim.indexWord8Array# bx_abjh bx1_abji
                                              of r#_abjw
                                              { __DEFAULT ->
                                              let {
                                                c#_abjx :: GHC.Prim.Int#
                                                [LclId,
                                                 Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                         Value=False, ConLike=False, WorkFree=False,
                                                         Expandable=False,
                                                         Guidance=IF_ARGS [] 4 0}]
                                                c#_abjx
                                                  = GHC.Prim.word2Int#
                                                      (GHC.Prim.clz8#
                                                         (GHC.Prim.and#
                                                            (GHC.Prim.not#
                                                               (GHC.Prim.word8ToWord# r#_abjw))
                                                            255##)) } in
                                              let {
                                                y_abjy :: GHC.Prim.Int#
                                                [LclId,
                                                 Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                         Value=False, ConLike=False, WorkFree=False,
                                                         Expandable=False,
                                                         Guidance=IF_ARGS [] 2 0}]
                                                y_abjy
                                                  = GHC.Prim.xorI#
                                                      c#_abjx (GHC.Prim.<=# c#_abjx 0#) } in
                                              Data.Text.Internal.Lazy.$WChunk
                                                (Data.Text.Internal.$WText
                                                   (Data.Text.Array.ByteArray bx_abjh)
                                                   (GHC.Types.I# (GHC.Prim.+# bx1_abji y_abjy))
                                                   (GHC.Types.I# (GHC.Prim.-# bx2_abjj y_abjy)))
                                                ts_abjk
                                              };
                                            GHC.Types.EQ -> ts_abjk
                                          })
                                   })
                                (let {
                                   f2_abjA
                                     :: Data.Text.Internal.Lazy.Text
                                        -> f_abj6 Data.Text.Internal.Lazy.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abjA
                                     = GHC.Base.pure
                                         @f_abj6
                                         $dApplicative_abj8
                                         @Data.Text.Internal.Lazy.Text } in
                                 let {
                                   ds2_abjB
                                     :: f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                        -> f_abj6 Data.Text.Internal.Lazy.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 100 0}]
                                   ds2_abjB
                                     = GHC.Base.fmap
                                         @f_abj6
                                         (GHC.Base.$p1Applicative @f_abj6 $dApplicative_abj8)
                                         @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                         @Data.Text.Internal.Lazy.Text
                                         (\ (p1_abjC
                                               :: (GHC.Types.Char, Data.Text.Internal.Lazy.Text)) ->
                                            case p1_abjC of { (x_abjE, ds_abjF) ->
                                            Data.Text.Lazy.cons x_abjE ds_abjF
                                            }) } in
                                 \ (ds3_abjH
                                      :: Data.Either.Either
                                           Data.Text.Internal.Lazy.Text
                                           (f_abj6
                                              (GHC.Types.Char, Data.Text.Internal.Lazy.Text))) ->
                                   case ds3_abjH of {
                                     Data.Either.Left x_abjJ -> f2_abjA x_abjJ;
                                     Data.Either.Right y_abjL -> ds2_abjB y_abjL
                                   }) } in
                        let {
                          g_abjN
                            :: p_abj5
                                 (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                 (f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                               -> p_abj5
                                    (Data.Either.Either
                                       Data.Text.Internal.Lazy.Text
                                       (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                                    (Data.Either.Either
                                       Data.Text.Internal.Lazy.Text
                                       (f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abjN
                            = Data.Profunctor.Choice.right'
                                @p_abj5
                                $dChoice_abj7
                                @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                @(f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                                @Data.Text.Internal.Lazy.Text } in
                        \ (x_abjO
                             :: p_abj5
                                  (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                  (f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text))) ->
                          f1_abj9 (g_abjN x_abjO))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <Data.Text.Internal.Lazy.Text>_N
                                      <Data.Text.Internal.Lazy.Text>_N
                                      <GHC.Types.Char>_N
                                      <GHC.Types.Char>_N)
                             :: Control.Lens.Type.Prism
                                  Data.Text.Internal.Lazy.Text
                                  Data.Text.Internal.Lazy.Text
                                  (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                  (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                ~R# Control.Lens.Cons.Cons
                                      Data.Text.Internal.Lazy.Text
                                      Data.Text.Internal.Lazy.Text
                                      GHC.Types.Char
                                      GHC.Types.Char)
              ValArg (\ (@(p_abjR :: * -> * -> *))
                        (@(f_abjS :: * -> *))
                        ($dChoice_abjT :: Data.Profunctor.Choice.Choice p_abjR)
                        ($dApplicative_abjU :: GHC.Base.Applicative f_abjS) ->
                        let {
                          f1_abjV
                            :: p_abjR
                                 (Data.Either.Either Data.Text.Internal.Lazy.Text ())
                                 (Data.Either.Either Data.Text.Internal.Lazy.Text (f_abjS ()))
                               -> p_abjR
                                    Data.Text.Internal.Lazy.Text
                                    (f_abjS Data.Text.Internal.Lazy.Text)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 310 0}]
                          f1_abjV
                            = Data.Profunctor.Unsafe.dimap
                                @p_abjR
                                (Data.Profunctor.Choice.$p1Choice @p_abjR $dChoice_abjT)
                                @Data.Text.Internal.Lazy.Text
                                @(Data.Either.Either Data.Text.Internal.Lazy.Text ())
                                @(Data.Either.Either Data.Text.Internal.Lazy.Text (f_abjS ()))
                                @(f_abjS Data.Text.Internal.Lazy.Text)
                                (\ (s_abjW :: Data.Text.Internal.Lazy.Text) ->
                                   case Data.Text.Lazy.null s_abjW of {
                                     GHC.Types.False ->
                                       Data.Either.Left @Data.Text.Internal.Lazy.Text @() s_abjW;
                                     GHC.Types.True ->
                                       Data.Either.Right
                                         @Data.Text.Internal.Lazy.Text @() GHC.Tuple.Prim.()
                                   })
                                (let {
                                   f2_abjZ
                                     :: Data.Text.Internal.Lazy.Text
                                        -> f_abjS Data.Text.Internal.Lazy.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abjZ
                                     = GHC.Base.pure
                                         @f_abjS
                                         $dApplicative_abjU
                                         @Data.Text.Internal.Lazy.Text } in
                                 let {
                                   ds2_abk0 :: f_abjS () -> f_abjS Data.Text.Internal.Lazy.Text
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 70 0}]
                                   ds2_abk0
                                     = GHC.Base.fmap
                                         @f_abjS
                                         (GHC.Base.$p1Applicative @f_abjS $dApplicative_abjU)
                                         @()
                                         @Data.Text.Internal.Lazy.Text
                                         (\ (ds3_abk1 :: ()) ->
                                            case ds3_abk1 of { () ->
                                            Data.Text.Internal.Lazy.empty
                                            }) } in
                                 \ (ds3_abk3
                                      :: Data.Either.Either
                                           Data.Text.Internal.Lazy.Text (f_abjS ())) ->
                                   case ds3_abk3 of {
                                     Data.Either.Left x_abk5 -> f2_abjZ x_abk5;
                                     Data.Either.Right y_abk7 -> ds2_abk0 y_abk7
                                   }) } in
                        let {
                          g_abk9
                            :: p_abjR () (f_abjS ())
                               -> p_abjR
                                    (Data.Either.Either Data.Text.Internal.Lazy.Text ())
                                    (Data.Either.Either Data.Text.Internal.Lazy.Text (f_abjS ()))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abk9
                            = Data.Profunctor.Choice.right'
                                @p_abjR
                                $dChoice_abjT
                                @()
                                @(f_abjS ())
                                @Data.Text.Internal.Lazy.Text } in
                        \ (x_abka :: p_abjR () (f_abjS ())) -> f1_abjV (g_abk9 x_abka))
                     `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                      <Data.Text.Internal.Lazy.Text>_N)
                             :: Control.Lens.Type.Prism' Data.Text.Internal.Lazy.Text ()
                                ~R# Control.Lens.Empty.AsEmpty Data.Text.Internal.Lazy.Text)
              TyArg Data.Functor.Const.Const Data.Text.Internal.Lazy.Text
              ValArg Data.Functor.Contravariant.$fContravariantConst
                       @Data.Text.Internal.Lazy.Text
              ValArg Data.Functor.Const.$fFunctorConst
                       @Data.Text.Internal.Lazy.Text
    After:  (\ (@(f_abf8 :: * -> *))
               ($dCons_abf9
                  :: Control.Lens.Cons.Cons
                       Data.Text.Internal.Text
                       Data.Text.Internal.Text
                       GHC.Types.Char
                       GHC.Types.Char)
               ($dCons1_abfa
                  :: Control.Lens.Cons.Cons
                       Data.Text.Internal.Lazy.Text
                       Data.Text.Internal.Lazy.Text
                       GHC.Types.Char
                       GHC.Types.Char)
               ($dAsEmpty_abfb
                  :: Control.Lens.Empty.AsEmpty Data.Text.Internal.Lazy.Text)
               ($dContravariant_abfc
                  :: Data.Functor.Contravariant.Contravariant f_abf8)
               ($dFunctor_abfd :: GHC.Base.Functor f_abf8) ->
               Data.Profunctor.Unsafe.$fProfunctorFUN_$cdimap
                 @Data.Text.Internal.Text
                 @Data.Text.Internal.Lazy.Text
                 @(f_abf8 Data.Text.Internal.Lazy.Text)
                 @(f_abf8 Data.Text.Internal.Text)
                 Data.Text.Lazy.fromStrict
                 (GHC.Base.fmap
                    @f_abf8
                    $dFunctor_abfd
                    @Data.Text.Internal.Lazy.Text
                    @Data.Text.Internal.Text
                    Data.Text.Lazy.toStrict))
              @(Data.Functor.Const.Const Data.Text.Internal.Lazy.Text)
              ((\ (@(p_abig :: * -> * -> *))
                  (@(f_abih :: * -> *))
                  ($dChoice_abii :: Data.Profunctor.Choice.Choice p_abig)
                  ($dApplicative_abij :: GHC.Base.Applicative f_abih) ->
                  let {
                    f1_abik
                      :: p_abig
                           (Data.Either.Either
                              Data.Text.Internal.Text (GHC.Types.Char, Data.Text.Internal.Text))
                           (Data.Either.Either
                              Data.Text.Internal.Text
                              (f_abih (GHC.Types.Char, Data.Text.Internal.Text)))
                         -> p_abig Data.Text.Internal.Text (f_abih Data.Text.Internal.Text)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 340 0}]
                    f1_abik
                      = Data.Profunctor.Unsafe.dimap
                          @p_abig
                          (Data.Profunctor.Choice.$p1Choice @p_abig $dChoice_abii)
                          @Data.Text.Internal.Text
                          @(Data.Either.Either
                              Data.Text.Internal.Text (GHC.Types.Char, Data.Text.Internal.Text))
                          @(Data.Either.Either
                              Data.Text.Internal.Text
                              (f_abih (GHC.Types.Char, Data.Text.Internal.Text)))
                          @(f_abih Data.Text.Internal.Text)
                          (\ (s1_abil :: Data.Text.Internal.Text) ->
                             case Data.Text.uncons s1_abil of {
                               GHC.Maybe.Nothing ->
                                 Data.Either.Left
                                   @Data.Text.Internal.Text
                                   @(GHC.Types.Char, Data.Text.Internal.Text)
                                   s1_abil;
                               GHC.Maybe.Just x_abio ->
                                 Data.Either.Right
                                   @Data.Text.Internal.Text
                                   @(GHC.Types.Char, Data.Text.Internal.Text)
                                   x_abio
                             })
                          (let {
                             f2_abiq
                               :: Data.Text.Internal.Text -> f_abih Data.Text.Internal.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abiq
                               = GHC.Base.pure
                                   @f_abih $dApplicative_abij @Data.Text.Internal.Text } in
                           let {
                             ds2_abir
                               :: f_abih (GHC.Types.Char, Data.Text.Internal.Text)
                                  -> f_abih Data.Text.Internal.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 100 0}]
                             ds2_abir
                               = GHC.Base.fmap
                                   @f_abih
                                   (GHC.Base.$p1Applicative @f_abih $dApplicative_abij)
                                   @(GHC.Types.Char, Data.Text.Internal.Text)
                                   @Data.Text.Internal.Text
                                   (\ (p1_abis :: (GHC.Types.Char, Data.Text.Internal.Text)) ->
                                      case p1_abis of { (x_abiu, ds_abiv) ->
                                      Data.Text.cons x_abiu ds_abiv
                                      }) } in
                           \ (ds3_abix
                                :: Data.Either.Either
                                     Data.Text.Internal.Text
                                     (f_abih (GHC.Types.Char, Data.Text.Internal.Text))) ->
                             case ds3_abix of {
                               Data.Either.Left x_abiz -> f2_abiq x_abiz;
                               Data.Either.Right y_abiB -> ds2_abir y_abiB
                             }) } in
                  let {
                    g_abiD
                      :: p_abig
                           (GHC.Types.Char, Data.Text.Internal.Text)
                           (f_abih (GHC.Types.Char, Data.Text.Internal.Text))
                         -> p_abig
                              (Data.Either.Either
                                 Data.Text.Internal.Text (GHC.Types.Char, Data.Text.Internal.Text))
                              (Data.Either.Either
                                 Data.Text.Internal.Text
                                 (f_abih (GHC.Types.Char, Data.Text.Internal.Text)))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abiD
                      = Data.Profunctor.Choice.right'
                          @p_abig
                          $dChoice_abii
                          @(GHC.Types.Char, Data.Text.Internal.Text)
                          @(f_abih (GHC.Types.Char, Data.Text.Internal.Text))
                          @Data.Text.Internal.Text } in
                  \ (x_abiE
                       :: p_abig
                            (GHC.Types.Char, Data.Text.Internal.Text)
                            (f_abih (GHC.Types.Char, Data.Text.Internal.Text))) ->
                    f1_abik (g_abiD x_abiE))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <Data.Text.Internal.Text>_N
                                <Data.Text.Internal.Text>_N
                                <GHC.Types.Char>_N
                                <GHC.Types.Char>_N)
                       :: Control.Lens.Type.Prism
                            Data.Text.Internal.Text
                            Data.Text.Internal.Text
                            (GHC.Types.Char, Data.Text.Internal.Text)
                            (GHC.Types.Char, Data.Text.Internal.Text)
                          ~R# Control.Lens.Cons.Cons
                                Data.Text.Internal.Text
                                Data.Text.Internal.Text
                                GHC.Types.Char
                                GHC.Types.Char))
              ((\ (@(p_abj5 :: * -> * -> *))
                  (@(f_abj6 :: * -> *))
                  ($dChoice_abj7 :: Data.Profunctor.Choice.Choice p_abj5)
                  ($dApplicative_abj8 :: GHC.Base.Applicative f_abj6) ->
                  let {
                    f1_abj9
                      :: p_abj5
                           (Data.Either.Either
                              Data.Text.Internal.Lazy.Text
                              (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                           (Data.Either.Either
                              Data.Text.Internal.Lazy.Text
                              (f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                         -> p_abj5
                              Data.Text.Internal.Lazy.Text (f_abj6 Data.Text.Internal.Lazy.Text)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 639 0}]
                    f1_abj9
                      = Data.Profunctor.Unsafe.dimap
                          @p_abj5
                          (Data.Profunctor.Choice.$p1Choice @p_abj5 $dChoice_abj7)
                          @Data.Text.Internal.Lazy.Text
                          @(Data.Either.Either
                              Data.Text.Internal.Lazy.Text
                              (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                          @(Data.Either.Either
                              Data.Text.Internal.Lazy.Text
                              (f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                          @(f_abj6 Data.Text.Internal.Lazy.Text)
                          (\ (s1_abja :: Data.Text.Internal.Lazy.Text) ->
                             case s1_abja of {
                               Data.Text.Internal.Lazy.Empty ->
                                 Data.Either.Left
                                   @Data.Text.Internal.Lazy.Text
                                   @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                   Data.Text.Internal.Lazy.Empty;
                               Data.Text.Internal.Lazy.Chunk bx_abjh bx1_abji bx2_abjj ts_abjk ->
                                 Data.Either.Right
                                   @Data.Text.Internal.Lazy.Text
                                   @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                   (case GHC.Prim.indexWord8Array# bx_abjh bx1_abji of r#_abjm
                                    { __DEFAULT ->
                                    let {
                                      c#_abjn :: GHC.Prim.Int#
                                      [LclId,
                                       Unf=Unf{Src=<vanilla>, TopLvl=False,
                                               Value=False, ConLike=False, WorkFree=False,
                                               Expandable=False,
                                               Guidance=IF_ARGS [] 4 0}]
                                      c#_abjn
                                        = GHC.Prim.word2Int#
                                            (GHC.Prim.clz8#
                                               (GHC.Prim.and#
                                                  (GHC.Prim.not# (GHC.Prim.word8ToWord# r#_abjm))
                                                  255##)) } in
                                    case GHC.Prim.xorI# c#_abjn (GHC.Prim.<=# c#_abjn 0#) of {
                                      __DEFAULT ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abjh (GHC.Prim.+# bx1_abji 1#)
                                        of r#1_abjp
                                        { __DEFAULT ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abjh (GHC.Prim.+# bx1_abji 2#)
                                        of r#2_abjq
                                        { __DEFAULT ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abjh (GHC.Prim.+# bx1_abji 3#)
                                        of r#3_abjr
                                        { __DEFAULT ->
                                        GHC.Types.C#
                                          (GHC.Prim.chr#
                                             (GHC.Prim.-#
                                                (GHC.Prim.+#
                                                   (GHC.Prim.+#
                                                      (GHC.Prim.+#
                                                         (GHC.Prim.uncheckedIShiftL#
                                                            (GHC.Prim.-#
                                                               (GHC.Prim.word2Int#
                                                                  (GHC.Prim.word8ToWord# r#_abjm))
                                                               240#)
                                                            18#)
                                                         (GHC.Prim.uncheckedIShiftL#
                                                            (GHC.Prim.-#
                                                               (GHC.Prim.word2Int#
                                                                  (GHC.Prim.word8ToWord# r#1_abjp))
                                                               128#)
                                                            12#))
                                                      (GHC.Prim.uncheckedIShiftL#
                                                         (GHC.Prim.-#
                                                            (GHC.Prim.word2Int#
                                                               (GHC.Prim.word8ToWord# r#2_abjq))
                                                            128#)
                                                         6#))
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.word8ToWord# r#3_abjr)))
                                                128#))
                                        }
                                        }
                                        };
                                      1# ->
                                        GHC.Types.C#
                                          (GHC.Prim.chr#
                                             (GHC.Prim.word2Int# (GHC.Prim.word8ToWord# r#_abjm)));
                                      2# ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abjh (GHC.Prim.+# bx1_abji 1#)
                                        of r#1_abjs
                                        { __DEFAULT ->
                                        GHC.Types.C#
                                          (GHC.Prim.chr#
                                             (GHC.Prim.-#
                                                (GHC.Prim.+#
                                                   (GHC.Prim.uncheckedIShiftL#
                                                      (GHC.Prim.-#
                                                         (GHC.Prim.word2Int#
                                                            (GHC.Prim.word8ToWord# r#_abjm))
                                                         192#)
                                                      6#)
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.word8ToWord# r#1_abjs)))
                                                128#))
                                        };
                                      3# ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abjh (GHC.Prim.+# bx1_abji 1#)
                                        of r#1_abjt
                                        { __DEFAULT ->
                                        case GHC.Prim.indexWord8Array#
                                               bx_abjh (GHC.Prim.+# bx1_abji 2#)
                                        of r#2_abju
                                        { __DEFAULT ->
                                        GHC.Types.C#
                                          (GHC.Prim.chr#
                                             (GHC.Prim.-#
                                                (GHC.Prim.+#
                                                   (GHC.Prim.+#
                                                      (GHC.Prim.uncheckedIShiftL#
                                                         (GHC.Prim.-#
                                                            (GHC.Prim.word2Int#
                                                               (GHC.Prim.word8ToWord# r#_abjm))
                                                            224#)
                                                         12#)
                                                      (GHC.Prim.uncheckedIShiftL#
                                                         (GHC.Prim.-#
                                                            (GHC.Prim.word2Int#
                                                               (GHC.Prim.word8ToWord# r#1_abjt))
                                                            128#)
                                                         6#))
                                                   (GHC.Prim.word2Int#
                                                      (GHC.Prim.word8ToWord# r#2_abju)))
                                                128#))
                                        }
                                        }
                                    }
                                    },
                                    case Data.Text.compareLength
                                           (Data.Text.Internal.Text bx_abjh bx1_abji bx2_abjj)
                                           (GHC.Types.I# 1#)
                                    of {
                                      __DEFAULT ->
                                        case GHC.Prim.indexWord8Array# bx_abjh bx1_abji of r#_abjw
                                        { __DEFAULT ->
                                        let {
                                          c#_abjx :: GHC.Prim.Int#
                                          [LclId,
                                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                   Value=False, ConLike=False, WorkFree=False,
                                                   Expandable=False,
                                                   Guidance=IF_ARGS [] 4 0}]
                                          c#_abjx
                                            = GHC.Prim.word2Int#
                                                (GHC.Prim.clz8#
                                                   (GHC.Prim.and#
                                                      (GHC.Prim.not#
                                                         (GHC.Prim.word8ToWord# r#_abjw))
                                                      255##)) } in
                                        let {
                                          y_abjy :: GHC.Prim.Int#
                                          [LclId,
                                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                   Value=False, ConLike=False, WorkFree=False,
                                                   Expandable=False,
                                                   Guidance=IF_ARGS [] 2 0}]
                                          y_abjy
                                            = GHC.Prim.xorI# c#_abjx (GHC.Prim.<=# c#_abjx 0#) } in
                                        Data.Text.Internal.Lazy.$WChunk
                                          (Data.Text.Internal.$WText
                                             (Data.Text.Array.ByteArray bx_abjh)
                                             (GHC.Types.I# (GHC.Prim.+# bx1_abji y_abjy))
                                             (GHC.Types.I# (GHC.Prim.-# bx2_abjj y_abjy)))
                                          ts_abjk
                                        };
                                      GHC.Types.EQ -> ts_abjk
                                    })
                             })
                          (let {
                             f2_abjA
                               :: Data.Text.Internal.Lazy.Text
                                  -> f_abj6 Data.Text.Internal.Lazy.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abjA
                               = GHC.Base.pure
                                   @f_abj6 $dApplicative_abj8 @Data.Text.Internal.Lazy.Text } in
                           let {
                             ds2_abjB
                               :: f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                  -> f_abj6 Data.Text.Internal.Lazy.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 100 0}]
                             ds2_abjB
                               = GHC.Base.fmap
                                   @f_abj6
                                   (GHC.Base.$p1Applicative @f_abj6 $dApplicative_abj8)
                                   @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                                   @Data.Text.Internal.Lazy.Text
                                   (\ (p1_abjC :: (GHC.Types.Char, Data.Text.Internal.Lazy.Text)) ->
                                      case p1_abjC of { (x_abjE, ds_abjF) ->
                                      Data.Text.Lazy.cons x_abjE ds_abjF
                                      }) } in
                           \ (ds3_abjH
                                :: Data.Either.Either
                                     Data.Text.Internal.Lazy.Text
                                     (f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text))) ->
                             case ds3_abjH of {
                               Data.Either.Left x_abjJ -> f2_abjA x_abjJ;
                               Data.Either.Right y_abjL -> ds2_abjB y_abjL
                             }) } in
                  let {
                    g_abjN
                      :: p_abj5
                           (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                           (f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                         -> p_abj5
                              (Data.Either.Either
                                 Data.Text.Internal.Lazy.Text
                                 (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                              (Data.Either.Either
                                 Data.Text.Internal.Lazy.Text
                                 (f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text)))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abjN
                      = Data.Profunctor.Choice.right'
                          @p_abj5
                          $dChoice_abj7
                          @(GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                          @(f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text))
                          @Data.Text.Internal.Lazy.Text } in
                  \ (x_abjO
                       :: p_abj5
                            (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                            (f_abj6 (GHC.Types.Char, Data.Text.Internal.Lazy.Text))) ->
                    f1_abj9 (g_abjN x_abjO))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <Data.Text.Internal.Lazy.Text>_N
                                <Data.Text.Internal.Lazy.Text>_N
                                <GHC.Types.Char>_N
                                <GHC.Types.Char>_N)
                       :: Control.Lens.Type.Prism
                            Data.Text.Internal.Lazy.Text
                            Data.Text.Internal.Lazy.Text
                            (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                            (GHC.Types.Char, Data.Text.Internal.Lazy.Text)
                          ~R# Control.Lens.Cons.Cons
                                Data.Text.Internal.Lazy.Text
                                Data.Text.Internal.Lazy.Text
                                GHC.Types.Char
                                GHC.Types.Char))
              ((\ (@(p_abjR :: * -> * -> *))
                  (@(f_abjS :: * -> *))
                  ($dChoice_abjT :: Data.Profunctor.Choice.Choice p_abjR)
                  ($dApplicative_abjU :: GHC.Base.Applicative f_abjS) ->
                  let {
                    f1_abjV
                      :: p_abjR
                           (Data.Either.Either Data.Text.Internal.Lazy.Text ())
                           (Data.Either.Either Data.Text.Internal.Lazy.Text (f_abjS ()))
                         -> p_abjR
                              Data.Text.Internal.Lazy.Text (f_abjS Data.Text.Internal.Lazy.Text)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 310 0}]
                    f1_abjV
                      = Data.Profunctor.Unsafe.dimap
                          @p_abjR
                          (Data.Profunctor.Choice.$p1Choice @p_abjR $dChoice_abjT)
                          @Data.Text.Internal.Lazy.Text
                          @(Data.Either.Either Data.Text.Internal.Lazy.Text ())
                          @(Data.Either.Either Data.Text.Internal.Lazy.Text (f_abjS ()))
                          @(f_abjS Data.Text.Internal.Lazy.Text)
                          (\ (s_abjW :: Data.Text.Internal.Lazy.Text) ->
                             case Data.Text.Lazy.null s_abjW of {
                               GHC.Types.False ->
                                 Data.Either.Left @Data.Text.Internal.Lazy.Text @() s_abjW;
                               GHC.Types.True ->
                                 Data.Either.Right
                                   @Data.Text.Internal.Lazy.Text @() GHC.Tuple.Prim.()
                             })
                          (let {
                             f2_abjZ
                               :: Data.Text.Internal.Lazy.Text
                                  -> f_abjS Data.Text.Internal.Lazy.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abjZ
                               = GHC.Base.pure
                                   @f_abjS $dApplicative_abjU @Data.Text.Internal.Lazy.Text } in
                           let {
                             ds2_abk0 :: f_abjS () -> f_abjS Data.Text.Internal.Lazy.Text
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 70 0}]
                             ds2_abk0
                               = GHC.Base.fmap
                                   @f_abjS
                                   (GHC.Base.$p1Applicative @f_abjS $dApplicative_abjU)
                                   @()
                                   @Data.Text.Internal.Lazy.Text
                                   (\ (ds3_abk1 :: ()) ->
                                      case ds3_abk1 of { () -> Data.Text.Internal.Lazy.empty }) } in
                           \ (ds3_abk3
                                :: Data.Either.Either Data.Text.Internal.Lazy.Text (f_abjS ())) ->
                             case ds3_abk3 of {
                               Data.Either.Left x_abk5 -> f2_abjZ x_abk5;
                               Data.Either.Right y_abk7 -> ds2_abk0 y_abk7
                             }) } in
                  let {
                    g_abk9
                      :: p_abjR () (f_abjS ())
                         -> p_abjR
                              (Data.Either.Either Data.Text.Internal.Lazy.Text ())
                              (Data.Either.Either Data.Text.Internal.Lazy.Text (f_abjS ()))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abk9
                      = Data.Profunctor.Choice.right'
                          @p_abjR
                          $dChoice_abjT
                          @()
                          @(f_abjS ())
                          @Data.Text.Internal.Lazy.Text } in
                  \ (x_abka :: p_abjR () (f_abjS ())) -> f1_abjV (g_abk9 x_abka))
               `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                <Data.Text.Internal.Lazy.Text>_N)
                       :: Control.Lens.Type.Prism' Data.Text.Internal.Lazy.Text ()
                          ~R# Control.Lens.Empty.AsEmpty Data.Text.Internal.Lazy.Text))
              (Data.Functor.Contravariant.$fContravariantConst
                 @Data.Text.Internal.Lazy.Text)
              (Data.Functor.Const.$fFunctorConst @Data.Text.Internal.Lazy.Text)
    Cont:   ApplyToVal nodup hole Control.Lens.Getter.Getting
                                    Data.Text.Internal.Lazy.Text
                                    Data.Text.Internal.Text
                                    Data.Text.Internal.Lazy.Text
              ((\ (ds_abeK [Occ=Once1] :: a_abeH) -> ds_abeK)
               `cast` (<a_abeH>_R
                       %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                          <*>_N <a_abeH>_R <a_abeH>_P)
                       :: (a_abeH -> a_abeH)
                          ~R# (a_abeH -> Data.Functor.Const.Const a_abeH a_abeH)))
            ApplyToVal nodup hole Data.Text.Internal.Text
                                  -> Data.Functor.Const.Const
                                       Data.Text.Internal.Lazy.Text Data.Text.Internal.Text
              s_a8Pw
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N <Data.Text.Internal.Lazy.Text>_R <Data.Text.Internal.Text>_P
                    :: Data.Functor.Const.Const
                         Data.Text.Internal.Lazy.Text Data.Text.Internal.Text
                       ~R# Data.Text.Internal.Lazy.Text)
            Stop[RuleArgCtxt] Data.Text.Internal.Lazy.Text
Rule fired
    Rule: Class op fmap
    Module: (BUILTIN)
    Before: GHC.Base.fmap
              TyArg Data.Functor.Const.Const Data.Text.Internal.Lazy.Text
              ValArg Data.Functor.Const.$fFunctorConst
                       @Data.Text.Internal.Lazy.Text
    After:  (Data.Functor.Const.$fFunctorConst2
               @Data.Text.Internal.Lazy.Text)
            `cast` (forall (a :: <*>_N) (b :: <*>_N).
                    <a -> b>_R
                    %<'GHC.Types.Many>_N ->_R <Data.Functor.Const.Const
                                                 Data.Text.Internal.Lazy.Text a>_R
                    %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                  <*>_N <Data.Text.Internal.Lazy.Text>_R <a>_P
                                              ; Sym (Data.Functor.Const.N:Const[0]
                                                         <*>_N
                                                         <Data.Text.Internal.Lazy.Text>_R
                                                         <b>_P)
                    :: (forall {a} {b}.
                        (a -> b)
                        -> Data.Functor.Const.Const Data.Text.Internal.Lazy.Text a
                        -> Data.Functor.Const.Const Data.Text.Internal.Lazy.Text a)
                       ~R# (forall {a} {b}.
                            (a -> b)
                            -> Data.Functor.Const.Const Data.Text.Internal.Lazy.Text a
                            -> Data.Functor.Const.Const Data.Text.Internal.Lazy.Text b))
    Cont:   ApplyToTy Data.Text.Internal.Lazy.Text
            ApplyToTy Data.Text.Internal.Text
            ApplyToVal nodup hole (Data.Text.Internal.Lazy.Text
                                   -> Data.Text.Internal.Text)
                                  -> Data.Functor.Const.Const
                                       Data.Text.Internal.Lazy.Text Data.Text.Internal.Lazy.Text
                                  -> Data.Functor.Const.Const
                                       Data.Text.Internal.Lazy.Text Data.Text.Internal.Text
              Data.Text.Lazy.toStrict
            ApplyToVal nodup hole Data.Functor.Const.Const
                                    Data.Text.Internal.Lazy.Text Data.Text.Internal.Lazy.Text
                                  -> Data.Functor.Const.Const
                                       Data.Text.Internal.Lazy.Text Data.Text.Internal.Text
              (bc_aboH (ab_aboF x_aboI))
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N <Data.Text.Internal.Lazy.Text>_R <Data.Text.Internal.Text>_P
                    :: Data.Functor.Const.Const
                         Data.Text.Internal.Lazy.Text Data.Text.Internal.Text
                       ~R# Data.Text.Internal.Lazy.Text)
            Stop[RuleArgCtxt] Data.Text.Internal.Lazy.Text
Rule fired
    Rule: Class op ==
    Module: (BUILTIN)
    Before: GHC.Classes.==
              TyArg Data.Text.Internal.Text
              ValArg Data.Text.$fEqText
              ValArg Data.Text.Lazy.toStrict (Data.Text.Lazy.fromStrict s_a8Pw)
              ValArg s_a8Pw
    After:  Data.Text.$fEqText_$c==
              ValArg Data.Text.Lazy.toStrict (Data.Text.Lazy.fromStrict s_a8Pw)
              ValArg s_a8Pw
    Cont:   Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: unpack
    Module: (GHC.Base)
    Before: GHC.CString.unpackCString# ValArg "[W8] -> B -> [W8]"#
    After:  (\ (a_ab7z :: GHC.Prim.Addr#) ->
               GHC.Base.build
                 @GHC.Types.Char
                 (\ (@b_ab7A) -> GHC.CString.unpackFoldrCString# @b_ab7A a_ab7z))
              "[W8] -> B -> [W8]"#
    Cont:   Stop[BoringCtxt] Test.Tasty.Core.TestName
Rule fired
    Rule: Class op property
    Module: (BUILTIN)
    Before: Test.QuickCheck.Property.property
              TyArg [GHC.Word.Word8] -> GHC.Types.Bool ValArg $dTestable_a9en
    After:  Test.QuickCheck.Property.$fTestableFUN_$cproperty
              @[GHC.Word.Word8]
              @GHC.Types.Bool
              $dArbitrary_aacW
              $dShow_aacX
              Test.QuickCheck.Property.$fTestableBool
    Cont:   ApplyToVal nodup hole ([GHC.Word.Word8] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              prop_ab7M
            CastIt (Sym (Test.Tasty.QuickCheck.N:QC[0])
                    :: Test.QuickCheck.Property.Property ~R# Test.Tasty.QuickCheck.QC)
            Stop[BoringCtxt] Test.Tasty.QuickCheck.QC
Rule fired
    Rule: Class op propertyForAllShrinkShow
    Module: (BUILTIN)
    Before: Test.QuickCheck.Property.propertyForAllShrinkShow
              TyArg GHC.Types.Bool ValArg Test.QuickCheck.Property.$fTestableBool
    After:  Test.QuickCheck.Property.$fTestableBool1
            `cast` (forall (a :: <*>_N).
                    <Test.QuickCheck.Gen.Gen a>_R
                    %<'GHC.Types.Many>_N ->_R <a -> [a]>_R
                    %<'GHC.Types.Many>_N ->_R <a -> [GHC.Base.String]>_R
                    %<'GHC.Types.Many>_N ->_R <a -> GHC.Types.Bool>_R
                    %<'GHC.Types.Many>_N ->_R Sym (Test.QuickCheck.Gen.N:Gen[0]
                                                       (Test.QuickCheck.Property.N:Prop[0]))
                                              ; Sym (Test.QuickCheck.Property.N:Property[0])
                    :: (forall {a}.
                        Test.QuickCheck.Gen.Gen a
                        -> (a -> [a])
                        -> (a -> [GHC.Base.String])
                        -> (a -> GHC.Types.Bool)
                        -> Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int
                        -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result)
                       ~R# (forall {a}.
                            Test.QuickCheck.Gen.Gen a
                            -> (a -> [a])
                            -> (a -> [GHC.Base.String])
                            -> (a -> GHC.Types.Bool)
                            -> Test.QuickCheck.Property.Property))
    Cont:   ApplyToTy [GHC.Word.Word8]
            ApplyToVal nodup hole Test.QuickCheck.Gen.Gen [GHC.Word.Word8]
                                  -> ([GHC.Word.Word8] -> [[GHC.Word.Word8]])
                                  -> ([GHC.Word.Word8] -> [GHC.Base.String])
                                  -> ([GHC.Word.Word8] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (Test.QuickCheck.Arbitrary.arbitrary @a_ab9u $dArbitrary_ab9w)
            ApplyToVal nodup hole ([GHC.Word.Word8] -> [[GHC.Word.Word8]])
                                  -> ([GHC.Word.Word8] -> [GHC.Base.String])
                                  -> ([GHC.Word.Word8] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (Test.QuickCheck.Arbitrary.shrink @a_ab9u $dArbitrary_ab9w)
            ApplyToVal nodup hole ([GHC.Word.Word8] -> [GHC.Base.String])
                                  -> ([GHC.Word.Word8] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (let {
                 g_ab9A [Occ=OnceL1!] :: a_ab9u -> GHC.Base.String
                 [LclId]
                 g_ab9A = GHC.Show.show @a_ab9u $dShow_ab9x } in
               \ (x_ab9B [Occ=Once1] :: a_ab9u) ->
                 GHC.Types.:
                   @GHC.Base.String (g_ab9A x_ab9B) (GHC.Types.[] @GHC.Base.String))
            ApplyToVal nodup hole ([GHC.Word.Word8] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              f_ab9z
            CastIt (Sym (Test.Tasty.QuickCheck.N:QC[0])
                    :: Test.QuickCheck.Property.Property ~R# Test.Tasty.QuickCheck.QC)
            Stop[BoringCtxt] Test.Tasty.QuickCheck.QC
Rule fired
    Rule: Class op arbitrary
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.arbitrary
              TyArg [GHC.Word.Word8] ValArg $dArbitrary_aacW
    After:  (Test.QuickCheck.Arbitrary.$fArbitraryList1
               @GHC.Word.Word8 Test.QuickCheck.Arbitrary.$fArbitraryWord8)
            `cast` (Sym (Test.QuickCheck.Gen.N:Gen[0] <[GHC.Word.Word8]>_R)
                    :: (Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int -> [GHC.Word.Word8])
                       ~R# Test.QuickCheck.Gen.Gen [GHC.Word.Word8])
    Cont:   Stop[BoringCtxt] Test.QuickCheck.Gen.Gen [GHC.Word.Word8]
Rule fired
    Rule: Class op arbitrary
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.arbitrary
              TyArg GHC.Word.Word8
              ValArg Test.QuickCheck.Arbitrary.$fArbitraryWord8
    After:  Test.QuickCheck.Arbitrary.$fArbitraryWord8_$sarbitrarySizedBoundedIntegral
            `cast` (Sym (Test.QuickCheck.Gen.N:Gen[0] <GHC.Word.Word8>_R)
                    :: (Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int -> GHC.Word.Word8)
                       ~R# Test.QuickCheck.Gen.Gen GHC.Word.Word8)
    Cont:   Stop[BoringCtxt, C(S,C(1,L))] Test.QuickCheck.Gen.Gen
                                            GHC.Word.Word8
Rule fired
    Rule: Class op shrink
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.shrink
              TyArg [GHC.Word.Word8] ValArg $dArbitrary_aacW
    After:  Test.QuickCheck.Arbitrary.$fArbitraryList_$cshrink
              @GHC.Word.Word8 Test.QuickCheck.Arbitrary.$fArbitraryWord8
    Cont:   Stop[BoringCtxt] [GHC.Word.Word8] -> [[GHC.Word.Word8]]
Rule fired
    Rule: Class op shrink
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.shrink
              TyArg GHC.Word.Word8
              ValArg Test.QuickCheck.Arbitrary.$fArbitraryWord8
    After:  Test.QuickCheck.Arbitrary.$fArbitraryWord8_$sshrinkIntegral
    Cont:   Stop[DiscArgCtxt, C(S,L)] GHC.Word.Word8
                                      -> [GHC.Word.Word8]
Rule fired
    Rule: Class op show
    Module: (BUILTIN)
    Before: GHC.Show.show TyArg [GHC.Word.Word8] ValArg $dShow_aacX
    After:  GHC.Show.$fShowList_$cshow
              @GHC.Word.Word8 GHC.Word.$fShowWord8
    Cont:   Stop[RhsCtxt(NonRecursive)] [GHC.Word.Word8]
                                        -> GHC.Base.String
Rule fired
    Rule: Class op showList
    Module: (BUILTIN)
    Before: GHC.Show.showList
              TyArg GHC.Word.Word8 ValArg GHC.Word.$fShowWord8
    After:  GHC.Word.$fShowWord8_$cshowList
    Cont:   ApplyToVal nodup hole [GHC.Word.Word8] -> GHC.Show.ShowS
              x_abrp
            ApplyToVal nodup hole GHC.Show.ShowS (GHC.Types.[] @GHC.Types.Char)
            Stop[BoringCtxt] GHC.Base.String
Rule fired
    Rule: Class op reader
    Module: (BUILTIN)
    Before: Control.Monad.Reader.Class.reader
              TyArg Data.ByteString.Internal.Type.ByteString
              TyArg (->) Data.ByteString.Internal.Type.ByteString
              ValArg Control.Monad.Reader.Class.$fMonadReaderrFUN
                       @Data.ByteString.Internal.Type.ByteString
    After:  \ (@a_abeP) ->
              GHC.Base.id @(Data.ByteString.Internal.Type.ByteString -> a_abeP)
    Cont:   ApplyToTy [GHC.Word.Word8]
            ApplyToVal nodup hole (Data.ByteString.Internal.Type.ByteString
                                   -> [GHC.Word.Word8])
                                  -> Data.ByteString.Internal.Type.ByteString -> [GHC.Word.Word8]
              ((l_abeJ
                  ((\ (ds_abeK [Occ=Once1] :: a_abeH) -> ds_abeK)
                   `cast` (<a_abeH>_R
                           %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                              <*>_N <a_abeH>_R <a_abeH>_P)
                           :: (a_abeH -> a_abeH)
                              ~R# (a_abeH -> Data.Functor.Const.Const a_abeH a_abeH))))
               `cast` (<s_abeF>_R
                       %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                     <*>_N <a_abeH>_R <s_abeF>_P
                       :: (s_abeF -> Data.Functor.Const.Const a_abeH s_abeF)
                          ~R# (s_abeF -> a_abeH)))
            ApplyToVal nodup hole Data.ByteString.Internal.Type.ByteString
                                  -> [GHC.Word.Word8]
              (Control.Lens.Getter.view
                 @[GHC.Word.Word8]
                 @((->) [GHC.Word.Word8])
                 @Data.ByteString.Internal.Type.ByteString
                 (Control.Monad.Reader.Class.$fMonadReaderrFUN @[GHC.Word.Word8])
                 (Control.Lens.Cons.Extras.recons
                    @[GHC.Word.Word8]
                    @GHC.Word.Word8
                    @Data.ByteString.Internal.Type.ByteString
                    (Control.Lens.Cons.$fConsListListab
                       @GHC.Word.Word8 @GHC.Word.Word8)
                    Control.Lens.Cons.$fConsByteStringByteStringWord8Word80
                    Control.Lens.Empty.$fAsEmptyByteString0
                    @(Data.Functor.Const.Const
                        Data.ByteString.Internal.Type.ByteString)
                    (Data.Functor.Contravariant.$fContravariantConst
                       @Data.ByteString.Internal.Type.ByteString)
                    (Data.Functor.Const.$fFunctorConst
                       @Data.ByteString.Internal.Type.ByteString))
                 s_a8Px)
            Stop[RuleArgCtxt] [GHC.Word.Word8]
Rule fired
    Rule: recons/bs-list
    Module: (Control.Lens.Cons.Extras)
    Before: Control.Lens.Cons.Extras.recons
              TyArg Data.ByteString.Internal.Type.ByteString
              TyArg GHC.Word.Word8
              TyArg [GHC.Word.Word8]
              ValArg (\ (@(p_abkq :: * -> * -> *))
                        (@(f_abkr :: * -> *))
                        ($dChoice_abks :: Data.Profunctor.Choice.Choice p_abkq)
                        ($dApplicative_abkt :: GHC.Base.Applicative f_abkr) ->
                        let {
                          f1_abku
                            :: p_abkq
                                 (Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                                 (Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString
                                    (f_abkr
                                       (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                               -> p_abkq
                                    Data.ByteString.Internal.Type.ByteString
                                    (f_abkr Data.ByteString.Internal.Type.ByteString)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 612 0}]
                          f1_abku
                            = Data.Profunctor.Unsafe.dimap
                                @p_abkq
                                (Data.Profunctor.Choice.$p1Choice @p_abkq $dChoice_abks)
                                @Data.ByteString.Internal.Type.ByteString
                                @(Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                                @(Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString
                                    (f_abkr
                                       (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                                @(f_abkr Data.ByteString.Internal.Type.ByteString)
                                (\ (s1_abkv :: Data.ByteString.Internal.Type.ByteString) ->
                                   case s1_abkv of wild_abkw
                                   { Data.ByteString.Internal.Type.BS bx_abkx bx1_abky bx2_abkz ->
                                   case GHC.Classes.leInt (GHC.Types.I# bx2_abkz) (GHC.Types.I# 0#)
                                   of {
                                     GHC.Types.False ->
                                       Data.Either.Right
                                         @Data.ByteString.Internal.Type.ByteString
                                         @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                         (case GHC.Prim.readWord8OffAddr#
                                                 @GHC.Prim.RealWorld bx_abkx 0# GHC.Prim.realWorld#
                                          of
                                          { (# ipv_abkE, ipv1_abkF #) ->
                                          case GHC.Prim.touch#
                                                 @'GHC.Types.Lifted
                                                 @GHC.ForeignPtr.ForeignPtrContents
                                                 bx1_abky
                                                 ipv_abkE
                                          of
                                          { __DEFAULT ->
                                          GHC.Word.W8# ipv1_abkF
                                          }
                                          },
                                          Data.ByteString.Internal.Type.$WBS
                                            (GHC.ForeignPtr.ForeignPtr
                                               @GHC.Word.Word8
                                               (GHC.Prim.plusAddr# bx_abkx 1#)
                                               bx1_abky)
                                            (GHC.Types.I# (GHC.Prim.-# bx2_abkz 1#)));
                                     GHC.Types.True ->
                                       Data.Either.Left
                                         @Data.ByteString.Internal.Type.ByteString
                                         @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                         wild_abkw
                                   }
                                   })
                                (let {
                                   f2_abkJ
                                     :: Data.ByteString.Internal.Type.ByteString
                                        -> f_abkr Data.ByteString.Internal.Type.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abkJ
                                     = GHC.Base.pure
                                         @f_abkr
                                         $dApplicative_abkt
                                         @Data.ByteString.Internal.Type.ByteString } in
                                 let {
                                   ds2_abkK
                                     :: f_abkr
                                          (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                        -> f_abkr Data.ByteString.Internal.Type.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 259 0}]
                                   ds2_abkK
                                     = GHC.Base.fmap
                                         @f_abkr
                                         (GHC.Base.$p1Applicative @f_abkr $dApplicative_abkt)
                                         @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                         @Data.ByteString.Internal.Type.ByteString
                                         (\ (p1_abkL
                                               :: (GHC.Word.Word8,
                                                   Data.ByteString.Internal.Type.ByteString)) ->
                                            case p1_abkL of { (ds_abkN, y_abkO) ->
                                            case y_abkO of
                                            { Data.ByteString.Internal.Type.BS bx_abl0 bx1_abl1
                                                                               bx2_abl2 ->
                                            GHC.Magic.runRW#
                                              @GHC.Types.LiftedRep
                                              @Data.ByteString.Internal.Type.ByteString
                                              (\ (s_abkY [OS=OneShot]
                                                    :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                                                 let {
                                                   x_abkZ :: GHC.Prim.Int#
                                                   [LclId,
                                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                            Value=False, ConLike=False,
                                                            WorkFree=False, Expandable=False,
                                                            Guidance=IF_ARGS [] 1 0}]
                                                   x_abkZ = GHC.Prim.+# bx2_abl2 1# } in
                                                 case GHC.Prim.<# x_abkZ 0# of {
                                                   __DEFAULT ->
                                                     case GHC.Prim.newPinnedByteArray#
                                                            @GHC.Prim.RealWorld x_abkZ s_abkY
                                                     of
                                                     { (# ipv_abl7, ipv1_abl8 #) ->
                                                     let {
                                                       ipv2_abl6 :: GHC.Prim.Addr#
                                                       [LclId,
                                                        Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                                Value=False, ConLike=False,
                                                                WorkFree=False, Expandable=False,
                                                                Guidance=IF_ARGS [] 1 0}]
                                                       ipv2_abl6
                                                         = GHC.Prim.mutableByteArrayContents#
                                                             @GHC.Prim.RealWorld ipv1_abl8 } in
                                                     let {
                                                       ipv3_abla
                                                         :: GHC.ForeignPtr.ForeignPtrContents
                                                       [LclId,
                                                        Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                                Value=True, ConLike=True,
                                                                WorkFree=True, Expandable=True,
                                                                Guidance=IF_ARGS [] 10 10}]
                                                       ipv3_abla
                                                         = GHC.ForeignPtr.PlainPtr ipv1_abl8 } in
                                                     case ds_abkN of { GHC.Word.W8# x1_abms ->
                                                     case GHC.Prim.writeWord8OffAddr#
                                                            @GHC.Prim.RealWorld
                                                            ipv2_abl6
                                                            0#
                                                            x1_abms
                                                            ipv_abl7
                                                     of s2_abmu
                                                     { __DEFAULT ->
                                                     case GHC.Prim.touch#
                                                            @'GHC.Types.Lifted
                                                            @GHC.ForeignPtr.ForeignPtrContents
                                                            ipv3_abla
                                                            s2_abmu
                                                     of s'_abmv
                                                     { __DEFAULT ->
                                                     case {__ffi_static_ccall_unsafe base:memcpy :: Addr#
                                          -> Addr#
                                          -> Word64#
                                          -> State# RealWorld
                                          -> (# State# RealWorld, Addr# #)}_abmw
                                                            (GHC.Prim.plusAddr# ipv2_abl6 1#)
                                                            bx_abl0
                                                            (GHC.Prim.int64ToWord64#
                                                               (GHC.Prim.intToInt64# bx2_abl2))
                                                            s'_abmv
                                                     of
                                                     { (# ds4_abmy, ds5_abmz #) ->
                                                     case GHC.Prim.touch#
                                                            @'GHC.Types.Lifted
                                                            @GHC.ForeignPtr.ForeignPtrContents
                                                            bx1_abl1
                                                            ds4_abmy
                                                     of s'1_abmB
                                                     { __DEFAULT ->
                                                     case GHC.Prim.touch#
                                                            @'GHC.Types.Lifted
                                                            @GHC.ForeignPtr.ForeignPtrContents
                                                            ipv3_abla
                                                            s'1_abmB
                                                     of s'2_abmC
                                                     { __DEFAULT ->
                                                     case GHC.Magic.lazy
                                                            @((GHC.Prim.State# GHC.Prim.RealWorld
                                                               -> (# GHC.Prim.State#
                                                                       GHC.Prim.RealWorld,
                                                                     GHC.Prim.Addr# #))
                                                              -> (# GHC.Prim.State#
                                                                      GHC.Prim.RealWorld,
                                                                    GHC.Prim.Addr# #))
                                                            (GHC.Magic.runRW#
                                                               @('GHC.Types.TupleRep
                                                                   '[GHC.Types.ZeroBitRep,
                                                                     'GHC.Types.AddrRep])
                                                               @(# GHC.Prim.State#
                                                                     GHC.Prim.RealWorld,
                                                                   GHC.Prim.Addr# #))
                                                            (\ _ [Occ=Dead] ->
                                                               (# s'2_abmC, ipv2_abl6 #))
                                                     of
                                                     { (# ipv6_abmF, ipv7_abmG #) ->
                                                     Data.ByteString.Internal.Type.BS
                                                       ipv7_abmG ipv3_abla x_abkZ
                                                     }
                                                     }
                                                     }
                                                     }
                                                     }
                                                     }
                                                     }
                                                     };
                                                   1# ->
                                                     case GHC.ForeignPtr.mallocPlainForeignPtrBytes2
                                                     of wild_00 {
                                                     }
                                                 })
                                            }
                                            }) } in
                                 \ (ds3_abmJ
                                      :: Data.Either.Either
                                           Data.ByteString.Internal.Type.ByteString
                                           (f_abkr
                                              (GHC.Word.Word8,
                                               Data.ByteString.Internal.Type.ByteString))) ->
                                   case ds3_abmJ of {
                                     Data.Either.Left x_abmL -> f2_abkJ x_abmL;
                                     Data.Either.Right y_abmN -> ds2_abkK y_abmN
                                   }) } in
                        let {
                          g_abmP
                            :: p_abkq
                                 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                 (f_abkr (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                               -> p_abkq
                                    (Data.Either.Either
                                       Data.ByteString.Internal.Type.ByteString
                                       (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                                    (Data.Either.Either
                                       Data.ByteString.Internal.Type.ByteString
                                       (f_abkr
                                          (GHC.Word.Word8,
                                           Data.ByteString.Internal.Type.ByteString)))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abmP
                            = Data.Profunctor.Choice.right'
                                @p_abkq
                                $dChoice_abks
                                @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                @(f_abkr
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                                @Data.ByteString.Internal.Type.ByteString } in
                        \ (x_abmQ
                             :: p_abkq
                                  (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                  (f_abkr
                                     (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))) ->
                          f1_abku (g_abmP x_abmQ))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <Data.ByteString.Internal.Type.ByteString>_N
                                      <Data.ByteString.Internal.Type.ByteString>_N
                                      <GHC.Word.Word8>_N
                                      <GHC.Word.Word8>_N)
                             :: Control.Lens.Type.Prism
                                  Data.ByteString.Internal.Type.ByteString
                                  Data.ByteString.Internal.Type.ByteString
                                  (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                  (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                ~R# Control.Lens.Cons.Cons
                                      Data.ByteString.Internal.Type.ByteString
                                      Data.ByteString.Internal.Type.ByteString
                                      GHC.Word.Word8
                                      GHC.Word.Word8)
              ValArg (\ (@(p_abgg :: * -> * -> *))
                        (@(f_abgh :: * -> *))
                        ($dChoice_abgi :: Data.Profunctor.Choice.Choice p_abgg)
                        ($dApplicative_abgj :: GHC.Base.Applicative f_abgh) ->
                        let {
                          f1_abgk
                            :: p_abgg
                                 (Data.Either.Either
                                    [GHC.Word.Word8] (GHC.Word.Word8, [GHC.Word.Word8]))
                                 (Data.Either.Either
                                    [GHC.Word.Word8] (f_abgh (GHC.Word.Word8, [GHC.Word.Word8])))
                               -> p_abgg [GHC.Word.Word8] (f_abgh [GHC.Word.Word8])
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 320 0}]
                          f1_abgk
                            = Data.Profunctor.Unsafe.dimap
                                @p_abgg
                                (Data.Profunctor.Choice.$p1Choice @p_abgg $dChoice_abgi)
                                @[GHC.Word.Word8]
                                @(Data.Either.Either
                                    [GHC.Word.Word8] (GHC.Word.Word8, [GHC.Word.Word8]))
                                @(Data.Either.Either
                                    [GHC.Word.Word8] (f_abgh (GHC.Word.Word8, [GHC.Word.Word8])))
                                @(f_abgh [GHC.Word.Word8])
                                (\ (aas_abgl :: [GHC.Word.Word8]) ->
                                   case aas_abgl of {
                                     [] ->
                                       Data.Either.Left
                                         @[GHC.Word.Word8]
                                         @(GHC.Word.Word8, [GHC.Word.Word8])
                                         (GHC.Types.[] @GHC.Word.Word8);
                                     : a1_abgn as_abgo ->
                                       Data.Either.Right
                                         @[GHC.Word.Word8]
                                         @(GHC.Word.Word8, [GHC.Word.Word8])
                                         (a1_abgn, as_abgo)
                                   })
                                (let {
                                   f2_abgq :: [GHC.Word.Word8] -> f_abgh [GHC.Word.Word8]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abgq
                                     = GHC.Base.pure
                                         @f_abgh $dApplicative_abgj @[GHC.Word.Word8] } in
                                 let {
                                   ds2_abgr
                                     :: f_abgh (GHC.Word.Word8, [GHC.Word.Word8])
                                        -> f_abgh [GHC.Word.Word8]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 90 0}]
                                   ds2_abgr
                                     = GHC.Base.fmap
                                         @f_abgh
                                         (GHC.Base.$p1Applicative @f_abgh $dApplicative_abgj)
                                         @(GHC.Word.Word8, [GHC.Word.Word8])
                                         @[GHC.Word.Word8]
                                         (\ (p1_abgs :: (GHC.Word.Word8, [GHC.Word.Word8])) ->
                                            GHC.Types.:
                                              @GHC.Word.Word8
                                              (case p1_abgs of { (x_abgu, ds_abgv) -> x_abgu })
                                              (case p1_abgs of { (ds_abgy, y_abgz) ->
                                               y_abgz
                                               })) } in
                                 \ (ds3_abgB
                                      :: Data.Either.Either
                                           [GHC.Word.Word8]
                                           (f_abgh (GHC.Word.Word8, [GHC.Word.Word8]))) ->
                                   case ds3_abgB of {
                                     Data.Either.Left x_abgD -> f2_abgq x_abgD;
                                     Data.Either.Right y_abgF -> ds2_abgr y_abgF
                                   }) } in
                        let {
                          g_abgH
                            :: p_abgg
                                 (GHC.Word.Word8, [GHC.Word.Word8])
                                 (f_abgh (GHC.Word.Word8, [GHC.Word.Word8]))
                               -> p_abgg
                                    (Data.Either.Either
                                       [GHC.Word.Word8] (GHC.Word.Word8, [GHC.Word.Word8]))
                                    (Data.Either.Either
                                       [GHC.Word.Word8] (f_abgh (GHC.Word.Word8, [GHC.Word.Word8])))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abgH
                            = Data.Profunctor.Choice.right'
                                @p_abgg
                                $dChoice_abgi
                                @(GHC.Word.Word8, [GHC.Word.Word8])
                                @(f_abgh (GHC.Word.Word8, [GHC.Word.Word8]))
                                @[GHC.Word.Word8] } in
                        \ (x_abgI
                             :: p_abgg
                                  (GHC.Word.Word8, [GHC.Word.Word8])
                                  (f_abgh (GHC.Word.Word8, [GHC.Word.Word8]))) ->
                          f1_abgk (g_abgH x_abgI))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <[GHC.Word.Word8]>_N
                                      <[GHC.Word.Word8]>_N
                                      <GHC.Word.Word8>_N
                                      <GHC.Word.Word8>_N)
                             :: Control.Lens.Type.Prism
                                  [GHC.Word.Word8]
                                  [GHC.Word.Word8]
                                  (GHC.Word.Word8, [GHC.Word.Word8])
                                  (GHC.Word.Word8, [GHC.Word.Word8])
                                ~R# Control.Lens.Cons.Cons
                                      [GHC.Word.Word8]
                                      [GHC.Word.Word8]
                                      GHC.Word.Word8
                                      GHC.Word.Word8)
              ValArg (\ (@(p_abgN :: * -> * -> *))
                        (@(f_abgO :: * -> *))
                        ($dChoice_abgP :: Data.Profunctor.Choice.Choice p_abgN)
                        ($dApplicative_abgQ :: GHC.Base.Applicative f_abgO) ->
                        let {
                          f1_abgR
                            :: p_abgN
                                 (Data.Either.Either [GHC.Word.Word8] ())
                                 (Data.Either.Either [GHC.Word.Word8] (f_abgO ()))
                               -> p_abgN [GHC.Word.Word8] (f_abgO [GHC.Word.Word8])
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 290 0}]
                          f1_abgR
                            = Data.Profunctor.Unsafe.dimap
                                @p_abgN
                                (Data.Profunctor.Choice.$p1Choice @p_abgN $dChoice_abgP)
                                @[GHC.Word.Word8]
                                @(Data.Either.Either [GHC.Word.Word8] ())
                                @(Data.Either.Either [GHC.Word.Word8] (f_abgO ()))
                                @(f_abgO [GHC.Word.Word8])
                                (\ (s_abgS :: [GHC.Word.Word8]) ->
                                   case s_abgS of wild_abgT {
                                     [] ->
                                       Data.Either.Right @[GHC.Word.Word8] @() GHC.Tuple.Prim.();
                                     : ds1_abgU ds2_abgV ->
                                       Data.Either.Left @[GHC.Word.Word8] @() wild_abgT
                                   })
                                (let {
                                   f2_abgX :: [GHC.Word.Word8] -> f_abgO [GHC.Word.Word8]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abgX
                                     = GHC.Base.pure
                                         @f_abgO $dApplicative_abgQ @[GHC.Word.Word8] } in
                                 let {
                                   ds2_abgY :: f_abgO () -> f_abgO [GHC.Word.Word8]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 70 0}]
                                   ds2_abgY
                                     = GHC.Base.fmap
                                         @f_abgO
                                         (GHC.Base.$p1Applicative @f_abgO $dApplicative_abgQ)
                                         @()
                                         @[GHC.Word.Word8]
                                         (\ (ds3_abgZ :: ()) ->
                                            case ds3_abgZ of { () ->
                                            GHC.Types.[] @GHC.Word.Word8
                                            }) } in
                                 \ (ds3_abh1 :: Data.Either.Either [GHC.Word.Word8] (f_abgO ())) ->
                                   case ds3_abh1 of {
                                     Data.Either.Left x_abh3 -> f2_abgX x_abh3;
                                     Data.Either.Right y_abh5 -> ds2_abgY y_abh5
                                   }) } in
                        let {
                          g_abh7
                            :: p_abgN () (f_abgO ())
                               -> p_abgN
                                    (Data.Either.Either [GHC.Word.Word8] ())
                                    (Data.Either.Either [GHC.Word.Word8] (f_abgO ()))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abh7
                            = Data.Profunctor.Choice.right'
                                @p_abgN $dChoice_abgP @() @(f_abgO ()) @[GHC.Word.Word8] } in
                        \ (x_abh8 :: p_abgN () (f_abgO ())) -> f1_abgR (g_abh7 x_abh8))
                     `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0] <[GHC.Word.Word8]>_N)
                             :: Control.Lens.Type.Prism' [GHC.Word.Word8] ()
                                ~R# Control.Lens.Empty.AsEmpty [GHC.Word.Word8])
              TyArg Data.Functor.Const.Const [GHC.Word.Word8]
              ValArg Data.Functor.Contravariant.$fContravariantConst
                       @[GHC.Word.Word8]
              ValArg Data.Functor.Const.$fFunctorConst @[GHC.Word.Word8]
    After:  (\ (@(f_abg2 :: * -> *))
               ($dCons_abg3
                  :: Control.Lens.Cons.Cons
                       Data.ByteString.Internal.Type.ByteString
                       Data.ByteString.Internal.Type.ByteString
                       GHC.Word.Word8
                       GHC.Word.Word8)
               ($dCons1_abg4
                  :: Control.Lens.Cons.Cons
                       [GHC.Word.Word8] [GHC.Word.Word8] GHC.Word.Word8 GHC.Word.Word8)
               ($dAsEmpty_abg5 :: Control.Lens.Empty.AsEmpty [GHC.Word.Word8])
               ($dContravariant_abg6
                  :: Data.Functor.Contravariant.Contravariant f_abg2)
               ($dFunctor_abg7 :: GHC.Base.Functor f_abg2) ->
               Data.Profunctor.Unsafe.$fProfunctorFUN_$cdimap
                 @Data.ByteString.Internal.Type.ByteString
                 @[GHC.Word.Word8]
                 @(f_abg2 [GHC.Word.Word8])
                 @(f_abg2 Data.ByteString.Internal.Type.ByteString)
                 Data.ByteString.unpack
                 (GHC.Base.fmap
                    @f_abg2
                    $dFunctor_abg7
                    @[GHC.Word.Word8]
                    @Data.ByteString.Internal.Type.ByteString
                    Data.ByteString.Internal.Type.packBytes))
              @(Data.Functor.Const.Const [GHC.Word.Word8])
              ((\ (@(p_abkq :: * -> * -> *))
                  (@(f_abkr :: * -> *))
                  ($dChoice_abks :: Data.Profunctor.Choice.Choice p_abkq)
                  ($dApplicative_abkt :: GHC.Base.Applicative f_abkr) ->
                  let {
                    f1_abku
                      :: p_abkq
                           (Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString
                              (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                           (Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString
                              (f_abkr
                                 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                         -> p_abkq
                              Data.ByteString.Internal.Type.ByteString
                              (f_abkr Data.ByteString.Internal.Type.ByteString)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 612 0}]
                    f1_abku
                      = Data.Profunctor.Unsafe.dimap
                          @p_abkq
                          (Data.Profunctor.Choice.$p1Choice @p_abkq $dChoice_abks)
                          @Data.ByteString.Internal.Type.ByteString
                          @(Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString
                              (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                          @(Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString
                              (f_abkr
                                 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                          @(f_abkr Data.ByteString.Internal.Type.ByteString)
                          (\ (s1_abkv :: Data.ByteString.Internal.Type.ByteString) ->
                             case s1_abkv of wild_abkw
                             { Data.ByteString.Internal.Type.BS bx_abkx bx1_abky bx2_abkz ->
                             case GHC.Classes.leInt (GHC.Types.I# bx2_abkz) (GHC.Types.I# 0#)
                             of {
                               GHC.Types.False ->
                                 Data.Either.Right
                                   @Data.ByteString.Internal.Type.ByteString
                                   @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                   (case GHC.Prim.readWord8OffAddr#
                                           @GHC.Prim.RealWorld bx_abkx 0# GHC.Prim.realWorld#
                                    of
                                    { (# ipv_abkE, ipv1_abkF #) ->
                                    case GHC.Prim.touch#
                                           @'GHC.Types.Lifted
                                           @GHC.ForeignPtr.ForeignPtrContents
                                           bx1_abky
                                           ipv_abkE
                                    of
                                    { __DEFAULT ->
                                    GHC.Word.W8# ipv1_abkF
                                    }
                                    },
                                    Data.ByteString.Internal.Type.$WBS
                                      (GHC.ForeignPtr.ForeignPtr
                                         @GHC.Word.Word8 (GHC.Prim.plusAddr# bx_abkx 1#) bx1_abky)
                                      (GHC.Types.I# (GHC.Prim.-# bx2_abkz 1#)));
                               GHC.Types.True ->
                                 Data.Either.Left
                                   @Data.ByteString.Internal.Type.ByteString
                                   @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                   wild_abkw
                             }
                             })
                          (let {
                             f2_abkJ
                               :: Data.ByteString.Internal.Type.ByteString
                                  -> f_abkr Data.ByteString.Internal.Type.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abkJ
                               = GHC.Base.pure
                                   @f_abkr
                                   $dApplicative_abkt
                                   @Data.ByteString.Internal.Type.ByteString } in
                           let {
                             ds2_abkK
                               :: f_abkr
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                  -> f_abkr Data.ByteString.Internal.Type.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 259 0}]
                             ds2_abkK
                               = GHC.Base.fmap
                                   @f_abkr
                                   (GHC.Base.$p1Applicative @f_abkr $dApplicative_abkt)
                                   @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                   @Data.ByteString.Internal.Type.ByteString
                                   (\ (p1_abkL
                                         :: (GHC.Word.Word8,
                                             Data.ByteString.Internal.Type.ByteString)) ->
                                      case p1_abkL of { (ds_abkN, y_abkO) ->
                                      case y_abkO of
                                      { Data.ByteString.Internal.Type.BS bx_abl0 bx1_abl1
                                                                         bx2_abl2 ->
                                      GHC.Magic.runRW#
                                        @GHC.Types.LiftedRep
                                        @Data.ByteString.Internal.Type.ByteString
                                        (\ (s_abkY [OS=OneShot]
                                              :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                                           let {
                                             x_abkZ :: GHC.Prim.Int#
                                             [LclId,
                                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                      Value=False, ConLike=False, WorkFree=False,
                                                      Expandable=False,
                                                      Guidance=IF_ARGS [] 1 0}]
                                             x_abkZ = GHC.Prim.+# bx2_abl2 1# } in
                                           case GHC.Prim.<# x_abkZ 0# of {
                                             __DEFAULT ->
                                               case GHC.Prim.newPinnedByteArray#
                                                      @GHC.Prim.RealWorld x_abkZ s_abkY
                                               of
                                               { (# ipv_abl7, ipv1_abl8 #) ->
                                               let {
                                                 ipv2_abl6 :: GHC.Prim.Addr#
                                                 [LclId,
                                                  Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                          Value=False, ConLike=False,
                                                          WorkFree=False, Expandable=False,
                                                          Guidance=IF_ARGS [] 1 0}]
                                                 ipv2_abl6
                                                   = GHC.Prim.mutableByteArrayContents#
                                                       @GHC.Prim.RealWorld ipv1_abl8 } in
                                               let {
                                                 ipv3_abla :: GHC.ForeignPtr.ForeignPtrContents
                                                 [LclId,
                                                  Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                          Value=True, ConLike=True, WorkFree=True,
                                                          Expandable=True,
                                                          Guidance=IF_ARGS [] 10 10}]
                                                 ipv3_abla = GHC.ForeignPtr.PlainPtr ipv1_abl8 } in
                                               case ds_abkN of { GHC.Word.W8# x1_abms ->
                                               case GHC.Prim.writeWord8OffAddr#
                                                      @GHC.Prim.RealWorld
                                                      ipv2_abl6
                                                      0#
                                                      x1_abms
                                                      ipv_abl7
                                               of s2_abmu
                                               { __DEFAULT ->
                                               case GHC.Prim.touch#
                                                      @'GHC.Types.Lifted
                                                      @GHC.ForeignPtr.ForeignPtrContents
                                                      ipv3_abla
                                                      s2_abmu
                                               of s'_abmv
                                               { __DEFAULT ->
                                               case {__ffi_static_ccall_unsafe base:memcpy :: Addr#
                                          -> Addr#
                                          -> Word64#
                                          -> State# RealWorld
                                          -> (# State# RealWorld, Addr# #)}_abmw
                                                      (GHC.Prim.plusAddr# ipv2_abl6 1#)
                                                      bx_abl0
                                                      (GHC.Prim.int64ToWord64#
                                                         (GHC.Prim.intToInt64# bx2_abl2))
                                                      s'_abmv
                                               of
                                               { (# ds4_abmy, ds5_abmz #) ->
                                               case GHC.Prim.touch#
                                                      @'GHC.Types.Lifted
                                                      @GHC.ForeignPtr.ForeignPtrContents
                                                      bx1_abl1
                                                      ds4_abmy
                                               of s'1_abmB
                                               { __DEFAULT ->
                                               case GHC.Prim.touch#
                                                      @'GHC.Types.Lifted
                                                      @GHC.ForeignPtr.ForeignPtrContents
                                                      ipv3_abla
                                                      s'1_abmB
                                               of s'2_abmC
                                               { __DEFAULT ->
                                               case GHC.Magic.lazy
                                                      @((GHC.Prim.State# GHC.Prim.RealWorld
                                                         -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                               GHC.Prim.Addr# #))
                                                        -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                              GHC.Prim.Addr# #))
                                                      (GHC.Magic.runRW#
                                                         @('GHC.Types.TupleRep
                                                             '[GHC.Types.ZeroBitRep,
                                                               'GHC.Types.AddrRep])
                                                         @(# GHC.Prim.State# GHC.Prim.RealWorld,
                                                             GHC.Prim.Addr# #))
                                                      (\ _ [Occ=Dead] -> (# s'2_abmC, ipv2_abl6 #))
                                               of
                                               { (# ipv6_abmF, ipv7_abmG #) ->
                                               Data.ByteString.Internal.Type.BS
                                                 ipv7_abmG ipv3_abla x_abkZ
                                               }
                                               }
                                               }
                                               }
                                               }
                                               }
                                               }
                                               };
                                             1# ->
                                               case GHC.ForeignPtr.mallocPlainForeignPtrBytes2
                                               of wild_00 {
                                               }
                                           })
                                      }
                                      }) } in
                           \ (ds3_abmJ
                                :: Data.Either.Either
                                     Data.ByteString.Internal.Type.ByteString
                                     (f_abkr
                                        (GHC.Word.Word8,
                                         Data.ByteString.Internal.Type.ByteString))) ->
                             case ds3_abmJ of {
                               Data.Either.Left x_abmL -> f2_abkJ x_abmL;
                               Data.Either.Right y_abmN -> ds2_abkK y_abmN
                             }) } in
                  let {
                    g_abmP
                      :: p_abkq
                           (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                           (f_abkr (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                         -> p_abkq
                              (Data.Either.Either
                                 Data.ByteString.Internal.Type.ByteString
                                 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                              (Data.Either.Either
                                 Data.ByteString.Internal.Type.ByteString
                                 (f_abkr
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abmP
                      = Data.Profunctor.Choice.right'
                          @p_abkq
                          $dChoice_abks
                          @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                          @(f_abkr
                              (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                          @Data.ByteString.Internal.Type.ByteString } in
                  \ (x_abmQ
                       :: p_abkq
                            (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                            (f_abkr
                               (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))) ->
                    f1_abku (g_abmP x_abmQ))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <Data.ByteString.Internal.Type.ByteString>_N
                                <Data.ByteString.Internal.Type.ByteString>_N
                                <GHC.Word.Word8>_N
                                <GHC.Word.Word8>_N)
                       :: Control.Lens.Type.Prism
                            Data.ByteString.Internal.Type.ByteString
                            Data.ByteString.Internal.Type.ByteString
                            (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                            (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                          ~R# Control.Lens.Cons.Cons
                                Data.ByteString.Internal.Type.ByteString
                                Data.ByteString.Internal.Type.ByteString
                                GHC.Word.Word8
                                GHC.Word.Word8))
              ((\ (@(p_abgg :: * -> * -> *))
                  (@(f_abgh :: * -> *))
                  ($dChoice_abgi :: Data.Profunctor.Choice.Choice p_abgg)
                  ($dApplicative_abgj :: GHC.Base.Applicative f_abgh) ->
                  let {
                    f1_abgk
                      :: p_abgg
                           (Data.Either.Either
                              [GHC.Word.Word8] (GHC.Word.Word8, [GHC.Word.Word8]))
                           (Data.Either.Either
                              [GHC.Word.Word8] (f_abgh (GHC.Word.Word8, [GHC.Word.Word8])))
                         -> p_abgg [GHC.Word.Word8] (f_abgh [GHC.Word.Word8])
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 320 0}]
                    f1_abgk
                      = Data.Profunctor.Unsafe.dimap
                          @p_abgg
                          (Data.Profunctor.Choice.$p1Choice @p_abgg $dChoice_abgi)
                          @[GHC.Word.Word8]
                          @(Data.Either.Either
                              [GHC.Word.Word8] (GHC.Word.Word8, [GHC.Word.Word8]))
                          @(Data.Either.Either
                              [GHC.Word.Word8] (f_abgh (GHC.Word.Word8, [GHC.Word.Word8])))
                          @(f_abgh [GHC.Word.Word8])
                          (\ (aas_abgl :: [GHC.Word.Word8]) ->
                             case aas_abgl of {
                               [] ->
                                 Data.Either.Left
                                   @[GHC.Word.Word8]
                                   @(GHC.Word.Word8, [GHC.Word.Word8])
                                   (GHC.Types.[] @GHC.Word.Word8);
                               : a1_abgn as_abgo ->
                                 Data.Either.Right
                                   @[GHC.Word.Word8]
                                   @(GHC.Word.Word8, [GHC.Word.Word8])
                                   (a1_abgn, as_abgo)
                             })
                          (let {
                             f2_abgq :: [GHC.Word.Word8] -> f_abgh [GHC.Word.Word8]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abgq
                               = GHC.Base.pure @f_abgh $dApplicative_abgj @[GHC.Word.Word8] } in
                           let {
                             ds2_abgr
                               :: f_abgh (GHC.Word.Word8, [GHC.Word.Word8])
                                  -> f_abgh [GHC.Word.Word8]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 90 0}]
                             ds2_abgr
                               = GHC.Base.fmap
                                   @f_abgh
                                   (GHC.Base.$p1Applicative @f_abgh $dApplicative_abgj)
                                   @(GHC.Word.Word8, [GHC.Word.Word8])
                                   @[GHC.Word.Word8]
                                   (\ (p1_abgs :: (GHC.Word.Word8, [GHC.Word.Word8])) ->
                                      GHC.Types.:
                                        @GHC.Word.Word8
                                        (case p1_abgs of { (x_abgu, ds_abgv) -> x_abgu })
                                        (case p1_abgs of { (ds_abgy, y_abgz) -> y_abgz })) } in
                           \ (ds3_abgB
                                :: Data.Either.Either
                                     [GHC.Word.Word8]
                                     (f_abgh (GHC.Word.Word8, [GHC.Word.Word8]))) ->
                             case ds3_abgB of {
                               Data.Either.Left x_abgD -> f2_abgq x_abgD;
                               Data.Either.Right y_abgF -> ds2_abgr y_abgF
                             }) } in
                  let {
                    g_abgH
                      :: p_abgg
                           (GHC.Word.Word8, [GHC.Word.Word8])
                           (f_abgh (GHC.Word.Word8, [GHC.Word.Word8]))
                         -> p_abgg
                              (Data.Either.Either
                                 [GHC.Word.Word8] (GHC.Word.Word8, [GHC.Word.Word8]))
                              (Data.Either.Either
                                 [GHC.Word.Word8] (f_abgh (GHC.Word.Word8, [GHC.Word.Word8])))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abgH
                      = Data.Profunctor.Choice.right'
                          @p_abgg
                          $dChoice_abgi
                          @(GHC.Word.Word8, [GHC.Word.Word8])
                          @(f_abgh (GHC.Word.Word8, [GHC.Word.Word8]))
                          @[GHC.Word.Word8] } in
                  \ (x_abgI
                       :: p_abgg
                            (GHC.Word.Word8, [GHC.Word.Word8])
                            (f_abgh (GHC.Word.Word8, [GHC.Word.Word8]))) ->
                    f1_abgk (g_abgH x_abgI))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <[GHC.Word.Word8]>_N
                                <[GHC.Word.Word8]>_N
                                <GHC.Word.Word8>_N
                                <GHC.Word.Word8>_N)
                       :: Control.Lens.Type.Prism
                            [GHC.Word.Word8]
                            [GHC.Word.Word8]
                            (GHC.Word.Word8, [GHC.Word.Word8])
                            (GHC.Word.Word8, [GHC.Word.Word8])
                          ~R# Control.Lens.Cons.Cons
                                [GHC.Word.Word8] [GHC.Word.Word8] GHC.Word.Word8 GHC.Word.Word8))
              ((\ (@(p_abgN :: * -> * -> *))
                  (@(f_abgO :: * -> *))
                  ($dChoice_abgP :: Data.Profunctor.Choice.Choice p_abgN)
                  ($dApplicative_abgQ :: GHC.Base.Applicative f_abgO) ->
                  let {
                    f1_abgR
                      :: p_abgN
                           (Data.Either.Either [GHC.Word.Word8] ())
                           (Data.Either.Either [GHC.Word.Word8] (f_abgO ()))
                         -> p_abgN [GHC.Word.Word8] (f_abgO [GHC.Word.Word8])
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 290 0}]
                    f1_abgR
                      = Data.Profunctor.Unsafe.dimap
                          @p_abgN
                          (Data.Profunctor.Choice.$p1Choice @p_abgN $dChoice_abgP)
                          @[GHC.Word.Word8]
                          @(Data.Either.Either [GHC.Word.Word8] ())
                          @(Data.Either.Either [GHC.Word.Word8] (f_abgO ()))
                          @(f_abgO [GHC.Word.Word8])
                          (\ (s_abgS :: [GHC.Word.Word8]) ->
                             case s_abgS of wild_abgT {
                               [] -> Data.Either.Right @[GHC.Word.Word8] @() GHC.Tuple.Prim.();
                               : ds1_abgU ds2_abgV ->
                                 Data.Either.Left @[GHC.Word.Word8] @() wild_abgT
                             })
                          (let {
                             f2_abgX :: [GHC.Word.Word8] -> f_abgO [GHC.Word.Word8]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abgX
                               = GHC.Base.pure @f_abgO $dApplicative_abgQ @[GHC.Word.Word8] } in
                           let {
                             ds2_abgY :: f_abgO () -> f_abgO [GHC.Word.Word8]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 70 0}]
                             ds2_abgY
                               = GHC.Base.fmap
                                   @f_abgO
                                   (GHC.Base.$p1Applicative @f_abgO $dApplicative_abgQ)
                                   @()
                                   @[GHC.Word.Word8]
                                   (\ (ds3_abgZ :: ()) ->
                                      case ds3_abgZ of { () -> GHC.Types.[] @GHC.Word.Word8 }) } in
                           \ (ds3_abh1 :: Data.Either.Either [GHC.Word.Word8] (f_abgO ())) ->
                             case ds3_abh1 of {
                               Data.Either.Left x_abh3 -> f2_abgX x_abh3;
                               Data.Either.Right y_abh5 -> ds2_abgY y_abh5
                             }) } in
                  let {
                    g_abh7
                      :: p_abgN () (f_abgO ())
                         -> p_abgN
                              (Data.Either.Either [GHC.Word.Word8] ())
                              (Data.Either.Either [GHC.Word.Word8] (f_abgO ()))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abh7
                      = Data.Profunctor.Choice.right'
                          @p_abgN $dChoice_abgP @() @(f_abgO ()) @[GHC.Word.Word8] } in
                  \ (x_abh8 :: p_abgN () (f_abgO ())) -> f1_abgR (g_abh7 x_abh8))
               `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0] <[GHC.Word.Word8]>_N)
                       :: Control.Lens.Type.Prism' [GHC.Word.Word8] ()
                          ~R# Control.Lens.Empty.AsEmpty [GHC.Word.Word8]))
              (Data.Functor.Contravariant.$fContravariantConst @[GHC.Word.Word8])
              (Data.Functor.Const.$fFunctorConst @[GHC.Word.Word8])
    Cont:   ApplyToVal nodup hole Control.Lens.Getter.Getting
                                    [GHC.Word.Word8]
                                    Data.ByteString.Internal.Type.ByteString
                                    [GHC.Word.Word8]
              ((\ (ds_abeK [Occ=Once1] :: a_abeH) -> ds_abeK)
               `cast` (<a_abeH>_R
                       %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                          <*>_N <a_abeH>_R <a_abeH>_P)
                       :: (a_abeH -> a_abeH)
                          ~R# (a_abeH -> Data.Functor.Const.Const a_abeH a_abeH)))
            ApplyToVal nodup hole Data.ByteString.Internal.Type.ByteString
                                  -> Data.Functor.Const.Const
                                       [GHC.Word.Word8] Data.ByteString.Internal.Type.ByteString
              (Control.Lens.Getter.view
                 @[GHC.Word.Word8]
                 @((->) [GHC.Word.Word8])
                 @Data.ByteString.Internal.Type.ByteString
                 (Control.Monad.Reader.Class.$fMonadReaderrFUN @[GHC.Word.Word8])
                 (Control.Lens.Cons.Extras.recons
                    @[GHC.Word.Word8]
                    @GHC.Word.Word8
                    @Data.ByteString.Internal.Type.ByteString
                    (Control.Lens.Cons.$fConsListListab
                       @GHC.Word.Word8 @GHC.Word.Word8)
                    Control.Lens.Cons.$fConsByteStringByteStringWord8Word80
                    Control.Lens.Empty.$fAsEmptyByteString0
                    @(Data.Functor.Const.Const
                        Data.ByteString.Internal.Type.ByteString)
                    (Data.Functor.Contravariant.$fContravariantConst
                       @Data.ByteString.Internal.Type.ByteString)
                    (Data.Functor.Const.$fFunctorConst
                       @Data.ByteString.Internal.Type.ByteString))
                 s_a8Px)
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N
                        <[GHC.Word.Word8]>_R
                        <Data.ByteString.Internal.Type.ByteString>_P
                    :: Data.Functor.Const.Const
                         [GHC.Word.Word8] Data.ByteString.Internal.Type.ByteString
                       ~R# [GHC.Word.Word8])
            Stop[RuleArgCtxt] [GHC.Word.Word8]
Rule fired
    Rule: Class op fmap
    Module: (BUILTIN)
    Before: GHC.Base.fmap
              TyArg Data.Functor.Const.Const [GHC.Word.Word8]
              ValArg Data.Functor.Const.$fFunctorConst @[GHC.Word.Word8]
    After:  (Data.Functor.Const.$fFunctorConst2 @[GHC.Word.Word8])
            `cast` (forall (a :: <*>_N) (b :: <*>_N).
                    <a -> b>_R
                    %<'GHC.Types.Many>_N ->_R <Data.Functor.Const.Const
                                                 [GHC.Word.Word8] a>_R
                    %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                  <*>_N <[GHC.Word.Word8]>_R <a>_P
                                              ; Sym (Data.Functor.Const.N:Const[0]
                                                         <*>_N <[GHC.Word.Word8]>_R <b>_P)
                    :: (forall {a} {b}.
                        (a -> b)
                        -> Data.Functor.Const.Const [GHC.Word.Word8] a
                        -> Data.Functor.Const.Const [GHC.Word.Word8] a)
                       ~R# (forall {a} {b}.
                            (a -> b)
                            -> Data.Functor.Const.Const [GHC.Word.Word8] a
                            -> Data.Functor.Const.Const [GHC.Word.Word8] b))
    Cont:   ApplyToTy [GHC.Word.Word8]
            ApplyToTy Data.ByteString.Internal.Type.ByteString
            ApplyToVal nodup hole ([GHC.Word.Word8]
                                   -> Data.ByteString.Internal.Type.ByteString)
                                  -> Data.Functor.Const.Const [GHC.Word.Word8] [GHC.Word.Word8]
                                  -> Data.Functor.Const.Const
                                       [GHC.Word.Word8] Data.ByteString.Internal.Type.ByteString
              Data.ByteString.Internal.Type.packBytes
            ApplyToVal nodup hole Data.Functor.Const.Const
                                    [GHC.Word.Word8] [GHC.Word.Word8]
                                  -> Data.Functor.Const.Const
                                       [GHC.Word.Word8] Data.ByteString.Internal.Type.ByteString
              (bc_aboH (ab_aboF x_aboI))
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N
                        <[GHC.Word.Word8]>_R
                        <Data.ByteString.Internal.Type.ByteString>_P
                    :: Data.Functor.Const.Const
                         [GHC.Word.Word8] Data.ByteString.Internal.Type.ByteString
                       ~R# [GHC.Word.Word8])
            Stop[RuleArgCtxt] [GHC.Word.Word8]
Rule fired
    Rule: Class op reader
    Module: (BUILTIN)
    Before: Control.Monad.Reader.Class.reader
              TyArg [GHC.Word.Word8]
              TyArg (->) [GHC.Word.Word8]
              ValArg Control.Monad.Reader.Class.$fMonadReaderrFUN
                       @[GHC.Word.Word8]
    After:  \ (@a_abeP) -> GHC.Base.id @([GHC.Word.Word8] -> a_abeP)
    Cont:   ApplyToTy Data.ByteString.Internal.Type.ByteString
            ApplyToVal nodup hole ([GHC.Word.Word8]
                                   -> Data.ByteString.Internal.Type.ByteString)
                                  -> [GHC.Word.Word8] -> Data.ByteString.Internal.Type.ByteString
              ((l_abeJ
                  ((\ (ds_abeK [Occ=Once1] :: a_abeH) -> ds_abeK)
                   `cast` (<a_abeH>_R
                           %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                              <*>_N <a_abeH>_R <a_abeH>_P)
                           :: (a_abeH -> a_abeH)
                              ~R# (a_abeH -> Data.Functor.Const.Const a_abeH a_abeH))))
               `cast` (<s_abeF>_R
                       %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                     <*>_N <a_abeH>_R <s_abeF>_P
                       :: (s_abeF -> Data.Functor.Const.Const a_abeH s_abeF)
                          ~R# (s_abeF -> a_abeH)))
            ApplyToVal nodup hole [GHC.Word.Word8]
                                  -> Data.ByteString.Internal.Type.ByteString
              s_a8Px
            Stop[BoringCtxt] Data.ByteString.Internal.Type.ByteString
Rule fired
    Rule: recons/list-bs
    Module: (Control.Lens.Cons.Extras)
    Before: Control.Lens.Cons.Extras.recons
              TyArg [GHC.Word.Word8]
              TyArg GHC.Word.Word8
              TyArg Data.ByteString.Internal.Type.ByteString
              ValArg (\ (@(p_abgg :: * -> * -> *))
                        (@(f_abgh :: * -> *))
                        ($dChoice_abgi :: Data.Profunctor.Choice.Choice p_abgg)
                        ($dApplicative_abgj :: GHC.Base.Applicative f_abgh) ->
                        let {
                          f1_abgk
                            :: p_abgg
                                 (Data.Either.Either
                                    [GHC.Word.Word8] (GHC.Word.Word8, [GHC.Word.Word8]))
                                 (Data.Either.Either
                                    [GHC.Word.Word8] (f_abgh (GHC.Word.Word8, [GHC.Word.Word8])))
                               -> p_abgg [GHC.Word.Word8] (f_abgh [GHC.Word.Word8])
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 320 0}]
                          f1_abgk
                            = Data.Profunctor.Unsafe.dimap
                                @p_abgg
                                (Data.Profunctor.Choice.$p1Choice @p_abgg $dChoice_abgi)
                                @[GHC.Word.Word8]
                                @(Data.Either.Either
                                    [GHC.Word.Word8] (GHC.Word.Word8, [GHC.Word.Word8]))
                                @(Data.Either.Either
                                    [GHC.Word.Word8] (f_abgh (GHC.Word.Word8, [GHC.Word.Word8])))
                                @(f_abgh [GHC.Word.Word8])
                                (\ (aas_abgl :: [GHC.Word.Word8]) ->
                                   case aas_abgl of {
                                     [] ->
                                       Data.Either.Left
                                         @[GHC.Word.Word8]
                                         @(GHC.Word.Word8, [GHC.Word.Word8])
                                         (GHC.Types.[] @GHC.Word.Word8);
                                     : a1_abgn as_abgo ->
                                       Data.Either.Right
                                         @[GHC.Word.Word8]
                                         @(GHC.Word.Word8, [GHC.Word.Word8])
                                         (a1_abgn, as_abgo)
                                   })
                                (let {
                                   f2_abgq :: [GHC.Word.Word8] -> f_abgh [GHC.Word.Word8]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abgq
                                     = GHC.Base.pure
                                         @f_abgh $dApplicative_abgj @[GHC.Word.Word8] } in
                                 let {
                                   ds2_abgr
                                     :: f_abgh (GHC.Word.Word8, [GHC.Word.Word8])
                                        -> f_abgh [GHC.Word.Word8]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 90 0}]
                                   ds2_abgr
                                     = GHC.Base.fmap
                                         @f_abgh
                                         (GHC.Base.$p1Applicative @f_abgh $dApplicative_abgj)
                                         @(GHC.Word.Word8, [GHC.Word.Word8])
                                         @[GHC.Word.Word8]
                                         (\ (p1_abgs :: (GHC.Word.Word8, [GHC.Word.Word8])) ->
                                            GHC.Types.:
                                              @GHC.Word.Word8
                                              (case p1_abgs of { (x_abgu, ds_abgv) -> x_abgu })
                                              (case p1_abgs of { (ds_abgy, y_abgz) ->
                                               y_abgz
                                               })) } in
                                 \ (ds3_abgB
                                      :: Data.Either.Either
                                           [GHC.Word.Word8]
                                           (f_abgh (GHC.Word.Word8, [GHC.Word.Word8]))) ->
                                   case ds3_abgB of {
                                     Data.Either.Left x_abgD -> f2_abgq x_abgD;
                                     Data.Either.Right y_abgF -> ds2_abgr y_abgF
                                   }) } in
                        let {
                          g_abgH
                            :: p_abgg
                                 (GHC.Word.Word8, [GHC.Word.Word8])
                                 (f_abgh (GHC.Word.Word8, [GHC.Word.Word8]))
                               -> p_abgg
                                    (Data.Either.Either
                                       [GHC.Word.Word8] (GHC.Word.Word8, [GHC.Word.Word8]))
                                    (Data.Either.Either
                                       [GHC.Word.Word8] (f_abgh (GHC.Word.Word8, [GHC.Word.Word8])))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abgH
                            = Data.Profunctor.Choice.right'
                                @p_abgg
                                $dChoice_abgi
                                @(GHC.Word.Word8, [GHC.Word.Word8])
                                @(f_abgh (GHC.Word.Word8, [GHC.Word.Word8]))
                                @[GHC.Word.Word8] } in
                        \ (x_abgI
                             :: p_abgg
                                  (GHC.Word.Word8, [GHC.Word.Word8])
                                  (f_abgh (GHC.Word.Word8, [GHC.Word.Word8]))) ->
                          f1_abgk (g_abgH x_abgI))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <[GHC.Word.Word8]>_N
                                      <[GHC.Word.Word8]>_N
                                      <GHC.Word.Word8>_N
                                      <GHC.Word.Word8>_N)
                             :: Control.Lens.Type.Prism
                                  [GHC.Word.Word8]
                                  [GHC.Word.Word8]
                                  (GHC.Word.Word8, [GHC.Word.Word8])
                                  (GHC.Word.Word8, [GHC.Word.Word8])
                                ~R# Control.Lens.Cons.Cons
                                      [GHC.Word.Word8]
                                      [GHC.Word.Word8]
                                      GHC.Word.Word8
                                      GHC.Word.Word8)
              ValArg (\ (@(p_abkq :: * -> * -> *))
                        (@(f_abkr :: * -> *))
                        ($dChoice_abks :: Data.Profunctor.Choice.Choice p_abkq)
                        ($dApplicative_abkt :: GHC.Base.Applicative f_abkr) ->
                        let {
                          f1_abku
                            :: p_abkq
                                 (Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                                 (Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString
                                    (f_abkr
                                       (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                               -> p_abkq
                                    Data.ByteString.Internal.Type.ByteString
                                    (f_abkr Data.ByteString.Internal.Type.ByteString)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 612 0}]
                          f1_abku
                            = Data.Profunctor.Unsafe.dimap
                                @p_abkq
                                (Data.Profunctor.Choice.$p1Choice @p_abkq $dChoice_abks)
                                @Data.ByteString.Internal.Type.ByteString
                                @(Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                                @(Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString
                                    (f_abkr
                                       (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                                @(f_abkr Data.ByteString.Internal.Type.ByteString)
                                (\ (s1_abkv :: Data.ByteString.Internal.Type.ByteString) ->
                                   case s1_abkv of wild_abkw
                                   { Data.ByteString.Internal.Type.BS bx_abkx bx1_abky bx2_abkz ->
                                   case GHC.Classes.leInt (GHC.Types.I# bx2_abkz) (GHC.Types.I# 0#)
                                   of {
                                     GHC.Types.False ->
                                       Data.Either.Right
                                         @Data.ByteString.Internal.Type.ByteString
                                         @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                         (case GHC.Prim.readWord8OffAddr#
                                                 @GHC.Prim.RealWorld bx_abkx 0# GHC.Prim.realWorld#
                                          of
                                          { (# ipv_abkE, ipv1_abkF #) ->
                                          case GHC.Prim.touch#
                                                 @'GHC.Types.Lifted
                                                 @GHC.ForeignPtr.ForeignPtrContents
                                                 bx1_abky
                                                 ipv_abkE
                                          of
                                          { __DEFAULT ->
                                          GHC.Word.W8# ipv1_abkF
                                          }
                                          },
                                          Data.ByteString.Internal.Type.$WBS
                                            (GHC.ForeignPtr.ForeignPtr
                                               @GHC.Word.Word8
                                               (GHC.Prim.plusAddr# bx_abkx 1#)
                                               bx1_abky)
                                            (GHC.Types.I# (GHC.Prim.-# bx2_abkz 1#)));
                                     GHC.Types.True ->
                                       Data.Either.Left
                                         @Data.ByteString.Internal.Type.ByteString
                                         @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                         wild_abkw
                                   }
                                   })
                                (let {
                                   f2_abkJ
                                     :: Data.ByteString.Internal.Type.ByteString
                                        -> f_abkr Data.ByteString.Internal.Type.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abkJ
                                     = GHC.Base.pure
                                         @f_abkr
                                         $dApplicative_abkt
                                         @Data.ByteString.Internal.Type.ByteString } in
                                 let {
                                   ds2_abkK
                                     :: f_abkr
                                          (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                        -> f_abkr Data.ByteString.Internal.Type.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 259 0}]
                                   ds2_abkK
                                     = GHC.Base.fmap
                                         @f_abkr
                                         (GHC.Base.$p1Applicative @f_abkr $dApplicative_abkt)
                                         @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                         @Data.ByteString.Internal.Type.ByteString
                                         (\ (p1_abkL
                                               :: (GHC.Word.Word8,
                                                   Data.ByteString.Internal.Type.ByteString)) ->
                                            case p1_abkL of { (ds_abkN, y_abkO) ->
                                            case y_abkO of
                                            { Data.ByteString.Internal.Type.BS bx_abl0 bx1_abl1
                                                                               bx2_abl2 ->
                                            GHC.Magic.runRW#
                                              @GHC.Types.LiftedRep
                                              @Data.ByteString.Internal.Type.ByteString
                                              (\ (s_abkY [OS=OneShot]
                                                    :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                                                 let {
                                                   x_abkZ :: GHC.Prim.Int#
                                                   [LclId,
                                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                            Value=False, ConLike=False,
                                                            WorkFree=False, Expandable=False,
                                                            Guidance=IF_ARGS [] 1 0}]
                                                   x_abkZ = GHC.Prim.+# bx2_abl2 1# } in
                                                 case GHC.Prim.<# x_abkZ 0# of {
                                                   __DEFAULT ->
                                                     case GHC.Prim.newPinnedByteArray#
                                                            @GHC.Prim.RealWorld x_abkZ s_abkY
                                                     of
                                                     { (# ipv_abl7, ipv1_abl8 #) ->
                                                     let {
                                                       ipv2_abl6 :: GHC.Prim.Addr#
                                                       [LclId,
                                                        Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                                Value=False, ConLike=False,
                                                                WorkFree=False, Expandable=False,
                                                                Guidance=IF_ARGS [] 1 0}]
                                                       ipv2_abl6
                                                         = GHC.Prim.mutableByteArrayContents#
                                                             @GHC.Prim.RealWorld ipv1_abl8 } in
                                                     let {
                                                       ipv3_abla
                                                         :: GHC.ForeignPtr.ForeignPtrContents
                                                       [LclId,
                                                        Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                                Value=True, ConLike=True,
                                                                WorkFree=True, Expandable=True,
                                                                Guidance=IF_ARGS [] 10 10}]
                                                       ipv3_abla
                                                         = GHC.ForeignPtr.PlainPtr ipv1_abl8 } in
                                                     case ds_abkN of { GHC.Word.W8# x1_abms ->
                                                     case GHC.Prim.writeWord8OffAddr#
                                                            @GHC.Prim.RealWorld
                                                            ipv2_abl6
                                                            0#
                                                            x1_abms
                                                            ipv_abl7
                                                     of s2_abmu
                                                     { __DEFAULT ->
                                                     case GHC.Prim.touch#
                                                            @'GHC.Types.Lifted
                                                            @GHC.ForeignPtr.ForeignPtrContents
                                                            ipv3_abla
                                                            s2_abmu
                                                     of s'_abmv
                                                     { __DEFAULT ->
                                                     case {__ffi_static_ccall_unsafe base:memcpy :: Addr#
                                          -> Addr#
                                          -> Word64#
                                          -> State# RealWorld
                                          -> (# State# RealWorld, Addr# #)}_abmw
                                                            (GHC.Prim.plusAddr# ipv2_abl6 1#)
                                                            bx_abl0
                                                            (GHC.Prim.int64ToWord64#
                                                               (GHC.Prim.intToInt64# bx2_abl2))
                                                            s'_abmv
                                                     of
                                                     { (# ds4_abmy, ds5_abmz #) ->
                                                     case GHC.Prim.touch#
                                                            @'GHC.Types.Lifted
                                                            @GHC.ForeignPtr.ForeignPtrContents
                                                            bx1_abl1
                                                            ds4_abmy
                                                     of s'1_abmB
                                                     { __DEFAULT ->
                                                     case GHC.Prim.touch#
                                                            @'GHC.Types.Lifted
                                                            @GHC.ForeignPtr.ForeignPtrContents
                                                            ipv3_abla
                                                            s'1_abmB
                                                     of s'2_abmC
                                                     { __DEFAULT ->
                                                     case GHC.Magic.lazy
                                                            @((GHC.Prim.State# GHC.Prim.RealWorld
                                                               -> (# GHC.Prim.State#
                                                                       GHC.Prim.RealWorld,
                                                                     GHC.Prim.Addr# #))
                                                              -> (# GHC.Prim.State#
                                                                      GHC.Prim.RealWorld,
                                                                    GHC.Prim.Addr# #))
                                                            (GHC.Magic.runRW#
                                                               @('GHC.Types.TupleRep
                                                                   '[GHC.Types.ZeroBitRep,
                                                                     'GHC.Types.AddrRep])
                                                               @(# GHC.Prim.State#
                                                                     GHC.Prim.RealWorld,
                                                                   GHC.Prim.Addr# #))
                                                            (\ _ [Occ=Dead] ->
                                                               (# s'2_abmC, ipv2_abl6 #))
                                                     of
                                                     { (# ipv6_abmF, ipv7_abmG #) ->
                                                     Data.ByteString.Internal.Type.BS
                                                       ipv7_abmG ipv3_abla x_abkZ
                                                     }
                                                     }
                                                     }
                                                     }
                                                     }
                                                     }
                                                     }
                                                     };
                                                   1# ->
                                                     case GHC.ForeignPtr.mallocPlainForeignPtrBytes2
                                                     of wild_00 {
                                                     }
                                                 })
                                            }
                                            }) } in
                                 \ (ds3_abmJ
                                      :: Data.Either.Either
                                           Data.ByteString.Internal.Type.ByteString
                                           (f_abkr
                                              (GHC.Word.Word8,
                                               Data.ByteString.Internal.Type.ByteString))) ->
                                   case ds3_abmJ of {
                                     Data.Either.Left x_abmL -> f2_abkJ x_abmL;
                                     Data.Either.Right y_abmN -> ds2_abkK y_abmN
                                   }) } in
                        let {
                          g_abmP
                            :: p_abkq
                                 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                 (f_abkr (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                               -> p_abkq
                                    (Data.Either.Either
                                       Data.ByteString.Internal.Type.ByteString
                                       (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                                    (Data.Either.Either
                                       Data.ByteString.Internal.Type.ByteString
                                       (f_abkr
                                          (GHC.Word.Word8,
                                           Data.ByteString.Internal.Type.ByteString)))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abmP
                            = Data.Profunctor.Choice.right'
                                @p_abkq
                                $dChoice_abks
                                @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                @(f_abkr
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                                @Data.ByteString.Internal.Type.ByteString } in
                        \ (x_abmQ
                             :: p_abkq
                                  (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                  (f_abkr
                                     (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))) ->
                          f1_abku (g_abmP x_abmQ))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <Data.ByteString.Internal.Type.ByteString>_N
                                      <Data.ByteString.Internal.Type.ByteString>_N
                                      <GHC.Word.Word8>_N
                                      <GHC.Word.Word8>_N)
                             :: Control.Lens.Type.Prism
                                  Data.ByteString.Internal.Type.ByteString
                                  Data.ByteString.Internal.Type.ByteString
                                  (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                  (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                ~R# Control.Lens.Cons.Cons
                                      Data.ByteString.Internal.Type.ByteString
                                      Data.ByteString.Internal.Type.ByteString
                                      GHC.Word.Word8
                                      GHC.Word.Word8)
              ValArg (\ (@(p_abmX :: * -> * -> *))
                        (@(f_abmY :: * -> *))
                        ($dChoice_abmZ :: Data.Profunctor.Choice.Choice p_abmX)
                        ($dApplicative_abn0 :: GHC.Base.Applicative f_abmY) ->
                        let {
                          f1_abn1
                            :: p_abmX
                                 (Data.Either.Either Data.ByteString.Internal.Type.ByteString ())
                                 (Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString (f_abmY ()))
                               -> p_abmX
                                    Data.ByteString.Internal.Type.ByteString
                                    (f_abmY Data.ByteString.Internal.Type.ByteString)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 350 0}]
                          f1_abn1
                            = Data.Profunctor.Unsafe.dimap
                                @p_abmX
                                (Data.Profunctor.Choice.$p1Choice @p_abmX $dChoice_abmZ)
                                @Data.ByteString.Internal.Type.ByteString
                                @(Data.Either.Either Data.ByteString.Internal.Type.ByteString ())
                                @(Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString (f_abmY ()))
                                @(f_abmY Data.ByteString.Internal.Type.ByteString)
                                (\ (s_abn2 :: Data.ByteString.Internal.Type.ByteString) ->
                                   case s_abn2 of wild_abn3
                                   { Data.ByteString.Internal.Type.BS bx_abn4 bx1_abn5 bx2_abn6 ->
                                   case GHC.Classes.leInt (GHC.Types.I# bx2_abn6) (GHC.Types.I# 0#)
                                   of {
                                     GHC.Types.False ->
                                       Data.Either.Left
                                         @Data.ByteString.Internal.Type.ByteString @() wild_abn3;
                                     GHC.Types.True ->
                                       Data.Either.Right
                                         @Data.ByteString.Internal.Type.ByteString
                                         @()
                                         GHC.Tuple.Prim.()
                                   }
                                   })
                                (let {
                                   f2_abna
                                     :: Data.ByteString.Internal.Type.ByteString
                                        -> f_abmY Data.ByteString.Internal.Type.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abna
                                     = GHC.Base.pure
                                         @f_abmY
                                         $dApplicative_abn0
                                         @Data.ByteString.Internal.Type.ByteString } in
                                 let {
                                   ds2_abnb
                                     :: f_abmY () -> f_abmY Data.ByteString.Internal.Type.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 70 0}]
                                   ds2_abnb
                                     = GHC.Base.fmap
                                         @f_abmY
                                         (GHC.Base.$p1Applicative @f_abmY $dApplicative_abn0)
                                         @()
                                         @Data.ByteString.Internal.Type.ByteString
                                         (\ (ds3_abnc :: ()) ->
                                            case ds3_abnc of { () ->
                                            Data.ByteString.Internal.Type.empty
                                            }) } in
                                 \ (ds3_abne
                                      :: Data.Either.Either
                                           Data.ByteString.Internal.Type.ByteString (f_abmY ())) ->
                                   case ds3_abne of {
                                     Data.Either.Left x_abng -> f2_abna x_abng;
                                     Data.Either.Right y_abni -> ds2_abnb y_abni
                                   }) } in
                        let {
                          g_abnk
                            :: p_abmX () (f_abmY ())
                               -> p_abmX
                                    (Data.Either.Either Data.ByteString.Internal.Type.ByteString ())
                                    (Data.Either.Either
                                       Data.ByteString.Internal.Type.ByteString (f_abmY ()))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abnk
                            = Data.Profunctor.Choice.right'
                                @p_abmX
                                $dChoice_abmZ
                                @()
                                @(f_abmY ())
                                @Data.ByteString.Internal.Type.ByteString } in
                        \ (x_abnl :: p_abmX () (f_abmY ())) -> f1_abn1 (g_abnk x_abnl))
                     `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                      <Data.ByteString.Internal.Type.ByteString>_N)
                             :: Control.Lens.Type.Prism'
                                  Data.ByteString.Internal.Type.ByteString ()
                                ~R# Control.Lens.Empty.AsEmpty
                                      Data.ByteString.Internal.Type.ByteString)
              TyArg Data.Functor.Const.Const
                      Data.ByteString.Internal.Type.ByteString
              ValArg Data.Functor.Contravariant.$fContravariantConst
                       @Data.ByteString.Internal.Type.ByteString
              ValArg Data.Functor.Const.$fFunctorConst
                       @Data.ByteString.Internal.Type.ByteString
    After:  (\ (@(f_abfw :: * -> *))
               ($dCons_abfx
                  :: Control.Lens.Cons.Cons
                       [GHC.Word.Word8] [GHC.Word.Word8] GHC.Word.Word8 GHC.Word.Word8)
               ($dCons1_abfy
                  :: Control.Lens.Cons.Cons
                       Data.ByteString.Internal.Type.ByteString
                       Data.ByteString.Internal.Type.ByteString
                       GHC.Word.Word8
                       GHC.Word.Word8)
               ($dAsEmpty_abfz
                  :: Control.Lens.Empty.AsEmpty
                       Data.ByteString.Internal.Type.ByteString)
               ($dContravariant_abfA
                  :: Data.Functor.Contravariant.Contravariant f_abfw)
               ($dFunctor_abfB :: GHC.Base.Functor f_abfw) ->
               Data.Profunctor.Unsafe.$fProfunctorFUN_$cdimap
                 @[GHC.Word.Word8]
                 @Data.ByteString.Internal.Type.ByteString
                 @(f_abfw Data.ByteString.Internal.Type.ByteString)
                 @(f_abfw [GHC.Word.Word8])
                 Data.ByteString.Internal.Type.packBytes
                 (GHC.Base.fmap
                    @f_abfw
                    $dFunctor_abfB
                    @Data.ByteString.Internal.Type.ByteString
                    @[GHC.Word.Word8]
                    Data.ByteString.unpack))
              @(Data.Functor.Const.Const
                  Data.ByteString.Internal.Type.ByteString)
              ((\ (@(p_abgg :: * -> * -> *))
                  (@(f_abgh :: * -> *))
                  ($dChoice_abgi :: Data.Profunctor.Choice.Choice p_abgg)
                  ($dApplicative_abgj :: GHC.Base.Applicative f_abgh) ->
                  let {
                    f1_abgk
                      :: p_abgg
                           (Data.Either.Either
                              [GHC.Word.Word8] (GHC.Word.Word8, [GHC.Word.Word8]))
                           (Data.Either.Either
                              [GHC.Word.Word8] (f_abgh (GHC.Word.Word8, [GHC.Word.Word8])))
                         -> p_abgg [GHC.Word.Word8] (f_abgh [GHC.Word.Word8])
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 320 0}]
                    f1_abgk
                      = Data.Profunctor.Unsafe.dimap
                          @p_abgg
                          (Data.Profunctor.Choice.$p1Choice @p_abgg $dChoice_abgi)
                          @[GHC.Word.Word8]
                          @(Data.Either.Either
                              [GHC.Word.Word8] (GHC.Word.Word8, [GHC.Word.Word8]))
                          @(Data.Either.Either
                              [GHC.Word.Word8] (f_abgh (GHC.Word.Word8, [GHC.Word.Word8])))
                          @(f_abgh [GHC.Word.Word8])
                          (\ (aas_abgl :: [GHC.Word.Word8]) ->
                             case aas_abgl of {
                               [] ->
                                 Data.Either.Left
                                   @[GHC.Word.Word8]
                                   @(GHC.Word.Word8, [GHC.Word.Word8])
                                   (GHC.Types.[] @GHC.Word.Word8);
                               : a1_abgn as_abgo ->
                                 Data.Either.Right
                                   @[GHC.Word.Word8]
                                   @(GHC.Word.Word8, [GHC.Word.Word8])
                                   (a1_abgn, as_abgo)
                             })
                          (let {
                             f2_abgq :: [GHC.Word.Word8] -> f_abgh [GHC.Word.Word8]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abgq
                               = GHC.Base.pure @f_abgh $dApplicative_abgj @[GHC.Word.Word8] } in
                           let {
                             ds2_abgr
                               :: f_abgh (GHC.Word.Word8, [GHC.Word.Word8])
                                  -> f_abgh [GHC.Word.Word8]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 90 0}]
                             ds2_abgr
                               = GHC.Base.fmap
                                   @f_abgh
                                   (GHC.Base.$p1Applicative @f_abgh $dApplicative_abgj)
                                   @(GHC.Word.Word8, [GHC.Word.Word8])
                                   @[GHC.Word.Word8]
                                   (\ (p1_abgs :: (GHC.Word.Word8, [GHC.Word.Word8])) ->
                                      GHC.Types.:
                                        @GHC.Word.Word8
                                        (case p1_abgs of { (x_abgu, ds_abgv) -> x_abgu })
                                        (case p1_abgs of { (ds_abgy, y_abgz) -> y_abgz })) } in
                           \ (ds3_abgB
                                :: Data.Either.Either
                                     [GHC.Word.Word8]
                                     (f_abgh (GHC.Word.Word8, [GHC.Word.Word8]))) ->
                             case ds3_abgB of {
                               Data.Either.Left x_abgD -> f2_abgq x_abgD;
                               Data.Either.Right y_abgF -> ds2_abgr y_abgF
                             }) } in
                  let {
                    g_abgH
                      :: p_abgg
                           (GHC.Word.Word8, [GHC.Word.Word8])
                           (f_abgh (GHC.Word.Word8, [GHC.Word.Word8]))
                         -> p_abgg
                              (Data.Either.Either
                                 [GHC.Word.Word8] (GHC.Word.Word8, [GHC.Word.Word8]))
                              (Data.Either.Either
                                 [GHC.Word.Word8] (f_abgh (GHC.Word.Word8, [GHC.Word.Word8])))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abgH
                      = Data.Profunctor.Choice.right'
                          @p_abgg
                          $dChoice_abgi
                          @(GHC.Word.Word8, [GHC.Word.Word8])
                          @(f_abgh (GHC.Word.Word8, [GHC.Word.Word8]))
                          @[GHC.Word.Word8] } in
                  \ (x_abgI
                       :: p_abgg
                            (GHC.Word.Word8, [GHC.Word.Word8])
                            (f_abgh (GHC.Word.Word8, [GHC.Word.Word8]))) ->
                    f1_abgk (g_abgH x_abgI))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <[GHC.Word.Word8]>_N
                                <[GHC.Word.Word8]>_N
                                <GHC.Word.Word8>_N
                                <GHC.Word.Word8>_N)
                       :: Control.Lens.Type.Prism
                            [GHC.Word.Word8]
                            [GHC.Word.Word8]
                            (GHC.Word.Word8, [GHC.Word.Word8])
                            (GHC.Word.Word8, [GHC.Word.Word8])
                          ~R# Control.Lens.Cons.Cons
                                [GHC.Word.Word8] [GHC.Word.Word8] GHC.Word.Word8 GHC.Word.Word8))
              ((\ (@(p_abkq :: * -> * -> *))
                  (@(f_abkr :: * -> *))
                  ($dChoice_abks :: Data.Profunctor.Choice.Choice p_abkq)
                  ($dApplicative_abkt :: GHC.Base.Applicative f_abkr) ->
                  let {
                    f1_abku
                      :: p_abkq
                           (Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString
                              (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                           (Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString
                              (f_abkr
                                 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                         -> p_abkq
                              Data.ByteString.Internal.Type.ByteString
                              (f_abkr Data.ByteString.Internal.Type.ByteString)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 612 0}]
                    f1_abku
                      = Data.Profunctor.Unsafe.dimap
                          @p_abkq
                          (Data.Profunctor.Choice.$p1Choice @p_abkq $dChoice_abks)
                          @Data.ByteString.Internal.Type.ByteString
                          @(Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString
                              (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                          @(Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString
                              (f_abkr
                                 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                          @(f_abkr Data.ByteString.Internal.Type.ByteString)
                          (\ (s1_abkv :: Data.ByteString.Internal.Type.ByteString) ->
                             case s1_abkv of wild_abkw
                             { Data.ByteString.Internal.Type.BS bx_abkx bx1_abky bx2_abkz ->
                             case GHC.Classes.leInt (GHC.Types.I# bx2_abkz) (GHC.Types.I# 0#)
                             of {
                               GHC.Types.False ->
                                 Data.Either.Right
                                   @Data.ByteString.Internal.Type.ByteString
                                   @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                   (case GHC.Prim.readWord8OffAddr#
                                           @GHC.Prim.RealWorld bx_abkx 0# GHC.Prim.realWorld#
                                    of
                                    { (# ipv_abkE, ipv1_abkF #) ->
                                    case GHC.Prim.touch#
                                           @'GHC.Types.Lifted
                                           @GHC.ForeignPtr.ForeignPtrContents
                                           bx1_abky
                                           ipv_abkE
                                    of
                                    { __DEFAULT ->
                                    GHC.Word.W8# ipv1_abkF
                                    }
                                    },
                                    Data.ByteString.Internal.Type.$WBS
                                      (GHC.ForeignPtr.ForeignPtr
                                         @GHC.Word.Word8 (GHC.Prim.plusAddr# bx_abkx 1#) bx1_abky)
                                      (GHC.Types.I# (GHC.Prim.-# bx2_abkz 1#)));
                               GHC.Types.True ->
                                 Data.Either.Left
                                   @Data.ByteString.Internal.Type.ByteString
                                   @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                   wild_abkw
                             }
                             })
                          (let {
                             f2_abkJ
                               :: Data.ByteString.Internal.Type.ByteString
                                  -> f_abkr Data.ByteString.Internal.Type.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abkJ
                               = GHC.Base.pure
                                   @f_abkr
                                   $dApplicative_abkt
                                   @Data.ByteString.Internal.Type.ByteString } in
                           let {
                             ds2_abkK
                               :: f_abkr
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                  -> f_abkr Data.ByteString.Internal.Type.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 259 0}]
                             ds2_abkK
                               = GHC.Base.fmap
                                   @f_abkr
                                   (GHC.Base.$p1Applicative @f_abkr $dApplicative_abkt)
                                   @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                   @Data.ByteString.Internal.Type.ByteString
                                   (\ (p1_abkL
                                         :: (GHC.Word.Word8,
                                             Data.ByteString.Internal.Type.ByteString)) ->
                                      case p1_abkL of { (ds_abkN, y_abkO) ->
                                      case y_abkO of
                                      { Data.ByteString.Internal.Type.BS bx_abl0 bx1_abl1
                                                                         bx2_abl2 ->
                                      GHC.Magic.runRW#
                                        @GHC.Types.LiftedRep
                                        @Data.ByteString.Internal.Type.ByteString
                                        (\ (s_abkY [OS=OneShot]
                                              :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                                           let {
                                             x_abkZ :: GHC.Prim.Int#
                                             [LclId,
                                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                      Value=False, ConLike=False, WorkFree=False,
                                                      Expandable=False,
                                                      Guidance=IF_ARGS [] 1 0}]
                                             x_abkZ = GHC.Prim.+# bx2_abl2 1# } in
                                           case GHC.Prim.<# x_abkZ 0# of {
                                             __DEFAULT ->
                                               case GHC.Prim.newPinnedByteArray#
                                                      @GHC.Prim.RealWorld x_abkZ s_abkY
                                               of
                                               { (# ipv_abl7, ipv1_abl8 #) ->
                                               let {
                                                 ipv2_abl6 :: GHC.Prim.Addr#
                                                 [LclId,
                                                  Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                          Value=False, ConLike=False,
                                                          WorkFree=False, Expandable=False,
                                                          Guidance=IF_ARGS [] 1 0}]
                                                 ipv2_abl6
                                                   = GHC.Prim.mutableByteArrayContents#
                                                       @GHC.Prim.RealWorld ipv1_abl8 } in
                                               let {
                                                 ipv3_abla :: GHC.ForeignPtr.ForeignPtrContents
                                                 [LclId,
                                                  Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                          Value=True, ConLike=True, WorkFree=True,
                                                          Expandable=True,
                                                          Guidance=IF_ARGS [] 10 10}]
                                                 ipv3_abla = GHC.ForeignPtr.PlainPtr ipv1_abl8 } in
                                               case ds_abkN of { GHC.Word.W8# x1_abms ->
                                               case GHC.Prim.writeWord8OffAddr#
                                                      @GHC.Prim.RealWorld
                                                      ipv2_abl6
                                                      0#
                                                      x1_abms
                                                      ipv_abl7
                                               of s2_abmu
                                               { __DEFAULT ->
                                               case GHC.Prim.touch#
                                                      @'GHC.Types.Lifted
                                                      @GHC.ForeignPtr.ForeignPtrContents
                                                      ipv3_abla
                                                      s2_abmu
                                               of s'_abmv
                                               { __DEFAULT ->
                                               case {__ffi_static_ccall_unsafe base:memcpy :: Addr#
                                          -> Addr#
                                          -> Word64#
                                          -> State# RealWorld
                                          -> (# State# RealWorld, Addr# #)}_abmw
                                                      (GHC.Prim.plusAddr# ipv2_abl6 1#)
                                                      bx_abl0
                                                      (GHC.Prim.int64ToWord64#
                                                         (GHC.Prim.intToInt64# bx2_abl2))
                                                      s'_abmv
                                               of
                                               { (# ds4_abmy, ds5_abmz #) ->
                                               case GHC.Prim.touch#
                                                      @'GHC.Types.Lifted
                                                      @GHC.ForeignPtr.ForeignPtrContents
                                                      bx1_abl1
                                                      ds4_abmy
                                               of s'1_abmB
                                               { __DEFAULT ->
                                               case GHC.Prim.touch#
                                                      @'GHC.Types.Lifted
                                                      @GHC.ForeignPtr.ForeignPtrContents
                                                      ipv3_abla
                                                      s'1_abmB
                                               of s'2_abmC
                                               { __DEFAULT ->
                                               case GHC.Magic.lazy
                                                      @((GHC.Prim.State# GHC.Prim.RealWorld
                                                         -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                               GHC.Prim.Addr# #))
                                                        -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                              GHC.Prim.Addr# #))
                                                      (GHC.Magic.runRW#
                                                         @('GHC.Types.TupleRep
                                                             '[GHC.Types.ZeroBitRep,
                                                               'GHC.Types.AddrRep])
                                                         @(# GHC.Prim.State# GHC.Prim.RealWorld,
                                                             GHC.Prim.Addr# #))
                                                      (\ _ [Occ=Dead] -> (# s'2_abmC, ipv2_abl6 #))
                                               of
                                               { (# ipv6_abmF, ipv7_abmG #) ->
                                               Data.ByteString.Internal.Type.BS
                                                 ipv7_abmG ipv3_abla x_abkZ
                                               }
                                               }
                                               }
                                               }
                                               }
                                               }
                                               }
                                               };
                                             1# ->
                                               case GHC.ForeignPtr.mallocPlainForeignPtrBytes2
                                               of wild_00 {
                                               }
                                           })
                                      }
                                      }) } in
                           \ (ds3_abmJ
                                :: Data.Either.Either
                                     Data.ByteString.Internal.Type.ByteString
                                     (f_abkr
                                        (GHC.Word.Word8,
                                         Data.ByteString.Internal.Type.ByteString))) ->
                             case ds3_abmJ of {
                               Data.Either.Left x_abmL -> f2_abkJ x_abmL;
                               Data.Either.Right y_abmN -> ds2_abkK y_abmN
                             }) } in
                  let {
                    g_abmP
                      :: p_abkq
                           (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                           (f_abkr (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                         -> p_abkq
                              (Data.Either.Either
                                 Data.ByteString.Internal.Type.ByteString
                                 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                              (Data.Either.Either
                                 Data.ByteString.Internal.Type.ByteString
                                 (f_abkr
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abmP
                      = Data.Profunctor.Choice.right'
                          @p_abkq
                          $dChoice_abks
                          @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                          @(f_abkr
                              (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                          @Data.ByteString.Internal.Type.ByteString } in
                  \ (x_abmQ
                       :: p_abkq
                            (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                            (f_abkr
                               (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))) ->
                    f1_abku (g_abmP x_abmQ))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <Data.ByteString.Internal.Type.ByteString>_N
                                <Data.ByteString.Internal.Type.ByteString>_N
                                <GHC.Word.Word8>_N
                                <GHC.Word.Word8>_N)
                       :: Control.Lens.Type.Prism
                            Data.ByteString.Internal.Type.ByteString
                            Data.ByteString.Internal.Type.ByteString
                            (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                            (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                          ~R# Control.Lens.Cons.Cons
                                Data.ByteString.Internal.Type.ByteString
                                Data.ByteString.Internal.Type.ByteString
                                GHC.Word.Word8
                                GHC.Word.Word8))
              ((\ (@(p_abmX :: * -> * -> *))
                  (@(f_abmY :: * -> *))
                  ($dChoice_abmZ :: Data.Profunctor.Choice.Choice p_abmX)
                  ($dApplicative_abn0 :: GHC.Base.Applicative f_abmY) ->
                  let {
                    f1_abn1
                      :: p_abmX
                           (Data.Either.Either Data.ByteString.Internal.Type.ByteString ())
                           (Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString (f_abmY ()))
                         -> p_abmX
                              Data.ByteString.Internal.Type.ByteString
                              (f_abmY Data.ByteString.Internal.Type.ByteString)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 350 0}]
                    f1_abn1
                      = Data.Profunctor.Unsafe.dimap
                          @p_abmX
                          (Data.Profunctor.Choice.$p1Choice @p_abmX $dChoice_abmZ)
                          @Data.ByteString.Internal.Type.ByteString
                          @(Data.Either.Either Data.ByteString.Internal.Type.ByteString ())
                          @(Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString (f_abmY ()))
                          @(f_abmY Data.ByteString.Internal.Type.ByteString)
                          (\ (s_abn2 :: Data.ByteString.Internal.Type.ByteString) ->
                             case s_abn2 of wild_abn3
                             { Data.ByteString.Internal.Type.BS bx_abn4 bx1_abn5 bx2_abn6 ->
                             case GHC.Classes.leInt (GHC.Types.I# bx2_abn6) (GHC.Types.I# 0#)
                             of {
                               GHC.Types.False ->
                                 Data.Either.Left
                                   @Data.ByteString.Internal.Type.ByteString @() wild_abn3;
                               GHC.Types.True ->
                                 Data.Either.Right
                                   @Data.ByteString.Internal.Type.ByteString @() GHC.Tuple.Prim.()
                             }
                             })
                          (let {
                             f2_abna
                               :: Data.ByteString.Internal.Type.ByteString
                                  -> f_abmY Data.ByteString.Internal.Type.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abna
                               = GHC.Base.pure
                                   @f_abmY
                                   $dApplicative_abn0
                                   @Data.ByteString.Internal.Type.ByteString } in
                           let {
                             ds2_abnb
                               :: f_abmY () -> f_abmY Data.ByteString.Internal.Type.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 70 0}]
                             ds2_abnb
                               = GHC.Base.fmap
                                   @f_abmY
                                   (GHC.Base.$p1Applicative @f_abmY $dApplicative_abn0)
                                   @()
                                   @Data.ByteString.Internal.Type.ByteString
                                   (\ (ds3_abnc :: ()) ->
                                      case ds3_abnc of { () ->
                                      Data.ByteString.Internal.Type.empty
                                      }) } in
                           \ (ds3_abne
                                :: Data.Either.Either
                                     Data.ByteString.Internal.Type.ByteString (f_abmY ())) ->
                             case ds3_abne of {
                               Data.Either.Left x_abng -> f2_abna x_abng;
                               Data.Either.Right y_abni -> ds2_abnb y_abni
                             }) } in
                  let {
                    g_abnk
                      :: p_abmX () (f_abmY ())
                         -> p_abmX
                              (Data.Either.Either Data.ByteString.Internal.Type.ByteString ())
                              (Data.Either.Either
                                 Data.ByteString.Internal.Type.ByteString (f_abmY ()))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abnk
                      = Data.Profunctor.Choice.right'
                          @p_abmX
                          $dChoice_abmZ
                          @()
                          @(f_abmY ())
                          @Data.ByteString.Internal.Type.ByteString } in
                  \ (x_abnl :: p_abmX () (f_abmY ())) -> f1_abn1 (g_abnk x_abnl))
               `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                <Data.ByteString.Internal.Type.ByteString>_N)
                       :: Control.Lens.Type.Prism'
                            Data.ByteString.Internal.Type.ByteString ()
                          ~R# Control.Lens.Empty.AsEmpty
                                Data.ByteString.Internal.Type.ByteString))
              (Data.Functor.Contravariant.$fContravariantConst
                 @Data.ByteString.Internal.Type.ByteString)
              (Data.Functor.Const.$fFunctorConst
                 @Data.ByteString.Internal.Type.ByteString)
    Cont:   ApplyToVal nodup hole Control.Lens.Getter.Getting
                                    Data.ByteString.Internal.Type.ByteString
                                    [GHC.Word.Word8]
                                    Data.ByteString.Internal.Type.ByteString
              ((\ (ds_abeK [Occ=Once1] :: a_abeH) -> ds_abeK)
               `cast` (<a_abeH>_R
                       %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                          <*>_N <a_abeH>_R <a_abeH>_P)
                       :: (a_abeH -> a_abeH)
                          ~R# (a_abeH -> Data.Functor.Const.Const a_abeH a_abeH)))
            ApplyToVal nodup hole [GHC.Word.Word8]
                                  -> Data.Functor.Const.Const
                                       Data.ByteString.Internal.Type.ByteString [GHC.Word.Word8]
              s_a8Px
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N
                        <Data.ByteString.Internal.Type.ByteString>_R
                        <[GHC.Word.Word8]>_P
                    :: Data.Functor.Const.Const
                         Data.ByteString.Internal.Type.ByteString [GHC.Word.Word8]
                       ~R# Data.ByteString.Internal.Type.ByteString)
            Stop[BoringCtxt] Data.ByteString.Internal.Type.ByteString
Rule fired
    Rule: Class op fmap
    Module: (BUILTIN)
    Before: GHC.Base.fmap
              TyArg Data.Functor.Const.Const
                      Data.ByteString.Internal.Type.ByteString
              ValArg Data.Functor.Const.$fFunctorConst
                       @Data.ByteString.Internal.Type.ByteString
    After:  (Data.Functor.Const.$fFunctorConst2
               @Data.ByteString.Internal.Type.ByteString)
            `cast` (forall (a :: <*>_N) (b :: <*>_N).
                    <a -> b>_R
                    %<'GHC.Types.Many>_N ->_R <Data.Functor.Const.Const
                                                 Data.ByteString.Internal.Type.ByteString a>_R
                    %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                  <*>_N
                                                  <Data.ByteString.Internal.Type.ByteString>_R
                                                  <a>_P
                                              ; Sym (Data.Functor.Const.N:Const[0]
                                                         <*>_N
                                                         <Data.ByteString.Internal.Type.ByteString>_R
                                                         <b>_P)
                    :: (forall {a} {b}.
                        (a -> b)
                        -> Data.Functor.Const.Const
                             Data.ByteString.Internal.Type.ByteString a
                        -> Data.Functor.Const.Const
                             Data.ByteString.Internal.Type.ByteString a)
                       ~R# (forall {a} {b}.
                            (a -> b)
                            -> Data.Functor.Const.Const
                                 Data.ByteString.Internal.Type.ByteString a
                            -> Data.Functor.Const.Const
                                 Data.ByteString.Internal.Type.ByteString b))
    Cont:   ApplyToTy Data.ByteString.Internal.Type.ByteString
            ApplyToTy [GHC.Word.Word8]
            ApplyToVal nodup hole (Data.ByteString.Internal.Type.ByteString
                                   -> [GHC.Word.Word8])
                                  -> Data.Functor.Const.Const
                                       Data.ByteString.Internal.Type.ByteString
                                       Data.ByteString.Internal.Type.ByteString
                                  -> Data.Functor.Const.Const
                                       Data.ByteString.Internal.Type.ByteString [GHC.Word.Word8]
              Data.ByteString.unpack
            ApplyToVal nodup hole Data.Functor.Const.Const
                                    Data.ByteString.Internal.Type.ByteString
                                    Data.ByteString.Internal.Type.ByteString
                                  -> Data.Functor.Const.Const
                                       Data.ByteString.Internal.Type.ByteString [GHC.Word.Word8]
              (bc_aboH (ab_aboF x_aboI))
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N
                        <Data.ByteString.Internal.Type.ByteString>_R
                        <[GHC.Word.Word8]>_P
                    :: Data.Functor.Const.Const
                         Data.ByteString.Internal.Type.ByteString [GHC.Word.Word8]
                       ~R# Data.ByteString.Internal.Type.ByteString)
            Stop[BoringCtxt] Data.ByteString.Internal.Type.ByteString
Rule fired
    Rule: Class op ==
    Module: (BUILTIN)
    Before: GHC.Classes.==
              TyArg [GHC.Word.Word8]
              ValArg $dEq_a9eu
              ValArg GHC.Base.build
                       @GHC.Word.Word8
                       (\ (@b_abrL) ->
                          Data.ByteString.unpackFoldr
                            @b_abrL (Data.ByteString.Internal.Type.packBytes s_a8Px))
              ValArg s_a8Px
    After:  GHC.Classes.$fEqList_$c==
              @GHC.Word.Word8 GHC.Word.$fEqWord8
              ValArg GHC.Base.build
                       @GHC.Word.Word8
                       (\ (@b_abrL) ->
                          Data.ByteString.unpackFoldr
                            @b_abrL (Data.ByteString.Internal.Type.packBytes s_a8Px))
              ValArg s_a8Px
    Cont:   Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: unpack
    Module: (GHC.Base)
    Before: GHC.CString.unpackCString# ValArg "[W8] -> L -> [W8]"#
    After:  (\ (a_ab7z :: GHC.Prim.Addr#) ->
               GHC.Base.build
                 @GHC.Types.Char
                 (\ (@b_ab7A) -> GHC.CString.unpackFoldrCString# @b_ab7A a_ab7z))
              "[W8] -> L -> [W8]"#
    Cont:   Stop[BoringCtxt] Test.Tasty.Core.TestName
Rule fired
    Rule: Class op property
    Module: (BUILTIN)
    Before: Test.QuickCheck.Property.property
              TyArg [GHC.Word.Word8] -> GHC.Types.Bool ValArg $dTestable_a9en
    After:  Test.QuickCheck.Property.$fTestableFUN_$cproperty
              @[GHC.Word.Word8]
              @GHC.Types.Bool
              $dArbitrary_aacW
              $dShow_aacX
              Test.QuickCheck.Property.$fTestableBool
    Cont:   ApplyToVal nodup hole ([GHC.Word.Word8] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              prop_ab7M
            CastIt (Sym (Test.Tasty.QuickCheck.N:QC[0])
                    :: Test.QuickCheck.Property.Property ~R# Test.Tasty.QuickCheck.QC)
            Stop[BoringCtxt] Test.Tasty.QuickCheck.QC
Rule fired
    Rule: Class op propertyForAllShrinkShow
    Module: (BUILTIN)
    Before: Test.QuickCheck.Property.propertyForAllShrinkShow
              TyArg GHC.Types.Bool ValArg Test.QuickCheck.Property.$fTestableBool
    After:  Test.QuickCheck.Property.$fTestableBool1
            `cast` (forall (a :: <*>_N).
                    <Test.QuickCheck.Gen.Gen a>_R
                    %<'GHC.Types.Many>_N ->_R <a -> [a]>_R
                    %<'GHC.Types.Many>_N ->_R <a -> [GHC.Base.String]>_R
                    %<'GHC.Types.Many>_N ->_R <a -> GHC.Types.Bool>_R
                    %<'GHC.Types.Many>_N ->_R Sym (Test.QuickCheck.Gen.N:Gen[0]
                                                       (Test.QuickCheck.Property.N:Prop[0]))
                                              ; Sym (Test.QuickCheck.Property.N:Property[0])
                    :: (forall {a}.
                        Test.QuickCheck.Gen.Gen a
                        -> (a -> [a])
                        -> (a -> [GHC.Base.String])
                        -> (a -> GHC.Types.Bool)
                        -> Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int
                        -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result)
                       ~R# (forall {a}.
                            Test.QuickCheck.Gen.Gen a
                            -> (a -> [a])
                            -> (a -> [GHC.Base.String])
                            -> (a -> GHC.Types.Bool)
                            -> Test.QuickCheck.Property.Property))
    Cont:   ApplyToTy [GHC.Word.Word8]
            ApplyToVal nodup hole Test.QuickCheck.Gen.Gen [GHC.Word.Word8]
                                  -> ([GHC.Word.Word8] -> [[GHC.Word.Word8]])
                                  -> ([GHC.Word.Word8] -> [GHC.Base.String])
                                  -> ([GHC.Word.Word8] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (Test.QuickCheck.Arbitrary.arbitrary @a_ab9u $dArbitrary_ab9w)
            ApplyToVal nodup hole ([GHC.Word.Word8] -> [[GHC.Word.Word8]])
                                  -> ([GHC.Word.Word8] -> [GHC.Base.String])
                                  -> ([GHC.Word.Word8] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (Test.QuickCheck.Arbitrary.shrink @a_ab9u $dArbitrary_ab9w)
            ApplyToVal nodup hole ([GHC.Word.Word8] -> [GHC.Base.String])
                                  -> ([GHC.Word.Word8] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (let {
                 g_ab9A [Occ=OnceL1!] :: a_ab9u -> GHC.Base.String
                 [LclId]
                 g_ab9A = GHC.Show.show @a_ab9u $dShow_ab9x } in
               \ (x_ab9B [Occ=Once1] :: a_ab9u) ->
                 GHC.Types.:
                   @GHC.Base.String (g_ab9A x_ab9B) (GHC.Types.[] @GHC.Base.String))
            ApplyToVal nodup hole ([GHC.Word.Word8] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              f_ab9z
            CastIt (Sym (Test.Tasty.QuickCheck.N:QC[0])
                    :: Test.QuickCheck.Property.Property ~R# Test.Tasty.QuickCheck.QC)
            Stop[BoringCtxt] Test.Tasty.QuickCheck.QC
Rule fired
    Rule: Class op arbitrary
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.arbitrary
              TyArg [GHC.Word.Word8] ValArg $dArbitrary_aacW
    After:  (Test.QuickCheck.Arbitrary.$fArbitraryList1
               @GHC.Word.Word8 Test.QuickCheck.Arbitrary.$fArbitraryWord8)
            `cast` (Sym (Test.QuickCheck.Gen.N:Gen[0] <[GHC.Word.Word8]>_R)
                    :: (Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int -> [GHC.Word.Word8])
                       ~R# Test.QuickCheck.Gen.Gen [GHC.Word.Word8])
    Cont:   Stop[BoringCtxt] Test.QuickCheck.Gen.Gen [GHC.Word.Word8]
Rule fired
    Rule: Class op arbitrary
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.arbitrary
              TyArg GHC.Word.Word8
              ValArg Test.QuickCheck.Arbitrary.$fArbitraryWord8
    After:  Test.QuickCheck.Arbitrary.$fArbitraryWord8_$sarbitrarySizedBoundedIntegral
            `cast` (Sym (Test.QuickCheck.Gen.N:Gen[0] <GHC.Word.Word8>_R)
                    :: (Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int -> GHC.Word.Word8)
                       ~R# Test.QuickCheck.Gen.Gen GHC.Word.Word8)
    Cont:   Stop[BoringCtxt, C(S,C(1,L))] Test.QuickCheck.Gen.Gen
                                            GHC.Word.Word8
Rule fired
    Rule: Class op shrink
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.shrink
              TyArg [GHC.Word.Word8] ValArg $dArbitrary_aacW
    After:  Test.QuickCheck.Arbitrary.$fArbitraryList_$cshrink
              @GHC.Word.Word8 Test.QuickCheck.Arbitrary.$fArbitraryWord8
    Cont:   Stop[BoringCtxt] [GHC.Word.Word8] -> [[GHC.Word.Word8]]
Rule fired
    Rule: Class op shrink
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.shrink
              TyArg GHC.Word.Word8
              ValArg Test.QuickCheck.Arbitrary.$fArbitraryWord8
    After:  Test.QuickCheck.Arbitrary.$fArbitraryWord8_$sshrinkIntegral
    Cont:   Stop[DiscArgCtxt, C(S,L)] GHC.Word.Word8
                                      -> [GHC.Word.Word8]
Rule fired
    Rule: Class op show
    Module: (BUILTIN)
    Before: GHC.Show.show TyArg [GHC.Word.Word8] ValArg $dShow_aacX
    After:  GHC.Show.$fShowList_$cshow
              @GHC.Word.Word8 GHC.Word.$fShowWord8
    Cont:   Stop[RhsCtxt(NonRecursive)] [GHC.Word.Word8]
                                        -> GHC.Base.String
Rule fired
    Rule: Class op showList
    Module: (BUILTIN)
    Before: GHC.Show.showList
              TyArg GHC.Word.Word8 ValArg GHC.Word.$fShowWord8
    After:  GHC.Word.$fShowWord8_$cshowList
    Cont:   ApplyToVal nodup hole [GHC.Word.Word8] -> GHC.Show.ShowS
              x_abrp
            ApplyToVal nodup hole GHC.Show.ShowS (GHC.Types.[] @GHC.Types.Char)
            Stop[BoringCtxt] GHC.Base.String
Rule fired
    Rule: Class op reader
    Module: (BUILTIN)
    Before: Control.Monad.Reader.Class.reader
              TyArg Data.ByteString.Lazy.Internal.ByteString
              TyArg (->) Data.ByteString.Lazy.Internal.ByteString
              ValArg Control.Monad.Reader.Class.$fMonadReaderrFUN
                       @Data.ByteString.Lazy.Internal.ByteString
    After:  \ (@a_abeP) ->
              GHC.Base.id @(Data.ByteString.Lazy.Internal.ByteString -> a_abeP)
    Cont:   ApplyToTy [GHC.Word.Word8]
            ApplyToVal nodup hole (Data.ByteString.Lazy.Internal.ByteString
                                   -> [GHC.Word.Word8])
                                  -> Data.ByteString.Lazy.Internal.ByteString -> [GHC.Word.Word8]
              ((l_abeJ
                  ((\ (ds_abeK [Occ=Once1] :: a_abeH) -> ds_abeK)
                   `cast` (<a_abeH>_R
                           %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                              <*>_N <a_abeH>_R <a_abeH>_P)
                           :: (a_abeH -> a_abeH)
                              ~R# (a_abeH -> Data.Functor.Const.Const a_abeH a_abeH))))
               `cast` (<s_abeF>_R
                       %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                     <*>_N <a_abeH>_R <s_abeF>_P
                       :: (s_abeF -> Data.Functor.Const.Const a_abeH s_abeF)
                          ~R# (s_abeF -> a_abeH)))
            ApplyToVal nodup hole Data.ByteString.Lazy.Internal.ByteString
                                  -> [GHC.Word.Word8]
              (Control.Lens.Getter.view
                 @[GHC.Word.Word8]
                 @((->) [GHC.Word.Word8])
                 @Data.ByteString.Lazy.Internal.ByteString
                 (Control.Monad.Reader.Class.$fMonadReaderrFUN @[GHC.Word.Word8])
                 (Control.Lens.Cons.Extras.recons
                    @[GHC.Word.Word8]
                    @GHC.Word.Word8
                    @Data.ByteString.Lazy.Internal.ByteString
                    (Control.Lens.Cons.$fConsListListab
                       @GHC.Word.Word8 @GHC.Word.Word8)
                    Control.Lens.Cons.$fConsByteStringByteStringWord8Word8
                    Control.Lens.Empty.$fAsEmptyByteString
                    @(Data.Functor.Const.Const
                        Data.ByteString.Lazy.Internal.ByteString)
                    (Data.Functor.Contravariant.$fContravariantConst
                       @Data.ByteString.Lazy.Internal.ByteString)
                    (Data.Functor.Const.$fFunctorConst
                       @Data.ByteString.Lazy.Internal.ByteString))
                 s_a8Py)
            Stop[RuleArgCtxt] [GHC.Word.Word8]
Rule fired
    Rule: recons/lazybs-list
    Module: (Control.Lens.Cons.Extras)
    Before: Control.Lens.Cons.Extras.recons
              TyArg Data.ByteString.Lazy.Internal.ByteString
              TyArg GHC.Word.Word8
              TyArg [GHC.Word.Word8]
              ValArg (\ (@(p_abnq :: * -> * -> *))
                        (@(f_abnr :: * -> *))
                        ($dChoice_abns :: Data.Profunctor.Choice.Choice p_abnq)
                        ($dApplicative_abnt :: GHC.Base.Applicative f_abnr) ->
                        let {
                          f1_abnu
                            :: p_abnq
                                 (Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                                 (Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (f_abnr
                                       (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                               -> p_abnq
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (f_abnr Data.ByteString.Lazy.Internal.ByteString)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 536 0}]
                          f1_abnu
                            = Data.Profunctor.Unsafe.dimap
                                @p_abnq
                                (Data.Profunctor.Choice.$p1Choice @p_abnq $dChoice_abns)
                                @Data.ByteString.Lazy.Internal.ByteString
                                @(Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                                @(Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (f_abnr
                                       (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                                @(f_abnr Data.ByteString.Lazy.Internal.ByteString)
                                (\ (s1_abnv :: Data.ByteString.Lazy.Internal.ByteString) ->
                                   case s1_abnv of {
                                     Data.ByteString.Lazy.Internal.Empty ->
                                       Data.Either.Left
                                         @Data.ByteString.Lazy.Internal.ByteString
                                         @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                         Data.ByteString.Lazy.Internal.Empty;
                                     Data.ByteString.Lazy.Internal.Chunk bx_abnC bx1_abnD bx2_abnE
                                                                         cs_abnF ->
                                       case bx2_abnE of ds1_abnH {
                                         __DEFAULT ->
                                           Data.Either.Right
                                             @Data.ByteString.Lazy.Internal.ByteString
                                             @(GHC.Word.Word8,
                                               Data.ByteString.Lazy.Internal.ByteString)
                                             (case GHC.Prim.readWord8OffAddr#
                                                     @GHC.Prim.RealWorld
                                                     bx_abnC
                                                     0#
                                                     GHC.Prim.realWorld#
                                              of
                                              { (# ipv_abnJ, ipv1_abnK #) ->
                                              case GHC.Prim.touch#
                                                     @'GHC.Types.Lifted
                                                     @GHC.ForeignPtr.ForeignPtrContents
                                                     bx1_abnD
                                                     ipv_abnJ
                                              of
                                              { __DEFAULT ->
                                              GHC.Word.W8# ipv1_abnK
                                              }
                                              },
                                              Data.ByteString.Lazy.Internal.$WChunk
                                                (Data.ByteString.Internal.Type.$WBS
                                                   (GHC.ForeignPtr.ForeignPtr
                                                      @GHC.Word.Word8
                                                      (GHC.Prim.plusAddr# bx_abnC 1#)
                                                      bx1_abnD)
                                                   (GHC.Types.I# (GHC.Prim.-# ds1_abnH 1#)))
                                                cs_abnF);
                                         1# ->
                                           Data.Either.Right
                                             @Data.ByteString.Lazy.Internal.ByteString
                                             @(GHC.Word.Word8,
                                               Data.ByteString.Lazy.Internal.ByteString)
                                             (case GHC.Prim.readWord8OffAddr#
                                                     @GHC.Prim.RealWorld
                                                     bx_abnC
                                                     0#
                                                     GHC.Prim.realWorld#
                                              of
                                              { (# ipv_abnO, ipv1_abnP #) ->
                                              case GHC.Prim.touch#
                                                     @'GHC.Types.Lifted
                                                     @GHC.ForeignPtr.ForeignPtrContents
                                                     bx1_abnD
                                                     ipv_abnO
                                              of
                                              { __DEFAULT ->
                                              GHC.Word.W8# ipv1_abnP
                                              }
                                              },
                                              cs_abnF)
                                       }
                                   })
                                (let {
                                   f2_abnS
                                     :: Data.ByteString.Lazy.Internal.ByteString
                                        -> f_abnr Data.ByteString.Lazy.Internal.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abnS
                                     = GHC.Base.pure
                                         @f_abnr
                                         $dApplicative_abnt
                                         @Data.ByteString.Lazy.Internal.ByteString } in
                                 let {
                                   ds2_abnT
                                     :: f_abnr
                                          (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                        -> f_abnr Data.ByteString.Lazy.Internal.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 162 0}]
                                   ds2_abnT
                                     = GHC.Base.fmap
                                         @f_abnr
                                         (GHC.Base.$p1Applicative @f_abnr $dApplicative_abnt)
                                         @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                         @Data.ByteString.Lazy.Internal.ByteString
                                         (\ (p1_abnU
                                               :: (GHC.Word.Word8,
                                                   Data.ByteString.Lazy.Internal.ByteString)) ->
                                            case p1_abnU of { (x_abnW, ds_abnX) ->
                                            case x_abnW of { GHC.Word.W8# x#_abo0 ->
                                            Data.ByteString.Lazy.Internal.$WChunk
                                              (Data.ByteString.Internal.Type.$WBS
                                                 (GHC.ForeignPtr.ForeignPtr
                                                    @GHC.Word.Word8
                                                    (GHC.Prim.plusAddr#
                                                       Data.ByteString.singleton1
                                                       (GHC.Prim.word2Int#
                                                          (GHC.Prim.word8ToWord# x#_abo0)))
                                                    GHC.ForeignPtr.FinalPtr)
                                                 (GHC.Types.I# 1#))
                                              ds_abnX
                                            }
                                            }) } in
                                 \ (ds3_abo2
                                      :: Data.Either.Either
                                           Data.ByteString.Lazy.Internal.ByteString
                                           (f_abnr
                                              (GHC.Word.Word8,
                                               Data.ByteString.Lazy.Internal.ByteString))) ->
                                   case ds3_abo2 of {
                                     Data.Either.Left x_abo4 -> f2_abnS x_abo4;
                                     Data.Either.Right y_abo6 -> ds2_abnT y_abo6
                                   }) } in
                        let {
                          g_abo8
                            :: p_abnq
                                 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                 (f_abnr (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                               -> p_abnq
                                    (Data.Either.Either
                                       Data.ByteString.Lazy.Internal.ByteString
                                       (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                                    (Data.Either.Either
                                       Data.ByteString.Lazy.Internal.ByteString
                                       (f_abnr
                                          (GHC.Word.Word8,
                                           Data.ByteString.Lazy.Internal.ByteString)))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abo8
                            = Data.Profunctor.Choice.right'
                                @p_abnq
                                $dChoice_abns
                                @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                @(f_abnr
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                                @Data.ByteString.Lazy.Internal.ByteString } in
                        \ (x_abo9
                             :: p_abnq
                                  (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                  (f_abnr
                                     (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))) ->
                          f1_abnu (g_abo8 x_abo9))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <Data.ByteString.Lazy.Internal.ByteString>_N
                                      <Data.ByteString.Lazy.Internal.ByteString>_N
                                      <GHC.Word.Word8>_N
                                      <GHC.Word.Word8>_N)
                             :: Control.Lens.Type.Prism
                                  Data.ByteString.Lazy.Internal.ByteString
                                  Data.ByteString.Lazy.Internal.ByteString
                                  (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                  (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                ~R# Control.Lens.Cons.Cons
                                      Data.ByteString.Lazy.Internal.ByteString
                                      Data.ByteString.Lazy.Internal.ByteString
                                      GHC.Word.Word8
                                      GHC.Word.Word8)
              ValArg (\ (@(p_abgg :: * -> * -> *))
                        (@(f_abgh :: * -> *))
                        ($dChoice_abgi :: Data.Profunctor.Choice.Choice p_abgg)
                        ($dApplicative_abgj :: GHC.Base.Applicative f_abgh) ->
                        let {
                          f1_abgk
                            :: p_abgg
                                 (Data.Either.Either
                                    [GHC.Word.Word8] (GHC.Word.Word8, [GHC.Word.Word8]))
                                 (Data.Either.Either
                                    [GHC.Word.Word8] (f_abgh (GHC.Word.Word8, [GHC.Word.Word8])))
                               -> p_abgg [GHC.Word.Word8] (f_abgh [GHC.Word.Word8])
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 320 0}]
                          f1_abgk
                            = Data.Profunctor.Unsafe.dimap
                                @p_abgg
                                (Data.Profunctor.Choice.$p1Choice @p_abgg $dChoice_abgi)
                                @[GHC.Word.Word8]
                                @(Data.Either.Either
                                    [GHC.Word.Word8] (GHC.Word.Word8, [GHC.Word.Word8]))
                                @(Data.Either.Either
                                    [GHC.Word.Word8] (f_abgh (GHC.Word.Word8, [GHC.Word.Word8])))
                                @(f_abgh [GHC.Word.Word8])
                                (\ (aas_abgl :: [GHC.Word.Word8]) ->
                                   case aas_abgl of {
                                     [] ->
                                       Data.Either.Left
                                         @[GHC.Word.Word8]
                                         @(GHC.Word.Word8, [GHC.Word.Word8])
                                         (GHC.Types.[] @GHC.Word.Word8);
                                     : a1_abgn as_abgo ->
                                       Data.Either.Right
                                         @[GHC.Word.Word8]
                                         @(GHC.Word.Word8, [GHC.Word.Word8])
                                         (a1_abgn, as_abgo)
                                   })
                                (let {
                                   f2_abgq :: [GHC.Word.Word8] -> f_abgh [GHC.Word.Word8]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abgq
                                     = GHC.Base.pure
                                         @f_abgh $dApplicative_abgj @[GHC.Word.Word8] } in
                                 let {
                                   ds2_abgr
                                     :: f_abgh (GHC.Word.Word8, [GHC.Word.Word8])
                                        -> f_abgh [GHC.Word.Word8]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 90 0}]
                                   ds2_abgr
                                     = GHC.Base.fmap
                                         @f_abgh
                                         (GHC.Base.$p1Applicative @f_abgh $dApplicative_abgj)
                                         @(GHC.Word.Word8, [GHC.Word.Word8])
                                         @[GHC.Word.Word8]
                                         (\ (p1_abgs :: (GHC.Word.Word8, [GHC.Word.Word8])) ->
                                            GHC.Types.:
                                              @GHC.Word.Word8
                                              (case p1_abgs of { (x_abgu, ds_abgv) -> x_abgu })
                                              (case p1_abgs of { (ds_abgy, y_abgz) ->
                                               y_abgz
                                               })) } in
                                 \ (ds3_abgB
                                      :: Data.Either.Either
                                           [GHC.Word.Word8]
                                           (f_abgh (GHC.Word.Word8, [GHC.Word.Word8]))) ->
                                   case ds3_abgB of {
                                     Data.Either.Left x_abgD -> f2_abgq x_abgD;
                                     Data.Either.Right y_abgF -> ds2_abgr y_abgF
                                   }) } in
                        let {
                          g_abgH
                            :: p_abgg
                                 (GHC.Word.Word8, [GHC.Word.Word8])
                                 (f_abgh (GHC.Word.Word8, [GHC.Word.Word8]))
                               -> p_abgg
                                    (Data.Either.Either
                                       [GHC.Word.Word8] (GHC.Word.Word8, [GHC.Word.Word8]))
                                    (Data.Either.Either
                                       [GHC.Word.Word8] (f_abgh (GHC.Word.Word8, [GHC.Word.Word8])))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abgH
                            = Data.Profunctor.Choice.right'
                                @p_abgg
                                $dChoice_abgi
                                @(GHC.Word.Word8, [GHC.Word.Word8])
                                @(f_abgh (GHC.Word.Word8, [GHC.Word.Word8]))
                                @[GHC.Word.Word8] } in
                        \ (x_abgI
                             :: p_abgg
                                  (GHC.Word.Word8, [GHC.Word.Word8])
                                  (f_abgh (GHC.Word.Word8, [GHC.Word.Word8]))) ->
                          f1_abgk (g_abgH x_abgI))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <[GHC.Word.Word8]>_N
                                      <[GHC.Word.Word8]>_N
                                      <GHC.Word.Word8>_N
                                      <GHC.Word.Word8>_N)
                             :: Control.Lens.Type.Prism
                                  [GHC.Word.Word8]
                                  [GHC.Word.Word8]
                                  (GHC.Word.Word8, [GHC.Word.Word8])
                                  (GHC.Word.Word8, [GHC.Word.Word8])
                                ~R# Control.Lens.Cons.Cons
                                      [GHC.Word.Word8]
                                      [GHC.Word.Word8]
                                      GHC.Word.Word8
                                      GHC.Word.Word8)
              ValArg (\ (@(p_abgN :: * -> * -> *))
                        (@(f_abgO :: * -> *))
                        ($dChoice_abgP :: Data.Profunctor.Choice.Choice p_abgN)
                        ($dApplicative_abgQ :: GHC.Base.Applicative f_abgO) ->
                        let {
                          f1_abgR
                            :: p_abgN
                                 (Data.Either.Either [GHC.Word.Word8] ())
                                 (Data.Either.Either [GHC.Word.Word8] (f_abgO ()))
                               -> p_abgN [GHC.Word.Word8] (f_abgO [GHC.Word.Word8])
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 290 0}]
                          f1_abgR
                            = Data.Profunctor.Unsafe.dimap
                                @p_abgN
                                (Data.Profunctor.Choice.$p1Choice @p_abgN $dChoice_abgP)
                                @[GHC.Word.Word8]
                                @(Data.Either.Either [GHC.Word.Word8] ())
                                @(Data.Either.Either [GHC.Word.Word8] (f_abgO ()))
                                @(f_abgO [GHC.Word.Word8])
                                (\ (s_abgS :: [GHC.Word.Word8]) ->
                                   case s_abgS of wild_abgT {
                                     [] ->
                                       Data.Either.Right @[GHC.Word.Word8] @() GHC.Tuple.Prim.();
                                     : ds1_abgU ds2_abgV ->
                                       Data.Either.Left @[GHC.Word.Word8] @() wild_abgT
                                   })
                                (let {
                                   f2_abgX :: [GHC.Word.Word8] -> f_abgO [GHC.Word.Word8]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abgX
                                     = GHC.Base.pure
                                         @f_abgO $dApplicative_abgQ @[GHC.Word.Word8] } in
                                 let {
                                   ds2_abgY :: f_abgO () -> f_abgO [GHC.Word.Word8]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 70 0}]
                                   ds2_abgY
                                     = GHC.Base.fmap
                                         @f_abgO
                                         (GHC.Base.$p1Applicative @f_abgO $dApplicative_abgQ)
                                         @()
                                         @[GHC.Word.Word8]
                                         (\ (ds3_abgZ :: ()) ->
                                            case ds3_abgZ of { () ->
                                            GHC.Types.[] @GHC.Word.Word8
                                            }) } in
                                 \ (ds3_abh1 :: Data.Either.Either [GHC.Word.Word8] (f_abgO ())) ->
                                   case ds3_abh1 of {
                                     Data.Either.Left x_abh3 -> f2_abgX x_abh3;
                                     Data.Either.Right y_abh5 -> ds2_abgY y_abh5
                                   }) } in
                        let {
                          g_abh7
                            :: p_abgN () (f_abgO ())
                               -> p_abgN
                                    (Data.Either.Either [GHC.Word.Word8] ())
                                    (Data.Either.Either [GHC.Word.Word8] (f_abgO ()))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abh7
                            = Data.Profunctor.Choice.right'
                                @p_abgN $dChoice_abgP @() @(f_abgO ()) @[GHC.Word.Word8] } in
                        \ (x_abh8 :: p_abgN () (f_abgO ())) -> f1_abgR (g_abh7 x_abh8))
                     `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0] <[GHC.Word.Word8]>_N)
                             :: Control.Lens.Type.Prism' [GHC.Word.Word8] ()
                                ~R# Control.Lens.Empty.AsEmpty [GHC.Word.Word8])
              TyArg Data.Functor.Const.Const [GHC.Word.Word8]
              ValArg Data.Functor.Contravariant.$fContravariantConst
                       @[GHC.Word.Word8]
              ValArg Data.Functor.Const.$fFunctorConst @[GHC.Word.Word8]
    After:  (\ (@(f_abfI :: * -> *))
               ($dCons_abfJ
                  :: Control.Lens.Cons.Cons
                       Data.ByteString.Lazy.Internal.ByteString
                       Data.ByteString.Lazy.Internal.ByteString
                       GHC.Word.Word8
                       GHC.Word.Word8)
               ($dCons1_abfK
                  :: Control.Lens.Cons.Cons
                       [GHC.Word.Word8] [GHC.Word.Word8] GHC.Word.Word8 GHC.Word.Word8)
               ($dAsEmpty_abfL :: Control.Lens.Empty.AsEmpty [GHC.Word.Word8])
               ($dContravariant_abfM
                  :: Data.Functor.Contravariant.Contravariant f_abfI)
               ($dFunctor_abfN :: GHC.Base.Functor f_abfI) ->
               Data.Profunctor.Unsafe.$fProfunctorFUN_$cdimap
                 @Data.ByteString.Lazy.Internal.ByteString
                 @[GHC.Word.Word8]
                 @(f_abfI [GHC.Word.Word8])
                 @(f_abfI Data.ByteString.Lazy.Internal.ByteString)
                 Data.ByteString.Lazy.Internal.unpackBytes
                 (GHC.Base.fmap
                    @f_abfI
                    $dFunctor_abfN
                    @[GHC.Word.Word8]
                    @Data.ByteString.Lazy.Internal.ByteString
                    Data.ByteString.Lazy.Internal.packBytes))
              @(Data.Functor.Const.Const [GHC.Word.Word8])
              ((\ (@(p_abnq :: * -> * -> *))
                  (@(f_abnr :: * -> *))
                  ($dChoice_abns :: Data.Profunctor.Choice.Choice p_abnq)
                  ($dApplicative_abnt :: GHC.Base.Applicative f_abnr) ->
                  let {
                    f1_abnu
                      :: p_abnq
                           (Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString
                              (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                           (Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString
                              (f_abnr
                                 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                         -> p_abnq
                              Data.ByteString.Lazy.Internal.ByteString
                              (f_abnr Data.ByteString.Lazy.Internal.ByteString)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 536 0}]
                    f1_abnu
                      = Data.Profunctor.Unsafe.dimap
                          @p_abnq
                          (Data.Profunctor.Choice.$p1Choice @p_abnq $dChoice_abns)
                          @Data.ByteString.Lazy.Internal.ByteString
                          @(Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString
                              (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                          @(Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString
                              (f_abnr
                                 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                          @(f_abnr Data.ByteString.Lazy.Internal.ByteString)
                          (\ (s1_abnv :: Data.ByteString.Lazy.Internal.ByteString) ->
                             case s1_abnv of {
                               Data.ByteString.Lazy.Internal.Empty ->
                                 Data.Either.Left
                                   @Data.ByteString.Lazy.Internal.ByteString
                                   @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                   Data.ByteString.Lazy.Internal.Empty;
                               Data.ByteString.Lazy.Internal.Chunk bx_abnC bx1_abnD bx2_abnE
                                                                   cs_abnF ->
                                 case bx2_abnE of ds1_abnH {
                                   __DEFAULT ->
                                     Data.Either.Right
                                       @Data.ByteString.Lazy.Internal.ByteString
                                       @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                       (case GHC.Prim.readWord8OffAddr#
                                               @GHC.Prim.RealWorld bx_abnC 0# GHC.Prim.realWorld#
                                        of
                                        { (# ipv_abnJ, ipv1_abnK #) ->
                                        case GHC.Prim.touch#
                                               @'GHC.Types.Lifted
                                               @GHC.ForeignPtr.ForeignPtrContents
                                               bx1_abnD
                                               ipv_abnJ
                                        of
                                        { __DEFAULT ->
                                        GHC.Word.W8# ipv1_abnK
                                        }
                                        },
                                        Data.ByteString.Lazy.Internal.$WChunk
                                          (Data.ByteString.Internal.Type.$WBS
                                             (GHC.ForeignPtr.ForeignPtr
                                                @GHC.Word.Word8
                                                (GHC.Prim.plusAddr# bx_abnC 1#)
                                                bx1_abnD)
                                             (GHC.Types.I# (GHC.Prim.-# ds1_abnH 1#)))
                                          cs_abnF);
                                   1# ->
                                     Data.Either.Right
                                       @Data.ByteString.Lazy.Internal.ByteString
                                       @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                       (case GHC.Prim.readWord8OffAddr#
                                               @GHC.Prim.RealWorld bx_abnC 0# GHC.Prim.realWorld#
                                        of
                                        { (# ipv_abnO, ipv1_abnP #) ->
                                        case GHC.Prim.touch#
                                               @'GHC.Types.Lifted
                                               @GHC.ForeignPtr.ForeignPtrContents
                                               bx1_abnD
                                               ipv_abnO
                                        of
                                        { __DEFAULT ->
                                        GHC.Word.W8# ipv1_abnP
                                        }
                                        },
                                        cs_abnF)
                                 }
                             })
                          (let {
                             f2_abnS
                               :: Data.ByteString.Lazy.Internal.ByteString
                                  -> f_abnr Data.ByteString.Lazy.Internal.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abnS
                               = GHC.Base.pure
                                   @f_abnr
                                   $dApplicative_abnt
                                   @Data.ByteString.Lazy.Internal.ByteString } in
                           let {
                             ds2_abnT
                               :: f_abnr
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                  -> f_abnr Data.ByteString.Lazy.Internal.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 162 0}]
                             ds2_abnT
                               = GHC.Base.fmap
                                   @f_abnr
                                   (GHC.Base.$p1Applicative @f_abnr $dApplicative_abnt)
                                   @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                   @Data.ByteString.Lazy.Internal.ByteString
                                   (\ (p1_abnU
                                         :: (GHC.Word.Word8,
                                             Data.ByteString.Lazy.Internal.ByteString)) ->
                                      case p1_abnU of { (x_abnW, ds_abnX) ->
                                      case x_abnW of { GHC.Word.W8# x#_abo0 ->
                                      Data.ByteString.Lazy.Internal.$WChunk
                                        (Data.ByteString.Internal.Type.$WBS
                                           (GHC.ForeignPtr.ForeignPtr
                                              @GHC.Word.Word8
                                              (GHC.Prim.plusAddr#
                                                 Data.ByteString.singleton1
                                                 (GHC.Prim.word2Int#
                                                    (GHC.Prim.word8ToWord# x#_abo0)))
                                              GHC.ForeignPtr.FinalPtr)
                                           (GHC.Types.I# 1#))
                                        ds_abnX
                                      }
                                      }) } in
                           \ (ds3_abo2
                                :: Data.Either.Either
                                     Data.ByteString.Lazy.Internal.ByteString
                                     (f_abnr
                                        (GHC.Word.Word8,
                                         Data.ByteString.Lazy.Internal.ByteString))) ->
                             case ds3_abo2 of {
                               Data.Either.Left x_abo4 -> f2_abnS x_abo4;
                               Data.Either.Right y_abo6 -> ds2_abnT y_abo6
                             }) } in
                  let {
                    g_abo8
                      :: p_abnq
                           (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                           (f_abnr (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                         -> p_abnq
                              (Data.Either.Either
                                 Data.ByteString.Lazy.Internal.ByteString
                                 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                              (Data.Either.Either
                                 Data.ByteString.Lazy.Internal.ByteString
                                 (f_abnr
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abo8
                      = Data.Profunctor.Choice.right'
                          @p_abnq
                          $dChoice_abns
                          @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                          @(f_abnr
                              (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                          @Data.ByteString.Lazy.Internal.ByteString } in
                  \ (x_abo9
                       :: p_abnq
                            (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                            (f_abnr
                               (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))) ->
                    f1_abnu (g_abo8 x_abo9))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <Data.ByteString.Lazy.Internal.ByteString>_N
                                <Data.ByteString.Lazy.Internal.ByteString>_N
                                <GHC.Word.Word8>_N
                                <GHC.Word.Word8>_N)
                       :: Control.Lens.Type.Prism
                            Data.ByteString.Lazy.Internal.ByteString
                            Data.ByteString.Lazy.Internal.ByteString
                            (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                            (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                          ~R# Control.Lens.Cons.Cons
                                Data.ByteString.Lazy.Internal.ByteString
                                Data.ByteString.Lazy.Internal.ByteString
                                GHC.Word.Word8
                                GHC.Word.Word8))
              ((\ (@(p_abgg :: * -> * -> *))
                  (@(f_abgh :: * -> *))
                  ($dChoice_abgi :: Data.Profunctor.Choice.Choice p_abgg)
                  ($dApplicative_abgj :: GHC.Base.Applicative f_abgh) ->
                  let {
                    f1_abgk
                      :: p_abgg
                           (Data.Either.Either
                              [GHC.Word.Word8] (GHC.Word.Word8, [GHC.Word.Word8]))
                           (Data.Either.Either
                              [GHC.Word.Word8] (f_abgh (GHC.Word.Word8, [GHC.Word.Word8])))
                         -> p_abgg [GHC.Word.Word8] (f_abgh [GHC.Word.Word8])
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 320 0}]
                    f1_abgk
                      = Data.Profunctor.Unsafe.dimap
                          @p_abgg
                          (Data.Profunctor.Choice.$p1Choice @p_abgg $dChoice_abgi)
                          @[GHC.Word.Word8]
                          @(Data.Either.Either
                              [GHC.Word.Word8] (GHC.Word.Word8, [GHC.Word.Word8]))
                          @(Data.Either.Either
                              [GHC.Word.Word8] (f_abgh (GHC.Word.Word8, [GHC.Word.Word8])))
                          @(f_abgh [GHC.Word.Word8])
                          (\ (aas_abgl :: [GHC.Word.Word8]) ->
                             case aas_abgl of {
                               [] ->
                                 Data.Either.Left
                                   @[GHC.Word.Word8]
                                   @(GHC.Word.Word8, [GHC.Word.Word8])
                                   (GHC.Types.[] @GHC.Word.Word8);
                               : a1_abgn as_abgo ->
                                 Data.Either.Right
                                   @[GHC.Word.Word8]
                                   @(GHC.Word.Word8, [GHC.Word.Word8])
                                   (a1_abgn, as_abgo)
                             })
                          (let {
                             f2_abgq :: [GHC.Word.Word8] -> f_abgh [GHC.Word.Word8]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abgq
                               = GHC.Base.pure @f_abgh $dApplicative_abgj @[GHC.Word.Word8] } in
                           let {
                             ds2_abgr
                               :: f_abgh (GHC.Word.Word8, [GHC.Word.Word8])
                                  -> f_abgh [GHC.Word.Word8]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 90 0}]
                             ds2_abgr
                               = GHC.Base.fmap
                                   @f_abgh
                                   (GHC.Base.$p1Applicative @f_abgh $dApplicative_abgj)
                                   @(GHC.Word.Word8, [GHC.Word.Word8])
                                   @[GHC.Word.Word8]
                                   (\ (p1_abgs :: (GHC.Word.Word8, [GHC.Word.Word8])) ->
                                      GHC.Types.:
                                        @GHC.Word.Word8
                                        (case p1_abgs of { (x_abgu, ds_abgv) -> x_abgu })
                                        (case p1_abgs of { (ds_abgy, y_abgz) -> y_abgz })) } in
                           \ (ds3_abgB
                                :: Data.Either.Either
                                     [GHC.Word.Word8]
                                     (f_abgh (GHC.Word.Word8, [GHC.Word.Word8]))) ->
                             case ds3_abgB of {
                               Data.Either.Left x_abgD -> f2_abgq x_abgD;
                               Data.Either.Right y_abgF -> ds2_abgr y_abgF
                             }) } in
                  let {
                    g_abgH
                      :: p_abgg
                           (GHC.Word.Word8, [GHC.Word.Word8])
                           (f_abgh (GHC.Word.Word8, [GHC.Word.Word8]))
                         -> p_abgg
                              (Data.Either.Either
                                 [GHC.Word.Word8] (GHC.Word.Word8, [GHC.Word.Word8]))
                              (Data.Either.Either
                                 [GHC.Word.Word8] (f_abgh (GHC.Word.Word8, [GHC.Word.Word8])))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abgH
                      = Data.Profunctor.Choice.right'
                          @p_abgg
                          $dChoice_abgi
                          @(GHC.Word.Word8, [GHC.Word.Word8])
                          @(f_abgh (GHC.Word.Word8, [GHC.Word.Word8]))
                          @[GHC.Word.Word8] } in
                  \ (x_abgI
                       :: p_abgg
                            (GHC.Word.Word8, [GHC.Word.Word8])
                            (f_abgh (GHC.Word.Word8, [GHC.Word.Word8]))) ->
                    f1_abgk (g_abgH x_abgI))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <[GHC.Word.Word8]>_N
                                <[GHC.Word.Word8]>_N
                                <GHC.Word.Word8>_N
                                <GHC.Word.Word8>_N)
                       :: Control.Lens.Type.Prism
                            [GHC.Word.Word8]
                            [GHC.Word.Word8]
                            (GHC.Word.Word8, [GHC.Word.Word8])
                            (GHC.Word.Word8, [GHC.Word.Word8])
                          ~R# Control.Lens.Cons.Cons
                                [GHC.Word.Word8] [GHC.Word.Word8] GHC.Word.Word8 GHC.Word.Word8))
              ((\ (@(p_abgN :: * -> * -> *))
                  (@(f_abgO :: * -> *))
                  ($dChoice_abgP :: Data.Profunctor.Choice.Choice p_abgN)
                  ($dApplicative_abgQ :: GHC.Base.Applicative f_abgO) ->
                  let {
                    f1_abgR
                      :: p_abgN
                           (Data.Either.Either [GHC.Word.Word8] ())
                           (Data.Either.Either [GHC.Word.Word8] (f_abgO ()))
                         -> p_abgN [GHC.Word.Word8] (f_abgO [GHC.Word.Word8])
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 290 0}]
                    f1_abgR
                      = Data.Profunctor.Unsafe.dimap
                          @p_abgN
                          (Data.Profunctor.Choice.$p1Choice @p_abgN $dChoice_abgP)
                          @[GHC.Word.Word8]
                          @(Data.Either.Either [GHC.Word.Word8] ())
                          @(Data.Either.Either [GHC.Word.Word8] (f_abgO ()))
                          @(f_abgO [GHC.Word.Word8])
                          (\ (s_abgS :: [GHC.Word.Word8]) ->
                             case s_abgS of wild_abgT {
                               [] -> Data.Either.Right @[GHC.Word.Word8] @() GHC.Tuple.Prim.();
                               : ds1_abgU ds2_abgV ->
                                 Data.Either.Left @[GHC.Word.Word8] @() wild_abgT
                             })
                          (let {
                             f2_abgX :: [GHC.Word.Word8] -> f_abgO [GHC.Word.Word8]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abgX
                               = GHC.Base.pure @f_abgO $dApplicative_abgQ @[GHC.Word.Word8] } in
                           let {
                             ds2_abgY :: f_abgO () -> f_abgO [GHC.Word.Word8]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 70 0}]
                             ds2_abgY
                               = GHC.Base.fmap
                                   @f_abgO
                                   (GHC.Base.$p1Applicative @f_abgO $dApplicative_abgQ)
                                   @()
                                   @[GHC.Word.Word8]
                                   (\ (ds3_abgZ :: ()) ->
                                      case ds3_abgZ of { () -> GHC.Types.[] @GHC.Word.Word8 }) } in
                           \ (ds3_abh1 :: Data.Either.Either [GHC.Word.Word8] (f_abgO ())) ->
                             case ds3_abh1 of {
                               Data.Either.Left x_abh3 -> f2_abgX x_abh3;
                               Data.Either.Right y_abh5 -> ds2_abgY y_abh5
                             }) } in
                  let {
                    g_abh7
                      :: p_abgN () (f_abgO ())
                         -> p_abgN
                              (Data.Either.Either [GHC.Word.Word8] ())
                              (Data.Either.Either [GHC.Word.Word8] (f_abgO ()))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abh7
                      = Data.Profunctor.Choice.right'
                          @p_abgN $dChoice_abgP @() @(f_abgO ()) @[GHC.Word.Word8] } in
                  \ (x_abh8 :: p_abgN () (f_abgO ())) -> f1_abgR (g_abh7 x_abh8))
               `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0] <[GHC.Word.Word8]>_N)
                       :: Control.Lens.Type.Prism' [GHC.Word.Word8] ()
                          ~R# Control.Lens.Empty.AsEmpty [GHC.Word.Word8]))
              (Data.Functor.Contravariant.$fContravariantConst @[GHC.Word.Word8])
              (Data.Functor.Const.$fFunctorConst @[GHC.Word.Word8])
    Cont:   ApplyToVal nodup hole Control.Lens.Getter.Getting
                                    [GHC.Word.Word8]
                                    Data.ByteString.Lazy.Internal.ByteString
                                    [GHC.Word.Word8]
              ((\ (ds_abeK [Occ=Once1] :: a_abeH) -> ds_abeK)
               `cast` (<a_abeH>_R
                       %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                          <*>_N <a_abeH>_R <a_abeH>_P)
                       :: (a_abeH -> a_abeH)
                          ~R# (a_abeH -> Data.Functor.Const.Const a_abeH a_abeH)))
            ApplyToVal nodup hole Data.ByteString.Lazy.Internal.ByteString
                                  -> Data.Functor.Const.Const
                                       [GHC.Word.Word8] Data.ByteString.Lazy.Internal.ByteString
              (Control.Lens.Getter.view
                 @[GHC.Word.Word8]
                 @((->) [GHC.Word.Word8])
                 @Data.ByteString.Lazy.Internal.ByteString
                 (Control.Monad.Reader.Class.$fMonadReaderrFUN @[GHC.Word.Word8])
                 (Control.Lens.Cons.Extras.recons
                    @[GHC.Word.Word8]
                    @GHC.Word.Word8
                    @Data.ByteString.Lazy.Internal.ByteString
                    (Control.Lens.Cons.$fConsListListab
                       @GHC.Word.Word8 @GHC.Word.Word8)
                    Control.Lens.Cons.$fConsByteStringByteStringWord8Word8
                    Control.Lens.Empty.$fAsEmptyByteString
                    @(Data.Functor.Const.Const
                        Data.ByteString.Lazy.Internal.ByteString)
                    (Data.Functor.Contravariant.$fContravariantConst
                       @Data.ByteString.Lazy.Internal.ByteString)
                    (Data.Functor.Const.$fFunctorConst
                       @Data.ByteString.Lazy.Internal.ByteString))
                 s_a8Py)
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N
                        <[GHC.Word.Word8]>_R
                        <Data.ByteString.Lazy.Internal.ByteString>_P
                    :: Data.Functor.Const.Const
                         [GHC.Word.Word8] Data.ByteString.Lazy.Internal.ByteString
                       ~R# [GHC.Word.Word8])
            Stop[RuleArgCtxt] [GHC.Word.Word8]
Rule fired
    Rule: Class op fmap
    Module: (BUILTIN)
    Before: GHC.Base.fmap
              TyArg Data.Functor.Const.Const [GHC.Word.Word8]
              ValArg Data.Functor.Const.$fFunctorConst @[GHC.Word.Word8]
    After:  (Data.Functor.Const.$fFunctorConst2 @[GHC.Word.Word8])
            `cast` (forall (a :: <*>_N) (b :: <*>_N).
                    <a -> b>_R
                    %<'GHC.Types.Many>_N ->_R <Data.Functor.Const.Const
                                                 [GHC.Word.Word8] a>_R
                    %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                  <*>_N <[GHC.Word.Word8]>_R <a>_P
                                              ; Sym (Data.Functor.Const.N:Const[0]
                                                         <*>_N <[GHC.Word.Word8]>_R <b>_P)
                    :: (forall {a} {b}.
                        (a -> b)
                        -> Data.Functor.Const.Const [GHC.Word.Word8] a
                        -> Data.Functor.Const.Const [GHC.Word.Word8] a)
                       ~R# (forall {a} {b}.
                            (a -> b)
                            -> Data.Functor.Const.Const [GHC.Word.Word8] a
                            -> Data.Functor.Const.Const [GHC.Word.Word8] b))
    Cont:   ApplyToTy [GHC.Word.Word8]
            ApplyToTy Data.ByteString.Lazy.Internal.ByteString
            ApplyToVal nodup hole ([GHC.Word.Word8]
                                   -> Data.ByteString.Lazy.Internal.ByteString)
                                  -> Data.Functor.Const.Const [GHC.Word.Word8] [GHC.Word.Word8]
                                  -> Data.Functor.Const.Const
                                       [GHC.Word.Word8] Data.ByteString.Lazy.Internal.ByteString
              Data.ByteString.Lazy.Internal.packBytes
            ApplyToVal nodup hole Data.Functor.Const.Const
                                    [GHC.Word.Word8] [GHC.Word.Word8]
                                  -> Data.Functor.Const.Const
                                       [GHC.Word.Word8] Data.ByteString.Lazy.Internal.ByteString
              (bc_aboH (ab_aboF x_aboI))
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N
                        <[GHC.Word.Word8]>_R
                        <Data.ByteString.Lazy.Internal.ByteString>_P
                    :: Data.Functor.Const.Const
                         [GHC.Word.Word8] Data.ByteString.Lazy.Internal.ByteString
                       ~R# [GHC.Word.Word8])
            Stop[RuleArgCtxt] [GHC.Word.Word8]
Rule fired
    Rule: Class op reader
    Module: (BUILTIN)
    Before: Control.Monad.Reader.Class.reader
              TyArg [GHC.Word.Word8]
              TyArg (->) [GHC.Word.Word8]
              ValArg Control.Monad.Reader.Class.$fMonadReaderrFUN
                       @[GHC.Word.Word8]
    After:  \ (@a_abeP) -> GHC.Base.id @([GHC.Word.Word8] -> a_abeP)
    Cont:   ApplyToTy Data.ByteString.Lazy.Internal.ByteString
            ApplyToVal nodup hole ([GHC.Word.Word8]
                                   -> Data.ByteString.Lazy.Internal.ByteString)
                                  -> [GHC.Word.Word8] -> Data.ByteString.Lazy.Internal.ByteString
              ((l_abeJ
                  ((\ (ds_abeK [Occ=Once1] :: a_abeH) -> ds_abeK)
                   `cast` (<a_abeH>_R
                           %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                              <*>_N <a_abeH>_R <a_abeH>_P)
                           :: (a_abeH -> a_abeH)
                              ~R# (a_abeH -> Data.Functor.Const.Const a_abeH a_abeH))))
               `cast` (<s_abeF>_R
                       %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                     <*>_N <a_abeH>_R <s_abeF>_P
                       :: (s_abeF -> Data.Functor.Const.Const a_abeH s_abeF)
                          ~R# (s_abeF -> a_abeH)))
            ApplyToVal nodup hole [GHC.Word.Word8]
                                  -> Data.ByteString.Lazy.Internal.ByteString
              s_a8Py
            Stop[RuleArgCtxt] Data.ByteString.Lazy.Internal.ByteString
Rule fired
    Rule: recons/list-lazybs
    Module: (Control.Lens.Cons.Extras)
    Before: Control.Lens.Cons.Extras.recons
              TyArg [GHC.Word.Word8]
              TyArg GHC.Word.Word8
              TyArg Data.ByteString.Lazy.Internal.ByteString
              ValArg (\ (@(p_abgg :: * -> * -> *))
                        (@(f_abgh :: * -> *))
                        ($dChoice_abgi :: Data.Profunctor.Choice.Choice p_abgg)
                        ($dApplicative_abgj :: GHC.Base.Applicative f_abgh) ->
                        let {
                          f1_abgk
                            :: p_abgg
                                 (Data.Either.Either
                                    [GHC.Word.Word8] (GHC.Word.Word8, [GHC.Word.Word8]))
                                 (Data.Either.Either
                                    [GHC.Word.Word8] (f_abgh (GHC.Word.Word8, [GHC.Word.Word8])))
                               -> p_abgg [GHC.Word.Word8] (f_abgh [GHC.Word.Word8])
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 320 0}]
                          f1_abgk
                            = Data.Profunctor.Unsafe.dimap
                                @p_abgg
                                (Data.Profunctor.Choice.$p1Choice @p_abgg $dChoice_abgi)
                                @[GHC.Word.Word8]
                                @(Data.Either.Either
                                    [GHC.Word.Word8] (GHC.Word.Word8, [GHC.Word.Word8]))
                                @(Data.Either.Either
                                    [GHC.Word.Word8] (f_abgh (GHC.Word.Word8, [GHC.Word.Word8])))
                                @(f_abgh [GHC.Word.Word8])
                                (\ (aas_abgl :: [GHC.Word.Word8]) ->
                                   case aas_abgl of {
                                     [] ->
                                       Data.Either.Left
                                         @[GHC.Word.Word8]
                                         @(GHC.Word.Word8, [GHC.Word.Word8])
                                         (GHC.Types.[] @GHC.Word.Word8);
                                     : a1_abgn as_abgo ->
                                       Data.Either.Right
                                         @[GHC.Word.Word8]
                                         @(GHC.Word.Word8, [GHC.Word.Word8])
                                         (a1_abgn, as_abgo)
                                   })
                                (let {
                                   f2_abgq :: [GHC.Word.Word8] -> f_abgh [GHC.Word.Word8]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abgq
                                     = GHC.Base.pure
                                         @f_abgh $dApplicative_abgj @[GHC.Word.Word8] } in
                                 let {
                                   ds2_abgr
                                     :: f_abgh (GHC.Word.Word8, [GHC.Word.Word8])
                                        -> f_abgh [GHC.Word.Word8]
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 90 0}]
                                   ds2_abgr
                                     = GHC.Base.fmap
                                         @f_abgh
                                         (GHC.Base.$p1Applicative @f_abgh $dApplicative_abgj)
                                         @(GHC.Word.Word8, [GHC.Word.Word8])
                                         @[GHC.Word.Word8]
                                         (\ (p1_abgs :: (GHC.Word.Word8, [GHC.Word.Word8])) ->
                                            GHC.Types.:
                                              @GHC.Word.Word8
                                              (case p1_abgs of { (x_abgu, ds_abgv) -> x_abgu })
                                              (case p1_abgs of { (ds_abgy, y_abgz) ->
                                               y_abgz
                                               })) } in
                                 \ (ds3_abgB
                                      :: Data.Either.Either
                                           [GHC.Word.Word8]
                                           (f_abgh (GHC.Word.Word8, [GHC.Word.Word8]))) ->
                                   case ds3_abgB of {
                                     Data.Either.Left x_abgD -> f2_abgq x_abgD;
                                     Data.Either.Right y_abgF -> ds2_abgr y_abgF
                                   }) } in
                        let {
                          g_abgH
                            :: p_abgg
                                 (GHC.Word.Word8, [GHC.Word.Word8])
                                 (f_abgh (GHC.Word.Word8, [GHC.Word.Word8]))
                               -> p_abgg
                                    (Data.Either.Either
                                       [GHC.Word.Word8] (GHC.Word.Word8, [GHC.Word.Word8]))
                                    (Data.Either.Either
                                       [GHC.Word.Word8] (f_abgh (GHC.Word.Word8, [GHC.Word.Word8])))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abgH
                            = Data.Profunctor.Choice.right'
                                @p_abgg
                                $dChoice_abgi
                                @(GHC.Word.Word8, [GHC.Word.Word8])
                                @(f_abgh (GHC.Word.Word8, [GHC.Word.Word8]))
                                @[GHC.Word.Word8] } in
                        \ (x_abgI
                             :: p_abgg
                                  (GHC.Word.Word8, [GHC.Word.Word8])
                                  (f_abgh (GHC.Word.Word8, [GHC.Word.Word8]))) ->
                          f1_abgk (g_abgH x_abgI))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <[GHC.Word.Word8]>_N
                                      <[GHC.Word.Word8]>_N
                                      <GHC.Word.Word8>_N
                                      <GHC.Word.Word8>_N)
                             :: Control.Lens.Type.Prism
                                  [GHC.Word.Word8]
                                  [GHC.Word.Word8]
                                  (GHC.Word.Word8, [GHC.Word.Word8])
                                  (GHC.Word.Word8, [GHC.Word.Word8])
                                ~R# Control.Lens.Cons.Cons
                                      [GHC.Word.Word8]
                                      [GHC.Word.Word8]
                                      GHC.Word.Word8
                                      GHC.Word.Word8)
              ValArg (\ (@(p_abnq :: * -> * -> *))
                        (@(f_abnr :: * -> *))
                        ($dChoice_abns :: Data.Profunctor.Choice.Choice p_abnq)
                        ($dApplicative_abnt :: GHC.Base.Applicative f_abnr) ->
                        let {
                          f1_abnu
                            :: p_abnq
                                 (Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                                 (Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (f_abnr
                                       (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                               -> p_abnq
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (f_abnr Data.ByteString.Lazy.Internal.ByteString)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 536 0}]
                          f1_abnu
                            = Data.Profunctor.Unsafe.dimap
                                @p_abnq
                                (Data.Profunctor.Choice.$p1Choice @p_abnq $dChoice_abns)
                                @Data.ByteString.Lazy.Internal.ByteString
                                @(Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                                @(Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (f_abnr
                                       (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                                @(f_abnr Data.ByteString.Lazy.Internal.ByteString)
                                (\ (s1_abnv :: Data.ByteString.Lazy.Internal.ByteString) ->
                                   case s1_abnv of {
                                     Data.ByteString.Lazy.Internal.Empty ->
                                       Data.Either.Left
                                         @Data.ByteString.Lazy.Internal.ByteString
                                         @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                         Data.ByteString.Lazy.Internal.Empty;
                                     Data.ByteString.Lazy.Internal.Chunk bx_abnC bx1_abnD bx2_abnE
                                                                         cs_abnF ->
                                       case bx2_abnE of ds1_abnH {
                                         __DEFAULT ->
                                           Data.Either.Right
                                             @Data.ByteString.Lazy.Internal.ByteString
                                             @(GHC.Word.Word8,
                                               Data.ByteString.Lazy.Internal.ByteString)
                                             (case GHC.Prim.readWord8OffAddr#
                                                     @GHC.Prim.RealWorld
                                                     bx_abnC
                                                     0#
                                                     GHC.Prim.realWorld#
                                              of
                                              { (# ipv_abnJ, ipv1_abnK #) ->
                                              case GHC.Prim.touch#
                                                     @'GHC.Types.Lifted
                                                     @GHC.ForeignPtr.ForeignPtrContents
                                                     bx1_abnD
                                                     ipv_abnJ
                                              of
                                              { __DEFAULT ->
                                              GHC.Word.W8# ipv1_abnK
                                              }
                                              },
                                              Data.ByteString.Lazy.Internal.$WChunk
                                                (Data.ByteString.Internal.Type.$WBS
                                                   (GHC.ForeignPtr.ForeignPtr
                                                      @GHC.Word.Word8
                                                      (GHC.Prim.plusAddr# bx_abnC 1#)
                                                      bx1_abnD)
                                                   (GHC.Types.I# (GHC.Prim.-# ds1_abnH 1#)))
                                                cs_abnF);
                                         1# ->
                                           Data.Either.Right
                                             @Data.ByteString.Lazy.Internal.ByteString
                                             @(GHC.Word.Word8,
                                               Data.ByteString.Lazy.Internal.ByteString)
                                             (case GHC.Prim.readWord8OffAddr#
                                                     @GHC.Prim.RealWorld
                                                     bx_abnC
                                                     0#
                                                     GHC.Prim.realWorld#
                                              of
                                              { (# ipv_abnO, ipv1_abnP #) ->
                                              case GHC.Prim.touch#
                                                     @'GHC.Types.Lifted
                                                     @GHC.ForeignPtr.ForeignPtrContents
                                                     bx1_abnD
                                                     ipv_abnO
                                              of
                                              { __DEFAULT ->
                                              GHC.Word.W8# ipv1_abnP
                                              }
                                              },
                                              cs_abnF)
                                       }
                                   })
                                (let {
                                   f2_abnS
                                     :: Data.ByteString.Lazy.Internal.ByteString
                                        -> f_abnr Data.ByteString.Lazy.Internal.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abnS
                                     = GHC.Base.pure
                                         @f_abnr
                                         $dApplicative_abnt
                                         @Data.ByteString.Lazy.Internal.ByteString } in
                                 let {
                                   ds2_abnT
                                     :: f_abnr
                                          (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                        -> f_abnr Data.ByteString.Lazy.Internal.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 162 0}]
                                   ds2_abnT
                                     = GHC.Base.fmap
                                         @f_abnr
                                         (GHC.Base.$p1Applicative @f_abnr $dApplicative_abnt)
                                         @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                         @Data.ByteString.Lazy.Internal.ByteString
                                         (\ (p1_abnU
                                               :: (GHC.Word.Word8,
                                                   Data.ByteString.Lazy.Internal.ByteString)) ->
                                            case p1_abnU of { (x_abnW, ds_abnX) ->
                                            case x_abnW of { GHC.Word.W8# x#_abo0 ->
                                            Data.ByteString.Lazy.Internal.$WChunk
                                              (Data.ByteString.Internal.Type.$WBS
                                                 (GHC.ForeignPtr.ForeignPtr
                                                    @GHC.Word.Word8
                                                    (GHC.Prim.plusAddr#
                                                       Data.ByteString.singleton1
                                                       (GHC.Prim.word2Int#
                                                          (GHC.Prim.word8ToWord# x#_abo0)))
                                                    GHC.ForeignPtr.FinalPtr)
                                                 (GHC.Types.I# 1#))
                                              ds_abnX
                                            }
                                            }) } in
                                 \ (ds3_abo2
                                      :: Data.Either.Either
                                           Data.ByteString.Lazy.Internal.ByteString
                                           (f_abnr
                                              (GHC.Word.Word8,
                                               Data.ByteString.Lazy.Internal.ByteString))) ->
                                   case ds3_abo2 of {
                                     Data.Either.Left x_abo4 -> f2_abnS x_abo4;
                                     Data.Either.Right y_abo6 -> ds2_abnT y_abo6
                                   }) } in
                        let {
                          g_abo8
                            :: p_abnq
                                 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                 (f_abnr (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                               -> p_abnq
                                    (Data.Either.Either
                                       Data.ByteString.Lazy.Internal.ByteString
                                       (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                                    (Data.Either.Either
                                       Data.ByteString.Lazy.Internal.ByteString
                                       (f_abnr
                                          (GHC.Word.Word8,
                                           Data.ByteString.Lazy.Internal.ByteString)))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abo8
                            = Data.Profunctor.Choice.right'
                                @p_abnq
                                $dChoice_abns
                                @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                @(f_abnr
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                                @Data.ByteString.Lazy.Internal.ByteString } in
                        \ (x_abo9
                             :: p_abnq
                                  (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                  (f_abnr
                                     (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))) ->
                          f1_abnu (g_abo8 x_abo9))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <Data.ByteString.Lazy.Internal.ByteString>_N
                                      <Data.ByteString.Lazy.Internal.ByteString>_N
                                      <GHC.Word.Word8>_N
                                      <GHC.Word.Word8>_N)
                             :: Control.Lens.Type.Prism
                                  Data.ByteString.Lazy.Internal.ByteString
                                  Data.ByteString.Lazy.Internal.ByteString
                                  (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                  (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                ~R# Control.Lens.Cons.Cons
                                      Data.ByteString.Lazy.Internal.ByteString
                                      Data.ByteString.Lazy.Internal.ByteString
                                      GHC.Word.Word8
                                      GHC.Word.Word8)
              ValArg (\ (@(p_abob :: * -> * -> *))
                        (@(f_aboc :: * -> *))
                        ($dChoice_abod :: Data.Profunctor.Choice.Choice p_abob)
                        ($dApplicative_aboe :: GHC.Base.Applicative f_aboc) ->
                        let {
                          f1_abof
                            :: p_abob
                                 (Data.Either.Either Data.ByteString.Lazy.Internal.ByteString ())
                                 (Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString (f_aboc ()))
                               -> p_abob
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (f_aboc Data.ByteString.Lazy.Internal.ByteString)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 290 0}]
                          f1_abof
                            = Data.Profunctor.Unsafe.dimap
                                @p_abob
                                (Data.Profunctor.Choice.$p1Choice @p_abob $dChoice_abod)
                                @Data.ByteString.Lazy.Internal.ByteString
                                @(Data.Either.Either Data.ByteString.Lazy.Internal.ByteString ())
                                @(Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString (f_aboc ()))
                                @(f_aboc Data.ByteString.Lazy.Internal.ByteString)
                                (\ (s_abog :: Data.ByteString.Lazy.Internal.ByteString) ->
                                   case s_abog of wild_aboh {
                                     Data.ByteString.Lazy.Internal.Empty ->
                                       Data.Either.Right
                                         @Data.ByteString.Lazy.Internal.ByteString
                                         @()
                                         GHC.Tuple.Prim.();
                                     Data.ByteString.Lazy.Internal.Chunk ipv_aboi ipv1_aboj
                                                                         ipv2_abok ipv3_abol ->
                                       Data.Either.Left
                                         @Data.ByteString.Lazy.Internal.ByteString @() wild_aboh
                                   })
                                (let {
                                   f2_abon
                                     :: Data.ByteString.Lazy.Internal.ByteString
                                        -> f_aboc Data.ByteString.Lazy.Internal.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abon
                                     = GHC.Base.pure
                                         @f_aboc
                                         $dApplicative_aboe
                                         @Data.ByteString.Lazy.Internal.ByteString } in
                                 let {
                                   ds2_aboo
                                     :: f_aboc () -> f_aboc Data.ByteString.Lazy.Internal.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 70 0}]
                                   ds2_aboo
                                     = GHC.Base.fmap
                                         @f_aboc
                                         (GHC.Base.$p1Applicative @f_aboc $dApplicative_aboe)
                                         @()
                                         @Data.ByteString.Lazy.Internal.ByteString
                                         (\ (ds3_abop :: ()) ->
                                            case ds3_abop of { () ->
                                            Data.ByteString.Lazy.Internal.Empty
                                            }) } in
                                 \ (ds3_abor
                                      :: Data.Either.Either
                                           Data.ByteString.Lazy.Internal.ByteString (f_aboc ())) ->
                                   case ds3_abor of {
                                     Data.Either.Left x_abot -> f2_abon x_abot;
                                     Data.Either.Right y_abov -> ds2_aboo y_abov
                                   }) } in
                        let {
                          g_abox
                            :: p_abob () (f_aboc ())
                               -> p_abob
                                    (Data.Either.Either Data.ByteString.Lazy.Internal.ByteString ())
                                    (Data.Either.Either
                                       Data.ByteString.Lazy.Internal.ByteString (f_aboc ()))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abox
                            = Data.Profunctor.Choice.right'
                                @p_abob
                                $dChoice_abod
                                @()
                                @(f_aboc ())
                                @Data.ByteString.Lazy.Internal.ByteString } in
                        \ (x_aboy :: p_abob () (f_aboc ())) -> f1_abof (g_abox x_aboy))
                     `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                      <Data.ByteString.Lazy.Internal.ByteString>_N)
                             :: Control.Lens.Type.Prism'
                                  Data.ByteString.Lazy.Internal.ByteString ()
                                ~R# Control.Lens.Empty.AsEmpty
                                      Data.ByteString.Lazy.Internal.ByteString)
              TyArg Data.Functor.Const.Const
                      Data.ByteString.Lazy.Internal.ByteString
              ValArg Data.Functor.Contravariant.$fContravariantConst
                       @Data.ByteString.Lazy.Internal.ByteString
              ValArg Data.Functor.Const.$fFunctorConst
                       @Data.ByteString.Lazy.Internal.ByteString
    After:  (\ (@(f_abfq :: * -> *))
               ($dCons_abfr
                  :: Control.Lens.Cons.Cons
                       [GHC.Word.Word8] [GHC.Word.Word8] GHC.Word.Word8 GHC.Word.Word8)
               ($dCons1_abfs
                  :: Control.Lens.Cons.Cons
                       Data.ByteString.Lazy.Internal.ByteString
                       Data.ByteString.Lazy.Internal.ByteString
                       GHC.Word.Word8
                       GHC.Word.Word8)
               ($dAsEmpty_abft
                  :: Control.Lens.Empty.AsEmpty
                       Data.ByteString.Lazy.Internal.ByteString)
               ($dContravariant_abfu
                  :: Data.Functor.Contravariant.Contravariant f_abfq)
               ($dFunctor_abfv :: GHC.Base.Functor f_abfq) ->
               Data.Profunctor.Unsafe.$fProfunctorFUN_$cdimap
                 @[GHC.Word.Word8]
                 @Data.ByteString.Lazy.Internal.ByteString
                 @(f_abfq Data.ByteString.Lazy.Internal.ByteString)
                 @(f_abfq [GHC.Word.Word8])
                 Data.ByteString.Lazy.Internal.packBytes
                 (GHC.Base.fmap
                    @f_abfq
                    $dFunctor_abfv
                    @Data.ByteString.Lazy.Internal.ByteString
                    @[GHC.Word.Word8]
                    Data.ByteString.Lazy.Internal.unpackBytes))
              @(Data.Functor.Const.Const
                  Data.ByteString.Lazy.Internal.ByteString)
              ((\ (@(p_abgg :: * -> * -> *))
                  (@(f_abgh :: * -> *))
                  ($dChoice_abgi :: Data.Profunctor.Choice.Choice p_abgg)
                  ($dApplicative_abgj :: GHC.Base.Applicative f_abgh) ->
                  let {
                    f1_abgk
                      :: p_abgg
                           (Data.Either.Either
                              [GHC.Word.Word8] (GHC.Word.Word8, [GHC.Word.Word8]))
                           (Data.Either.Either
                              [GHC.Word.Word8] (f_abgh (GHC.Word.Word8, [GHC.Word.Word8])))
                         -> p_abgg [GHC.Word.Word8] (f_abgh [GHC.Word.Word8])
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 320 0}]
                    f1_abgk
                      = Data.Profunctor.Unsafe.dimap
                          @p_abgg
                          (Data.Profunctor.Choice.$p1Choice @p_abgg $dChoice_abgi)
                          @[GHC.Word.Word8]
                          @(Data.Either.Either
                              [GHC.Word.Word8] (GHC.Word.Word8, [GHC.Word.Word8]))
                          @(Data.Either.Either
                              [GHC.Word.Word8] (f_abgh (GHC.Word.Word8, [GHC.Word.Word8])))
                          @(f_abgh [GHC.Word.Word8])
                          (\ (aas_abgl :: [GHC.Word.Word8]) ->
                             case aas_abgl of {
                               [] ->
                                 Data.Either.Left
                                   @[GHC.Word.Word8]
                                   @(GHC.Word.Word8, [GHC.Word.Word8])
                                   (GHC.Types.[] @GHC.Word.Word8);
                               : a1_abgn as_abgo ->
                                 Data.Either.Right
                                   @[GHC.Word.Word8]
                                   @(GHC.Word.Word8, [GHC.Word.Word8])
                                   (a1_abgn, as_abgo)
                             })
                          (let {
                             f2_abgq :: [GHC.Word.Word8] -> f_abgh [GHC.Word.Word8]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abgq
                               = GHC.Base.pure @f_abgh $dApplicative_abgj @[GHC.Word.Word8] } in
                           let {
                             ds2_abgr
                               :: f_abgh (GHC.Word.Word8, [GHC.Word.Word8])
                                  -> f_abgh [GHC.Word.Word8]
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 90 0}]
                             ds2_abgr
                               = GHC.Base.fmap
                                   @f_abgh
                                   (GHC.Base.$p1Applicative @f_abgh $dApplicative_abgj)
                                   @(GHC.Word.Word8, [GHC.Word.Word8])
                                   @[GHC.Word.Word8]
                                   (\ (p1_abgs :: (GHC.Word.Word8, [GHC.Word.Word8])) ->
                                      GHC.Types.:
                                        @GHC.Word.Word8
                                        (case p1_abgs of { (x_abgu, ds_abgv) -> x_abgu })
                                        (case p1_abgs of { (ds_abgy, y_abgz) -> y_abgz })) } in
                           \ (ds3_abgB
                                :: Data.Either.Either
                                     [GHC.Word.Word8]
                                     (f_abgh (GHC.Word.Word8, [GHC.Word.Word8]))) ->
                             case ds3_abgB of {
                               Data.Either.Left x_abgD -> f2_abgq x_abgD;
                               Data.Either.Right y_abgF -> ds2_abgr y_abgF
                             }) } in
                  let {
                    g_abgH
                      :: p_abgg
                           (GHC.Word.Word8, [GHC.Word.Word8])
                           (f_abgh (GHC.Word.Word8, [GHC.Word.Word8]))
                         -> p_abgg
                              (Data.Either.Either
                                 [GHC.Word.Word8] (GHC.Word.Word8, [GHC.Word.Word8]))
                              (Data.Either.Either
                                 [GHC.Word.Word8] (f_abgh (GHC.Word.Word8, [GHC.Word.Word8])))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abgH
                      = Data.Profunctor.Choice.right'
                          @p_abgg
                          $dChoice_abgi
                          @(GHC.Word.Word8, [GHC.Word.Word8])
                          @(f_abgh (GHC.Word.Word8, [GHC.Word.Word8]))
                          @[GHC.Word.Word8] } in
                  \ (x_abgI
                       :: p_abgg
                            (GHC.Word.Word8, [GHC.Word.Word8])
                            (f_abgh (GHC.Word.Word8, [GHC.Word.Word8]))) ->
                    f1_abgk (g_abgH x_abgI))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <[GHC.Word.Word8]>_N
                                <[GHC.Word.Word8]>_N
                                <GHC.Word.Word8>_N
                                <GHC.Word.Word8>_N)
                       :: Control.Lens.Type.Prism
                            [GHC.Word.Word8]
                            [GHC.Word.Word8]
                            (GHC.Word.Word8, [GHC.Word.Word8])
                            (GHC.Word.Word8, [GHC.Word.Word8])
                          ~R# Control.Lens.Cons.Cons
                                [GHC.Word.Word8] [GHC.Word.Word8] GHC.Word.Word8 GHC.Word.Word8))
              ((\ (@(p_abnq :: * -> * -> *))
                  (@(f_abnr :: * -> *))
                  ($dChoice_abns :: Data.Profunctor.Choice.Choice p_abnq)
                  ($dApplicative_abnt :: GHC.Base.Applicative f_abnr) ->
                  let {
                    f1_abnu
                      :: p_abnq
                           (Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString
                              (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                           (Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString
                              (f_abnr
                                 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                         -> p_abnq
                              Data.ByteString.Lazy.Internal.ByteString
                              (f_abnr Data.ByteString.Lazy.Internal.ByteString)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 536 0}]
                    f1_abnu
                      = Data.Profunctor.Unsafe.dimap
                          @p_abnq
                          (Data.Profunctor.Choice.$p1Choice @p_abnq $dChoice_abns)
                          @Data.ByteString.Lazy.Internal.ByteString
                          @(Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString
                              (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                          @(Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString
                              (f_abnr
                                 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                          @(f_abnr Data.ByteString.Lazy.Internal.ByteString)
                          (\ (s1_abnv :: Data.ByteString.Lazy.Internal.ByteString) ->
                             case s1_abnv of {
                               Data.ByteString.Lazy.Internal.Empty ->
                                 Data.Either.Left
                                   @Data.ByteString.Lazy.Internal.ByteString
                                   @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                   Data.ByteString.Lazy.Internal.Empty;
                               Data.ByteString.Lazy.Internal.Chunk bx_abnC bx1_abnD bx2_abnE
                                                                   cs_abnF ->
                                 case bx2_abnE of ds1_abnH {
                                   __DEFAULT ->
                                     Data.Either.Right
                                       @Data.ByteString.Lazy.Internal.ByteString
                                       @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                       (case GHC.Prim.readWord8OffAddr#
                                               @GHC.Prim.RealWorld bx_abnC 0# GHC.Prim.realWorld#
                                        of
                                        { (# ipv_abnJ, ipv1_abnK #) ->
                                        case GHC.Prim.touch#
                                               @'GHC.Types.Lifted
                                               @GHC.ForeignPtr.ForeignPtrContents
                                               bx1_abnD
                                               ipv_abnJ
                                        of
                                        { __DEFAULT ->
                                        GHC.Word.W8# ipv1_abnK
                                        }
                                        },
                                        Data.ByteString.Lazy.Internal.$WChunk
                                          (Data.ByteString.Internal.Type.$WBS
                                             (GHC.ForeignPtr.ForeignPtr
                                                @GHC.Word.Word8
                                                (GHC.Prim.plusAddr# bx_abnC 1#)
                                                bx1_abnD)
                                             (GHC.Types.I# (GHC.Prim.-# ds1_abnH 1#)))
                                          cs_abnF);
                                   1# ->
                                     Data.Either.Right
                                       @Data.ByteString.Lazy.Internal.ByteString
                                       @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                       (case GHC.Prim.readWord8OffAddr#
                                               @GHC.Prim.RealWorld bx_abnC 0# GHC.Prim.realWorld#
                                        of
                                        { (# ipv_abnO, ipv1_abnP #) ->
                                        case GHC.Prim.touch#
                                               @'GHC.Types.Lifted
                                               @GHC.ForeignPtr.ForeignPtrContents
                                               bx1_abnD
                                               ipv_abnO
                                        of
                                        { __DEFAULT ->
                                        GHC.Word.W8# ipv1_abnP
                                        }
                                        },
                                        cs_abnF)
                                 }
                             })
                          (let {
                             f2_abnS
                               :: Data.ByteString.Lazy.Internal.ByteString
                                  -> f_abnr Data.ByteString.Lazy.Internal.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abnS
                               = GHC.Base.pure
                                   @f_abnr
                                   $dApplicative_abnt
                                   @Data.ByteString.Lazy.Internal.ByteString } in
                           let {
                             ds2_abnT
                               :: f_abnr
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                  -> f_abnr Data.ByteString.Lazy.Internal.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 162 0}]
                             ds2_abnT
                               = GHC.Base.fmap
                                   @f_abnr
                                   (GHC.Base.$p1Applicative @f_abnr $dApplicative_abnt)
                                   @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                   @Data.ByteString.Lazy.Internal.ByteString
                                   (\ (p1_abnU
                                         :: (GHC.Word.Word8,
                                             Data.ByteString.Lazy.Internal.ByteString)) ->
                                      case p1_abnU of { (x_abnW, ds_abnX) ->
                                      case x_abnW of { GHC.Word.W8# x#_abo0 ->
                                      Data.ByteString.Lazy.Internal.$WChunk
                                        (Data.ByteString.Internal.Type.$WBS
                                           (GHC.ForeignPtr.ForeignPtr
                                              @GHC.Word.Word8
                                              (GHC.Prim.plusAddr#
                                                 Data.ByteString.singleton1
                                                 (GHC.Prim.word2Int#
                                                    (GHC.Prim.word8ToWord# x#_abo0)))
                                              GHC.ForeignPtr.FinalPtr)
                                           (GHC.Types.I# 1#))
                                        ds_abnX
                                      }
                                      }) } in
                           \ (ds3_abo2
                                :: Data.Either.Either
                                     Data.ByteString.Lazy.Internal.ByteString
                                     (f_abnr
                                        (GHC.Word.Word8,
                                         Data.ByteString.Lazy.Internal.ByteString))) ->
                             case ds3_abo2 of {
                               Data.Either.Left x_abo4 -> f2_abnS x_abo4;
                               Data.Either.Right y_abo6 -> ds2_abnT y_abo6
                             }) } in
                  let {
                    g_abo8
                      :: p_abnq
                           (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                           (f_abnr (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                         -> p_abnq
                              (Data.Either.Either
                                 Data.ByteString.Lazy.Internal.ByteString
                                 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                              (Data.Either.Either
                                 Data.ByteString.Lazy.Internal.ByteString
                                 (f_abnr
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abo8
                      = Data.Profunctor.Choice.right'
                          @p_abnq
                          $dChoice_abns
                          @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                          @(f_abnr
                              (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                          @Data.ByteString.Lazy.Internal.ByteString } in
                  \ (x_abo9
                       :: p_abnq
                            (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                            (f_abnr
                               (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))) ->
                    f1_abnu (g_abo8 x_abo9))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <Data.ByteString.Lazy.Internal.ByteString>_N
                                <Data.ByteString.Lazy.Internal.ByteString>_N
                                <GHC.Word.Word8>_N
                                <GHC.Word.Word8>_N)
                       :: Control.Lens.Type.Prism
                            Data.ByteString.Lazy.Internal.ByteString
                            Data.ByteString.Lazy.Internal.ByteString
                            (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                            (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                          ~R# Control.Lens.Cons.Cons
                                Data.ByteString.Lazy.Internal.ByteString
                                Data.ByteString.Lazy.Internal.ByteString
                                GHC.Word.Word8
                                GHC.Word.Word8))
              ((\ (@(p_abob :: * -> * -> *))
                  (@(f_aboc :: * -> *))
                  ($dChoice_abod :: Data.Profunctor.Choice.Choice p_abob)
                  ($dApplicative_aboe :: GHC.Base.Applicative f_aboc) ->
                  let {
                    f1_abof
                      :: p_abob
                           (Data.Either.Either Data.ByteString.Lazy.Internal.ByteString ())
                           (Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString (f_aboc ()))
                         -> p_abob
                              Data.ByteString.Lazy.Internal.ByteString
                              (f_aboc Data.ByteString.Lazy.Internal.ByteString)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 290 0}]
                    f1_abof
                      = Data.Profunctor.Unsafe.dimap
                          @p_abob
                          (Data.Profunctor.Choice.$p1Choice @p_abob $dChoice_abod)
                          @Data.ByteString.Lazy.Internal.ByteString
                          @(Data.Either.Either Data.ByteString.Lazy.Internal.ByteString ())
                          @(Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString (f_aboc ()))
                          @(f_aboc Data.ByteString.Lazy.Internal.ByteString)
                          (\ (s_abog :: Data.ByteString.Lazy.Internal.ByteString) ->
                             case s_abog of wild_aboh {
                               Data.ByteString.Lazy.Internal.Empty ->
                                 Data.Either.Right
                                   @Data.ByteString.Lazy.Internal.ByteString @() GHC.Tuple.Prim.();
                               Data.ByteString.Lazy.Internal.Chunk ipv_aboi ipv1_aboj ipv2_abok
                                                                   ipv3_abol ->
                                 Data.Either.Left
                                   @Data.ByteString.Lazy.Internal.ByteString @() wild_aboh
                             })
                          (let {
                             f2_abon
                               :: Data.ByteString.Lazy.Internal.ByteString
                                  -> f_aboc Data.ByteString.Lazy.Internal.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abon
                               = GHC.Base.pure
                                   @f_aboc
                                   $dApplicative_aboe
                                   @Data.ByteString.Lazy.Internal.ByteString } in
                           let {
                             ds2_aboo
                               :: f_aboc () -> f_aboc Data.ByteString.Lazy.Internal.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 70 0}]
                             ds2_aboo
                               = GHC.Base.fmap
                                   @f_aboc
                                   (GHC.Base.$p1Applicative @f_aboc $dApplicative_aboe)
                                   @()
                                   @Data.ByteString.Lazy.Internal.ByteString
                                   (\ (ds3_abop :: ()) ->
                                      case ds3_abop of { () ->
                                      Data.ByteString.Lazy.Internal.Empty
                                      }) } in
                           \ (ds3_abor
                                :: Data.Either.Either
                                     Data.ByteString.Lazy.Internal.ByteString (f_aboc ())) ->
                             case ds3_abor of {
                               Data.Either.Left x_abot -> f2_abon x_abot;
                               Data.Either.Right y_abov -> ds2_aboo y_abov
                             }) } in
                  let {
                    g_abox
                      :: p_abob () (f_aboc ())
                         -> p_abob
                              (Data.Either.Either Data.ByteString.Lazy.Internal.ByteString ())
                              (Data.Either.Either
                                 Data.ByteString.Lazy.Internal.ByteString (f_aboc ()))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abox
                      = Data.Profunctor.Choice.right'
                          @p_abob
                          $dChoice_abod
                          @()
                          @(f_aboc ())
                          @Data.ByteString.Lazy.Internal.ByteString } in
                  \ (x_aboy :: p_abob () (f_aboc ())) -> f1_abof (g_abox x_aboy))
               `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                <Data.ByteString.Lazy.Internal.ByteString>_N)
                       :: Control.Lens.Type.Prism'
                            Data.ByteString.Lazy.Internal.ByteString ()
                          ~R# Control.Lens.Empty.AsEmpty
                                Data.ByteString.Lazy.Internal.ByteString))
              (Data.Functor.Contravariant.$fContravariantConst
                 @Data.ByteString.Lazy.Internal.ByteString)
              (Data.Functor.Const.$fFunctorConst
                 @Data.ByteString.Lazy.Internal.ByteString)
    Cont:   ApplyToVal nodup hole Control.Lens.Getter.Getting
                                    Data.ByteString.Lazy.Internal.ByteString
                                    [GHC.Word.Word8]
                                    Data.ByteString.Lazy.Internal.ByteString
              ((\ (ds_abeK [Occ=Once1] :: a_abeH) -> ds_abeK)
               `cast` (<a_abeH>_R
                       %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                          <*>_N <a_abeH>_R <a_abeH>_P)
                       :: (a_abeH -> a_abeH)
                          ~R# (a_abeH -> Data.Functor.Const.Const a_abeH a_abeH)))
            ApplyToVal nodup hole [GHC.Word.Word8]
                                  -> Data.Functor.Const.Const
                                       Data.ByteString.Lazy.Internal.ByteString [GHC.Word.Word8]
              s_a8Py
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N
                        <Data.ByteString.Lazy.Internal.ByteString>_R
                        <[GHC.Word.Word8]>_P
                    :: Data.Functor.Const.Const
                         Data.ByteString.Lazy.Internal.ByteString [GHC.Word.Word8]
                       ~R# Data.ByteString.Lazy.Internal.ByteString)
            Stop[RuleArgCtxt] Data.ByteString.Lazy.Internal.ByteString
Rule fired
    Rule: Class op fmap
    Module: (BUILTIN)
    Before: GHC.Base.fmap
              TyArg Data.Functor.Const.Const
                      Data.ByteString.Lazy.Internal.ByteString
              ValArg Data.Functor.Const.$fFunctorConst
                       @Data.ByteString.Lazy.Internal.ByteString
    After:  (Data.Functor.Const.$fFunctorConst2
               @Data.ByteString.Lazy.Internal.ByteString)
            `cast` (forall (a :: <*>_N) (b :: <*>_N).
                    <a -> b>_R
                    %<'GHC.Types.Many>_N ->_R <Data.Functor.Const.Const
                                                 Data.ByteString.Lazy.Internal.ByteString a>_R
                    %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                  <*>_N
                                                  <Data.ByteString.Lazy.Internal.ByteString>_R
                                                  <a>_P
                                              ; Sym (Data.Functor.Const.N:Const[0]
                                                         <*>_N
                                                         <Data.ByteString.Lazy.Internal.ByteString>_R
                                                         <b>_P)
                    :: (forall {a} {b}.
                        (a -> b)
                        -> Data.Functor.Const.Const
                             Data.ByteString.Lazy.Internal.ByteString a
                        -> Data.Functor.Const.Const
                             Data.ByteString.Lazy.Internal.ByteString a)
                       ~R# (forall {a} {b}.
                            (a -> b)
                            -> Data.Functor.Const.Const
                                 Data.ByteString.Lazy.Internal.ByteString a
                            -> Data.Functor.Const.Const
                                 Data.ByteString.Lazy.Internal.ByteString b))
    Cont:   ApplyToTy Data.ByteString.Lazy.Internal.ByteString
            ApplyToTy [GHC.Word.Word8]
            ApplyToVal nodup hole (Data.ByteString.Lazy.Internal.ByteString
                                   -> [GHC.Word.Word8])
                                  -> Data.Functor.Const.Const
                                       Data.ByteString.Lazy.Internal.ByteString
                                       Data.ByteString.Lazy.Internal.ByteString
                                  -> Data.Functor.Const.Const
                                       Data.ByteString.Lazy.Internal.ByteString [GHC.Word.Word8]
              Data.ByteString.Lazy.Internal.unpackBytes
            ApplyToVal nodup hole Data.Functor.Const.Const
                                    Data.ByteString.Lazy.Internal.ByteString
                                    Data.ByteString.Lazy.Internal.ByteString
                                  -> Data.Functor.Const.Const
                                       Data.ByteString.Lazy.Internal.ByteString [GHC.Word.Word8]
              (bc_aboH (ab_aboF x_aboI))
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N
                        <Data.ByteString.Lazy.Internal.ByteString>_R
                        <[GHC.Word.Word8]>_P
                    :: Data.Functor.Const.Const
                         Data.ByteString.Lazy.Internal.ByteString [GHC.Word.Word8]
                       ~R# Data.ByteString.Lazy.Internal.ByteString)
            Stop[RuleArgCtxt] Data.ByteString.Lazy.Internal.ByteString
Rule fired
    Rule: Class op ==
    Module: (BUILTIN)
    Before: GHC.Classes.==
              TyArg [GHC.Word.Word8]
              ValArg $dEq_a9eu
              ValArg Data.ByteString.Lazy.Internal.unpackBytes
                       (Data.ByteString.Lazy.Internal.packBytes_packChunks
                          Data.ByteString.Lazy.Internal.packBytes1 s_a8Py)
              ValArg s_a8Py
    After:  GHC.Classes.$fEqList_$c==
              @GHC.Word.Word8 GHC.Word.$fEqWord8
              ValArg Data.ByteString.Lazy.Internal.unpackBytes
                       (Data.ByteString.Lazy.Internal.packBytes_packChunks
                          Data.ByteString.Lazy.Internal.packBytes1 s_a8Py)
              ValArg s_a8Py
    Cont:   Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: unpack
    Module: (GHC.Base)
    Before: GHC.CString.unpackCString# ValArg "B -> L -> B"#
    After:  (\ (a_ab7z :: GHC.Prim.Addr#) ->
               GHC.Base.build
                 @GHC.Types.Char
                 (\ (@b_ab7A) -> GHC.CString.unpackFoldrCString# @b_ab7A a_ab7z))
              "B -> L -> B"#
    Cont:   Stop[BoringCtxt] Test.Tasty.Core.TestName
Rule fired
    Rule: Class op property
    Module: (BUILTIN)
    Before: Test.QuickCheck.Property.property
              TyArg Data.ByteString.Internal.Type.ByteString -> GHC.Types.Bool
              ValArg $dTestable_a9a1
    After:  Test.QuickCheck.Property.$fTestableFUN_$cproperty
              @Data.ByteString.Internal.Type.ByteString
              @GHC.Types.Bool
              Test.QuickCheck.Instances.ByteString.$fArbitraryByteString0
              Data.ByteString.Internal.Type.$fShowByteString
              Test.QuickCheck.Property.$fTestableBool
    Cont:   ApplyToVal nodup hole (Data.ByteString.Internal.Type.ByteString
                                   -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              prop_ab7M
            CastIt (Sym (Test.Tasty.QuickCheck.N:QC[0])
                    :: Test.QuickCheck.Property.Property ~R# Test.Tasty.QuickCheck.QC)
            Stop[BoringCtxt] Test.Tasty.QuickCheck.QC
Rule fired
    Rule: Class op propertyForAllShrinkShow
    Module: (BUILTIN)
    Before: Test.QuickCheck.Property.propertyForAllShrinkShow
              TyArg GHC.Types.Bool ValArg Test.QuickCheck.Property.$fTestableBool
    After:  Test.QuickCheck.Property.$fTestableBool1
            `cast` (forall (a :: <*>_N).
                    <Test.QuickCheck.Gen.Gen a>_R
                    %<'GHC.Types.Many>_N ->_R <a -> [a]>_R
                    %<'GHC.Types.Many>_N ->_R <a -> [GHC.Base.String]>_R
                    %<'GHC.Types.Many>_N ->_R <a -> GHC.Types.Bool>_R
                    %<'GHC.Types.Many>_N ->_R Sym (Test.QuickCheck.Gen.N:Gen[0]
                                                       (Test.QuickCheck.Property.N:Prop[0]))
                                              ; Sym (Test.QuickCheck.Property.N:Property[0])
                    :: (forall {a}.
                        Test.QuickCheck.Gen.Gen a
                        -> (a -> [a])
                        -> (a -> [GHC.Base.String])
                        -> (a -> GHC.Types.Bool)
                        -> Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int
                        -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result)
                       ~R# (forall {a}.
                            Test.QuickCheck.Gen.Gen a
                            -> (a -> [a])
                            -> (a -> [GHC.Base.String])
                            -> (a -> GHC.Types.Bool)
                            -> Test.QuickCheck.Property.Property))
    Cont:   ApplyToTy Data.ByteString.Internal.Type.ByteString
            ApplyToVal nodup hole Test.QuickCheck.Gen.Gen
                                    Data.ByteString.Internal.Type.ByteString
                                  -> (Data.ByteString.Internal.Type.ByteString
                                      -> [Data.ByteString.Internal.Type.ByteString])
                                  -> (Data.ByteString.Internal.Type.ByteString -> [GHC.Base.String])
                                  -> (Data.ByteString.Internal.Type.ByteString -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (Test.QuickCheck.Arbitrary.arbitrary @a_ab9u $dArbitrary_ab9w)
            ApplyToVal nodup hole (Data.ByteString.Internal.Type.ByteString
                                   -> [Data.ByteString.Internal.Type.ByteString])
                                  -> (Data.ByteString.Internal.Type.ByteString -> [GHC.Base.String])
                                  -> (Data.ByteString.Internal.Type.ByteString -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (Test.QuickCheck.Arbitrary.shrink @a_ab9u $dArbitrary_ab9w)
            ApplyToVal nodup hole (Data.ByteString.Internal.Type.ByteString
                                   -> [GHC.Base.String])
                                  -> (Data.ByteString.Internal.Type.ByteString -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (let {
                 g_ab9A [Occ=OnceL1!] :: a_ab9u -> GHC.Base.String
                 [LclId]
                 g_ab9A = GHC.Show.show @a_ab9u $dShow_ab9x } in
               \ (x_ab9B [Occ=Once1] :: a_ab9u) ->
                 GHC.Types.:
                   @GHC.Base.String (g_ab9A x_ab9B) (GHC.Types.[] @GHC.Base.String))
            ApplyToVal nodup hole (Data.ByteString.Internal.Type.ByteString
                                   -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              f_ab9z
            CastIt (Sym (Test.Tasty.QuickCheck.N:QC[0])
                    :: Test.QuickCheck.Property.Property ~R# Test.Tasty.QuickCheck.QC)
            Stop[BoringCtxt] Test.Tasty.QuickCheck.QC
Rule fired
    Rule: Class op arbitrary
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.arbitrary
              TyArg Data.ByteString.Internal.Type.ByteString
              ValArg Test.QuickCheck.Instances.ByteString.$fArbitraryByteString0
    After:  Test.QuickCheck.Instances.ByteString.$fArbitraryByteString3
            `cast` (Sym (Test.QuickCheck.Gen.N:Gen[0]
                             <Data.ByteString.Internal.Type.ByteString>_R)
                    :: (Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int -> Data.ByteString.Internal.Type.ByteString)
                       ~R# Test.QuickCheck.Gen.Gen
                             Data.ByteString.Internal.Type.ByteString)
    Cont:   Stop[BoringCtxt] Test.QuickCheck.Gen.Gen
                               Data.ByteString.Internal.Type.ByteString
Rule fired
    Rule: Class op shrink
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.shrink
              TyArg Data.ByteString.Internal.Type.ByteString
              ValArg Test.QuickCheck.Instances.ByteString.$fArbitraryByteString0
    After:  Test.QuickCheck.Instances.ByteString.$fArbitraryByteString0_$cshrink
    Cont:   Stop[BoringCtxt] Data.ByteString.Internal.Type.ByteString
                             -> [Data.ByteString.Internal.Type.ByteString]
Rule fired
    Rule: Class op show
    Module: (BUILTIN)
    Before: GHC.Show.show
              TyArg Data.ByteString.Internal.Type.ByteString
              ValArg Data.ByteString.Internal.Type.$fShowByteString
    After:  Data.ByteString.Internal.Type.$fShowByteString_$cshow
    Cont:   Stop[RhsCtxt(NonRecursive)] Data.ByteString.Internal.Type.ByteString
                                        -> GHC.Base.String
Rule fired
    Rule: Class op reader
    Module: (BUILTIN)
    Before: Control.Monad.Reader.Class.reader
              TyArg Data.ByteString.Lazy.Internal.ByteString
              TyArg (->) Data.ByteString.Lazy.Internal.ByteString
              ValArg Control.Monad.Reader.Class.$fMonadReaderrFUN
                       @Data.ByteString.Lazy.Internal.ByteString
    After:  \ (@a_abeP) ->
              GHC.Base.id @(Data.ByteString.Lazy.Internal.ByteString -> a_abeP)
    Cont:   ApplyToTy Data.ByteString.Internal.Type.ByteString
            ApplyToVal nodup hole (Data.ByteString.Lazy.Internal.ByteString
                                   -> Data.ByteString.Internal.Type.ByteString)
                                  -> Data.ByteString.Lazy.Internal.ByteString
                                  -> Data.ByteString.Internal.Type.ByteString
              ((l_abeJ
                  ((\ (ds_abeK [Occ=Once1] :: a_abeH) -> ds_abeK)
                   `cast` (<a_abeH>_R
                           %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                              <*>_N <a_abeH>_R <a_abeH>_P)
                           :: (a_abeH -> a_abeH)
                              ~R# (a_abeH -> Data.Functor.Const.Const a_abeH a_abeH))))
               `cast` (<s_abeF>_R
                       %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                     <*>_N <a_abeH>_R <s_abeF>_P
                       :: (s_abeF -> Data.Functor.Const.Const a_abeH s_abeF)
                          ~R# (s_abeF -> a_abeH)))
            ApplyToVal nodup hole Data.ByteString.Lazy.Internal.ByteString
                                  -> Data.ByteString.Internal.Type.ByteString
              (Control.Lens.Getter.view
                 @Data.ByteString.Internal.Type.ByteString
                 @((->) Data.ByteString.Internal.Type.ByteString)
                 @Data.ByteString.Lazy.Internal.ByteString
                 (Control.Monad.Reader.Class.$fMonadReaderrFUN
                    @Data.ByteString.Internal.Type.ByteString)
                 (Control.Lens.Cons.Extras.recons
                    @Data.ByteString.Internal.Type.ByteString
                    @GHC.Word.Word8
                    @Data.ByteString.Lazy.Internal.ByteString
                    Control.Lens.Cons.$fConsByteStringByteStringWord8Word80
                    Control.Lens.Cons.$fConsByteStringByteStringWord8Word8
                    Control.Lens.Empty.$fAsEmptyByteString
                    @(Data.Functor.Const.Const
                        Data.ByteString.Lazy.Internal.ByteString)
                    (Data.Functor.Contravariant.$fContravariantConst
                       @Data.ByteString.Lazy.Internal.ByteString)
                    (Data.Functor.Const.$fFunctorConst
                       @Data.ByteString.Lazy.Internal.ByteString))
                 s_a8Pz)
            Stop[RuleArgCtxt] Data.ByteString.Internal.Type.ByteString
Rule fired
    Rule: recons/bs-strict
    Module: (Control.Lens.Cons.Extras)
    Before: Control.Lens.Cons.Extras.recons
              TyArg Data.ByteString.Lazy.Internal.ByteString
              TyArg GHC.Word.Word8
              TyArg Data.ByteString.Internal.Type.ByteString
              ValArg (\ (@(p_abnq :: * -> * -> *))
                        (@(f_abnr :: * -> *))
                        ($dChoice_abns :: Data.Profunctor.Choice.Choice p_abnq)
                        ($dApplicative_abnt :: GHC.Base.Applicative f_abnr) ->
                        let {
                          f1_abnu
                            :: p_abnq
                                 (Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                                 (Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (f_abnr
                                       (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                               -> p_abnq
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (f_abnr Data.ByteString.Lazy.Internal.ByteString)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 536 0}]
                          f1_abnu
                            = Data.Profunctor.Unsafe.dimap
                                @p_abnq
                                (Data.Profunctor.Choice.$p1Choice @p_abnq $dChoice_abns)
                                @Data.ByteString.Lazy.Internal.ByteString
                                @(Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                                @(Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (f_abnr
                                       (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                                @(f_abnr Data.ByteString.Lazy.Internal.ByteString)
                                (\ (s1_abnv :: Data.ByteString.Lazy.Internal.ByteString) ->
                                   case s1_abnv of {
                                     Data.ByteString.Lazy.Internal.Empty ->
                                       Data.Either.Left
                                         @Data.ByteString.Lazy.Internal.ByteString
                                         @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                         Data.ByteString.Lazy.Internal.Empty;
                                     Data.ByteString.Lazy.Internal.Chunk bx_abnC bx1_abnD bx2_abnE
                                                                         cs_abnF ->
                                       case bx2_abnE of ds1_abnH {
                                         __DEFAULT ->
                                           Data.Either.Right
                                             @Data.ByteString.Lazy.Internal.ByteString
                                             @(GHC.Word.Word8,
                                               Data.ByteString.Lazy.Internal.ByteString)
                                             (case GHC.Prim.readWord8OffAddr#
                                                     @GHC.Prim.RealWorld
                                                     bx_abnC
                                                     0#
                                                     GHC.Prim.realWorld#
                                              of
                                              { (# ipv_abnJ, ipv1_abnK #) ->
                                              case GHC.Prim.touch#
                                                     @'GHC.Types.Lifted
                                                     @GHC.ForeignPtr.ForeignPtrContents
                                                     bx1_abnD
                                                     ipv_abnJ
                                              of
                                              { __DEFAULT ->
                                              GHC.Word.W8# ipv1_abnK
                                              }
                                              },
                                              Data.ByteString.Lazy.Internal.$WChunk
                                                (Data.ByteString.Internal.Type.$WBS
                                                   (GHC.ForeignPtr.ForeignPtr
                                                      @GHC.Word.Word8
                                                      (GHC.Prim.plusAddr# bx_abnC 1#)
                                                      bx1_abnD)
                                                   (GHC.Types.I# (GHC.Prim.-# ds1_abnH 1#)))
                                                cs_abnF);
                                         1# ->
                                           Data.Either.Right
                                             @Data.ByteString.Lazy.Internal.ByteString
                                             @(GHC.Word.Word8,
                                               Data.ByteString.Lazy.Internal.ByteString)
                                             (case GHC.Prim.readWord8OffAddr#
                                                     @GHC.Prim.RealWorld
                                                     bx_abnC
                                                     0#
                                                     GHC.Prim.realWorld#
                                              of
                                              { (# ipv_abnO, ipv1_abnP #) ->
                                              case GHC.Prim.touch#
                                                     @'GHC.Types.Lifted
                                                     @GHC.ForeignPtr.ForeignPtrContents
                                                     bx1_abnD
                                                     ipv_abnO
                                              of
                                              { __DEFAULT ->
                                              GHC.Word.W8# ipv1_abnP
                                              }
                                              },
                                              cs_abnF)
                                       }
                                   })
                                (let {
                                   f2_abnS
                                     :: Data.ByteString.Lazy.Internal.ByteString
                                        -> f_abnr Data.ByteString.Lazy.Internal.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abnS
                                     = GHC.Base.pure
                                         @f_abnr
                                         $dApplicative_abnt
                                         @Data.ByteString.Lazy.Internal.ByteString } in
                                 let {
                                   ds2_abnT
                                     :: f_abnr
                                          (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                        -> f_abnr Data.ByteString.Lazy.Internal.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 162 0}]
                                   ds2_abnT
                                     = GHC.Base.fmap
                                         @f_abnr
                                         (GHC.Base.$p1Applicative @f_abnr $dApplicative_abnt)
                                         @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                         @Data.ByteString.Lazy.Internal.ByteString
                                         (\ (p1_abnU
                                               :: (GHC.Word.Word8,
                                                   Data.ByteString.Lazy.Internal.ByteString)) ->
                                            case p1_abnU of { (x_abnW, ds_abnX) ->
                                            case x_abnW of { GHC.Word.W8# x#_abo0 ->
                                            Data.ByteString.Lazy.Internal.$WChunk
                                              (Data.ByteString.Internal.Type.$WBS
                                                 (GHC.ForeignPtr.ForeignPtr
                                                    @GHC.Word.Word8
                                                    (GHC.Prim.plusAddr#
                                                       Data.ByteString.singleton1
                                                       (GHC.Prim.word2Int#
                                                          (GHC.Prim.word8ToWord# x#_abo0)))
                                                    GHC.ForeignPtr.FinalPtr)
                                                 (GHC.Types.I# 1#))
                                              ds_abnX
                                            }
                                            }) } in
                                 \ (ds3_abo2
                                      :: Data.Either.Either
                                           Data.ByteString.Lazy.Internal.ByteString
                                           (f_abnr
                                              (GHC.Word.Word8,
                                               Data.ByteString.Lazy.Internal.ByteString))) ->
                                   case ds3_abo2 of {
                                     Data.Either.Left x_abo4 -> f2_abnS x_abo4;
                                     Data.Either.Right y_abo6 -> ds2_abnT y_abo6
                                   }) } in
                        let {
                          g_abo8
                            :: p_abnq
                                 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                 (f_abnr (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                               -> p_abnq
                                    (Data.Either.Either
                                       Data.ByteString.Lazy.Internal.ByteString
                                       (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                                    (Data.Either.Either
                                       Data.ByteString.Lazy.Internal.ByteString
                                       (f_abnr
                                          (GHC.Word.Word8,
                                           Data.ByteString.Lazy.Internal.ByteString)))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abo8
                            = Data.Profunctor.Choice.right'
                                @p_abnq
                                $dChoice_abns
                                @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                @(f_abnr
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                                @Data.ByteString.Lazy.Internal.ByteString } in
                        \ (x_abo9
                             :: p_abnq
                                  (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                  (f_abnr
                                     (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))) ->
                          f1_abnu (g_abo8 x_abo9))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <Data.ByteString.Lazy.Internal.ByteString>_N
                                      <Data.ByteString.Lazy.Internal.ByteString>_N
                                      <GHC.Word.Word8>_N
                                      <GHC.Word.Word8>_N)
                             :: Control.Lens.Type.Prism
                                  Data.ByteString.Lazy.Internal.ByteString
                                  Data.ByteString.Lazy.Internal.ByteString
                                  (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                  (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                ~R# Control.Lens.Cons.Cons
                                      Data.ByteString.Lazy.Internal.ByteString
                                      Data.ByteString.Lazy.Internal.ByteString
                                      GHC.Word.Word8
                                      GHC.Word.Word8)
              ValArg (\ (@(p_abkq :: * -> * -> *))
                        (@(f_abkr :: * -> *))
                        ($dChoice_abks :: Data.Profunctor.Choice.Choice p_abkq)
                        ($dApplicative_abkt :: GHC.Base.Applicative f_abkr) ->
                        let {
                          f1_abku
                            :: p_abkq
                                 (Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                                 (Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString
                                    (f_abkr
                                       (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                               -> p_abkq
                                    Data.ByteString.Internal.Type.ByteString
                                    (f_abkr Data.ByteString.Internal.Type.ByteString)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 612 0}]
                          f1_abku
                            = Data.Profunctor.Unsafe.dimap
                                @p_abkq
                                (Data.Profunctor.Choice.$p1Choice @p_abkq $dChoice_abks)
                                @Data.ByteString.Internal.Type.ByteString
                                @(Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                                @(Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString
                                    (f_abkr
                                       (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                                @(f_abkr Data.ByteString.Internal.Type.ByteString)
                                (\ (s1_abkv :: Data.ByteString.Internal.Type.ByteString) ->
                                   case s1_abkv of wild_abkw
                                   { Data.ByteString.Internal.Type.BS bx_abkx bx1_abky bx2_abkz ->
                                   case GHC.Classes.leInt (GHC.Types.I# bx2_abkz) (GHC.Types.I# 0#)
                                   of {
                                     GHC.Types.False ->
                                       Data.Either.Right
                                         @Data.ByteString.Internal.Type.ByteString
                                         @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                         (case GHC.Prim.readWord8OffAddr#
                                                 @GHC.Prim.RealWorld bx_abkx 0# GHC.Prim.realWorld#
                                          of
                                          { (# ipv_abkE, ipv1_abkF #) ->
                                          case GHC.Prim.touch#
                                                 @'GHC.Types.Lifted
                                                 @GHC.ForeignPtr.ForeignPtrContents
                                                 bx1_abky
                                                 ipv_abkE
                                          of
                                          { __DEFAULT ->
                                          GHC.Word.W8# ipv1_abkF
                                          }
                                          },
                                          Data.ByteString.Internal.Type.$WBS
                                            (GHC.ForeignPtr.ForeignPtr
                                               @GHC.Word.Word8
                                               (GHC.Prim.plusAddr# bx_abkx 1#)
                                               bx1_abky)
                                            (GHC.Types.I# (GHC.Prim.-# bx2_abkz 1#)));
                                     GHC.Types.True ->
                                       Data.Either.Left
                                         @Data.ByteString.Internal.Type.ByteString
                                         @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                         wild_abkw
                                   }
                                   })
                                (let {
                                   f2_abkJ
                                     :: Data.ByteString.Internal.Type.ByteString
                                        -> f_abkr Data.ByteString.Internal.Type.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abkJ
                                     = GHC.Base.pure
                                         @f_abkr
                                         $dApplicative_abkt
                                         @Data.ByteString.Internal.Type.ByteString } in
                                 let {
                                   ds2_abkK
                                     :: f_abkr
                                          (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                        -> f_abkr Data.ByteString.Internal.Type.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 259 0}]
                                   ds2_abkK
                                     = GHC.Base.fmap
                                         @f_abkr
                                         (GHC.Base.$p1Applicative @f_abkr $dApplicative_abkt)
                                         @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                         @Data.ByteString.Internal.Type.ByteString
                                         (\ (p1_abkL
                                               :: (GHC.Word.Word8,
                                                   Data.ByteString.Internal.Type.ByteString)) ->
                                            case p1_abkL of { (ds_abkN, y_abkO) ->
                                            case y_abkO of
                                            { Data.ByteString.Internal.Type.BS bx_abl0 bx1_abl1
                                                                               bx2_abl2 ->
                                            GHC.Magic.runRW#
                                              @GHC.Types.LiftedRep
                                              @Data.ByteString.Internal.Type.ByteString
                                              (\ (s_abkY [OS=OneShot]
                                                    :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                                                 let {
                                                   x_abkZ :: GHC.Prim.Int#
                                                   [LclId,
                                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                            Value=False, ConLike=False,
                                                            WorkFree=False, Expandable=False,
                                                            Guidance=IF_ARGS [] 1 0}]
                                                   x_abkZ = GHC.Prim.+# bx2_abl2 1# } in
                                                 case GHC.Prim.<# x_abkZ 0# of {
                                                   __DEFAULT ->
                                                     case GHC.Prim.newPinnedByteArray#
                                                            @GHC.Prim.RealWorld x_abkZ s_abkY
                                                     of
                                                     { (# ipv_abl7, ipv1_abl8 #) ->
                                                     let {
                                                       ipv2_abl6 :: GHC.Prim.Addr#
                                                       [LclId,
                                                        Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                                Value=False, ConLike=False,
                                                                WorkFree=False, Expandable=False,
                                                                Guidance=IF_ARGS [] 1 0}]
                                                       ipv2_abl6
                                                         = GHC.Prim.mutableByteArrayContents#
                                                             @GHC.Prim.RealWorld ipv1_abl8 } in
                                                     let {
                                                       ipv3_abla
                                                         :: GHC.ForeignPtr.ForeignPtrContents
                                                       [LclId,
                                                        Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                                Value=True, ConLike=True,
                                                                WorkFree=True, Expandable=True,
                                                                Guidance=IF_ARGS [] 10 10}]
                                                       ipv3_abla
                                                         = GHC.ForeignPtr.PlainPtr ipv1_abl8 } in
                                                     case ds_abkN of { GHC.Word.W8# x1_abms ->
                                                     case GHC.Prim.writeWord8OffAddr#
                                                            @GHC.Prim.RealWorld
                                                            ipv2_abl6
                                                            0#
                                                            x1_abms
                                                            ipv_abl7
                                                     of s2_abmu
                                                     { __DEFAULT ->
                                                     case GHC.Prim.touch#
                                                            @'GHC.Types.Lifted
                                                            @GHC.ForeignPtr.ForeignPtrContents
                                                            ipv3_abla
                                                            s2_abmu
                                                     of s'_abmv
                                                     { __DEFAULT ->
                                                     case {__ffi_static_ccall_unsafe base:memcpy :: Addr#
                                          -> Addr#
                                          -> Word64#
                                          -> State# RealWorld
                                          -> (# State# RealWorld, Addr# #)}_abmw
                                                            (GHC.Prim.plusAddr# ipv2_abl6 1#)
                                                            bx_abl0
                                                            (GHC.Prim.int64ToWord64#
                                                               (GHC.Prim.intToInt64# bx2_abl2))
                                                            s'_abmv
                                                     of
                                                     { (# ds4_abmy, ds5_abmz #) ->
                                                     case GHC.Prim.touch#
                                                            @'GHC.Types.Lifted
                                                            @GHC.ForeignPtr.ForeignPtrContents
                                                            bx1_abl1
                                                            ds4_abmy
                                                     of s'1_abmB
                                                     { __DEFAULT ->
                                                     case GHC.Prim.touch#
                                                            @'GHC.Types.Lifted
                                                            @GHC.ForeignPtr.ForeignPtrContents
                                                            ipv3_abla
                                                            s'1_abmB
                                                     of s'2_abmC
                                                     { __DEFAULT ->
                                                     case GHC.Magic.lazy
                                                            @((GHC.Prim.State# GHC.Prim.RealWorld
                                                               -> (# GHC.Prim.State#
                                                                       GHC.Prim.RealWorld,
                                                                     GHC.Prim.Addr# #))
                                                              -> (# GHC.Prim.State#
                                                                      GHC.Prim.RealWorld,
                                                                    GHC.Prim.Addr# #))
                                                            (GHC.Magic.runRW#
                                                               @('GHC.Types.TupleRep
                                                                   '[GHC.Types.ZeroBitRep,
                                                                     'GHC.Types.AddrRep])
                                                               @(# GHC.Prim.State#
                                                                     GHC.Prim.RealWorld,
                                                                   GHC.Prim.Addr# #))
                                                            (\ _ [Occ=Dead] ->
                                                               (# s'2_abmC, ipv2_abl6 #))
                                                     of
                                                     { (# ipv6_abmF, ipv7_abmG #) ->
                                                     Data.ByteString.Internal.Type.BS
                                                       ipv7_abmG ipv3_abla x_abkZ
                                                     }
                                                     }
                                                     }
                                                     }
                                                     }
                                                     }
                                                     }
                                                     };
                                                   1# ->
                                                     case GHC.ForeignPtr.mallocPlainForeignPtrBytes2
                                                     of wild_00 {
                                                     }
                                                 })
                                            }
                                            }) } in
                                 \ (ds3_abmJ
                                      :: Data.Either.Either
                                           Data.ByteString.Internal.Type.ByteString
                                           (f_abkr
                                              (GHC.Word.Word8,
                                               Data.ByteString.Internal.Type.ByteString))) ->
                                   case ds3_abmJ of {
                                     Data.Either.Left x_abmL -> f2_abkJ x_abmL;
                                     Data.Either.Right y_abmN -> ds2_abkK y_abmN
                                   }) } in
                        let {
                          g_abmP
                            :: p_abkq
                                 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                 (f_abkr (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                               -> p_abkq
                                    (Data.Either.Either
                                       Data.ByteString.Internal.Type.ByteString
                                       (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                                    (Data.Either.Either
                                       Data.ByteString.Internal.Type.ByteString
                                       (f_abkr
                                          (GHC.Word.Word8,
                                           Data.ByteString.Internal.Type.ByteString)))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abmP
                            = Data.Profunctor.Choice.right'
                                @p_abkq
                                $dChoice_abks
                                @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                @(f_abkr
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                                @Data.ByteString.Internal.Type.ByteString } in
                        \ (x_abmQ
                             :: p_abkq
                                  (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                  (f_abkr
                                     (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))) ->
                          f1_abku (g_abmP x_abmQ))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <Data.ByteString.Internal.Type.ByteString>_N
                                      <Data.ByteString.Internal.Type.ByteString>_N
                                      <GHC.Word.Word8>_N
                                      <GHC.Word.Word8>_N)
                             :: Control.Lens.Type.Prism
                                  Data.ByteString.Internal.Type.ByteString
                                  Data.ByteString.Internal.Type.ByteString
                                  (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                  (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                ~R# Control.Lens.Cons.Cons
                                      Data.ByteString.Internal.Type.ByteString
                                      Data.ByteString.Internal.Type.ByteString
                                      GHC.Word.Word8
                                      GHC.Word.Word8)
              ValArg (\ (@(p_abmX :: * -> * -> *))
                        (@(f_abmY :: * -> *))
                        ($dChoice_abmZ :: Data.Profunctor.Choice.Choice p_abmX)
                        ($dApplicative_abn0 :: GHC.Base.Applicative f_abmY) ->
                        let {
                          f1_abn1
                            :: p_abmX
                                 (Data.Either.Either Data.ByteString.Internal.Type.ByteString ())
                                 (Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString (f_abmY ()))
                               -> p_abmX
                                    Data.ByteString.Internal.Type.ByteString
                                    (f_abmY Data.ByteString.Internal.Type.ByteString)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 350 0}]
                          f1_abn1
                            = Data.Profunctor.Unsafe.dimap
                                @p_abmX
                                (Data.Profunctor.Choice.$p1Choice @p_abmX $dChoice_abmZ)
                                @Data.ByteString.Internal.Type.ByteString
                                @(Data.Either.Either Data.ByteString.Internal.Type.ByteString ())
                                @(Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString (f_abmY ()))
                                @(f_abmY Data.ByteString.Internal.Type.ByteString)
                                (\ (s_abn2 :: Data.ByteString.Internal.Type.ByteString) ->
                                   case s_abn2 of wild_abn3
                                   { Data.ByteString.Internal.Type.BS bx_abn4 bx1_abn5 bx2_abn6 ->
                                   case GHC.Classes.leInt (GHC.Types.I# bx2_abn6) (GHC.Types.I# 0#)
                                   of {
                                     GHC.Types.False ->
                                       Data.Either.Left
                                         @Data.ByteString.Internal.Type.ByteString @() wild_abn3;
                                     GHC.Types.True ->
                                       Data.Either.Right
                                         @Data.ByteString.Internal.Type.ByteString
                                         @()
                                         GHC.Tuple.Prim.()
                                   }
                                   })
                                (let {
                                   f2_abna
                                     :: Data.ByteString.Internal.Type.ByteString
                                        -> f_abmY Data.ByteString.Internal.Type.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abna
                                     = GHC.Base.pure
                                         @f_abmY
                                         $dApplicative_abn0
                                         @Data.ByteString.Internal.Type.ByteString } in
                                 let {
                                   ds2_abnb
                                     :: f_abmY () -> f_abmY Data.ByteString.Internal.Type.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 70 0}]
                                   ds2_abnb
                                     = GHC.Base.fmap
                                         @f_abmY
                                         (GHC.Base.$p1Applicative @f_abmY $dApplicative_abn0)
                                         @()
                                         @Data.ByteString.Internal.Type.ByteString
                                         (\ (ds3_abnc :: ()) ->
                                            case ds3_abnc of { () ->
                                            Data.ByteString.Internal.Type.empty
                                            }) } in
                                 \ (ds3_abne
                                      :: Data.Either.Either
                                           Data.ByteString.Internal.Type.ByteString (f_abmY ())) ->
                                   case ds3_abne of {
                                     Data.Either.Left x_abng -> f2_abna x_abng;
                                     Data.Either.Right y_abni -> ds2_abnb y_abni
                                   }) } in
                        let {
                          g_abnk
                            :: p_abmX () (f_abmY ())
                               -> p_abmX
                                    (Data.Either.Either Data.ByteString.Internal.Type.ByteString ())
                                    (Data.Either.Either
                                       Data.ByteString.Internal.Type.ByteString (f_abmY ()))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abnk
                            = Data.Profunctor.Choice.right'
                                @p_abmX
                                $dChoice_abmZ
                                @()
                                @(f_abmY ())
                                @Data.ByteString.Internal.Type.ByteString } in
                        \ (x_abnl :: p_abmX () (f_abmY ())) -> f1_abn1 (g_abnk x_abnl))
                     `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                      <Data.ByteString.Internal.Type.ByteString>_N)
                             :: Control.Lens.Type.Prism'
                                  Data.ByteString.Internal.Type.ByteString ()
                                ~R# Control.Lens.Empty.AsEmpty
                                      Data.ByteString.Internal.Type.ByteString)
              TyArg Data.Functor.Const.Const
                      Data.ByteString.Internal.Type.ByteString
              ValArg Data.Functor.Contravariant.$fContravariantConst
                       @Data.ByteString.Internal.Type.ByteString
              ValArg Data.Functor.Const.$fFunctorConst
                       @Data.ByteString.Internal.Type.ByteString
    After:  (\ (@(f_abfW :: * -> *))
               ($dCons_abfX
                  :: Control.Lens.Cons.Cons
                       Data.ByteString.Lazy.Internal.ByteString
                       Data.ByteString.Lazy.Internal.ByteString
                       GHC.Word.Word8
                       GHC.Word.Word8)
               ($dCons1_abfY
                  :: Control.Lens.Cons.Cons
                       Data.ByteString.Internal.Type.ByteString
                       Data.ByteString.Internal.Type.ByteString
                       GHC.Word.Word8
                       GHC.Word.Word8)
               ($dAsEmpty_abfZ
                  :: Control.Lens.Empty.AsEmpty
                       Data.ByteString.Internal.Type.ByteString)
               ($dContravariant_abg0
                  :: Data.Functor.Contravariant.Contravariant f_abfW)
               ($dFunctor_abg1 :: GHC.Base.Functor f_abfW) ->
               Data.Profunctor.Unsafe.$fProfunctorFUN_$cdimap
                 @Data.ByteString.Lazy.Internal.ByteString
                 @Data.ByteString.Internal.Type.ByteString
                 @(f_abfW Data.ByteString.Internal.Type.ByteString)
                 @(f_abfW Data.ByteString.Lazy.Internal.ByteString)
                 Data.ByteString.Lazy.Internal.toStrict
                 (GHC.Base.fmap
                    @f_abfW
                    $dFunctor_abg1
                    @Data.ByteString.Internal.Type.ByteString
                    @Data.ByteString.Lazy.Internal.ByteString
                    Data.ByteString.Lazy.Internal.fromStrict))
              @(Data.Functor.Const.Const
                  Data.ByteString.Internal.Type.ByteString)
              ((\ (@(p_abnq :: * -> * -> *))
                  (@(f_abnr :: * -> *))
                  ($dChoice_abns :: Data.Profunctor.Choice.Choice p_abnq)
                  ($dApplicative_abnt :: GHC.Base.Applicative f_abnr) ->
                  let {
                    f1_abnu
                      :: p_abnq
                           (Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString
                              (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                           (Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString
                              (f_abnr
                                 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                         -> p_abnq
                              Data.ByteString.Lazy.Internal.ByteString
                              (f_abnr Data.ByteString.Lazy.Internal.ByteString)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 536 0}]
                    f1_abnu
                      = Data.Profunctor.Unsafe.dimap
                          @p_abnq
                          (Data.Profunctor.Choice.$p1Choice @p_abnq $dChoice_abns)
                          @Data.ByteString.Lazy.Internal.ByteString
                          @(Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString
                              (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                          @(Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString
                              (f_abnr
                                 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                          @(f_abnr Data.ByteString.Lazy.Internal.ByteString)
                          (\ (s1_abnv :: Data.ByteString.Lazy.Internal.ByteString) ->
                             case s1_abnv of {
                               Data.ByteString.Lazy.Internal.Empty ->
                                 Data.Either.Left
                                   @Data.ByteString.Lazy.Internal.ByteString
                                   @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                   Data.ByteString.Lazy.Internal.Empty;
                               Data.ByteString.Lazy.Internal.Chunk bx_abnC bx1_abnD bx2_abnE
                                                                   cs_abnF ->
                                 case bx2_abnE of ds1_abnH {
                                   __DEFAULT ->
                                     Data.Either.Right
                                       @Data.ByteString.Lazy.Internal.ByteString
                                       @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                       (case GHC.Prim.readWord8OffAddr#
                                               @GHC.Prim.RealWorld bx_abnC 0# GHC.Prim.realWorld#
                                        of
                                        { (# ipv_abnJ, ipv1_abnK #) ->
                                        case GHC.Prim.touch#
                                               @'GHC.Types.Lifted
                                               @GHC.ForeignPtr.ForeignPtrContents
                                               bx1_abnD
                                               ipv_abnJ
                                        of
                                        { __DEFAULT ->
                                        GHC.Word.W8# ipv1_abnK
                                        }
                                        },
                                        Data.ByteString.Lazy.Internal.$WChunk
                                          (Data.ByteString.Internal.Type.$WBS
                                             (GHC.ForeignPtr.ForeignPtr
                                                @GHC.Word.Word8
                                                (GHC.Prim.plusAddr# bx_abnC 1#)
                                                bx1_abnD)
                                             (GHC.Types.I# (GHC.Prim.-# ds1_abnH 1#)))
                                          cs_abnF);
                                   1# ->
                                     Data.Either.Right
                                       @Data.ByteString.Lazy.Internal.ByteString
                                       @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                       (case GHC.Prim.readWord8OffAddr#
                                               @GHC.Prim.RealWorld bx_abnC 0# GHC.Prim.realWorld#
                                        of
                                        { (# ipv_abnO, ipv1_abnP #) ->
                                        case GHC.Prim.touch#
                                               @'GHC.Types.Lifted
                                               @GHC.ForeignPtr.ForeignPtrContents
                                               bx1_abnD
                                               ipv_abnO
                                        of
                                        { __DEFAULT ->
                                        GHC.Word.W8# ipv1_abnP
                                        }
                                        },
                                        cs_abnF)
                                 }
                             })
                          (let {
                             f2_abnS
                               :: Data.ByteString.Lazy.Internal.ByteString
                                  -> f_abnr Data.ByteString.Lazy.Internal.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abnS
                               = GHC.Base.pure
                                   @f_abnr
                                   $dApplicative_abnt
                                   @Data.ByteString.Lazy.Internal.ByteString } in
                           let {
                             ds2_abnT
                               :: f_abnr
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                  -> f_abnr Data.ByteString.Lazy.Internal.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 162 0}]
                             ds2_abnT
                               = GHC.Base.fmap
                                   @f_abnr
                                   (GHC.Base.$p1Applicative @f_abnr $dApplicative_abnt)
                                   @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                   @Data.ByteString.Lazy.Internal.ByteString
                                   (\ (p1_abnU
                                         :: (GHC.Word.Word8,
                                             Data.ByteString.Lazy.Internal.ByteString)) ->
                                      case p1_abnU of { (x_abnW, ds_abnX) ->
                                      case x_abnW of { GHC.Word.W8# x#_abo0 ->
                                      Data.ByteString.Lazy.Internal.$WChunk
                                        (Data.ByteString.Internal.Type.$WBS
                                           (GHC.ForeignPtr.ForeignPtr
                                              @GHC.Word.Word8
                                              (GHC.Prim.plusAddr#
                                                 Data.ByteString.singleton1
                                                 (GHC.Prim.word2Int#
                                                    (GHC.Prim.word8ToWord# x#_abo0)))
                                              GHC.ForeignPtr.FinalPtr)
                                           (GHC.Types.I# 1#))
                                        ds_abnX
                                      }
                                      }) } in
                           \ (ds3_abo2
                                :: Data.Either.Either
                                     Data.ByteString.Lazy.Internal.ByteString
                                     (f_abnr
                                        (GHC.Word.Word8,
                                         Data.ByteString.Lazy.Internal.ByteString))) ->
                             case ds3_abo2 of {
                               Data.Either.Left x_abo4 -> f2_abnS x_abo4;
                               Data.Either.Right y_abo6 -> ds2_abnT y_abo6
                             }) } in
                  let {
                    g_abo8
                      :: p_abnq
                           (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                           (f_abnr (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                         -> p_abnq
                              (Data.Either.Either
                                 Data.ByteString.Lazy.Internal.ByteString
                                 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                              (Data.Either.Either
                                 Data.ByteString.Lazy.Internal.ByteString
                                 (f_abnr
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abo8
                      = Data.Profunctor.Choice.right'
                          @p_abnq
                          $dChoice_abns
                          @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                          @(f_abnr
                              (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                          @Data.ByteString.Lazy.Internal.ByteString } in
                  \ (x_abo9
                       :: p_abnq
                            (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                            (f_abnr
                               (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))) ->
                    f1_abnu (g_abo8 x_abo9))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <Data.ByteString.Lazy.Internal.ByteString>_N
                                <Data.ByteString.Lazy.Internal.ByteString>_N
                                <GHC.Word.Word8>_N
                                <GHC.Word.Word8>_N)
                       :: Control.Lens.Type.Prism
                            Data.ByteString.Lazy.Internal.ByteString
                            Data.ByteString.Lazy.Internal.ByteString
                            (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                            (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                          ~R# Control.Lens.Cons.Cons
                                Data.ByteString.Lazy.Internal.ByteString
                                Data.ByteString.Lazy.Internal.ByteString
                                GHC.Word.Word8
                                GHC.Word.Word8))
              ((\ (@(p_abkq :: * -> * -> *))
                  (@(f_abkr :: * -> *))
                  ($dChoice_abks :: Data.Profunctor.Choice.Choice p_abkq)
                  ($dApplicative_abkt :: GHC.Base.Applicative f_abkr) ->
                  let {
                    f1_abku
                      :: p_abkq
                           (Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString
                              (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                           (Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString
                              (f_abkr
                                 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                         -> p_abkq
                              Data.ByteString.Internal.Type.ByteString
                              (f_abkr Data.ByteString.Internal.Type.ByteString)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 612 0}]
                    f1_abku
                      = Data.Profunctor.Unsafe.dimap
                          @p_abkq
                          (Data.Profunctor.Choice.$p1Choice @p_abkq $dChoice_abks)
                          @Data.ByteString.Internal.Type.ByteString
                          @(Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString
                              (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                          @(Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString
                              (f_abkr
                                 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                          @(f_abkr Data.ByteString.Internal.Type.ByteString)
                          (\ (s1_abkv :: Data.ByteString.Internal.Type.ByteString) ->
                             case s1_abkv of wild_abkw
                             { Data.ByteString.Internal.Type.BS bx_abkx bx1_abky bx2_abkz ->
                             case GHC.Classes.leInt (GHC.Types.I# bx2_abkz) (GHC.Types.I# 0#)
                             of {
                               GHC.Types.False ->
                                 Data.Either.Right
                                   @Data.ByteString.Internal.Type.ByteString
                                   @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                   (case GHC.Prim.readWord8OffAddr#
                                           @GHC.Prim.RealWorld bx_abkx 0# GHC.Prim.realWorld#
                                    of
                                    { (# ipv_abkE, ipv1_abkF #) ->
                                    case GHC.Prim.touch#
                                           @'GHC.Types.Lifted
                                           @GHC.ForeignPtr.ForeignPtrContents
                                           bx1_abky
                                           ipv_abkE
                                    of
                                    { __DEFAULT ->
                                    GHC.Word.W8# ipv1_abkF
                                    }
                                    },
                                    Data.ByteString.Internal.Type.$WBS
                                      (GHC.ForeignPtr.ForeignPtr
                                         @GHC.Word.Word8 (GHC.Prim.plusAddr# bx_abkx 1#) bx1_abky)
                                      (GHC.Types.I# (GHC.Prim.-# bx2_abkz 1#)));
                               GHC.Types.True ->
                                 Data.Either.Left
                                   @Data.ByteString.Internal.Type.ByteString
                                   @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                   wild_abkw
                             }
                             })
                          (let {
                             f2_abkJ
                               :: Data.ByteString.Internal.Type.ByteString
                                  -> f_abkr Data.ByteString.Internal.Type.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abkJ
                               = GHC.Base.pure
                                   @f_abkr
                                   $dApplicative_abkt
                                   @Data.ByteString.Internal.Type.ByteString } in
                           let {
                             ds2_abkK
                               :: f_abkr
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                  -> f_abkr Data.ByteString.Internal.Type.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 259 0}]
                             ds2_abkK
                               = GHC.Base.fmap
                                   @f_abkr
                                   (GHC.Base.$p1Applicative @f_abkr $dApplicative_abkt)
                                   @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                   @Data.ByteString.Internal.Type.ByteString
                                   (\ (p1_abkL
                                         :: (GHC.Word.Word8,
                                             Data.ByteString.Internal.Type.ByteString)) ->
                                      case p1_abkL of { (ds_abkN, y_abkO) ->
                                      case y_abkO of
                                      { Data.ByteString.Internal.Type.BS bx_abl0 bx1_abl1
                                                                         bx2_abl2 ->
                                      GHC.Magic.runRW#
                                        @GHC.Types.LiftedRep
                                        @Data.ByteString.Internal.Type.ByteString
                                        (\ (s_abkY [OS=OneShot]
                                              :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                                           let {
                                             x_abkZ :: GHC.Prim.Int#
                                             [LclId,
                                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                      Value=False, ConLike=False, WorkFree=False,
                                                      Expandable=False,
                                                      Guidance=IF_ARGS [] 1 0}]
                                             x_abkZ = GHC.Prim.+# bx2_abl2 1# } in
                                           case GHC.Prim.<# x_abkZ 0# of {
                                             __DEFAULT ->
                                               case GHC.Prim.newPinnedByteArray#
                                                      @GHC.Prim.RealWorld x_abkZ s_abkY
                                               of
                                               { (# ipv_abl7, ipv1_abl8 #) ->
                                               let {
                                                 ipv2_abl6 :: GHC.Prim.Addr#
                                                 [LclId,
                                                  Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                          Value=False, ConLike=False,
                                                          WorkFree=False, Expandable=False,
                                                          Guidance=IF_ARGS [] 1 0}]
                                                 ipv2_abl6
                                                   = GHC.Prim.mutableByteArrayContents#
                                                       @GHC.Prim.RealWorld ipv1_abl8 } in
                                               let {
                                                 ipv3_abla :: GHC.ForeignPtr.ForeignPtrContents
                                                 [LclId,
                                                  Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                          Value=True, ConLike=True, WorkFree=True,
                                                          Expandable=True,
                                                          Guidance=IF_ARGS [] 10 10}]
                                                 ipv3_abla = GHC.ForeignPtr.PlainPtr ipv1_abl8 } in
                                               case ds_abkN of { GHC.Word.W8# x1_abms ->
                                               case GHC.Prim.writeWord8OffAddr#
                                                      @GHC.Prim.RealWorld
                                                      ipv2_abl6
                                                      0#
                                                      x1_abms
                                                      ipv_abl7
                                               of s2_abmu
                                               { __DEFAULT ->
                                               case GHC.Prim.touch#
                                                      @'GHC.Types.Lifted
                                                      @GHC.ForeignPtr.ForeignPtrContents
                                                      ipv3_abla
                                                      s2_abmu
                                               of s'_abmv
                                               { __DEFAULT ->
                                               case {__ffi_static_ccall_unsafe base:memcpy :: Addr#
                                          -> Addr#
                                          -> Word64#
                                          -> State# RealWorld
                                          -> (# State# RealWorld, Addr# #)}_abmw
                                                      (GHC.Prim.plusAddr# ipv2_abl6 1#)
                                                      bx_abl0
                                                      (GHC.Prim.int64ToWord64#
                                                         (GHC.Prim.intToInt64# bx2_abl2))
                                                      s'_abmv
                                               of
                                               { (# ds4_abmy, ds5_abmz #) ->
                                               case GHC.Prim.touch#
                                                      @'GHC.Types.Lifted
                                                      @GHC.ForeignPtr.ForeignPtrContents
                                                      bx1_abl1
                                                      ds4_abmy
                                               of s'1_abmB
                                               { __DEFAULT ->
                                               case GHC.Prim.touch#
                                                      @'GHC.Types.Lifted
                                                      @GHC.ForeignPtr.ForeignPtrContents
                                                      ipv3_abla
                                                      s'1_abmB
                                               of s'2_abmC
                                               { __DEFAULT ->
                                               case GHC.Magic.lazy
                                                      @((GHC.Prim.State# GHC.Prim.RealWorld
                                                         -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                               GHC.Prim.Addr# #))
                                                        -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                              GHC.Prim.Addr# #))
                                                      (GHC.Magic.runRW#
                                                         @('GHC.Types.TupleRep
                                                             '[GHC.Types.ZeroBitRep,
                                                               'GHC.Types.AddrRep])
                                                         @(# GHC.Prim.State# GHC.Prim.RealWorld,
                                                             GHC.Prim.Addr# #))
                                                      (\ _ [Occ=Dead] -> (# s'2_abmC, ipv2_abl6 #))
                                               of
                                               { (# ipv6_abmF, ipv7_abmG #) ->
                                               Data.ByteString.Internal.Type.BS
                                                 ipv7_abmG ipv3_abla x_abkZ
                                               }
                                               }
                                               }
                                               }
                                               }
                                               }
                                               }
                                               };
                                             1# ->
                                               case GHC.ForeignPtr.mallocPlainForeignPtrBytes2
                                               of wild_00 {
                                               }
                                           })
                                      }
                                      }) } in
                           \ (ds3_abmJ
                                :: Data.Either.Either
                                     Data.ByteString.Internal.Type.ByteString
                                     (f_abkr
                                        (GHC.Word.Word8,
                                         Data.ByteString.Internal.Type.ByteString))) ->
                             case ds3_abmJ of {
                               Data.Either.Left x_abmL -> f2_abkJ x_abmL;
                               Data.Either.Right y_abmN -> ds2_abkK y_abmN
                             }) } in
                  let {
                    g_abmP
                      :: p_abkq
                           (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                           (f_abkr (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                         -> p_abkq
                              (Data.Either.Either
                                 Data.ByteString.Internal.Type.ByteString
                                 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                              (Data.Either.Either
                                 Data.ByteString.Internal.Type.ByteString
                                 (f_abkr
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abmP
                      = Data.Profunctor.Choice.right'
                          @p_abkq
                          $dChoice_abks
                          @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                          @(f_abkr
                              (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                          @Data.ByteString.Internal.Type.ByteString } in
                  \ (x_abmQ
                       :: p_abkq
                            (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                            (f_abkr
                               (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))) ->
                    f1_abku (g_abmP x_abmQ))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <Data.ByteString.Internal.Type.ByteString>_N
                                <Data.ByteString.Internal.Type.ByteString>_N
                                <GHC.Word.Word8>_N
                                <GHC.Word.Word8>_N)
                       :: Control.Lens.Type.Prism
                            Data.ByteString.Internal.Type.ByteString
                            Data.ByteString.Internal.Type.ByteString
                            (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                            (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                          ~R# Control.Lens.Cons.Cons
                                Data.ByteString.Internal.Type.ByteString
                                Data.ByteString.Internal.Type.ByteString
                                GHC.Word.Word8
                                GHC.Word.Word8))
              ((\ (@(p_abmX :: * -> * -> *))
                  (@(f_abmY :: * -> *))
                  ($dChoice_abmZ :: Data.Profunctor.Choice.Choice p_abmX)
                  ($dApplicative_abn0 :: GHC.Base.Applicative f_abmY) ->
                  let {
                    f1_abn1
                      :: p_abmX
                           (Data.Either.Either Data.ByteString.Internal.Type.ByteString ())
                           (Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString (f_abmY ()))
                         -> p_abmX
                              Data.ByteString.Internal.Type.ByteString
                              (f_abmY Data.ByteString.Internal.Type.ByteString)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 350 0}]
                    f1_abn1
                      = Data.Profunctor.Unsafe.dimap
                          @p_abmX
                          (Data.Profunctor.Choice.$p1Choice @p_abmX $dChoice_abmZ)
                          @Data.ByteString.Internal.Type.ByteString
                          @(Data.Either.Either Data.ByteString.Internal.Type.ByteString ())
                          @(Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString (f_abmY ()))
                          @(f_abmY Data.ByteString.Internal.Type.ByteString)
                          (\ (s_abn2 :: Data.ByteString.Internal.Type.ByteString) ->
                             case s_abn2 of wild_abn3
                             { Data.ByteString.Internal.Type.BS bx_abn4 bx1_abn5 bx2_abn6 ->
                             case GHC.Classes.leInt (GHC.Types.I# bx2_abn6) (GHC.Types.I# 0#)
                             of {
                               GHC.Types.False ->
                                 Data.Either.Left
                                   @Data.ByteString.Internal.Type.ByteString @() wild_abn3;
                               GHC.Types.True ->
                                 Data.Either.Right
                                   @Data.ByteString.Internal.Type.ByteString @() GHC.Tuple.Prim.()
                             }
                             })
                          (let {
                             f2_abna
                               :: Data.ByteString.Internal.Type.ByteString
                                  -> f_abmY Data.ByteString.Internal.Type.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abna
                               = GHC.Base.pure
                                   @f_abmY
                                   $dApplicative_abn0
                                   @Data.ByteString.Internal.Type.ByteString } in
                           let {
                             ds2_abnb
                               :: f_abmY () -> f_abmY Data.ByteString.Internal.Type.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 70 0}]
                             ds2_abnb
                               = GHC.Base.fmap
                                   @f_abmY
                                   (GHC.Base.$p1Applicative @f_abmY $dApplicative_abn0)
                                   @()
                                   @Data.ByteString.Internal.Type.ByteString
                                   (\ (ds3_abnc :: ()) ->
                                      case ds3_abnc of { () ->
                                      Data.ByteString.Internal.Type.empty
                                      }) } in
                           \ (ds3_abne
                                :: Data.Either.Either
                                     Data.ByteString.Internal.Type.ByteString (f_abmY ())) ->
                             case ds3_abne of {
                               Data.Either.Left x_abng -> f2_abna x_abng;
                               Data.Either.Right y_abni -> ds2_abnb y_abni
                             }) } in
                  let {
                    g_abnk
                      :: p_abmX () (f_abmY ())
                         -> p_abmX
                              (Data.Either.Either Data.ByteString.Internal.Type.ByteString ())
                              (Data.Either.Either
                                 Data.ByteString.Internal.Type.ByteString (f_abmY ()))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abnk
                      = Data.Profunctor.Choice.right'
                          @p_abmX
                          $dChoice_abmZ
                          @()
                          @(f_abmY ())
                          @Data.ByteString.Internal.Type.ByteString } in
                  \ (x_abnl :: p_abmX () (f_abmY ())) -> f1_abn1 (g_abnk x_abnl))
               `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                <Data.ByteString.Internal.Type.ByteString>_N)
                       :: Control.Lens.Type.Prism'
                            Data.ByteString.Internal.Type.ByteString ()
                          ~R# Control.Lens.Empty.AsEmpty
                                Data.ByteString.Internal.Type.ByteString))
              (Data.Functor.Contravariant.$fContravariantConst
                 @Data.ByteString.Internal.Type.ByteString)
              (Data.Functor.Const.$fFunctorConst
                 @Data.ByteString.Internal.Type.ByteString)
    Cont:   ApplyToVal nodup hole Control.Lens.Getter.Getting
                                    Data.ByteString.Internal.Type.ByteString
                                    Data.ByteString.Lazy.Internal.ByteString
                                    Data.ByteString.Internal.Type.ByteString
              ((\ (ds_abeK [Occ=Once1] :: a_abeH) -> ds_abeK)
               `cast` (<a_abeH>_R
                       %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                          <*>_N <a_abeH>_R <a_abeH>_P)
                       :: (a_abeH -> a_abeH)
                          ~R# (a_abeH -> Data.Functor.Const.Const a_abeH a_abeH)))
            ApplyToVal nodup hole Data.ByteString.Lazy.Internal.ByteString
                                  -> Data.Functor.Const.Const
                                       Data.ByteString.Internal.Type.ByteString
                                       Data.ByteString.Lazy.Internal.ByteString
              (Control.Lens.Getter.view
                 @Data.ByteString.Internal.Type.ByteString
                 @((->) Data.ByteString.Internal.Type.ByteString)
                 @Data.ByteString.Lazy.Internal.ByteString
                 (Control.Monad.Reader.Class.$fMonadReaderrFUN
                    @Data.ByteString.Internal.Type.ByteString)
                 (Control.Lens.Cons.Extras.recons
                    @Data.ByteString.Internal.Type.ByteString
                    @GHC.Word.Word8
                    @Data.ByteString.Lazy.Internal.ByteString
                    Control.Lens.Cons.$fConsByteStringByteStringWord8Word80
                    Control.Lens.Cons.$fConsByteStringByteStringWord8Word8
                    Control.Lens.Empty.$fAsEmptyByteString
                    @(Data.Functor.Const.Const
                        Data.ByteString.Lazy.Internal.ByteString)
                    (Data.Functor.Contravariant.$fContravariantConst
                       @Data.ByteString.Lazy.Internal.ByteString)
                    (Data.Functor.Const.$fFunctorConst
                       @Data.ByteString.Lazy.Internal.ByteString))
                 s_a8Pz)
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N
                        <Data.ByteString.Internal.Type.ByteString>_R
                        <Data.ByteString.Lazy.Internal.ByteString>_P
                    :: Data.Functor.Const.Const
                         Data.ByteString.Internal.Type.ByteString
                         Data.ByteString.Lazy.Internal.ByteString
                       ~R# Data.ByteString.Internal.Type.ByteString)
            Stop[RuleArgCtxt] Data.ByteString.Internal.Type.ByteString
Rule fired
    Rule: Class op fmap
    Module: (BUILTIN)
    Before: GHC.Base.fmap
              TyArg Data.Functor.Const.Const
                      Data.ByteString.Internal.Type.ByteString
              ValArg Data.Functor.Const.$fFunctorConst
                       @Data.ByteString.Internal.Type.ByteString
    After:  (Data.Functor.Const.$fFunctorConst2
               @Data.ByteString.Internal.Type.ByteString)
            `cast` (forall (a :: <*>_N) (b :: <*>_N).
                    <a -> b>_R
                    %<'GHC.Types.Many>_N ->_R <Data.Functor.Const.Const
                                                 Data.ByteString.Internal.Type.ByteString a>_R
                    %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                  <*>_N
                                                  <Data.ByteString.Internal.Type.ByteString>_R
                                                  <a>_P
                                              ; Sym (Data.Functor.Const.N:Const[0]
                                                         <*>_N
                                                         <Data.ByteString.Internal.Type.ByteString>_R
                                                         <b>_P)
                    :: (forall {a} {b}.
                        (a -> b)
                        -> Data.Functor.Const.Const
                             Data.ByteString.Internal.Type.ByteString a
                        -> Data.Functor.Const.Const
                             Data.ByteString.Internal.Type.ByteString a)
                       ~R# (forall {a} {b}.
                            (a -> b)
                            -> Data.Functor.Const.Const
                                 Data.ByteString.Internal.Type.ByteString a
                            -> Data.Functor.Const.Const
                                 Data.ByteString.Internal.Type.ByteString b))
    Cont:   ApplyToTy Data.ByteString.Internal.Type.ByteString
            ApplyToTy Data.ByteString.Lazy.Internal.ByteString
            ApplyToVal nodup hole (Data.ByteString.Internal.Type.ByteString
                                   -> Data.ByteString.Lazy.Internal.ByteString)
                                  -> Data.Functor.Const.Const
                                       Data.ByteString.Internal.Type.ByteString
                                       Data.ByteString.Internal.Type.ByteString
                                  -> Data.Functor.Const.Const
                                       Data.ByteString.Internal.Type.ByteString
                                       Data.ByteString.Lazy.Internal.ByteString
              Data.ByteString.Lazy.Internal.fromStrict
            ApplyToVal nodup hole Data.Functor.Const.Const
                                    Data.ByteString.Internal.Type.ByteString
                                    Data.ByteString.Internal.Type.ByteString
                                  -> Data.Functor.Const.Const
                                       Data.ByteString.Internal.Type.ByteString
                                       Data.ByteString.Lazy.Internal.ByteString
              (bc_aboH (ab_aboF x_aboI))
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N
                        <Data.ByteString.Internal.Type.ByteString>_R
                        <Data.ByteString.Lazy.Internal.ByteString>_P
                    :: Data.Functor.Const.Const
                         Data.ByteString.Internal.Type.ByteString
                         Data.ByteString.Lazy.Internal.ByteString
                       ~R# Data.ByteString.Internal.Type.ByteString)
            Stop[RuleArgCtxt] Data.ByteString.Internal.Type.ByteString
Rule fired
    Rule: Class op reader
    Module: (BUILTIN)
    Before: Control.Monad.Reader.Class.reader
              TyArg Data.ByteString.Internal.Type.ByteString
              TyArg (->) Data.ByteString.Internal.Type.ByteString
              ValArg Control.Monad.Reader.Class.$fMonadReaderrFUN
                       @Data.ByteString.Internal.Type.ByteString
    After:  \ (@a_abeP) ->
              GHC.Base.id @(Data.ByteString.Internal.Type.ByteString -> a_abeP)
    Cont:   ApplyToTy Data.ByteString.Lazy.Internal.ByteString
            ApplyToVal nodup hole (Data.ByteString.Internal.Type.ByteString
                                   -> Data.ByteString.Lazy.Internal.ByteString)
                                  -> Data.ByteString.Internal.Type.ByteString
                                  -> Data.ByteString.Lazy.Internal.ByteString
              ((l_abeJ
                  ((\ (ds_abeK [Occ=Once1] :: a_abeH) -> ds_abeK)
                   `cast` (<a_abeH>_R
                           %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                              <*>_N <a_abeH>_R <a_abeH>_P)
                           :: (a_abeH -> a_abeH)
                              ~R# (a_abeH -> Data.Functor.Const.Const a_abeH a_abeH))))
               `cast` (<s_abeF>_R
                       %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                     <*>_N <a_abeH>_R <s_abeF>_P
                       :: (s_abeF -> Data.Functor.Const.Const a_abeH s_abeF)
                          ~R# (s_abeF -> a_abeH)))
            ApplyToVal nodup hole Data.ByteString.Internal.Type.ByteString
                                  -> Data.ByteString.Lazy.Internal.ByteString
              s_a8Pz
            Stop[RuleArgCtxt] Data.ByteString.Lazy.Internal.ByteString
Rule fired
    Rule: recons/bs-lazy
    Module: (Control.Lens.Cons.Extras)
    Before: Control.Lens.Cons.Extras.recons
              TyArg Data.ByteString.Internal.Type.ByteString
              TyArg GHC.Word.Word8
              TyArg Data.ByteString.Lazy.Internal.ByteString
              ValArg (\ (@(p_abkq :: * -> * -> *))
                        (@(f_abkr :: * -> *))
                        ($dChoice_abks :: Data.Profunctor.Choice.Choice p_abkq)
                        ($dApplicative_abkt :: GHC.Base.Applicative f_abkr) ->
                        let {
                          f1_abku
                            :: p_abkq
                                 (Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                                 (Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString
                                    (f_abkr
                                       (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                               -> p_abkq
                                    Data.ByteString.Internal.Type.ByteString
                                    (f_abkr Data.ByteString.Internal.Type.ByteString)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 612 0}]
                          f1_abku
                            = Data.Profunctor.Unsafe.dimap
                                @p_abkq
                                (Data.Profunctor.Choice.$p1Choice @p_abkq $dChoice_abks)
                                @Data.ByteString.Internal.Type.ByteString
                                @(Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                                @(Data.Either.Either
                                    Data.ByteString.Internal.Type.ByteString
                                    (f_abkr
                                       (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                                @(f_abkr Data.ByteString.Internal.Type.ByteString)
                                (\ (s1_abkv :: Data.ByteString.Internal.Type.ByteString) ->
                                   case s1_abkv of wild_abkw
                                   { Data.ByteString.Internal.Type.BS bx_abkx bx1_abky bx2_abkz ->
                                   case GHC.Classes.leInt (GHC.Types.I# bx2_abkz) (GHC.Types.I# 0#)
                                   of {
                                     GHC.Types.False ->
                                       Data.Either.Right
                                         @Data.ByteString.Internal.Type.ByteString
                                         @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                         (case GHC.Prim.readWord8OffAddr#
                                                 @GHC.Prim.RealWorld bx_abkx 0# GHC.Prim.realWorld#
                                          of
                                          { (# ipv_abkE, ipv1_abkF #) ->
                                          case GHC.Prim.touch#
                                                 @'GHC.Types.Lifted
                                                 @GHC.ForeignPtr.ForeignPtrContents
                                                 bx1_abky
                                                 ipv_abkE
                                          of
                                          { __DEFAULT ->
                                          GHC.Word.W8# ipv1_abkF
                                          }
                                          },
                                          Data.ByteString.Internal.Type.$WBS
                                            (GHC.ForeignPtr.ForeignPtr
                                               @GHC.Word.Word8
                                               (GHC.Prim.plusAddr# bx_abkx 1#)
                                               bx1_abky)
                                            (GHC.Types.I# (GHC.Prim.-# bx2_abkz 1#)));
                                     GHC.Types.True ->
                                       Data.Either.Left
                                         @Data.ByteString.Internal.Type.ByteString
                                         @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                         wild_abkw
                                   }
                                   })
                                (let {
                                   f2_abkJ
                                     :: Data.ByteString.Internal.Type.ByteString
                                        -> f_abkr Data.ByteString.Internal.Type.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abkJ
                                     = GHC.Base.pure
                                         @f_abkr
                                         $dApplicative_abkt
                                         @Data.ByteString.Internal.Type.ByteString } in
                                 let {
                                   ds2_abkK
                                     :: f_abkr
                                          (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                        -> f_abkr Data.ByteString.Internal.Type.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 259 0}]
                                   ds2_abkK
                                     = GHC.Base.fmap
                                         @f_abkr
                                         (GHC.Base.$p1Applicative @f_abkr $dApplicative_abkt)
                                         @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                         @Data.ByteString.Internal.Type.ByteString
                                         (\ (p1_abkL
                                               :: (GHC.Word.Word8,
                                                   Data.ByteString.Internal.Type.ByteString)) ->
                                            case p1_abkL of { (ds_abkN, y_abkO) ->
                                            case y_abkO of
                                            { Data.ByteString.Internal.Type.BS bx_abl0 bx1_abl1
                                                                               bx2_abl2 ->
                                            GHC.Magic.runRW#
                                              @GHC.Types.LiftedRep
                                              @Data.ByteString.Internal.Type.ByteString
                                              (\ (s_abkY [OS=OneShot]
                                                    :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                                                 let {
                                                   x_abkZ :: GHC.Prim.Int#
                                                   [LclId,
                                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                            Value=False, ConLike=False,
                                                            WorkFree=False, Expandable=False,
                                                            Guidance=IF_ARGS [] 1 0}]
                                                   x_abkZ = GHC.Prim.+# bx2_abl2 1# } in
                                                 case GHC.Prim.<# x_abkZ 0# of {
                                                   __DEFAULT ->
                                                     case GHC.Prim.newPinnedByteArray#
                                                            @GHC.Prim.RealWorld x_abkZ s_abkY
                                                     of
                                                     { (# ipv_abl7, ipv1_abl8 #) ->
                                                     let {
                                                       ipv2_abl6 :: GHC.Prim.Addr#
                                                       [LclId,
                                                        Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                                Value=False, ConLike=False,
                                                                WorkFree=False, Expandable=False,
                                                                Guidance=IF_ARGS [] 1 0}]
                                                       ipv2_abl6
                                                         = GHC.Prim.mutableByteArrayContents#
                                                             @GHC.Prim.RealWorld ipv1_abl8 } in
                                                     let {
                                                       ipv3_abla
                                                         :: GHC.ForeignPtr.ForeignPtrContents
                                                       [LclId,
                                                        Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                                Value=True, ConLike=True,
                                                                WorkFree=True, Expandable=True,
                                                                Guidance=IF_ARGS [] 10 10}]
                                                       ipv3_abla
                                                         = GHC.ForeignPtr.PlainPtr ipv1_abl8 } in
                                                     case ds_abkN of { GHC.Word.W8# x1_abms ->
                                                     case GHC.Prim.writeWord8OffAddr#
                                                            @GHC.Prim.RealWorld
                                                            ipv2_abl6
                                                            0#
                                                            x1_abms
                                                            ipv_abl7
                                                     of s2_abmu
                                                     { __DEFAULT ->
                                                     case GHC.Prim.touch#
                                                            @'GHC.Types.Lifted
                                                            @GHC.ForeignPtr.ForeignPtrContents
                                                            ipv3_abla
                                                            s2_abmu
                                                     of s'_abmv
                                                     { __DEFAULT ->
                                                     case {__ffi_static_ccall_unsafe base:memcpy :: Addr#
                                          -> Addr#
                                          -> Word64#
                                          -> State# RealWorld
                                          -> (# State# RealWorld, Addr# #)}_abmw
                                                            (GHC.Prim.plusAddr# ipv2_abl6 1#)
                                                            bx_abl0
                                                            (GHC.Prim.int64ToWord64#
                                                               (GHC.Prim.intToInt64# bx2_abl2))
                                                            s'_abmv
                                                     of
                                                     { (# ds4_abmy, ds5_abmz #) ->
                                                     case GHC.Prim.touch#
                                                            @'GHC.Types.Lifted
                                                            @GHC.ForeignPtr.ForeignPtrContents
                                                            bx1_abl1
                                                            ds4_abmy
                                                     of s'1_abmB
                                                     { __DEFAULT ->
                                                     case GHC.Prim.touch#
                                                            @'GHC.Types.Lifted
                                                            @GHC.ForeignPtr.ForeignPtrContents
                                                            ipv3_abla
                                                            s'1_abmB
                                                     of s'2_abmC
                                                     { __DEFAULT ->
                                                     case GHC.Magic.lazy
                                                            @((GHC.Prim.State# GHC.Prim.RealWorld
                                                               -> (# GHC.Prim.State#
                                                                       GHC.Prim.RealWorld,
                                                                     GHC.Prim.Addr# #))
                                                              -> (# GHC.Prim.State#
                                                                      GHC.Prim.RealWorld,
                                                                    GHC.Prim.Addr# #))
                                                            (GHC.Magic.runRW#
                                                               @('GHC.Types.TupleRep
                                                                   '[GHC.Types.ZeroBitRep,
                                                                     'GHC.Types.AddrRep])
                                                               @(# GHC.Prim.State#
                                                                     GHC.Prim.RealWorld,
                                                                   GHC.Prim.Addr# #))
                                                            (\ _ [Occ=Dead] ->
                                                               (# s'2_abmC, ipv2_abl6 #))
                                                     of
                                                     { (# ipv6_abmF, ipv7_abmG #) ->
                                                     Data.ByteString.Internal.Type.BS
                                                       ipv7_abmG ipv3_abla x_abkZ
                                                     }
                                                     }
                                                     }
                                                     }
                                                     }
                                                     }
                                                     }
                                                     };
                                                   1# ->
                                                     case GHC.ForeignPtr.mallocPlainForeignPtrBytes2
                                                     of wild_00 {
                                                     }
                                                 })
                                            }
                                            }) } in
                                 \ (ds3_abmJ
                                      :: Data.Either.Either
                                           Data.ByteString.Internal.Type.ByteString
                                           (f_abkr
                                              (GHC.Word.Word8,
                                               Data.ByteString.Internal.Type.ByteString))) ->
                                   case ds3_abmJ of {
                                     Data.Either.Left x_abmL -> f2_abkJ x_abmL;
                                     Data.Either.Right y_abmN -> ds2_abkK y_abmN
                                   }) } in
                        let {
                          g_abmP
                            :: p_abkq
                                 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                 (f_abkr (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                               -> p_abkq
                                    (Data.Either.Either
                                       Data.ByteString.Internal.Type.ByteString
                                       (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                                    (Data.Either.Either
                                       Data.ByteString.Internal.Type.ByteString
                                       (f_abkr
                                          (GHC.Word.Word8,
                                           Data.ByteString.Internal.Type.ByteString)))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abmP
                            = Data.Profunctor.Choice.right'
                                @p_abkq
                                $dChoice_abks
                                @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                @(f_abkr
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                                @Data.ByteString.Internal.Type.ByteString } in
                        \ (x_abmQ
                             :: p_abkq
                                  (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                  (f_abkr
                                     (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))) ->
                          f1_abku (g_abmP x_abmQ))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <Data.ByteString.Internal.Type.ByteString>_N
                                      <Data.ByteString.Internal.Type.ByteString>_N
                                      <GHC.Word.Word8>_N
                                      <GHC.Word.Word8>_N)
                             :: Control.Lens.Type.Prism
                                  Data.ByteString.Internal.Type.ByteString
                                  Data.ByteString.Internal.Type.ByteString
                                  (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                  (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                ~R# Control.Lens.Cons.Cons
                                      Data.ByteString.Internal.Type.ByteString
                                      Data.ByteString.Internal.Type.ByteString
                                      GHC.Word.Word8
                                      GHC.Word.Word8)
              ValArg (\ (@(p_abnq :: * -> * -> *))
                        (@(f_abnr :: * -> *))
                        ($dChoice_abns :: Data.Profunctor.Choice.Choice p_abnq)
                        ($dApplicative_abnt :: GHC.Base.Applicative f_abnr) ->
                        let {
                          f1_abnu
                            :: p_abnq
                                 (Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                                 (Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (f_abnr
                                       (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                               -> p_abnq
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (f_abnr Data.ByteString.Lazy.Internal.ByteString)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 536 0}]
                          f1_abnu
                            = Data.Profunctor.Unsafe.dimap
                                @p_abnq
                                (Data.Profunctor.Choice.$p1Choice @p_abnq $dChoice_abns)
                                @Data.ByteString.Lazy.Internal.ByteString
                                @(Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                                @(Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (f_abnr
                                       (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                                @(f_abnr Data.ByteString.Lazy.Internal.ByteString)
                                (\ (s1_abnv :: Data.ByteString.Lazy.Internal.ByteString) ->
                                   case s1_abnv of {
                                     Data.ByteString.Lazy.Internal.Empty ->
                                       Data.Either.Left
                                         @Data.ByteString.Lazy.Internal.ByteString
                                         @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                         Data.ByteString.Lazy.Internal.Empty;
                                     Data.ByteString.Lazy.Internal.Chunk bx_abnC bx1_abnD bx2_abnE
                                                                         cs_abnF ->
                                       case bx2_abnE of ds1_abnH {
                                         __DEFAULT ->
                                           Data.Either.Right
                                             @Data.ByteString.Lazy.Internal.ByteString
                                             @(GHC.Word.Word8,
                                               Data.ByteString.Lazy.Internal.ByteString)
                                             (case GHC.Prim.readWord8OffAddr#
                                                     @GHC.Prim.RealWorld
                                                     bx_abnC
                                                     0#
                                                     GHC.Prim.realWorld#
                                              of
                                              { (# ipv_abnJ, ipv1_abnK #) ->
                                              case GHC.Prim.touch#
                                                     @'GHC.Types.Lifted
                                                     @GHC.ForeignPtr.ForeignPtrContents
                                                     bx1_abnD
                                                     ipv_abnJ
                                              of
                                              { __DEFAULT ->
                                              GHC.Word.W8# ipv1_abnK
                                              }
                                              },
                                              Data.ByteString.Lazy.Internal.$WChunk
                                                (Data.ByteString.Internal.Type.$WBS
                                                   (GHC.ForeignPtr.ForeignPtr
                                                      @GHC.Word.Word8
                                                      (GHC.Prim.plusAddr# bx_abnC 1#)
                                                      bx1_abnD)
                                                   (GHC.Types.I# (GHC.Prim.-# ds1_abnH 1#)))
                                                cs_abnF);
                                         1# ->
                                           Data.Either.Right
                                             @Data.ByteString.Lazy.Internal.ByteString
                                             @(GHC.Word.Word8,
                                               Data.ByteString.Lazy.Internal.ByteString)
                                             (case GHC.Prim.readWord8OffAddr#
                                                     @GHC.Prim.RealWorld
                                                     bx_abnC
                                                     0#
                                                     GHC.Prim.realWorld#
                                              of
                                              { (# ipv_abnO, ipv1_abnP #) ->
                                              case GHC.Prim.touch#
                                                     @'GHC.Types.Lifted
                                                     @GHC.ForeignPtr.ForeignPtrContents
                                                     bx1_abnD
                                                     ipv_abnO
                                              of
                                              { __DEFAULT ->
                                              GHC.Word.W8# ipv1_abnP
                                              }
                                              },
                                              cs_abnF)
                                       }
                                   })
                                (let {
                                   f2_abnS
                                     :: Data.ByteString.Lazy.Internal.ByteString
                                        -> f_abnr Data.ByteString.Lazy.Internal.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abnS
                                     = GHC.Base.pure
                                         @f_abnr
                                         $dApplicative_abnt
                                         @Data.ByteString.Lazy.Internal.ByteString } in
                                 let {
                                   ds2_abnT
                                     :: f_abnr
                                          (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                        -> f_abnr Data.ByteString.Lazy.Internal.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 162 0}]
                                   ds2_abnT
                                     = GHC.Base.fmap
                                         @f_abnr
                                         (GHC.Base.$p1Applicative @f_abnr $dApplicative_abnt)
                                         @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                         @Data.ByteString.Lazy.Internal.ByteString
                                         (\ (p1_abnU
                                               :: (GHC.Word.Word8,
                                                   Data.ByteString.Lazy.Internal.ByteString)) ->
                                            case p1_abnU of { (x_abnW, ds_abnX) ->
                                            case x_abnW of { GHC.Word.W8# x#_abo0 ->
                                            Data.ByteString.Lazy.Internal.$WChunk
                                              (Data.ByteString.Internal.Type.$WBS
                                                 (GHC.ForeignPtr.ForeignPtr
                                                    @GHC.Word.Word8
                                                    (GHC.Prim.plusAddr#
                                                       Data.ByteString.singleton1
                                                       (GHC.Prim.word2Int#
                                                          (GHC.Prim.word8ToWord# x#_abo0)))
                                                    GHC.ForeignPtr.FinalPtr)
                                                 (GHC.Types.I# 1#))
                                              ds_abnX
                                            }
                                            }) } in
                                 \ (ds3_abo2
                                      :: Data.Either.Either
                                           Data.ByteString.Lazy.Internal.ByteString
                                           (f_abnr
                                              (GHC.Word.Word8,
                                               Data.ByteString.Lazy.Internal.ByteString))) ->
                                   case ds3_abo2 of {
                                     Data.Either.Left x_abo4 -> f2_abnS x_abo4;
                                     Data.Either.Right y_abo6 -> ds2_abnT y_abo6
                                   }) } in
                        let {
                          g_abo8
                            :: p_abnq
                                 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                 (f_abnr (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                               -> p_abnq
                                    (Data.Either.Either
                                       Data.ByteString.Lazy.Internal.ByteString
                                       (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                                    (Data.Either.Either
                                       Data.ByteString.Lazy.Internal.ByteString
                                       (f_abnr
                                          (GHC.Word.Word8,
                                           Data.ByteString.Lazy.Internal.ByteString)))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abo8
                            = Data.Profunctor.Choice.right'
                                @p_abnq
                                $dChoice_abns
                                @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                @(f_abnr
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                                @Data.ByteString.Lazy.Internal.ByteString } in
                        \ (x_abo9
                             :: p_abnq
                                  (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                  (f_abnr
                                     (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))) ->
                          f1_abnu (g_abo8 x_abo9))
                     `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                      <Data.ByteString.Lazy.Internal.ByteString>_N
                                      <Data.ByteString.Lazy.Internal.ByteString>_N
                                      <GHC.Word.Word8>_N
                                      <GHC.Word.Word8>_N)
                             :: Control.Lens.Type.Prism
                                  Data.ByteString.Lazy.Internal.ByteString
                                  Data.ByteString.Lazy.Internal.ByteString
                                  (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                  (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                ~R# Control.Lens.Cons.Cons
                                      Data.ByteString.Lazy.Internal.ByteString
                                      Data.ByteString.Lazy.Internal.ByteString
                                      GHC.Word.Word8
                                      GHC.Word.Word8)
              ValArg (\ (@(p_abob :: * -> * -> *))
                        (@(f_aboc :: * -> *))
                        ($dChoice_abod :: Data.Profunctor.Choice.Choice p_abob)
                        ($dApplicative_aboe :: GHC.Base.Applicative f_aboc) ->
                        let {
                          f1_abof
                            :: p_abob
                                 (Data.Either.Either Data.ByteString.Lazy.Internal.ByteString ())
                                 (Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString (f_aboc ()))
                               -> p_abob
                                    Data.ByteString.Lazy.Internal.ByteString
                                    (f_aboc Data.ByteString.Lazy.Internal.ByteString)
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 290 0}]
                          f1_abof
                            = Data.Profunctor.Unsafe.dimap
                                @p_abob
                                (Data.Profunctor.Choice.$p1Choice @p_abob $dChoice_abod)
                                @Data.ByteString.Lazy.Internal.ByteString
                                @(Data.Either.Either Data.ByteString.Lazy.Internal.ByteString ())
                                @(Data.Either.Either
                                    Data.ByteString.Lazy.Internal.ByteString (f_aboc ()))
                                @(f_aboc Data.ByteString.Lazy.Internal.ByteString)
                                (\ (s_abog :: Data.ByteString.Lazy.Internal.ByteString) ->
                                   case s_abog of wild_aboh {
                                     Data.ByteString.Lazy.Internal.Empty ->
                                       Data.Either.Right
                                         @Data.ByteString.Lazy.Internal.ByteString
                                         @()
                                         GHC.Tuple.Prim.();
                                     Data.ByteString.Lazy.Internal.Chunk ipv_aboi ipv1_aboj
                                                                         ipv2_abok ipv3_abol ->
                                       Data.Either.Left
                                         @Data.ByteString.Lazy.Internal.ByteString @() wild_aboh
                                   })
                                (let {
                                   f2_abon
                                     :: Data.ByteString.Lazy.Internal.ByteString
                                        -> f_aboc Data.ByteString.Lazy.Internal.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=True,
                                            Guidance=IF_ARGS [] 20 0}]
                                   f2_abon
                                     = GHC.Base.pure
                                         @f_aboc
                                         $dApplicative_aboe
                                         @Data.ByteString.Lazy.Internal.ByteString } in
                                 let {
                                   ds2_aboo
                                     :: f_aboc () -> f_aboc Data.ByteString.Lazy.Internal.ByteString
                                   [LclId,
                                    Unf=Unf{Src=<vanilla>, TopLvl=False,
                                            Value=False, ConLike=False, WorkFree=False,
                                            Expandable=False,
                                            Guidance=IF_ARGS [] 70 0}]
                                   ds2_aboo
                                     = GHC.Base.fmap
                                         @f_aboc
                                         (GHC.Base.$p1Applicative @f_aboc $dApplicative_aboe)
                                         @()
                                         @Data.ByteString.Lazy.Internal.ByteString
                                         (\ (ds3_abop :: ()) ->
                                            case ds3_abop of { () ->
                                            Data.ByteString.Lazy.Internal.Empty
                                            }) } in
                                 \ (ds3_abor
                                      :: Data.Either.Either
                                           Data.ByteString.Lazy.Internal.ByteString (f_aboc ())) ->
                                   case ds3_abor of {
                                     Data.Either.Left x_abot -> f2_abon x_abot;
                                     Data.Either.Right y_abov -> ds2_aboo y_abov
                                   }) } in
                        let {
                          g_abox
                            :: p_abob () (f_aboc ())
                               -> p_abob
                                    (Data.Either.Either Data.ByteString.Lazy.Internal.ByteString ())
                                    (Data.Either.Either
                                       Data.ByteString.Lazy.Internal.ByteString (f_aboc ()))
                          [LclId,
                           Unf=Unf{Src=<vanilla>, TopLvl=False,
                                   Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                   Guidance=IF_ARGS [] 20 0}]
                          g_abox
                            = Data.Profunctor.Choice.right'
                                @p_abob
                                $dChoice_abod
                                @()
                                @(f_aboc ())
                                @Data.ByteString.Lazy.Internal.ByteString } in
                        \ (x_aboy :: p_abob () (f_aboc ())) -> f1_abof (g_abox x_aboy))
                     `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                      <Data.ByteString.Lazy.Internal.ByteString>_N)
                             :: Control.Lens.Type.Prism'
                                  Data.ByteString.Lazy.Internal.ByteString ()
                                ~R# Control.Lens.Empty.AsEmpty
                                      Data.ByteString.Lazy.Internal.ByteString)
              TyArg Data.Functor.Const.Const
                      Data.ByteString.Lazy.Internal.ByteString
              ValArg Data.Functor.Contravariant.$fContravariantConst
                       @Data.ByteString.Lazy.Internal.ByteString
              ValArg Data.Functor.Const.$fFunctorConst
                       @Data.ByteString.Lazy.Internal.ByteString
    After:  (\ (@(f_abg8 :: * -> *))
               ($dCons_abg9
                  :: Control.Lens.Cons.Cons
                       Data.ByteString.Internal.Type.ByteString
                       Data.ByteString.Internal.Type.ByteString
                       GHC.Word.Word8
                       GHC.Word.Word8)
               ($dCons1_abga
                  :: Control.Lens.Cons.Cons
                       Data.ByteString.Lazy.Internal.ByteString
                       Data.ByteString.Lazy.Internal.ByteString
                       GHC.Word.Word8
                       GHC.Word.Word8)
               ($dAsEmpty_abgb
                  :: Control.Lens.Empty.AsEmpty
                       Data.ByteString.Lazy.Internal.ByteString)
               ($dContravariant_abgc
                  :: Data.Functor.Contravariant.Contravariant f_abg8)
               ($dFunctor_abgd :: GHC.Base.Functor f_abg8) ->
               Data.Profunctor.Unsafe.$fProfunctorFUN_$cdimap
                 @Data.ByteString.Internal.Type.ByteString
                 @Data.ByteString.Lazy.Internal.ByteString
                 @(f_abg8 Data.ByteString.Lazy.Internal.ByteString)
                 @(f_abg8 Data.ByteString.Internal.Type.ByteString)
                 Data.ByteString.Lazy.Internal.fromStrict
                 (GHC.Base.fmap
                    @f_abg8
                    $dFunctor_abgd
                    @Data.ByteString.Lazy.Internal.ByteString
                    @Data.ByteString.Internal.Type.ByteString
                    Data.ByteString.Lazy.Internal.toStrict))
              @(Data.Functor.Const.Const
                  Data.ByteString.Lazy.Internal.ByteString)
              ((\ (@(p_abkq :: * -> * -> *))
                  (@(f_abkr :: * -> *))
                  ($dChoice_abks :: Data.Profunctor.Choice.Choice p_abkq)
                  ($dApplicative_abkt :: GHC.Base.Applicative f_abkr) ->
                  let {
                    f1_abku
                      :: p_abkq
                           (Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString
                              (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                           (Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString
                              (f_abkr
                                 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                         -> p_abkq
                              Data.ByteString.Internal.Type.ByteString
                              (f_abkr Data.ByteString.Internal.Type.ByteString)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 612 0}]
                    f1_abku
                      = Data.Profunctor.Unsafe.dimap
                          @p_abkq
                          (Data.Profunctor.Choice.$p1Choice @p_abkq $dChoice_abks)
                          @Data.ByteString.Internal.Type.ByteString
                          @(Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString
                              (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                          @(Data.Either.Either
                              Data.ByteString.Internal.Type.ByteString
                              (f_abkr
                                 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                          @(f_abkr Data.ByteString.Internal.Type.ByteString)
                          (\ (s1_abkv :: Data.ByteString.Internal.Type.ByteString) ->
                             case s1_abkv of wild_abkw
                             { Data.ByteString.Internal.Type.BS bx_abkx bx1_abky bx2_abkz ->
                             case GHC.Classes.leInt (GHC.Types.I# bx2_abkz) (GHC.Types.I# 0#)
                             of {
                               GHC.Types.False ->
                                 Data.Either.Right
                                   @Data.ByteString.Internal.Type.ByteString
                                   @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                   (case GHC.Prim.readWord8OffAddr#
                                           @GHC.Prim.RealWorld bx_abkx 0# GHC.Prim.realWorld#
                                    of
                                    { (# ipv_abkE, ipv1_abkF #) ->
                                    case GHC.Prim.touch#
                                           @'GHC.Types.Lifted
                                           @GHC.ForeignPtr.ForeignPtrContents
                                           bx1_abky
                                           ipv_abkE
                                    of
                                    { __DEFAULT ->
                                    GHC.Word.W8# ipv1_abkF
                                    }
                                    },
                                    Data.ByteString.Internal.Type.$WBS
                                      (GHC.ForeignPtr.ForeignPtr
                                         @GHC.Word.Word8 (GHC.Prim.plusAddr# bx_abkx 1#) bx1_abky)
                                      (GHC.Types.I# (GHC.Prim.-# bx2_abkz 1#)));
                               GHC.Types.True ->
                                 Data.Either.Left
                                   @Data.ByteString.Internal.Type.ByteString
                                   @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                   wild_abkw
                             }
                             })
                          (let {
                             f2_abkJ
                               :: Data.ByteString.Internal.Type.ByteString
                                  -> f_abkr Data.ByteString.Internal.Type.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abkJ
                               = GHC.Base.pure
                                   @f_abkr
                                   $dApplicative_abkt
                                   @Data.ByteString.Internal.Type.ByteString } in
                           let {
                             ds2_abkK
                               :: f_abkr
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                  -> f_abkr Data.ByteString.Internal.Type.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 259 0}]
                             ds2_abkK
                               = GHC.Base.fmap
                                   @f_abkr
                                   (GHC.Base.$p1Applicative @f_abkr $dApplicative_abkt)
                                   @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                                   @Data.ByteString.Internal.Type.ByteString
                                   (\ (p1_abkL
                                         :: (GHC.Word.Word8,
                                             Data.ByteString.Internal.Type.ByteString)) ->
                                      case p1_abkL of { (ds_abkN, y_abkO) ->
                                      case y_abkO of
                                      { Data.ByteString.Internal.Type.BS bx_abl0 bx1_abl1
                                                                         bx2_abl2 ->
                                      GHC.Magic.runRW#
                                        @GHC.Types.LiftedRep
                                        @Data.ByteString.Internal.Type.ByteString
                                        (\ (s_abkY [OS=OneShot]
                                              :: GHC.Prim.State# GHC.Prim.RealWorld) ->
                                           let {
                                             x_abkZ :: GHC.Prim.Int#
                                             [LclId,
                                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                      Value=False, ConLike=False, WorkFree=False,
                                                      Expandable=False,
                                                      Guidance=IF_ARGS [] 1 0}]
                                             x_abkZ = GHC.Prim.+# bx2_abl2 1# } in
                                           case GHC.Prim.<# x_abkZ 0# of {
                                             __DEFAULT ->
                                               case GHC.Prim.newPinnedByteArray#
                                                      @GHC.Prim.RealWorld x_abkZ s_abkY
                                               of
                                               { (# ipv_abl7, ipv1_abl8 #) ->
                                               let {
                                                 ipv2_abl6 :: GHC.Prim.Addr#
                                                 [LclId,
                                                  Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                          Value=False, ConLike=False,
                                                          WorkFree=False, Expandable=False,
                                                          Guidance=IF_ARGS [] 1 0}]
                                                 ipv2_abl6
                                                   = GHC.Prim.mutableByteArrayContents#
                                                       @GHC.Prim.RealWorld ipv1_abl8 } in
                                               let {
                                                 ipv3_abla :: GHC.ForeignPtr.ForeignPtrContents
                                                 [LclId,
                                                  Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                          Value=True, ConLike=True, WorkFree=True,
                                                          Expandable=True,
                                                          Guidance=IF_ARGS [] 10 10}]
                                                 ipv3_abla = GHC.ForeignPtr.PlainPtr ipv1_abl8 } in
                                               case ds_abkN of { GHC.Word.W8# x1_abms ->
                                               case GHC.Prim.writeWord8OffAddr#
                                                      @GHC.Prim.RealWorld
                                                      ipv2_abl6
                                                      0#
                                                      x1_abms
                                                      ipv_abl7
                                               of s2_abmu
                                               { __DEFAULT ->
                                               case GHC.Prim.touch#
                                                      @'GHC.Types.Lifted
                                                      @GHC.ForeignPtr.ForeignPtrContents
                                                      ipv3_abla
                                                      s2_abmu
                                               of s'_abmv
                                               { __DEFAULT ->
                                               case {__ffi_static_ccall_unsafe base:memcpy :: Addr#
                                          -> Addr#
                                          -> Word64#
                                          -> State# RealWorld
                                          -> (# State# RealWorld, Addr# #)}_abmw
                                                      (GHC.Prim.plusAddr# ipv2_abl6 1#)
                                                      bx_abl0
                                                      (GHC.Prim.int64ToWord64#
                                                         (GHC.Prim.intToInt64# bx2_abl2))
                                                      s'_abmv
                                               of
                                               { (# ds4_abmy, ds5_abmz #) ->
                                               case GHC.Prim.touch#
                                                      @'GHC.Types.Lifted
                                                      @GHC.ForeignPtr.ForeignPtrContents
                                                      bx1_abl1
                                                      ds4_abmy
                                               of s'1_abmB
                                               { __DEFAULT ->
                                               case GHC.Prim.touch#
                                                      @'GHC.Types.Lifted
                                                      @GHC.ForeignPtr.ForeignPtrContents
                                                      ipv3_abla
                                                      s'1_abmB
                                               of s'2_abmC
                                               { __DEFAULT ->
                                               case GHC.Magic.lazy
                                                      @((GHC.Prim.State# GHC.Prim.RealWorld
                                                         -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                               GHC.Prim.Addr# #))
                                                        -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                              GHC.Prim.Addr# #))
                                                      (GHC.Magic.runRW#
                                                         @('GHC.Types.TupleRep
                                                             '[GHC.Types.ZeroBitRep,
                                                               'GHC.Types.AddrRep])
                                                         @(# GHC.Prim.State# GHC.Prim.RealWorld,
                                                             GHC.Prim.Addr# #))
                                                      (\ _ [Occ=Dead] -> (# s'2_abmC, ipv2_abl6 #))
                                               of
                                               { (# ipv6_abmF, ipv7_abmG #) ->
                                               Data.ByteString.Internal.Type.BS
                                                 ipv7_abmG ipv3_abla x_abkZ
                                               }
                                               }
                                               }
                                               }
                                               }
                                               }
                                               }
                                               };
                                             1# ->
                                               case GHC.ForeignPtr.mallocPlainForeignPtrBytes2
                                               of wild_00 {
                                               }
                                           })
                                      }
                                      }) } in
                           \ (ds3_abmJ
                                :: Data.Either.Either
                                     Data.ByteString.Internal.Type.ByteString
                                     (f_abkr
                                        (GHC.Word.Word8,
                                         Data.ByteString.Internal.Type.ByteString))) ->
                             case ds3_abmJ of {
                               Data.Either.Left x_abmL -> f2_abkJ x_abmL;
                               Data.Either.Right y_abmN -> ds2_abkK y_abmN
                             }) } in
                  let {
                    g_abmP
                      :: p_abkq
                           (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                           (f_abkr (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                         -> p_abkq
                              (Data.Either.Either
                                 Data.ByteString.Internal.Type.ByteString
                                 (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                              (Data.Either.Either
                                 Data.ByteString.Internal.Type.ByteString
                                 (f_abkr
                                    (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abmP
                      = Data.Profunctor.Choice.right'
                          @p_abkq
                          $dChoice_abks
                          @(GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                          @(f_abkr
                              (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))
                          @Data.ByteString.Internal.Type.ByteString } in
                  \ (x_abmQ
                       :: p_abkq
                            (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                            (f_abkr
                               (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString))) ->
                    f1_abku (g_abmP x_abmQ))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <Data.ByteString.Internal.Type.ByteString>_N
                                <Data.ByteString.Internal.Type.ByteString>_N
                                <GHC.Word.Word8>_N
                                <GHC.Word.Word8>_N)
                       :: Control.Lens.Type.Prism
                            Data.ByteString.Internal.Type.ByteString
                            Data.ByteString.Internal.Type.ByteString
                            (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                            (GHC.Word.Word8, Data.ByteString.Internal.Type.ByteString)
                          ~R# Control.Lens.Cons.Cons
                                Data.ByteString.Internal.Type.ByteString
                                Data.ByteString.Internal.Type.ByteString
                                GHC.Word.Word8
                                GHC.Word.Word8))
              ((\ (@(p_abnq :: * -> * -> *))
                  (@(f_abnr :: * -> *))
                  ($dChoice_abns :: Data.Profunctor.Choice.Choice p_abnq)
                  ($dApplicative_abnt :: GHC.Base.Applicative f_abnr) ->
                  let {
                    f1_abnu
                      :: p_abnq
                           (Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString
                              (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                           (Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString
                              (f_abnr
                                 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                         -> p_abnq
                              Data.ByteString.Lazy.Internal.ByteString
                              (f_abnr Data.ByteString.Lazy.Internal.ByteString)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 536 0}]
                    f1_abnu
                      = Data.Profunctor.Unsafe.dimap
                          @p_abnq
                          (Data.Profunctor.Choice.$p1Choice @p_abnq $dChoice_abns)
                          @Data.ByteString.Lazy.Internal.ByteString
                          @(Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString
                              (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                          @(Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString
                              (f_abnr
                                 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                          @(f_abnr Data.ByteString.Lazy.Internal.ByteString)
                          (\ (s1_abnv :: Data.ByteString.Lazy.Internal.ByteString) ->
                             case s1_abnv of {
                               Data.ByteString.Lazy.Internal.Empty ->
                                 Data.Either.Left
                                   @Data.ByteString.Lazy.Internal.ByteString
                                   @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                   Data.ByteString.Lazy.Internal.Empty;
                               Data.ByteString.Lazy.Internal.Chunk bx_abnC bx1_abnD bx2_abnE
                                                                   cs_abnF ->
                                 case bx2_abnE of ds1_abnH {
                                   __DEFAULT ->
                                     Data.Either.Right
                                       @Data.ByteString.Lazy.Internal.ByteString
                                       @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                       (case GHC.Prim.readWord8OffAddr#
                                               @GHC.Prim.RealWorld bx_abnC 0# GHC.Prim.realWorld#
                                        of
                                        { (# ipv_abnJ, ipv1_abnK #) ->
                                        case GHC.Prim.touch#
                                               @'GHC.Types.Lifted
                                               @GHC.ForeignPtr.ForeignPtrContents
                                               bx1_abnD
                                               ipv_abnJ
                                        of
                                        { __DEFAULT ->
                                        GHC.Word.W8# ipv1_abnK
                                        }
                                        },
                                        Data.ByteString.Lazy.Internal.$WChunk
                                          (Data.ByteString.Internal.Type.$WBS
                                             (GHC.ForeignPtr.ForeignPtr
                                                @GHC.Word.Word8
                                                (GHC.Prim.plusAddr# bx_abnC 1#)
                                                bx1_abnD)
                                             (GHC.Types.I# (GHC.Prim.-# ds1_abnH 1#)))
                                          cs_abnF);
                                   1# ->
                                     Data.Either.Right
                                       @Data.ByteString.Lazy.Internal.ByteString
                                       @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                       (case GHC.Prim.readWord8OffAddr#
                                               @GHC.Prim.RealWorld bx_abnC 0# GHC.Prim.realWorld#
                                        of
                                        { (# ipv_abnO, ipv1_abnP #) ->
                                        case GHC.Prim.touch#
                                               @'GHC.Types.Lifted
                                               @GHC.ForeignPtr.ForeignPtrContents
                                               bx1_abnD
                                               ipv_abnO
                                        of
                                        { __DEFAULT ->
                                        GHC.Word.W8# ipv1_abnP
                                        }
                                        },
                                        cs_abnF)
                                 }
                             })
                          (let {
                             f2_abnS
                               :: Data.ByteString.Lazy.Internal.ByteString
                                  -> f_abnr Data.ByteString.Lazy.Internal.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abnS
                               = GHC.Base.pure
                                   @f_abnr
                                   $dApplicative_abnt
                                   @Data.ByteString.Lazy.Internal.ByteString } in
                           let {
                             ds2_abnT
                               :: f_abnr
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                  -> f_abnr Data.ByteString.Lazy.Internal.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 162 0}]
                             ds2_abnT
                               = GHC.Base.fmap
                                   @f_abnr
                                   (GHC.Base.$p1Applicative @f_abnr $dApplicative_abnt)
                                   @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                                   @Data.ByteString.Lazy.Internal.ByteString
                                   (\ (p1_abnU
                                         :: (GHC.Word.Word8,
                                             Data.ByteString.Lazy.Internal.ByteString)) ->
                                      case p1_abnU of { (x_abnW, ds_abnX) ->
                                      case x_abnW of { GHC.Word.W8# x#_abo0 ->
                                      Data.ByteString.Lazy.Internal.$WChunk
                                        (Data.ByteString.Internal.Type.$WBS
                                           (GHC.ForeignPtr.ForeignPtr
                                              @GHC.Word.Word8
                                              (GHC.Prim.plusAddr#
                                                 Data.ByteString.singleton1
                                                 (GHC.Prim.word2Int#
                                                    (GHC.Prim.word8ToWord# x#_abo0)))
                                              GHC.ForeignPtr.FinalPtr)
                                           (GHC.Types.I# 1#))
                                        ds_abnX
                                      }
                                      }) } in
                           \ (ds3_abo2
                                :: Data.Either.Either
                                     Data.ByteString.Lazy.Internal.ByteString
                                     (f_abnr
                                        (GHC.Word.Word8,
                                         Data.ByteString.Lazy.Internal.ByteString))) ->
                             case ds3_abo2 of {
                               Data.Either.Left x_abo4 -> f2_abnS x_abo4;
                               Data.Either.Right y_abo6 -> ds2_abnT y_abo6
                             }) } in
                  let {
                    g_abo8
                      :: p_abnq
                           (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                           (f_abnr (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                         -> p_abnq
                              (Data.Either.Either
                                 Data.ByteString.Lazy.Internal.ByteString
                                 (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                              (Data.Either.Either
                                 Data.ByteString.Lazy.Internal.ByteString
                                 (f_abnr
                                    (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abo8
                      = Data.Profunctor.Choice.right'
                          @p_abnq
                          $dChoice_abns
                          @(GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                          @(f_abnr
                              (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))
                          @Data.ByteString.Lazy.Internal.ByteString } in
                  \ (x_abo9
                       :: p_abnq
                            (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                            (f_abnr
                               (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString))) ->
                    f1_abnu (g_abo8 x_abo9))
               `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                <Data.ByteString.Lazy.Internal.ByteString>_N
                                <Data.ByteString.Lazy.Internal.ByteString>_N
                                <GHC.Word.Word8>_N
                                <GHC.Word.Word8>_N)
                       :: Control.Lens.Type.Prism
                            Data.ByteString.Lazy.Internal.ByteString
                            Data.ByteString.Lazy.Internal.ByteString
                            (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                            (GHC.Word.Word8, Data.ByteString.Lazy.Internal.ByteString)
                          ~R# Control.Lens.Cons.Cons
                                Data.ByteString.Lazy.Internal.ByteString
                                Data.ByteString.Lazy.Internal.ByteString
                                GHC.Word.Word8
                                GHC.Word.Word8))
              ((\ (@(p_abob :: * -> * -> *))
                  (@(f_aboc :: * -> *))
                  ($dChoice_abod :: Data.Profunctor.Choice.Choice p_abob)
                  ($dApplicative_aboe :: GHC.Base.Applicative f_aboc) ->
                  let {
                    f1_abof
                      :: p_abob
                           (Data.Either.Either Data.ByteString.Lazy.Internal.ByteString ())
                           (Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString (f_aboc ()))
                         -> p_abob
                              Data.ByteString.Lazy.Internal.ByteString
                              (f_aboc Data.ByteString.Lazy.Internal.ByteString)
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 290 0}]
                    f1_abof
                      = Data.Profunctor.Unsafe.dimap
                          @p_abob
                          (Data.Profunctor.Choice.$p1Choice @p_abob $dChoice_abod)
                          @Data.ByteString.Lazy.Internal.ByteString
                          @(Data.Either.Either Data.ByteString.Lazy.Internal.ByteString ())
                          @(Data.Either.Either
                              Data.ByteString.Lazy.Internal.ByteString (f_aboc ()))
                          @(f_aboc Data.ByteString.Lazy.Internal.ByteString)
                          (\ (s_abog :: Data.ByteString.Lazy.Internal.ByteString) ->
                             case s_abog of wild_aboh {
                               Data.ByteString.Lazy.Internal.Empty ->
                                 Data.Either.Right
                                   @Data.ByteString.Lazy.Internal.ByteString @() GHC.Tuple.Prim.();
                               Data.ByteString.Lazy.Internal.Chunk ipv_aboi ipv1_aboj ipv2_abok
                                                                   ipv3_abol ->
                                 Data.Either.Left
                                   @Data.ByteString.Lazy.Internal.ByteString @() wild_aboh
                             })
                          (let {
                             f2_abon
                               :: Data.ByteString.Lazy.Internal.ByteString
                                  -> f_aboc Data.ByteString.Lazy.Internal.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 20 0}]
                             f2_abon
                               = GHC.Base.pure
                                   @f_aboc
                                   $dApplicative_aboe
                                   @Data.ByteString.Lazy.Internal.ByteString } in
                           let {
                             ds2_aboo
                               :: f_aboc () -> f_aboc Data.ByteString.Lazy.Internal.ByteString
                             [LclId,
                              Unf=Unf{Src=<vanilla>, TopLvl=False,
                                      Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                      Guidance=IF_ARGS [] 70 0}]
                             ds2_aboo
                               = GHC.Base.fmap
                                   @f_aboc
                                   (GHC.Base.$p1Applicative @f_aboc $dApplicative_aboe)
                                   @()
                                   @Data.ByteString.Lazy.Internal.ByteString
                                   (\ (ds3_abop :: ()) ->
                                      case ds3_abop of { () ->
                                      Data.ByteString.Lazy.Internal.Empty
                                      }) } in
                           \ (ds3_abor
                                :: Data.Either.Either
                                     Data.ByteString.Lazy.Internal.ByteString (f_aboc ())) ->
                             case ds3_abor of {
                               Data.Either.Left x_abot -> f2_abon x_abot;
                               Data.Either.Right y_abov -> ds2_aboo y_abov
                             }) } in
                  let {
                    g_abox
                      :: p_abob () (f_aboc ())
                         -> p_abob
                              (Data.Either.Either Data.ByteString.Lazy.Internal.ByteString ())
                              (Data.Either.Either
                                 Data.ByteString.Lazy.Internal.ByteString (f_aboc ()))
                    [LclId,
                     Unf=Unf{Src=<vanilla>, TopLvl=False,
                             Value=False, ConLike=False, WorkFree=False, Expandable=True,
                             Guidance=IF_ARGS [] 20 0}]
                    g_abox
                      = Data.Profunctor.Choice.right'
                          @p_abob
                          $dChoice_abod
                          @()
                          @(f_aboc ())
                          @Data.ByteString.Lazy.Internal.ByteString } in
                  \ (x_aboy :: p_abob () (f_aboc ())) -> f1_abof (g_abox x_aboy))
               `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                <Data.ByteString.Lazy.Internal.ByteString>_N)
                       :: Control.Lens.Type.Prism'
                            Data.ByteString.Lazy.Internal.ByteString ()
                          ~R# Control.Lens.Empty.AsEmpty
                                Data.ByteString.Lazy.Internal.ByteString))
              (Data.Functor.Contravariant.$fContravariantConst
                 @Data.ByteString.Lazy.Internal.ByteString)
              (Data.Functor.Const.$fFunctorConst
                 @Data.ByteString.Lazy.Internal.ByteString)
    Cont:   ApplyToVal nodup hole Control.Lens.Getter.Getting
                                    Data.ByteString.Lazy.Internal.ByteString
                                    Data.ByteString.Internal.Type.ByteString
                                    Data.ByteString.Lazy.Internal.ByteString
              ((\ (ds_abeK [Occ=Once1] :: a_abeH) -> ds_abeK)
               `cast` (<a_abeH>_R
                       %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                          <*>_N <a_abeH>_R <a_abeH>_P)
                       :: (a_abeH -> a_abeH)
                          ~R# (a_abeH -> Data.Functor.Const.Const a_abeH a_abeH)))
            ApplyToVal nodup hole Data.ByteString.Internal.Type.ByteString
                                  -> Data.Functor.Const.Const
                                       Data.ByteString.Lazy.Internal.ByteString
                                       Data.ByteString.Internal.Type.ByteString
              s_a8Pz
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N
                        <Data.ByteString.Lazy.Internal.ByteString>_R
                        <Data.ByteString.Internal.Type.ByteString>_P
                    :: Data.Functor.Const.Const
                         Data.ByteString.Lazy.Internal.ByteString
                         Data.ByteString.Internal.Type.ByteString
                       ~R# Data.ByteString.Lazy.Internal.ByteString)
            Stop[RuleArgCtxt] Data.ByteString.Lazy.Internal.ByteString
Rule fired
    Rule: Class op fmap
    Module: (BUILTIN)
    Before: GHC.Base.fmap
              TyArg Data.Functor.Const.Const
                      Data.ByteString.Lazy.Internal.ByteString
              ValArg Data.Functor.Const.$fFunctorConst
                       @Data.ByteString.Lazy.Internal.ByteString
    After:  (Data.Functor.Const.$fFunctorConst2
               @Data.ByteString.Lazy.Internal.ByteString)
            `cast` (forall (a :: <*>_N) (b :: <*>_N).
                    <a -> b>_R
                    %<'GHC.Types.Many>_N ->_R <Data.Functor.Const.Const
                                                 Data.ByteString.Lazy.Internal.ByteString a>_R
                    %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                  <*>_N
                                                  <Data.ByteString.Lazy.Internal.ByteString>_R
                                                  <a>_P
                                              ; Sym (Data.Functor.Const.N:Const[0]
                                                         <*>_N
                                                         <Data.ByteString.Lazy.Internal.ByteString>_R
                                                         <b>_P)
                    :: (forall {a} {b}.
                        (a -> b)
                        -> Data.Functor.Const.Const
                             Data.ByteString.Lazy.Internal.ByteString a
                        -> Data.Functor.Const.Const
                             Data.ByteString.Lazy.Internal.ByteString a)
                       ~R# (forall {a} {b}.
                            (a -> b)
                            -> Data.Functor.Const.Const
                                 Data.ByteString.Lazy.Internal.ByteString a
                            -> Data.Functor.Const.Const
                                 Data.ByteString.Lazy.Internal.ByteString b))
    Cont:   ApplyToTy Data.ByteString.Lazy.Internal.ByteString
            ApplyToTy Data.ByteString.Internal.Type.ByteString
            ApplyToVal nodup hole (Data.ByteString.Lazy.Internal.ByteString
                                   -> Data.ByteString.Internal.Type.ByteString)
                                  -> Data.Functor.Const.Const
                                       Data.ByteString.Lazy.Internal.ByteString
                                       Data.ByteString.Lazy.Internal.ByteString
                                  -> Data.Functor.Const.Const
                                       Data.ByteString.Lazy.Internal.ByteString
                                       Data.ByteString.Internal.Type.ByteString
              Data.ByteString.Lazy.Internal.toStrict
            ApplyToVal nodup hole Data.Functor.Const.Const
                                    Data.ByteString.Lazy.Internal.ByteString
                                    Data.ByteString.Lazy.Internal.ByteString
                                  -> Data.Functor.Const.Const
                                       Data.ByteString.Lazy.Internal.ByteString
                                       Data.ByteString.Internal.Type.ByteString
              (bc_aboH (ab_aboF x_aboI))
            CastIt (Data.Functor.Const.N:Const[0]
                        <*>_N
                        <Data.ByteString.Lazy.Internal.ByteString>_R
                        <Data.ByteString.Internal.Type.ByteString>_P
                    :: Data.Functor.Const.Const
                         Data.ByteString.Lazy.Internal.ByteString
                         Data.ByteString.Internal.Type.ByteString
                       ~R# Data.ByteString.Lazy.Internal.ByteString)
            Stop[RuleArgCtxt] Data.ByteString.Lazy.Internal.ByteString
Rule fired
    Rule: Class op ==
    Module: (BUILTIN)
    Before: GHC.Classes.==
              TyArg Data.ByteString.Internal.Type.ByteString
              ValArg Data.ByteString.Internal.Type.$fEqByteString
              ValArg Data.ByteString.Lazy.Internal.toStrict
                       (case s_a8Pz of
                        { Data.ByteString.Internal.Type.BS bx_abrY bx1_abrZ bx2_abs0 ->
                        case bx2_abs0 of ds1_abs2 {
                          __DEFAULT ->
                            Data.ByteString.Lazy.Internal.Chunk
                              bx_abrY bx1_abrZ ds1_abs2 Data.ByteString.Lazy.Internal.Empty;
                          0# -> Data.ByteString.Lazy.Internal.Empty
                        }
                        })
              ValArg s_a8Pz
    After:  Data.ByteString.Internal.Type.eq
              ValArg Data.ByteString.Lazy.Internal.toStrict
                       (case s_a8Pz of
                        { Data.ByteString.Internal.Type.BS bx_abrY bx1_abrZ bx2_abs0 ->
                        case bx2_abs0 of ds1_abs2 {
                          __DEFAULT ->
                            Data.ByteString.Lazy.Internal.Chunk
                              bx_abrY bx1_abrZ ds1_abs2 Data.ByteString.Lazy.Internal.Empty;
                          0# -> Data.ByteString.Lazy.Internal.Empty
                        }
                        })
              ValArg s_a8Pz
    Cont:   Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: unpack
    Module: (GHC.Base)
    Before: GHC.CString.unpackCString# ValArg "[a] -> List a -> [a]"#
    After:  (\ (a_ab7z :: GHC.Prim.Addr#) ->
               GHC.Base.build
                 @GHC.Types.Char
                 (\ (@b_ab7A) -> GHC.CString.unpackFoldrCString# @b_ab7A a_ab7z))
              "[a] -> List a -> [a]"#
    Cont:   Stop[BoringCtxt] Test.Tasty.Core.TestName
Rule fired
    Rule: USPEC $fShowList @Int
    Module: (GHC.Show)
    Before: GHC.Show.$fShowList
              TyArg GHC.Types.Int ValArg GHC.Show.$fShowInt
    After:  (\ ($dShow_ab7o :: GHC.Show.Show GHC.Types.Int) ->
               GHC.Show.$fShowList_$s$fShowList)
              GHC.Show.$fShowInt
    Cont:   Stop[RuleArgCtxt, P(A,L,A)] GHC.Show.Show [GHC.Types.Int]
Rule fired
    Rule: Class op property
    Module: (BUILTIN)
    Before: Test.QuickCheck.Property.property
              TyArg [GHC.Types.Int] -> GHC.Types.Bool
              ValArg Test.QuickCheck.Property.$fTestableFUN
                       @[GHC.Types.Int]
                       @GHC.Types.Bool
                       (Test.QuickCheck.Arbitrary.$fArbitraryList
                          @GHC.Types.Int Test.QuickCheck.Arbitrary.$fArbitraryInt)
                       GHC.Show.$fShowList_$s$fShowList
                       Test.QuickCheck.Property.$fTestableBool
    After:  Test.QuickCheck.Property.$fTestableFUN_$cproperty
              @[GHC.Types.Int]
              @GHC.Types.Bool
              (Test.QuickCheck.Arbitrary.$fArbitraryList
                 @GHC.Types.Int Test.QuickCheck.Arbitrary.$fArbitraryInt)
              GHC.Show.$fShowList_$s$fShowList
              Test.QuickCheck.Property.$fTestableBool
    Cont:   ApplyToVal nodup hole ([GHC.Types.Int] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              prop_ab7M
            CastIt (Sym (Test.Tasty.QuickCheck.N:QC[0])
                    :: Test.QuickCheck.Property.Property ~R# Test.Tasty.QuickCheck.QC)
            Stop[BoringCtxt] Test.Tasty.QuickCheck.QC
Rule fired
    Rule: Class op propertyForAllShrinkShow
    Module: (BUILTIN)
    Before: Test.QuickCheck.Property.propertyForAllShrinkShow
              TyArg GHC.Types.Bool ValArg Test.QuickCheck.Property.$fTestableBool
    After:  Test.QuickCheck.Property.$fTestableBool1
            `cast` (forall (a :: <*>_N).
                    <Test.QuickCheck.Gen.Gen a>_R
                    %<'GHC.Types.Many>_N ->_R <a -> [a]>_R
                    %<'GHC.Types.Many>_N ->_R <a -> [GHC.Base.String]>_R
                    %<'GHC.Types.Many>_N ->_R <a -> GHC.Types.Bool>_R
                    %<'GHC.Types.Many>_N ->_R Sym (Test.QuickCheck.Gen.N:Gen[0]
                                                       (Test.QuickCheck.Property.N:Prop[0]))
                                              ; Sym (Test.QuickCheck.Property.N:Property[0])
                    :: (forall {a}.
                        Test.QuickCheck.Gen.Gen a
                        -> (a -> [a])
                        -> (a -> [GHC.Base.String])
                        -> (a -> GHC.Types.Bool)
                        -> Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int
                        -> Test.QuickCheck.Property.Rose Test.QuickCheck.Property.Result)
                       ~R# (forall {a}.
                            Test.QuickCheck.Gen.Gen a
                            -> (a -> [a])
                            -> (a -> [GHC.Base.String])
                            -> (a -> GHC.Types.Bool)
                            -> Test.QuickCheck.Property.Property))
    Cont:   ApplyToTy [GHC.Types.Int]
            ApplyToVal nodup hole Test.QuickCheck.Gen.Gen [GHC.Types.Int]
                                  -> ([GHC.Types.Int] -> [[GHC.Types.Int]])
                                  -> ([GHC.Types.Int] -> [GHC.Base.String])
                                  -> ([GHC.Types.Int] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (Test.QuickCheck.Arbitrary.arbitrary @a_ab9u $dArbitrary_ab9w)
            ApplyToVal nodup hole ([GHC.Types.Int] -> [[GHC.Types.Int]])
                                  -> ([GHC.Types.Int] -> [GHC.Base.String])
                                  -> ([GHC.Types.Int] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (Test.QuickCheck.Arbitrary.shrink @a_ab9u $dArbitrary_ab9w)
            ApplyToVal nodup hole ([GHC.Types.Int] -> [GHC.Base.String])
                                  -> ([GHC.Types.Int] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              (let {
                 g_ab9A [Occ=OnceL1!] :: a_ab9u -> GHC.Base.String
                 [LclId]
                 g_ab9A = GHC.Show.show @a_ab9u $dShow_ab9x } in
               \ (x_ab9B [Occ=Once1] :: a_ab9u) ->
                 GHC.Types.:
                   @GHC.Base.String (g_ab9A x_ab9B) (GHC.Types.[] @GHC.Base.String))
            ApplyToVal nodup hole ([GHC.Types.Int] -> GHC.Types.Bool)
                                  -> Test.QuickCheck.Property.Property
              f_ab9z
            CastIt (Sym (Test.Tasty.QuickCheck.N:QC[0])
                    :: Test.QuickCheck.Property.Property ~R# Test.Tasty.QuickCheck.QC)
            Stop[BoringCtxt] Test.Tasty.QuickCheck.QC
Rule fired
    Rule: Class op arbitrary
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.arbitrary
              TyArg [GHC.Types.Int] ValArg $dArbitrary_ab9w
    After:  (Test.QuickCheck.Arbitrary.$fArbitraryList1
               @GHC.Types.Int Test.QuickCheck.Arbitrary.$fArbitraryInt)
            `cast` (Sym (Test.QuickCheck.Gen.N:Gen[0] <[GHC.Types.Int]>_R)
                    :: (Test.QuickCheck.Random.QCGen
                        -> GHC.Types.Int -> [GHC.Types.Int])
                       ~R# Test.QuickCheck.Gen.Gen [GHC.Types.Int])
    Cont:   Stop[BoringCtxt] Test.QuickCheck.Gen.Gen [GHC.Types.Int]
Rule fired
    Rule: Class op arbitrary
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.arbitrary
              TyArg GHC.Types.Int ValArg Test.QuickCheck.Arbitrary.$fArbitraryInt
    After:  Test.QuickCheck.Arbitrary.$fArbitraryInt_$sarbitrarySizedIntegral
            `cast` (Sym (Test.QuickCheck.Gen.N:Gen[0] <GHC.Types.Int>_R)
                    :: (Test.QuickCheck.Random.QCGen -> GHC.Types.Int -> GHC.Types.Int)
                       ~R# Test.QuickCheck.Gen.Gen GHC.Types.Int)
    Cont:   Stop[BoringCtxt, C(S,C(1,L))] Test.QuickCheck.Gen.Gen
                                            GHC.Types.Int
Rule fired
    Rule: Class op shrink
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.shrink
              TyArg [GHC.Types.Int] ValArg $dArbitrary_ab9w
    After:  Test.QuickCheck.Arbitrary.$fArbitraryList_$cshrink
              @GHC.Types.Int Test.QuickCheck.Arbitrary.$fArbitraryInt
    Cont:   Stop[BoringCtxt] [GHC.Types.Int] -> [[GHC.Types.Int]]
Rule fired
    Rule: Class op shrink
    Module: (BUILTIN)
    Before: Test.QuickCheck.Arbitrary.shrink
              TyArg GHC.Types.Int ValArg Test.QuickCheck.Arbitrary.$fArbitraryInt
    After:  Test.QuickCheck.Arbitrary.$fArbitrary1IntMap_$sshrinkIntegral
    Cont:   Stop[DiscArgCtxt, C(S,L)] GHC.Types.Int -> [GHC.Types.Int]
Rule fired
    Rule: Class op show
    Module: (BUILTIN)
    Before: GHC.Show.show
              TyArg [GHC.Types.Int] ValArg GHC.Show.$fShowList_$s$fShowList
    After:  GHC.Show.$fShowList_$s$cshow
    Cont:   Stop[RhsCtxt(NonRecursive)] [GHC.Types.Int]
                                        -> GHC.Base.String
Rule fired
    Rule: Class op reader
    Module: (BUILTIN)
    Before: Control.Monad.Reader.Class.reader
              TyArg Main.List GHC.Types.Int
              TyArg (->) (Main.List GHC.Types.Int)
              ValArg Control.Monad.Reader.Class.$fMonadReaderrFUN
                       @(Main.List GHC.Types.Int)
    After:  \ (@a_abeP) ->
              GHC.Base.id @(Main.List GHC.Types.Int -> a_abeP)
    Cont:   ApplyToTy [GHC.Types.Int]
            ApplyToVal nodup hole (Main.List GHC.Types.Int -> [GHC.Types.Int])
                                  -> Main.List GHC.Types.Int -> [GHC.Types.Int]
              ((l_abeJ
                  ((\ (ds_abeK [Occ=Once1] :: a_abeH) -> ds_abeK)
                   `cast` (<a_abeH>_R
                           %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                              <*>_N <a_abeH>_R <a_abeH>_P)
                           :: (a_abeH -> a_abeH)
                              ~R# (a_abeH -> Data.Functor.Const.Const a_abeH a_abeH))))
               `cast` (<s_abeF>_R
                       %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                     <*>_N <a_abeH>_R <s_abeF>_P
                       :: (s_abeF -> Data.Functor.Const.Const a_abeH s_abeF)
                          ~R# (s_abeF -> a_abeH)))
            ApplyToVal nodup hole Main.List GHC.Types.Int -> [GHC.Types.Int]
              (Control.Lens.Getter.view
                 @[GHC.Types.Int]
                 @((->) [GHC.Types.Int])
                 @(Main.List GHC.Types.Int)
                 (Control.Monad.Reader.Class.$fMonadReaderrFUN @[GHC.Types.Int])
                 (Control.Lens.Cons.Extras.recons
                    @[GHC.Types.Int]
                    @GHC.Types.Int
                    @(Main.List GHC.Types.Int)
                    (Control.Lens.Cons.$fConsListListab @GHC.Types.Int @GHC.Types.Int)
                    (Main.$fConsListListab @GHC.Types.Int @GHC.Types.Int)
                    (Main.$fAsEmptyList @GHC.Types.Int)
                    @(Data.Functor.Const.Const (Main.List GHC.Types.Int))
                    (Data.Functor.Contravariant.$fContravariantConst
                       @(Main.List GHC.Types.Int))
                    (Data.Functor.Const.$fFunctorConst @(Main.List GHC.Types.Int)))
                 s_a8PA)
            Stop[RuleArgCtxt] [GHC.Types.Int]
Rule fired
    Rule: Class op reader
    Module: (BUILTIN)
    Before: Control.Monad.Reader.Class.reader
              TyArg [GHC.Types.Int]
              TyArg (->) [GHC.Types.Int]
              ValArg Control.Monad.Reader.Class.$fMonadReaderrFUN
                       @[GHC.Types.Int]
    After:  \ (@a_abeP) -> GHC.Base.id @([GHC.Types.Int] -> a_abeP)
    Cont:   ApplyToTy (Main.List GHC.Types.Int)
            ApplyToVal nodup hole ([GHC.Types.Int] -> Main.List GHC.Types.Int)
                                  -> [GHC.Types.Int] -> Main.List GHC.Types.Int
              ((l_abeJ
                  ((\ (ds_abeK [Occ=Once1] :: a_abeH) -> ds_abeK)
                   `cast` (<a_abeH>_R
                           %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                              <*>_N <a_abeH>_R <a_abeH>_P)
                           :: (a_abeH -> a_abeH)
                              ~R# (a_abeH -> Data.Functor.Const.Const a_abeH a_abeH))))
               `cast` (<s_abeF>_R
                       %<'GHC.Types.Many>_N ->_R Data.Functor.Const.N:Const[0]
                                                     <*>_N <a_abeH>_R <s_abeF>_P
                       :: (s_abeF -> Data.Functor.Const.Const a_abeH s_abeF)
                          ~R# (s_abeF -> a_abeH)))
            ApplyToVal nodup hole [GHC.Types.Int] -> Main.List GHC.Types.Int
              s_a8PA
            Stop[RuleArgCtxt] Main.List GHC.Types.Int
Rule fired
    Rule: Class op ==
    Module: (BUILTIN)
    Before: GHC.Classes.==
              TyArg [GHC.Types.Int]
              ValArg GHC.Classes.$fEqList_$s$fEqList
              ValArg (Control.Lens.Cons.Extras.recons
                        @(Main.List GHC.Types.Int)
                        @GHC.Types.Int
                        @[GHC.Types.Int]
                        (($c_Cons_a9jd @GHC.Types.Int @GHC.Types.Int)
                         `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                          <Main.List GHC.Types.Int>_N
                                          <Main.List GHC.Types.Int>_N
                                          <GHC.Types.Int>_N
                                          <GHC.Types.Int>_N)
                                 :: Control.Lens.Type.Prism
                                      (Main.List GHC.Types.Int)
                                      (Main.List GHC.Types.Int)
                                      (GHC.Types.Int, Main.List GHC.Types.Int)
                                      (GHC.Types.Int, Main.List GHC.Types.Int)
                                    ~R# Control.Lens.Cons.Cons
                                          (Main.List GHC.Types.Int)
                                          (Main.List GHC.Types.Int)
                                          GHC.Types.Int
                                          GHC.Types.Int))
                        ((\ (@(p_abgg :: * -> * -> *))
                            (@(f_abgh :: * -> *))
                            ($dChoice_abgi :: Data.Profunctor.Choice.Choice p_abgg)
                            ($dApplicative_abgj :: GHC.Base.Applicative f_abgh) ->
                            let {
                              f1_abgk
                                :: p_abgg
                                     (Data.Either.Either
                                        [GHC.Types.Int] (GHC.Types.Int, [GHC.Types.Int]))
                                     (Data.Either.Either
                                        [GHC.Types.Int] (f_abgh (GHC.Types.Int, [GHC.Types.Int])))
                                   -> p_abgg [GHC.Types.Int] (f_abgh [GHC.Types.Int])
                              [LclId,
                               Unf=Unf{Src=<vanilla>, TopLvl=False,
                                       Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                       Guidance=IF_ARGS [] 320 0}]
                              f1_abgk
                                = Data.Profunctor.Unsafe.dimap
                                    @p_abgg
                                    (Data.Profunctor.Choice.$p1Choice @p_abgg $dChoice_abgi)
                                    @[GHC.Types.Int]
                                    @(Data.Either.Either
                                        [GHC.Types.Int] (GHC.Types.Int, [GHC.Types.Int]))
                                    @(Data.Either.Either
                                        [GHC.Types.Int] (f_abgh (GHC.Types.Int, [GHC.Types.Int])))
                                    @(f_abgh [GHC.Types.Int])
                                    (\ (aas_abgl :: [GHC.Types.Int]) ->
                                       case aas_abgl of {
                                         [] ->
                                           Data.Either.Left
                                             @[GHC.Types.Int]
                                             @(GHC.Types.Int, [GHC.Types.Int])
                                             (GHC.Types.[] @GHC.Types.Int);
                                         : a1_abgn as_abgo ->
                                           Data.Either.Right
                                             @[GHC.Types.Int]
                                             @(GHC.Types.Int, [GHC.Types.Int])
                                             (a1_abgn, as_abgo)
                                       })
                                    (let {
                                       f2_abgq :: [GHC.Types.Int] -> f_abgh [GHC.Types.Int]
                                       [LclId,
                                        Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                Value=False, ConLike=False, WorkFree=False,
                                                Expandable=True,
                                                Guidance=IF_ARGS [] 20 0}]
                                       f2_abgq
                                         = GHC.Base.pure
                                             @f_abgh $dApplicative_abgj @[GHC.Types.Int] } in
                                     let {
                                       ds2_abgr
                                         :: f_abgh (GHC.Types.Int, [GHC.Types.Int])
                                            -> f_abgh [GHC.Types.Int]
                                       [LclId,
                                        Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                Value=False, ConLike=False, WorkFree=False,
                                                Expandable=False,
                                                Guidance=IF_ARGS [] 90 0}]
                                       ds2_abgr
                                         = GHC.Base.fmap
                                             @f_abgh
                                             (GHC.Base.$p1Applicative @f_abgh $dApplicative_abgj)
                                             @(GHC.Types.Int, [GHC.Types.Int])
                                             @[GHC.Types.Int]
                                             (\ (p1_abgs :: (GHC.Types.Int, [GHC.Types.Int])) ->
                                                GHC.Types.:
                                                  @GHC.Types.Int
                                                  (case p1_abgs of { (x_abgu, ds_abgv) -> x_abgu })
                                                  (case p1_abgs of { (ds_abgy, y_abgz) ->
                                                   y_abgz
                                                   })) } in
                                     \ (ds3_abgB
                                          :: Data.Either.Either
                                               [GHC.Types.Int]
                                               (f_abgh (GHC.Types.Int, [GHC.Types.Int]))) ->
                                       case ds3_abgB of {
                                         Data.Either.Left x_abgD -> f2_abgq x_abgD;
                                         Data.Either.Right y_abgF -> ds2_abgr y_abgF
                                       }) } in
                            let {
                              g_abgH
                                :: p_abgg
                                     (GHC.Types.Int, [GHC.Types.Int])
                                     (f_abgh (GHC.Types.Int, [GHC.Types.Int]))
                                   -> p_abgg
                                        (Data.Either.Either
                                           [GHC.Types.Int] (GHC.Types.Int, [GHC.Types.Int]))
                                        (Data.Either.Either
                                           [GHC.Types.Int]
                                           (f_abgh (GHC.Types.Int, [GHC.Types.Int])))
                              [LclId,
                               Unf=Unf{Src=<vanilla>, TopLvl=False,
                                       Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                       Guidance=IF_ARGS [] 20 0}]
                              g_abgH
                                = Data.Profunctor.Choice.right'
                                    @p_abgg
                                    $dChoice_abgi
                                    @(GHC.Types.Int, [GHC.Types.Int])
                                    @(f_abgh (GHC.Types.Int, [GHC.Types.Int]))
                                    @[GHC.Types.Int] } in
                            \ (x_abgI
                                 :: p_abgg
                                      (GHC.Types.Int, [GHC.Types.Int])
                                      (f_abgh (GHC.Types.Int, [GHC.Types.Int]))) ->
                              f1_abgk (g_abgH x_abgI))
                         `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                          <[GHC.Types.Int]>_N
                                          <[GHC.Types.Int]>_N
                                          <GHC.Types.Int>_N
                                          <GHC.Types.Int>_N)
                                 :: Control.Lens.Type.Prism
                                      [GHC.Types.Int]
                                      [GHC.Types.Int]
                                      (GHC.Types.Int, [GHC.Types.Int])
                                      (GHC.Types.Int, [GHC.Types.Int])
                                    ~R# Control.Lens.Cons.Cons
                                          [GHC.Types.Int]
                                          [GHC.Types.Int]
                                          GHC.Types.Int
                                          GHC.Types.Int))
                        ((\ (@(p_abgN :: * -> * -> *))
                            (@(f_abgO :: * -> *))
                            ($dChoice_abgP :: Data.Profunctor.Choice.Choice p_abgN)
                            ($dApplicative_abgQ :: GHC.Base.Applicative f_abgO) ->
                            let {
                              f1_abgR
                                :: p_abgN
                                     (Data.Either.Either [GHC.Types.Int] ())
                                     (Data.Either.Either [GHC.Types.Int] (f_abgO ()))
                                   -> p_abgN [GHC.Types.Int] (f_abgO [GHC.Types.Int])
                              [LclId,
                               Unf=Unf{Src=<vanilla>, TopLvl=False,
                                       Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                       Guidance=IF_ARGS [] 290 0}]
                              f1_abgR
                                = Data.Profunctor.Unsafe.dimap
                                    @p_abgN
                                    (Data.Profunctor.Choice.$p1Choice @p_abgN $dChoice_abgP)
                                    @[GHC.Types.Int]
                                    @(Data.Either.Either [GHC.Types.Int] ())
                                    @(Data.Either.Either [GHC.Types.Int] (f_abgO ()))
                                    @(f_abgO [GHC.Types.Int])
                                    (\ (s_abgS :: [GHC.Types.Int]) ->
                                       case s_abgS of wild_abgT {
                                         [] ->
                                           Data.Either.Right @[GHC.Types.Int] @() GHC.Tuple.Prim.();
                                         : ds1_abgU ds2_abgV ->
                                           Data.Either.Left @[GHC.Types.Int] @() wild_abgT
                                       })
                                    (let {
                                       f2_abgX :: [GHC.Types.Int] -> f_abgO [GHC.Types.Int]
                                       [LclId,
                                        Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                Value=False, ConLike=False, WorkFree=False,
                                                Expandable=True,
                                                Guidance=IF_ARGS [] 20 0}]
                                       f2_abgX
                                         = GHC.Base.pure
                                             @f_abgO $dApplicative_abgQ @[GHC.Types.Int] } in
                                     let {
                                       ds2_abgY :: f_abgO () -> f_abgO [GHC.Types.Int]
                                       [LclId,
                                        Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                Value=False, ConLike=False, WorkFree=False,
                                                Expandable=False,
                                                Guidance=IF_ARGS [] 70 0}]
                                       ds2_abgY
                                         = GHC.Base.fmap
                                             @f_abgO
                                             (GHC.Base.$p1Applicative @f_abgO $dApplicative_abgQ)
                                             @()
                                             @[GHC.Types.Int]
                                             (\ (ds3_abgZ :: ()) ->
                                                case ds3_abgZ of { () ->
                                                GHC.Types.[] @GHC.Types.Int
                                                }) } in
                                     \ (ds3_abh1
                                          :: Data.Either.Either [GHC.Types.Int] (f_abgO ())) ->
                                       case ds3_abh1 of {
                                         Data.Either.Left x_abh3 -> f2_abgX x_abh3;
                                         Data.Either.Right y_abh5 -> ds2_abgY y_abh5
                                       }) } in
                            let {
                              g_abh7
                                :: p_abgN () (f_abgO ())
                                   -> p_abgN
                                        (Data.Either.Either [GHC.Types.Int] ())
                                        (Data.Either.Either [GHC.Types.Int] (f_abgO ()))
                              [LclId,
                               Unf=Unf{Src=<vanilla>, TopLvl=False,
                                       Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                       Guidance=IF_ARGS [] 20 0}]
                              g_abh7
                                = Data.Profunctor.Choice.right'
                                    @p_abgN $dChoice_abgP @() @(f_abgO ()) @[GHC.Types.Int] } in
                            \ (x_abh8 :: p_abgN () (f_abgO ())) -> f1_abgR (g_abh7 x_abh8))
                         `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0] <[GHC.Types.Int]>_N)
                                 :: Control.Lens.Type.Prism' [GHC.Types.Int] ()
                                    ~R# Control.Lens.Empty.AsEmpty [GHC.Types.Int]))
                        @(Data.Functor.Const.Const [GHC.Types.Int])
                        (Data.Functor.Contravariant.$fContravariantConst @[GHC.Types.Int])
                        (Data.Functor.Const.$fFunctorConst @[GHC.Types.Int])
                        ((\ (ds_abeK :: [GHC.Types.Int]) -> ds_abeK)
                         `cast` (<[GHC.Types.Int]>_R
                                 %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                                    <*>_N
                                                                    <[GHC.Types.Int]>_R
                                                                    <[GHC.Types.Int]>_P)
                                 :: ([GHC.Types.Int] -> [GHC.Types.Int])
                                    ~R# ([GHC.Types.Int]
                                         -> Data.Functor.Const.Const
                                              [GHC.Types.Int] [GHC.Types.Int])))
                        ((Control.Lens.Cons.Extras.recons
                            @[GHC.Types.Int]
                            @GHC.Types.Int
                            @(Main.List GHC.Types.Int)
                            ((\ (@(p_abgg :: * -> * -> *))
                                (@(f_abgh :: * -> *))
                                ($dChoice_abgi :: Data.Profunctor.Choice.Choice p_abgg)
                                ($dApplicative_abgj :: GHC.Base.Applicative f_abgh) ->
                                let {
                                  f1_abgk
                                    :: p_abgg
                                         (Data.Either.Either
                                            [GHC.Types.Int] (GHC.Types.Int, [GHC.Types.Int]))
                                         (Data.Either.Either
                                            [GHC.Types.Int]
                                            (f_abgh (GHC.Types.Int, [GHC.Types.Int])))
                                       -> p_abgg [GHC.Types.Int] (f_abgh [GHC.Types.Int])
                                  [LclId,
                                   Unf=Unf{Src=<vanilla>, TopLvl=False,
                                           Value=False, ConLike=False, WorkFree=False,
                                           Expandable=False,
                                           Guidance=IF_ARGS [] 320 0}]
                                  f1_abgk
                                    = Data.Profunctor.Unsafe.dimap
                                        @p_abgg
                                        (Data.Profunctor.Choice.$p1Choice @p_abgg $dChoice_abgi)
                                        @[GHC.Types.Int]
                                        @(Data.Either.Either
                                            [GHC.Types.Int] (GHC.Types.Int, [GHC.Types.Int]))
                                        @(Data.Either.Either
                                            [GHC.Types.Int]
                                            (f_abgh (GHC.Types.Int, [GHC.Types.Int])))
                                        @(f_abgh [GHC.Types.Int])
                                        (\ (aas_abgl :: [GHC.Types.Int]) ->
                                           case aas_abgl of {
                                             [] ->
                                               Data.Either.Left
                                                 @[GHC.Types.Int]
                                                 @(GHC.Types.Int, [GHC.Types.Int])
                                                 (GHC.Types.[] @GHC.Types.Int);
                                             : a1_abgn as_abgo ->
                                               Data.Either.Right
                                                 @[GHC.Types.Int]
                                                 @(GHC.Types.Int, [GHC.Types.Int])
                                                 (a1_abgn, as_abgo)
                                           })
                                        (let {
                                           f2_abgq :: [GHC.Types.Int] -> f_abgh [GHC.Types.Int]
                                           [LclId,
                                            Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                    Value=False, ConLike=False, WorkFree=False,
                                                    Expandable=True,
                                                    Guidance=IF_ARGS [] 20 0}]
                                           f2_abgq
                                             = GHC.Base.pure
                                                 @f_abgh $dApplicative_abgj @[GHC.Types.Int] } in
                                         let {
                                           ds2_abgr
                                             :: f_abgh (GHC.Types.Int, [GHC.Types.Int])
                                                -> f_abgh [GHC.Types.Int]
                                           [LclId,
                                            Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                    Value=False, ConLike=False, WorkFree=False,
                                                    Expandable=False,
                                                    Guidance=IF_ARGS [] 90 0}]
                                           ds2_abgr
                                             = GHC.Base.fmap
                                                 @f_abgh
                                                 (GHC.Base.$p1Applicative
                                                    @f_abgh $dApplicative_abgj)
                                                 @(GHC.Types.Int, [GHC.Types.Int])
                                                 @[GHC.Types.Int]
                                                 (\ (p1_abgs :: (GHC.Types.Int, [GHC.Types.Int])) ->
                                                    GHC.Types.:
                                                      @GHC.Types.Int
                                                      (case p1_abgs of { (x_abgu, ds_abgv) ->
                                                       x_abgu
                                                       })
                                                      (case p1_abgs of { (ds_abgy, y_abgz) ->
                                                       y_abgz
                                                       })) } in
                                         \ (ds3_abgB
                                              :: Data.Either.Either
                                                   [GHC.Types.Int]
                                                   (f_abgh (GHC.Types.Int, [GHC.Types.Int]))) ->
                                           case ds3_abgB of {
                                             Data.Either.Left x_abgD -> f2_abgq x_abgD;
                                             Data.Either.Right y_abgF -> ds2_abgr y_abgF
                                           }) } in
                                let {
                                  g_abgH
                                    :: p_abgg
                                         (GHC.Types.Int, [GHC.Types.Int])
                                         (f_abgh (GHC.Types.Int, [GHC.Types.Int]))
                                       -> p_abgg
                                            (Data.Either.Either
                                               [GHC.Types.Int] (GHC.Types.Int, [GHC.Types.Int]))
                                            (Data.Either.Either
                                               [GHC.Types.Int]
                                               (f_abgh (GHC.Types.Int, [GHC.Types.Int])))
                                  [LclId,
                                   Unf=Unf{Src=<vanilla>, TopLvl=False,
                                           Value=False, ConLike=False, WorkFree=False,
                                           Expandable=True,
                                           Guidance=IF_ARGS [] 20 0}]
                                  g_abgH
                                    = Data.Profunctor.Choice.right'
                                        @p_abgg
                                        $dChoice_abgi
                                        @(GHC.Types.Int, [GHC.Types.Int])
                                        @(f_abgh (GHC.Types.Int, [GHC.Types.Int]))
                                        @[GHC.Types.Int] } in
                                \ (x_abgI
                                     :: p_abgg
                                          (GHC.Types.Int, [GHC.Types.Int])
                                          (f_abgh (GHC.Types.Int, [GHC.Types.Int]))) ->
                                  f1_abgk (g_abgH x_abgI))
                             `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                              <[GHC.Types.Int]>_N
                                              <[GHC.Types.Int]>_N
                                              <GHC.Types.Int>_N
                                              <GHC.Types.Int>_N)
                                     :: Control.Lens.Type.Prism
                                          [GHC.Types.Int]
                                          [GHC.Types.Int]
                                          (GHC.Types.Int, [GHC.Types.Int])
                                          (GHC.Types.Int, [GHC.Types.Int])
                                        ~R# Control.Lens.Cons.Cons
                                              [GHC.Types.Int]
                                              [GHC.Types.Int]
                                              GHC.Types.Int
                                              GHC.Types.Int))
                            (($c_Cons_a9jd @GHC.Types.Int @GHC.Types.Int)
                             `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                              <Main.List GHC.Types.Int>_N
                                              <Main.List GHC.Types.Int>_N
                                              <GHC.Types.Int>_N
                                              <GHC.Types.Int>_N)
                                     :: Control.Lens.Type.Prism
                                          (Main.List GHC.Types.Int)
                                          (Main.List GHC.Types.Int)
                                          (GHC.Types.Int, Main.List GHC.Types.Int)
                                          (GHC.Types.Int, Main.List GHC.Types.Int)
                                        ~R# Control.Lens.Cons.Cons
                                              (Main.List GHC.Types.Int)
                                              (Main.List GHC.Types.Int)
                                              GHC.Types.Int
                                              GHC.Types.Int))
                            (($c_Empty_a9oc @GHC.Types.Int)
                             `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                              <Main.List GHC.Types.Int>_N)
                                     :: Control.Lens.Type.Prism' (Main.List GHC.Types.Int) ()
                                        ~R# Control.Lens.Empty.AsEmpty (Main.List GHC.Types.Int)))
                            @(Data.Functor.Const.Const (Main.List GHC.Types.Int))
                            (Data.Functor.Contravariant.$fContravariantConst
                               @(Main.List GHC.Types.Int))
                            (Data.Functor.Const.$fFunctorConst @(Main.List GHC.Types.Int))
                            ((\ (ds_abeK :: Main.List GHC.Types.Int) -> ds_abeK)
                             `cast` (<Main.List GHC.Types.Int>_R
                                     %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                                        <*>_N
                                                                        <Main.List GHC.Types.Int>_R
                                                                        <Main.List GHC.Types.Int>_P)
                                     :: (Main.List GHC.Types.Int -> Main.List GHC.Types.Int)
                                        ~R# (Main.List GHC.Types.Int
                                             -> Data.Functor.Const.Const
                                                  (Main.List GHC.Types.Int)
                                                  (Main.List GHC.Types.Int))))
                            s_a8PA)
                         `cast` (Data.Functor.Const.N:Const[0]
                                     <*>_N <Main.List GHC.Types.Int>_R <[GHC.Types.Int]>_P
                                 :: Data.Functor.Const.Const
                                      (Main.List GHC.Types.Int) [GHC.Types.Int]
                                    ~R# Main.List GHC.Types.Int)))
                     `cast` (Data.Functor.Const.N:Const[0]
                                 <*>_N <[GHC.Types.Int]>_R <Main.List GHC.Types.Int>_P
                             :: Data.Functor.Const.Const
                                  [GHC.Types.Int] (Main.List GHC.Types.Int)
                                ~R# [GHC.Types.Int])
              ValArg s_a8PA
    After:  GHC.Classes.$fEqList_$s$c==
              ValArg (Control.Lens.Cons.Extras.recons
                        @(Main.List GHC.Types.Int)
                        @GHC.Types.Int
                        @[GHC.Types.Int]
                        (($c_Cons_a9jd @GHC.Types.Int @GHC.Types.Int)
                         `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                          <Main.List GHC.Types.Int>_N
                                          <Main.List GHC.Types.Int>_N
                                          <GHC.Types.Int>_N
                                          <GHC.Types.Int>_N)
                                 :: Control.Lens.Type.Prism
                                      (Main.List GHC.Types.Int)
                                      (Main.List GHC.Types.Int)
                                      (GHC.Types.Int, Main.List GHC.Types.Int)
                                      (GHC.Types.Int, Main.List GHC.Types.Int)
                                    ~R# Control.Lens.Cons.Cons
                                          (Main.List GHC.Types.Int)
                                          (Main.List GHC.Types.Int)
                                          GHC.Types.Int
                                          GHC.Types.Int))
                        ((\ (@(p_abgg :: * -> * -> *))
                            (@(f_abgh :: * -> *))
                            ($dChoice_abgi :: Data.Profunctor.Choice.Choice p_abgg)
                            ($dApplicative_abgj :: GHC.Base.Applicative f_abgh) ->
                            let {
                              f1_abgk
                                :: p_abgg
                                     (Data.Either.Either
                                        [GHC.Types.Int] (GHC.Types.Int, [GHC.Types.Int]))
                                     (Data.Either.Either
                                        [GHC.Types.Int] (f_abgh (GHC.Types.Int, [GHC.Types.Int])))
                                   -> p_abgg [GHC.Types.Int] (f_abgh [GHC.Types.Int])
                              [LclId,
                               Unf=Unf{Src=<vanilla>, TopLvl=False,
                                       Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                       Guidance=IF_ARGS [] 320 0}]
                              f1_abgk
                                = Data.Profunctor.Unsafe.dimap
                                    @p_abgg
                                    (Data.Profunctor.Choice.$p1Choice @p_abgg $dChoice_abgi)
                                    @[GHC.Types.Int]
                                    @(Data.Either.Either
                                        [GHC.Types.Int] (GHC.Types.Int, [GHC.Types.Int]))
                                    @(Data.Either.Either
                                        [GHC.Types.Int] (f_abgh (GHC.Types.Int, [GHC.Types.Int])))
                                    @(f_abgh [GHC.Types.Int])
                                    (\ (aas_abgl :: [GHC.Types.Int]) ->
                                       case aas_abgl of {
                                         [] ->
                                           Data.Either.Left
                                             @[GHC.Types.Int]
                                             @(GHC.Types.Int, [GHC.Types.Int])
                                             (GHC.Types.[] @GHC.Types.Int);
                                         : a1_abgn as_abgo ->
                                           Data.Either.Right
                                             @[GHC.Types.Int]
                                             @(GHC.Types.Int, [GHC.Types.Int])
                                             (a1_abgn, as_abgo)
                                       })
                                    (let {
                                       f2_abgq :: [GHC.Types.Int] -> f_abgh [GHC.Types.Int]
                                       [LclId,
                                        Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                Value=False, ConLike=False, WorkFree=False,
                                                Expandable=True,
                                                Guidance=IF_ARGS [] 20 0}]
                                       f2_abgq
                                         = GHC.Base.pure
                                             @f_abgh $dApplicative_abgj @[GHC.Types.Int] } in
                                     let {
                                       ds2_abgr
                                         :: f_abgh (GHC.Types.Int, [GHC.Types.Int])
                                            -> f_abgh [GHC.Types.Int]
                                       [LclId,
                                        Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                Value=False, ConLike=False, WorkFree=False,
                                                Expandable=False,
                                                Guidance=IF_ARGS [] 90 0}]
                                       ds2_abgr
                                         = GHC.Base.fmap
                                             @f_abgh
                                             (GHC.Base.$p1Applicative @f_abgh $dApplicative_abgj)
                                             @(GHC.Types.Int, [GHC.Types.Int])
                                             @[GHC.Types.Int]
                                             (\ (p1_abgs :: (GHC.Types.Int, [GHC.Types.Int])) ->
                                                GHC.Types.:
                                                  @GHC.Types.Int
                                                  (case p1_abgs of { (x_abgu, ds_abgv) -> x_abgu })
                                                  (case p1_abgs of { (ds_abgy, y_abgz) ->
                                                   y_abgz
                                                   })) } in
                                     \ (ds3_abgB
                                          :: Data.Either.Either
                                               [GHC.Types.Int]
                                               (f_abgh (GHC.Types.Int, [GHC.Types.Int]))) ->
                                       case ds3_abgB of {
                                         Data.Either.Left x_abgD -> f2_abgq x_abgD;
                                         Data.Either.Right y_abgF -> ds2_abgr y_abgF
                                       }) } in
                            let {
                              g_abgH
                                :: p_abgg
                                     (GHC.Types.Int, [GHC.Types.Int])
                                     (f_abgh (GHC.Types.Int, [GHC.Types.Int]))
                                   -> p_abgg
                                        (Data.Either.Either
                                           [GHC.Types.Int] (GHC.Types.Int, [GHC.Types.Int]))
                                        (Data.Either.Either
                                           [GHC.Types.Int]
                                           (f_abgh (GHC.Types.Int, [GHC.Types.Int])))
                              [LclId,
                               Unf=Unf{Src=<vanilla>, TopLvl=False,
                                       Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                       Guidance=IF_ARGS [] 20 0}]
                              g_abgH
                                = Data.Profunctor.Choice.right'
                                    @p_abgg
                                    $dChoice_abgi
                                    @(GHC.Types.Int, [GHC.Types.Int])
                                    @(f_abgh (GHC.Types.Int, [GHC.Types.Int]))
                                    @[GHC.Types.Int] } in
                            \ (x_abgI
                                 :: p_abgg
                                      (GHC.Types.Int, [GHC.Types.Int])
                                      (f_abgh (GHC.Types.Int, [GHC.Types.Int]))) ->
                              f1_abgk (g_abgH x_abgI))
                         `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                          <[GHC.Types.Int]>_N
                                          <[GHC.Types.Int]>_N
                                          <GHC.Types.Int>_N
                                          <GHC.Types.Int>_N)
                                 :: Control.Lens.Type.Prism
                                      [GHC.Types.Int]
                                      [GHC.Types.Int]
                                      (GHC.Types.Int, [GHC.Types.Int])
                                      (GHC.Types.Int, [GHC.Types.Int])
                                    ~R# Control.Lens.Cons.Cons
                                          [GHC.Types.Int]
                                          [GHC.Types.Int]
                                          GHC.Types.Int
                                          GHC.Types.Int))
                        ((\ (@(p_abgN :: * -> * -> *))
                            (@(f_abgO :: * -> *))
                            ($dChoice_abgP :: Data.Profunctor.Choice.Choice p_abgN)
                            ($dApplicative_abgQ :: GHC.Base.Applicative f_abgO) ->
                            let {
                              f1_abgR
                                :: p_abgN
                                     (Data.Either.Either [GHC.Types.Int] ())
                                     (Data.Either.Either [GHC.Types.Int] (f_abgO ()))
                                   -> p_abgN [GHC.Types.Int] (f_abgO [GHC.Types.Int])
                              [LclId,
                               Unf=Unf{Src=<vanilla>, TopLvl=False,
                                       Value=False, ConLike=False, WorkFree=False, Expandable=False,
                                       Guidance=IF_ARGS [] 290 0}]
                              f1_abgR
                                = Data.Profunctor.Unsafe.dimap
                                    @p_abgN
                                    (Data.Profunctor.Choice.$p1Choice @p_abgN $dChoice_abgP)
                                    @[GHC.Types.Int]
                                    @(Data.Either.Either [GHC.Types.Int] ())
                                    @(Data.Either.Either [GHC.Types.Int] (f_abgO ()))
                                    @(f_abgO [GHC.Types.Int])
                                    (\ (s_abgS :: [GHC.Types.Int]) ->
                                       case s_abgS of wild_abgT {
                                         [] ->
                                           Data.Either.Right @[GHC.Types.Int] @() GHC.Tuple.Prim.();
                                         : ds1_abgU ds2_abgV ->
                                           Data.Either.Left @[GHC.Types.Int] @() wild_abgT
                                       })
                                    (let {
                                       f2_abgX :: [GHC.Types.Int] -> f_abgO [GHC.Types.Int]
                                       [LclId,
                                        Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                Value=False, ConLike=False, WorkFree=False,
                                                Expandable=True,
                                                Guidance=IF_ARGS [] 20 0}]
                                       f2_abgX
                                         = GHC.Base.pure
                                             @f_abgO $dApplicative_abgQ @[GHC.Types.Int] } in
                                     let {
                                       ds2_abgY :: f_abgO () -> f_abgO [GHC.Types.Int]
                                       [LclId,
                                        Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                Value=False, ConLike=False, WorkFree=False,
                                                Expandable=False,
                                                Guidance=IF_ARGS [] 70 0}]
                                       ds2_abgY
                                         = GHC.Base.fmap
                                             @f_abgO
                                             (GHC.Base.$p1Applicative @f_abgO $dApplicative_abgQ)
                                             @()
                                             @[GHC.Types.Int]
                                             (\ (ds3_abgZ :: ()) ->
                                                case ds3_abgZ of { () ->
                                                GHC.Types.[] @GHC.Types.Int
                                                }) } in
                                     \ (ds3_abh1
                                          :: Data.Either.Either [GHC.Types.Int] (f_abgO ())) ->
                                       case ds3_abh1 of {
                                         Data.Either.Left x_abh3 -> f2_abgX x_abh3;
                                         Data.Either.Right y_abh5 -> ds2_abgY y_abh5
                                       }) } in
                            let {
                              g_abh7
                                :: p_abgN () (f_abgO ())
                                   -> p_abgN
                                        (Data.Either.Either [GHC.Types.Int] ())
                                        (Data.Either.Either [GHC.Types.Int] (f_abgO ()))
                              [LclId,
                               Unf=Unf{Src=<vanilla>, TopLvl=False,
                                       Value=False, ConLike=False, WorkFree=False, Expandable=True,
                                       Guidance=IF_ARGS [] 20 0}]
                              g_abh7
                                = Data.Profunctor.Choice.right'
                                    @p_abgN $dChoice_abgP @() @(f_abgO ()) @[GHC.Types.Int] } in
                            \ (x_abh8 :: p_abgN () (f_abgO ())) -> f1_abgR (g_abh7 x_abh8))
                         `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0] <[GHC.Types.Int]>_N)
                                 :: Control.Lens.Type.Prism' [GHC.Types.Int] ()
                                    ~R# Control.Lens.Empty.AsEmpty [GHC.Types.Int]))
                        @(Data.Functor.Const.Const [GHC.Types.Int])
                        (Data.Functor.Contravariant.$fContravariantConst @[GHC.Types.Int])
                        (Data.Functor.Const.$fFunctorConst @[GHC.Types.Int])
                        ((\ (ds_abeK :: [GHC.Types.Int]) -> ds_abeK)
                         `cast` (<[GHC.Types.Int]>_R
                                 %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                                    <*>_N
                                                                    <[GHC.Types.Int]>_R
                                                                    <[GHC.Types.Int]>_P)
                                 :: ([GHC.Types.Int] -> [GHC.Types.Int])
                                    ~R# ([GHC.Types.Int]
                                         -> Data.Functor.Const.Const
                                              [GHC.Types.Int] [GHC.Types.Int])))
                        ((Control.Lens.Cons.Extras.recons
                            @[GHC.Types.Int]
                            @GHC.Types.Int
                            @(Main.List GHC.Types.Int)
                            ((\ (@(p_abgg :: * -> * -> *))
                                (@(f_abgh :: * -> *))
                                ($dChoice_abgi :: Data.Profunctor.Choice.Choice p_abgg)
                                ($dApplicative_abgj :: GHC.Base.Applicative f_abgh) ->
                                let {
                                  f1_abgk
                                    :: p_abgg
                                         (Data.Either.Either
                                            [GHC.Types.Int] (GHC.Types.Int, [GHC.Types.Int]))
                                         (Data.Either.Either
                                            [GHC.Types.Int]
                                            (f_abgh (GHC.Types.Int, [GHC.Types.Int])))
                                       -> p_abgg [GHC.Types.Int] (f_abgh [GHC.Types.Int])
                                  [LclId,
                                   Unf=Unf{Src=<vanilla>, TopLvl=False,
                                           Value=False, ConLike=False, WorkFree=False,
                                           Expandable=False,
                                           Guidance=IF_ARGS [] 320 0}]
                                  f1_abgk
                                    = Data.Profunctor.Unsafe.dimap
                                        @p_abgg
                                        (Data.Profunctor.Choice.$p1Choice @p_abgg $dChoice_abgi)
                                        @[GHC.Types.Int]
                                        @(Data.Either.Either
                                            [GHC.Types.Int] (GHC.Types.Int, [GHC.Types.Int]))
                                        @(Data.Either.Either
                                            [GHC.Types.Int]
                                            (f_abgh (GHC.Types.Int, [GHC.Types.Int])))
                                        @(f_abgh [GHC.Types.Int])
                                        (\ (aas_abgl :: [GHC.Types.Int]) ->
                                           case aas_abgl of {
                                             [] ->
                                               Data.Either.Left
                                                 @[GHC.Types.Int]
                                                 @(GHC.Types.Int, [GHC.Types.Int])
                                                 (GHC.Types.[] @GHC.Types.Int);
                                             : a1_abgn as_abgo ->
                                               Data.Either.Right
                                                 @[GHC.Types.Int]
                                                 @(GHC.Types.Int, [GHC.Types.Int])
                                                 (a1_abgn, as_abgo)
                                           })
                                        (let {
                                           f2_abgq :: [GHC.Types.Int] -> f_abgh [GHC.Types.Int]
                                           [LclId,
                                            Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                    Value=False, ConLike=False, WorkFree=False,
                                                    Expandable=True,
                                                    Guidance=IF_ARGS [] 20 0}]
                                           f2_abgq
                                             = GHC.Base.pure
                                                 @f_abgh $dApplicative_abgj @[GHC.Types.Int] } in
                                         let {
                                           ds2_abgr
                                             :: f_abgh (GHC.Types.Int, [GHC.Types.Int])
                                                -> f_abgh [GHC.Types.Int]
                                           [LclId,
                                            Unf=Unf{Src=<vanilla>, TopLvl=False,
                                                    Value=False, ConLike=False, WorkFree=False,
                                                    Expandable=False,
                                                    Guidance=IF_ARGS [] 90 0}]
                                           ds2_abgr
                                             = GHC.Base.fmap
                                                 @f_abgh
                                                 (GHC.Base.$p1Applicative
                                                    @f_abgh $dApplicative_abgj)
                                                 @(GHC.Types.Int, [GHC.Types.Int])
                                                 @[GHC.Types.Int]
                                                 (\ (p1_abgs :: (GHC.Types.Int, [GHC.Types.Int])) ->
                                                    GHC.Types.:
                                                      @GHC.Types.Int
                                                      (case p1_abgs of { (x_abgu, ds_abgv) ->
                                                       x_abgu
                                                       })
                                                      (case p1_abgs of { (ds_abgy, y_abgz) ->
                                                       y_abgz
                                                       })) } in
                                         \ (ds3_abgB
                                              :: Data.Either.Either
                                                   [GHC.Types.Int]
                                                   (f_abgh (GHC.Types.Int, [GHC.Types.Int]))) ->
                                           case ds3_abgB of {
                                             Data.Either.Left x_abgD -> f2_abgq x_abgD;
                                             Data.Either.Right y_abgF -> ds2_abgr y_abgF
                                           }) } in
                                let {
                                  g_abgH
                                    :: p_abgg
                                         (GHC.Types.Int, [GHC.Types.Int])
                                         (f_abgh (GHC.Types.Int, [GHC.Types.Int]))
                                       -> p_abgg
                                            (Data.Either.Either
                                               [GHC.Types.Int] (GHC.Types.Int, [GHC.Types.Int]))
                                            (Data.Either.Either
                                               [GHC.Types.Int]
                                               (f_abgh (GHC.Types.Int, [GHC.Types.Int])))
                                  [LclId,
                                   Unf=Unf{Src=<vanilla>, TopLvl=False,
                                           Value=False, ConLike=False, WorkFree=False,
                                           Expandable=True,
                                           Guidance=IF_ARGS [] 20 0}]
                                  g_abgH
                                    = Data.Profunctor.Choice.right'
                                        @p_abgg
                                        $dChoice_abgi
                                        @(GHC.Types.Int, [GHC.Types.Int])
                                        @(f_abgh (GHC.Types.Int, [GHC.Types.Int]))
                                        @[GHC.Types.Int] } in
                                \ (x_abgI
                                     :: p_abgg
                                          (GHC.Types.Int, [GHC.Types.Int])
                                          (f_abgh (GHC.Types.Int, [GHC.Types.Int]))) ->
                                  f1_abgk (g_abgH x_abgI))
                             `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                              <[GHC.Types.Int]>_N
                                              <[GHC.Types.Int]>_N
                                              <GHC.Types.Int>_N
                                              <GHC.Types.Int>_N)
                                     :: Control.Lens.Type.Prism
                                          [GHC.Types.Int]
                                          [GHC.Types.Int]
                                          (GHC.Types.Int, [GHC.Types.Int])
                                          (GHC.Types.Int, [GHC.Types.Int])
                                        ~R# Control.Lens.Cons.Cons
                                              [GHC.Types.Int]
                                              [GHC.Types.Int]
                                              GHC.Types.Int
                                              GHC.Types.Int))
                            (($c_Cons_a9jd @GHC.Types.Int @GHC.Types.Int)
                             `cast` (Sym (Control.Lens.Cons.N:Cons[0]
                                              <Main.List GHC.Types.Int>_N
                                              <Main.List GHC.Types.Int>_N
                                              <GHC.Types.Int>_N
                                              <GHC.Types.Int>_N)
                                     :: Control.Lens.Type.Prism
                                          (Main.List GHC.Types.Int)
                                          (Main.List GHC.Types.Int)
                                          (GHC.Types.Int, Main.List GHC.Types.Int)
                                          (GHC.Types.Int, Main.List GHC.Types.Int)
                                        ~R# Control.Lens.Cons.Cons
                                              (Main.List GHC.Types.Int)
                                              (Main.List GHC.Types.Int)
                                              GHC.Types.Int
                                              GHC.Types.Int))
                            (($c_Empty_a9oc @GHC.Types.Int)
                             `cast` (Sym (Control.Lens.Empty.N:AsEmpty[0]
                                              <Main.List GHC.Types.Int>_N)
                                     :: Control.Lens.Type.Prism' (Main.List GHC.Types.Int) ()
                                        ~R# Control.Lens.Empty.AsEmpty (Main.List GHC.Types.Int)))
                            @(Data.Functor.Const.Const (Main.List GHC.Types.Int))
                            (Data.Functor.Contravariant.$fContravariantConst
                               @(Main.List GHC.Types.Int))
                            (Data.Functor.Const.$fFunctorConst @(Main.List GHC.Types.Int))
                            ((\ (ds_abeK :: Main.List GHC.Types.Int) -> ds_abeK)
                             `cast` (<Main.List GHC.Types.Int>_R
                                     %<'GHC.Types.Many>_N ->_R Sym (Data.Functor.Const.N:Const[0]
                                                                        <*>_N
                                                                        <Main.List GHC.Types.Int>_R
                                                                        <Main.List GHC.Types.Int>_P)
                                     :: (Main.List GHC.Types.Int -> Main.List GHC.Types.Int)
                                        ~R# (Main.List GHC.Types.Int
                                             -> Data.Functor.Const.Const
                                                  (Main.List GHC.Types.Int)
                                                  (Main.List GHC.Types.Int))))
                            s_a8PA)
                         `cast` (Data.Functor.Const.N:Const[0]
                                     <*>_N <Main.List GHC.Types.Int>_R <[GHC.Types.Int]>_P
                                 :: Data.Functor.Const.Const
                                      (Main.List GHC.Types.Int) [GHC.Types.Int]
                                    ~R# Main.List GHC.Types.Int)))
                     `cast` (Data.Functor.Const.N:Const[0]
                                 <*>_N <[GHC.Types.Int]>_R <Main.List GHC.Types.Int>_P
                             :: Data.Functor.Const.Const
                                  [GHC.Types.Int] (Main.List GHC.Types.Int)
                                ~R# [GHC.Types.Int])
              ValArg s_a8PA
    Cont:   Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: unpack-list
    Module: (GHC.Base)
    Before: GHC.CString.unpackFoldrCString#
              TyArg [GHC.Types.Char]
              ValArg "Properties"#
              ValArg \ (ds_abU6 :: GHC.Types.Char)
                       (ds1_abU7 :: [GHC.Types.Char]) ->
                       GHC.Types.: @GHC.Types.Char ds_abU6 ds1_abU7
              ValArg GHC.Types.[] @GHC.Types.Char
    After:  (\ (a_ab7C :: GHC.Prim.Addr#) ->
               GHC.CString.unpackCString# a_ab7C)
              "Properties"#
    Cont:   Stop[RhsCtxt(NonRecursive)] [GHC.Types.Char]
Rule fired
    Rule: unpack-list
    Module: (GHC.Base)
    Before: GHC.CString.unpackFoldrCString#
              TyArg [GHC.Types.Char]
              ValArg "[a] -> [a]"#
              ValArg \ (ds_abU6 :: GHC.Types.Char)
                       (ds1_abU7 :: [GHC.Types.Char]) ->
                       GHC.Types.: @GHC.Types.Char ds_abU6 ds1_abU7
              ValArg GHC.Types.[] @GHC.Types.Char
    After:  (\ (a_ab7C :: GHC.Prim.Addr#) ->
               GHC.CString.unpackCString# a_ab7C)
              "[a] -> [a]"#
    Cont:   Stop[BoringCtxt] Test.Tasty.Core.TestName
Rule fired
    Rule: unpack-list
    Module: (GHC.Base)
    Before: GHC.CString.unpackFoldrCString#
              TyArg [GHC.Types.Char]
              ValArg "T -> T"#
              ValArg \ (ds_abU6 :: GHC.Types.Char)
                       (ds1_abU7 :: [GHC.Types.Char]) ->
                       GHC.Types.: @GHC.Types.Char ds_abU6 ds1_abU7
              ValArg GHC.Types.[] @GHC.Types.Char
    After:  (\ (a_ab7C :: GHC.Prim.Addr#) ->
               GHC.CString.unpackCString# a_ab7C)
              "T -> T"#
    Cont:   Stop[BoringCtxt] Test.Tasty.Core.TestName
Rule fired
    Rule: unpack-list
    Module: (GHC.Base)
    Before: GHC.CString.unpackFoldrCString#
              TyArg [GHC.Types.Char]
              ValArg "TL -> TL"#
              ValArg \ (ds_abU6 :: GHC.Types.Char)
                       (ds1_abU7 :: [GHC.Types.Char]) ->
                       GHC.Types.: @GHC.Types.Char ds_abU6 ds1_abU7
              ValArg GHC.Types.[] @GHC.Types.Char
    After:  (\ (a_ab7C :: GHC.Prim.Addr#) ->
               GHC.CString.unpackCString# a_ab7C)
              "TL -> TL"#
    Cont:   Stop[BoringCtxt] Test.Tasty.Core.TestName
Rule fired
    Rule: unpack-list
    Module: (GHC.Base)
    Before: GHC.CString.unpackFoldrCString#
              TyArg [GHC.Types.Char]
              ValArg "B -> B"#
              ValArg \ (ds_abU6 :: GHC.Types.Char)
                       (ds1_abU7 :: [GHC.Types.Char]) ->
                       GHC.Types.: @GHC.Types.Char ds_abU6 ds1_abU7
              ValArg GHC.Types.[] @GHC.Types.Char
    After:  (\ (a_ab7C :: GHC.Prim.Addr#) ->
               GHC.CString.unpackCString# a_ab7C)
              "B -> B"#
    Cont:   Stop[BoringCtxt] Test.Tasty.Core.TestName
Rule fired
    Rule: unpack-list
    Module: (GHC.Base)
    Before: GHC.CString.unpackFoldrCString#
              TyArg [GHC.Types.Char]
              ValArg "L -> L"#
              ValArg \ (ds_abU6 :: GHC.Types.Char)
                       (ds1_abU7 :: [GHC.Types.Char]) ->
                       GHC.Types.: @GHC.Types.Char ds_abU6 ds1_abU7
              ValArg GHC.Types.[] @GHC.Types.Char
    After:  (\ (a_ab7C :: GHC.Prim.Addr#) ->
               GHC.CString.unpackCString# a_ab7C)
              "L -> L"#
    Cont:   Stop[BoringCtxt] Test.Tasty.Core.TestName
Rule fired
    Rule: unpack-list
    Module: (GHC.Base)
    Before: GHC.CString.unpackFoldrCString#
              TyArg [GHC.Types.Char]
              ValArg "Str -> T -> Str"#
              ValArg \ (ds_abU6 :: GHC.Types.Char)
                       (ds1_abU7 :: [GHC.Types.Char]) ->
                       GHC.Types.: @GHC.Types.Char ds_abU6 ds1_abU7
              ValArg GHC.Types.[] @GHC.Types.Char
    After:  (\ (a_ab7C :: GHC.Prim.Addr#) ->
               GHC.CString.unpackCString# a_ab7C)
              "Str -> T -> Str"#
    Cont:   Stop[BoringCtxt] Test.Tasty.Core.TestName
Rule fired
    Rule: unpack-list
    Module: (GHC.Base)
    Before: GHC.CString.unpackFoldrCString#
              TyArg [GHC.Types.Char]
              ValArg "Str -> TL -> Str"#
              ValArg \ (ds_abU6 :: GHC.Types.Char)
                       (ds1_abU7 :: [GHC.Types.Char]) ->
                       GHC.Types.: @GHC.Types.Char ds_abU6 ds1_abU7
              ValArg GHC.Types.[] @GHC.Types.Char
    After:  (\ (a_ab7C :: GHC.Prim.Addr#) ->
               GHC.CString.unpackCString# a_ab7C)
              "Str -> TL -> Str"#
    Cont:   Stop[BoringCtxt] Test.Tasty.Core.TestName
Rule fired
    Rule: LAZY STREAM stream/unstream fusion
    Module: (Data.Text.Internal.Lazy.Fusion)
    Before: Data.Text.Internal.Lazy.Fusion.stream
              ValArg Data.Text.Internal.Lazy.Fusion.unstream
                       (Data.Text.Internal.Fusion.Common.streamList
                          @GHC.Types.Char
                          (GHC.Base.map
                             @GHC.Types.Char @GHC.Types.Char Data.Text.Internal.safe s_a8Pv))
    After:  (\ (s_abZz
                  :: Data.Text.Internal.Fusion.Types.Stream GHC.Types.Char) ->
               s_abZz)
              (Data.Text.Internal.Fusion.Common.streamList
                 @GHC.Types.Char
                 (GHC.Base.map
                    @GHC.Types.Char @GHC.Types.Char Data.Text.Internal.safe s_a8Pv))
    Cont:   StrictArg Data.Text.Internal.Fusion.Common.unstreamList
            StrictArg GHC.Base.eqString
            ApplyToVal nodup hole GHC.Base.String -> GHC.Types.Bool s_a8Pv
            Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: unpack-list
    Module: (GHC.Base)
    Before: GHC.CString.unpackFoldrCString#
              TyArg [GHC.Types.Char]
              ValArg "T -> TL -> T"#
              ValArg \ (ds_abU6 :: GHC.Types.Char)
                       (ds1_abU7 :: [GHC.Types.Char]) ->
                       GHC.Types.: @GHC.Types.Char ds_abU6 ds1_abU7
              ValArg GHC.Types.[] @GHC.Types.Char
    After:  (\ (a_ab7C :: GHC.Prim.Addr#) ->
               GHC.CString.unpackCString# a_ab7C)
              "T -> TL -> T"#
    Cont:   Stop[BoringCtxt] Test.Tasty.Core.TestName
Rule fired
    Rule: ==#
    Module: (BUILTIN)
    Before: GHC.Prim.==# ValArg ds2_abpf ValArg 0#
    After:  case ds2_abpf of wild_00 {
              __DEFAULT -> 0#;
              0# -> 1#
            }
    Cont:   StrictArg GHC.Prim.tagToEnum#
            Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: tagToEnum#
    Module: (BUILTIN)
    Before: GHC.Prim.tagToEnum# TyArg GHC.Types.Bool ValArg 0#
    After:  GHC.Types.False
    Cont:   Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: tagToEnum#
    Module: (BUILTIN)
    Before: GHC.Prim.tagToEnum# TyArg GHC.Types.Bool ValArg 1#
    After:  GHC.Types.True
    Cont:   Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: unpack-list
    Module: (GHC.Base)
    Before: GHC.CString.unpackFoldrCString#
              TyArg [GHC.Types.Char]
              ValArg "[W8] -> B -> [W8]"#
              ValArg \ (ds_abU6 :: GHC.Types.Char)
                       (ds1_abU7 :: [GHC.Types.Char]) ->
                       GHC.Types.: @GHC.Types.Char ds_abU6 ds1_abU7
              ValArg GHC.Types.[] @GHC.Types.Char
    After:  (\ (a_ab7C :: GHC.Prim.Addr#) ->
               GHC.CString.unpackCString# a_ab7C)
              "[W8] -> B -> [W8]"#
    Cont:   Stop[BoringCtxt] Test.Tasty.Core.TestName
Rule fired
    Rule: ByteString unpack-list
    Module: (Data.ByteString)
    Before: Data.ByteString.unpackFoldr
              TyArg [GHC.Word.Word8]
              ValArg Data.ByteString.Internal.Type.BS
                       ww1_ac1B (GHC.ForeignPtr.PlainPtr ww2_ac1C) ww3_ac1D
              ValArg \ (ds_abU6 :: GHC.Word.Word8)
                       (ds1_abU7 :: [GHC.Word.Word8]) ->
                       GHC.Types.: @GHC.Word.Word8 ds_abU6 ds1_abU7
              ValArg GHC.Types.[] @GHC.Word.Word8
    After:  (\ (bs_abrN :: Data.ByteString.Internal.Type.ByteString) ->
               Data.ByteString.Internal.Type.unpackBytes bs_abrN)
              (Data.ByteString.Internal.Type.BS
                 ww1_ac1B (GHC.ForeignPtr.PlainPtr ww2_ac1C) ww3_ac1D)
    Cont:   StrictArg GHC.Classes.$fEqList_$c==
            ApplyToVal nodup hole [GHC.Word.Word8] -> GHC.Types.Bool s_a8Px
            Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: unpack-list
    Module: (GHC.Base)
    Before: GHC.CString.unpackFoldrCString#
              TyArg [GHC.Types.Char]
              ValArg "[W8] -> L -> [W8]"#
              ValArg \ (ds_abU6 :: GHC.Types.Char)
                       (ds1_abU7 :: [GHC.Types.Char]) ->
                       GHC.Types.: @GHC.Types.Char ds_abU6 ds1_abU7
              ValArg GHC.Types.[] @GHC.Types.Char
    After:  (\ (a_ab7C :: GHC.Prim.Addr#) ->
               GHC.CString.unpackCString# a_ab7C)
              "[W8] -> L -> [W8]"#
    Cont:   Stop[BoringCtxt] Test.Tasty.Core.TestName
Rule fired
    Rule: unpack-list
    Module: (GHC.Base)
    Before: GHC.CString.unpackFoldrCString#
              TyArg [GHC.Types.Char]
              ValArg "B -> L -> B"#
              ValArg \ (ds_abU6 :: GHC.Types.Char)
                       (ds1_abU7 :: [GHC.Types.Char]) ->
                       GHC.Types.: @GHC.Types.Char ds_abU6 ds1_abU7
              ValArg GHC.Types.[] @GHC.Types.Char
    After:  (\ (a_ab7C :: GHC.Prim.Addr#) ->
               GHC.CString.unpackCString# a_ab7C)
              "B -> L -> B"#
    Cont:   Stop[BoringCtxt] Test.Tasty.Core.TestName
Rule fired
    Rule: /=#
    Module: (BUILTIN)
    Before: GHC.Prim./=# ValArg 0# ValArg 0#
    After:  0#
    Cont:   Select nodup lwild_sc2a
            Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: <#
    Module: (BUILTIN)
    Before: GHC.Prim.<# ValArg 0# ValArg 0#
    After:  0#
    Cont:   Select nodup lwild_ac2d
            Select ok lwild1_absi
            Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: ==#
    Module: (BUILTIN)
    Before: GHC.Prim.==# ValArg 0# ValArg 0#
    After:  1#
    Cont:   Select nodup lwild1_ac2e
            Select ok lwild1_absi
            Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: <=#
    Module: (BUILTIN)
    Before: GHC.Prim.<=# ValArg 0# ValArg 0#
    After:  1#
    Cont:   Select nodup lwild_abTT
            Select ok lwild1_absi
            Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: intToInt64#
    Module: (BUILTIN)
    Before: GHC.Prim.intToInt64# ValArg 0#
    After:  0#Int64
    Cont:   StrictArg GHC.Prim.int64ToWord64#
            StrictArg {__ffi_static_ccall_unsafe bytestring-0.11.5.3:memcmp :: Addr#
                                                         -> Addr#
                                                         -> Word64#
                                                         -> State# RealWorld
                                                         -> (# State# RealWorld, Int32# #)}_abTG
            ApplyToVal nodup hole GHC.Prim.State# GHC.Prim.RealWorld
                                  -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Prim.Int32# #)
              GHC.Prim.realWorld#
            Select nodup wild_abTH
            Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: int64ToWord64#
    Module: (BUILTIN)
    Before: GHC.Prim.int64ToWord64# ValArg 0#Int64
    After:  0#Word64
    Cont:   StrictArg {__ffi_static_ccall_unsafe bytestring-0.11.5.3:memcmp :: Addr#
                                                         -> Addr#
                                                         -> Word64#
                                                         -> State# RealWorld
                                                         -> (# State# RealWorld, Int32# #)}_abTG
            ApplyToVal nodup hole GHC.Prim.State# GHC.Prim.RealWorld
                                  -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Prim.Int32# #)
              GHC.Prim.realWorld#
            Select nodup wild_abTH
            Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: unpack-list
    Module: (GHC.Base)
    Before: GHC.CString.unpackFoldrCString#
              TyArg [GHC.Types.Char]
              ValArg "[a] -> List a -> [a]"#
              ValArg \ (ds_abU6 :: GHC.Types.Char)
                       (ds1_abU7 :: [GHC.Types.Char]) ->
                       GHC.Types.: @GHC.Types.Char ds_abU6 ds1_abU7
              ValArg GHC.Types.[] @GHC.Types.Char
    After:  (\ (a_ab7C :: GHC.Prim.Addr#) ->
               GHC.CString.unpackCString# a_ab7C)
              "[a] -> List a -> [a]"#
    Cont:   Stop[BoringCtxt] Test.Tasty.Core.TestName
Rule fired
    Rule: ==#
    Module: (BUILTIN)
    Before: GHC.Prim.==# ValArg bx2_abp6 ValArg 0#
    After:  case bx2_abp6 of wild_00 {
              __DEFAULT -> 0#;
              0# -> 1#
            }
    Cont:   Select nodup lwild_sc1r
            Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: /=#
    Module: (BUILTIN)
    Before: GHC.Prim./=# ValArg ds1_abs2 ValArg ds1_abs2
    After:  0#
    Cont:   Select nodup lwild_sc2a
            Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: <#
    Module: (BUILTIN)
    Before: GHC.Prim.<# ValArg ds1_abs2 ValArg ds1_abs2
    After:  0#
    Cont:   Select nodup lwild_ac2d
            Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: ==#
    Module: (BUILTIN)
    Before: GHC.Prim.==# ValArg ds1_abs2 ValArg ds1_abs2
    After:  1#
    Cont:   Select nodup lwild1_ac2e
            Stop[BoringCtxt] GHC.Types.Bool
Rule fired
    Rule: <=#
    Module: (BUILTIN)
    Before: GHC.Prim.<=# ValArg ds1_abs2 ValArg ds1_abs2
    After:  1#
    Cont:   Select nodup lwild_abTT
            Stop[BoringCtxt] GHC.Types.Bool
[2 of 2] Linking /tmp/workdir-concise/concise-0.1.0.1/dist-newstyle/build/x86_64-linux/ghc-9.6.6/concise-0.1.0.1/t/tests/build/tests/tests
