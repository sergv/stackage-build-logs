Build profile: -w ghc-9.6.6 -O1
In order, the following will be built (use -v for more details):
 - conduit-extra-1.3.6 (lib) (first run)
 - conduit-extra-1.3.6 (test:test) (first run)
Configuring library for conduit-extra-1.3.6...
Preprocessing library for conduit-extra-1.3.6...
Building library for conduit-extra-1.3.6...
[ 1 of 13] Compiling Data.Conduit.Attoparsec
[ 2 of 13] Compiling Data.Conduit.Binary
[ 3 of 13] Compiling Data.Conduit.ByteString.Builder
[ 4 of 13] Compiling Data.Conduit.Filesystem
[ 5 of 13] Compiling Data.Conduit.Foldl
[ 6 of 13] Compiling Data.Conduit.Lazy
[ 7 of 13] Compiling Data.Conduit.Network
[ 8 of 13] Compiling Data.Conduit.Network.UDP
[ 9 of 13] Compiling Data.Conduit.Network.Unix
[10 of 13] Compiling Data.Conduit.Process

Data/Conduit/Process.hs:47:13: warning: [GHC-58520] [-Wtype-equality-requires-operators]
    The use of ‘~’ without TypeOperators
    will become an error in a future GHC release.
    Suggested fix: Perhaps you intended to use TypeOperators
   |
47 | instance (r ~ (), MonadIO m, i ~ ByteString) => InputSource (ConduitM i o m r) where
   |             ^

Data/Conduit/Process.hs:47:32: warning: [GHC-58520] [-Wtype-equality-requires-operators]
    The use of ‘~’ without TypeOperators
    will become an error in a future GHC release.
    Suggested fix: Perhaps you intended to use TypeOperators
   |
47 | instance (r ~ (), MonadIO m, i ~ ByteString) => InputSource (ConduitM i o m r) where
   |                                ^

Data/Conduit/Process.hs:48:20: warning: [GHC-62161] [-Wincomplete-uni-patterns]
    Pattern match(es) are non-exhaustive
    In a lambda abstraction:
        Patterns of type ‘Maybe GHC.IO.Handle.Types.Handle’ not matched:
            Nothing
   |
48 |     isStdStream = (\(Just h) -> hSetBuffering h NoBuffering $> sinkHandle h, Just CreatePipe)
   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Data/Conduit/Process.hs:49:13: warning: [GHC-58520] [-Wtype-equality-requires-operators]
    The use of ‘~’ without TypeOperators
    will become an error in a future GHC release.
    Suggested fix: Perhaps you intended to use TypeOperators
   |
49 | instance (r ~ (), r' ~ (), MonadIO m, MonadIO n, i ~ ByteString) => InputSource (ConduitM i o m r, n r') where
   |             ^

Data/Conduit/Process.hs:49:22: warning: [GHC-58520] [-Wtype-equality-requires-operators]
    The use of ‘~’ without TypeOperators
    will become an error in a future GHC release.
    Suggested fix: Perhaps you intended to use TypeOperators
   |
49 | instance (r ~ (), r' ~ (), MonadIO m, MonadIO n, i ~ ByteString) => InputSource (ConduitM i o m r, n r') where
   |                      ^

Data/Conduit/Process.hs:49:52: warning: [GHC-58520] [-Wtype-equality-requires-operators]
    The use of ‘~’ without TypeOperators
    will become an error in a future GHC release.
    Suggested fix: Perhaps you intended to use TypeOperators
   |
49 | instance (r ~ (), r' ~ (), MonadIO m, MonadIO n, i ~ ByteString) => InputSource (ConduitM i o m r, n r') where
   |                                                    ^

Data/Conduit/Process.hs:50:20: warning: [GHC-62161] [-Wincomplete-uni-patterns]
    Pattern match(es) are non-exhaustive
    In a lambda abstraction:
        Patterns of type ‘Maybe GHC.IO.Handle.Types.Handle’ not matched:
            Nothing
   |
50 |     isStdStream = (\(Just h) -> hSetBuffering h NoBuffering $> (sinkHandle h, liftIO $ hClose h), Just CreatePipe)
   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Data/Conduit/Process.hs:65:24: warning: [GHC-58520] [-Wtype-equality-requires-operators]
    The use of ‘~’ without TypeOperators
    will become an error in a future GHC release.
    Suggested fix: Perhaps you intended to use TypeOperators
   |
65 | instance (MonadIO m, r ~ ()) => InputSource (BuilderInput o m r) where
   |                        ^

Data/Conduit/Process.hs:66:18: warning: [GHC-62161] [-Wincomplete-uni-patterns]
    Pattern match(es) are non-exhaustive
    In a lambda abstraction:
        Patterns of type ‘Maybe GHC.IO.Handle.Types.Handle’ not matched:
            Nothing
   |
66 |   isStdStream = (\(Just h) -> return $ BuilderInput $ sinkHandleBuilder h, Just CreatePipe)
   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Data/Conduit/Process.hs:67:35: warning: [GHC-58520] [-Wtype-equality-requires-operators]
    The use of ‘~’ without TypeOperators
    will become an error in a future GHC release.
    Suggested fix: Perhaps you intended to use TypeOperators
   |
67 | instance (MonadIO m, MonadIO n, r ~ (), r' ~ ()) => InputSource (BuilderInput o m r, n r') where
   |                                   ^

Data/Conduit/Process.hs:67:44: warning: [GHC-58520] [-Wtype-equality-requires-operators]
    The use of ‘~’ without TypeOperators
    will become an error in a future GHC release.
    Suggested fix: Perhaps you intended to use TypeOperators
   |
67 | instance (MonadIO m, MonadIO n, r ~ (), r' ~ ()) => InputSource (BuilderInput o m r, n r') where
   |                                            ^

Data/Conduit/Process.hs:68:18: warning: [GHC-62161] [-Wincomplete-uni-patterns]
    Pattern match(es) are non-exhaustive
    In a lambda abstraction:
        Patterns of type ‘Maybe GHC.IO.Handle.Types.Handle’ not matched:
            Nothing
   |
68 |   isStdStream = (\(Just h) -> return (BuilderInput $ sinkHandleBuilder h, liftIO $ hClose h), Just CreatePipe)
   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Data/Conduit/Process.hs:69:24: warning: [GHC-58520] [-Wtype-equality-requires-operators]
    The use of ‘~’ without TypeOperators
    will become an error in a future GHC release.
    Suggested fix: Perhaps you intended to use TypeOperators
   |
69 | instance (MonadIO m, r ~ ()) => InputSource (FlushInput o m r) where
   |                        ^

Data/Conduit/Process.hs:70:18: warning: [GHC-62161] [-Wincomplete-uni-patterns]
    Pattern match(es) are non-exhaustive
    In a lambda abstraction:
        Patterns of type ‘Maybe GHC.IO.Handle.Types.Handle’ not matched:
            Nothing
   |
70 |   isStdStream = (\(Just h) -> return $ FlushInput $ sinkHandleFlush h, Just CreatePipe)
   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Data/Conduit/Process.hs:71:35: warning: [GHC-58520] [-Wtype-equality-requires-operators]
    The use of ‘~’ without TypeOperators
    will become an error in a future GHC release.
    Suggested fix: Perhaps you intended to use TypeOperators
   |
71 | instance (MonadIO m, MonadIO n, r ~ (), r' ~ ()) => InputSource (FlushInput o m r, n r') where
   |                                   ^

Data/Conduit/Process.hs:71:44: warning: [GHC-58520] [-Wtype-equality-requires-operators]
    The use of ‘~’ without TypeOperators
    will become an error in a future GHC release.
    Suggested fix: Perhaps you intended to use TypeOperators
   |
71 | instance (MonadIO m, MonadIO n, r ~ (), r' ~ ()) => InputSource (FlushInput o m r, n r') where
   |                                            ^

Data/Conduit/Process.hs:72:18: warning: [GHC-62161] [-Wincomplete-uni-patterns]
    Pattern match(es) are non-exhaustive
    In a lambda abstraction:
        Patterns of type ‘Maybe GHC.IO.Handle.Types.Handle’ not matched:
            Nothing
   |
72 |   isStdStream = (\(Just h) -> return (FlushInput $ sinkHandleFlush h, liftIO $ hClose h), Just CreatePipe)
   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Data/Conduit/Process.hs:74:13: warning: [GHC-58520] [-Wtype-equality-requires-operators]
    The use of ‘~’ without TypeOperators
    will become an error in a future GHC release.
    Suggested fix: Perhaps you intended to use TypeOperators
   |
74 | instance (r ~ (), MonadIO m, o ~ ByteString) => OutputSink (ConduitM i o m r) where
   |             ^

Data/Conduit/Process.hs:74:32: warning: [GHC-58520] [-Wtype-equality-requires-operators]
    The use of ‘~’ without TypeOperators
    will become an error in a future GHC release.
    Suggested fix: Perhaps you intended to use TypeOperators
   |
74 | instance (r ~ (), MonadIO m, o ~ ByteString) => OutputSink (ConduitM i o m r) where
   |                                ^

Data/Conduit/Process.hs:75:20: warning: [GHC-62161] [-Wincomplete-uni-patterns]
    Pattern match(es) are non-exhaustive
    In a lambda abstraction:
        Patterns of type ‘Maybe GHC.IO.Handle.Types.Handle’ not matched:
            Nothing
   |
75 |     osStdStream = (\(Just h) -> hSetBuffering h NoBuffering $> sourceHandle h, Just CreatePipe)
   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Data/Conduit/Process.hs:76:13: warning: [GHC-58520] [-Wtype-equality-requires-operators]
    The use of ‘~’ without TypeOperators
    will become an error in a future GHC release.
    Suggested fix: Perhaps you intended to use TypeOperators
   |
76 | instance (r ~ (), r' ~ (), MonadIO m, MonadIO n, o ~ ByteString) => OutputSink (ConduitM i o m r, n r') where
   |             ^

Data/Conduit/Process.hs:76:22: warning: [GHC-58520] [-Wtype-equality-requires-operators]
    The use of ‘~’ without TypeOperators
    will become an error in a future GHC release.
    Suggested fix: Perhaps you intended to use TypeOperators
   |
76 | instance (r ~ (), r' ~ (), MonadIO m, MonadIO n, o ~ ByteString) => OutputSink (ConduitM i o m r, n r') where
   |                      ^

Data/Conduit/Process.hs:76:52: warning: [GHC-58520] [-Wtype-equality-requires-operators]
    The use of ‘~’ without TypeOperators
    will become an error in a future GHC release.
    Suggested fix: Perhaps you intended to use TypeOperators
   |
76 | instance (r ~ (), r' ~ (), MonadIO m, MonadIO n, o ~ ByteString) => OutputSink (ConduitM i o m r, n r') where
   |                                                    ^

Data/Conduit/Process.hs:77:20: warning: [GHC-62161] [-Wincomplete-uni-patterns]
    Pattern match(es) are non-exhaustive
    In a lambda abstraction:
        Patterns of type ‘Maybe GHC.IO.Handle.Types.Handle’ not matched:
            Nothing
   |
77 |     osStdStream = (\(Just h) -> hSetBuffering h NoBuffering $> (sourceHandle h, liftIO $ hClose h), Just CreatePipe)
   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
[11 of 13] Compiling Data.Conduit.Process.Typed
[12 of 13] Compiling Data.Conduit.Text
[13 of 13] Compiling Data.Conduit.Zlib
Configuring test suite 'test' for conduit-extra-1.3.6...
Preprocessing test suite 'test' for conduit-extra-1.3.6...
Building test suite 'test' for conduit-extra-1.3.6...
[ 1 of 12] Compiling Data.Conduit.AttoparsecSpec

test/Data/Conduit/AttoparsecSpec.hs:10:52: warning: [-Wunused-imports]
    The import of ‘<*’ from module ‘Control.Applicative’ is redundant
   |
10 | import           Control.Applicative              ((<*), (<|>))
   |                                                    ^^^^

test/Data/Conduit/AttoparsecSpec.hs:153:17: warning: [GHC-62161] [-Wincomplete-uni-patterns]
    Pattern match(es) are non-exhaustive
    In a pattern binding:
        Patterns of type ‘Either
                            ghc-prim:GHC.Types.Any
                            [Either
                               ParseError (PositionRange, Data.Text.Internal.Text)]’ not matched:
            Left _
    |
153 |                 (Right !ea) = runConduit $ CL.sourceList input .| sink
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

test/Data/Conduit/AttoparsecSpec.hs:159:36: warning: [GHC-62161] [-Wincomplete-uni-patterns]
    Pattern match(es) are non-exhaustive
    In a lambda abstraction:
        Patterns of type ‘(Either
                             ParseError (PositionRange, Data.Text.Internal.Text),
                           Int)’ not matched:
            ((Left _), _)
    |
159 |             forM_ (zip ea [1..]) $ \ (Right (pos, _), l) -> pos `shouldBe` chkp l
    |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
[ 2 of 12] Compiling Data.Conduit.BinarySpec

test/Data/Conduit/BinarySpec.hs:30:1: warning: [-Wunused-imports]
    The import of ‘Control.Applicative’ is redundant
      except perhaps to import instances from ‘Control.Applicative’
    To import instances alone, use: import Control.Applicative()
   |
30 | import Control.Applicative ((<$>))
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
[ 3 of 12] Compiling Data.Conduit.ByteString.BuilderSpec
[ 4 of 12] Compiling Data.Conduit.ExtraSpec
[ 5 of 12] Compiling Data.Conduit.FilesystemSpec
[ 6 of 12] Compiling Data.Conduit.LazySpec
[ 7 of 12] Compiling Data.Conduit.NetworkSpec
[ 8 of 12] Compiling Data.Conduit.Process.TypedSpec

test/Data/Conduit/Process/TypedSpec.hs:15:12: warning: [GHC-68441] [-Wdeprecations]
    In the use of ‘withProcess_’
    (imported from Data.Conduit.Process.Typed, but defined in System.Process.Typed):
    Deprecated: "Please consider using `withProcessWait_`, or instead use `withProcessTerm_`"
   |
15 |     bss <- withProcess_ pc $ \p ->
   |            ^^^^^^^^^^^^

test/Data/Conduit/Process/TypedSpec.hs:30:6: warning: [GHC-68441] [-Wdeprecations]
    In the use of ‘withProcess_’
    (imported from Data.Conduit.Process.Typed, but defined in System.Process.Typed):
    Deprecated: "Please consider using `withProcessWait_`, or instead use `withProcessTerm_`"
   |
30 |     (withProcess_ (proc "cat" ["does not exist"]) $ const $ return ())
   |      ^^^^^^^^^^^^
[ 9 of 12] Compiling Data.Conduit.ProcessSpec
[10 of 12] Compiling Data.Conduit.TextSpec

test/Data/Conduit/TextSpec.hs:125:17: warning: [GHC-62161] [-Wincomplete-uni-patterns]
    Pattern match(es) are non-exhaustive
    In a pattern binding:
        Patterns of type ‘Either
                            SomeException
                            ([Either SomeException T.Text], [S.ByteString])’ not matched:
            Left _
    |
125 |             let Right res = runIdentity $ runCatchT $ runConduit $ C.yield badBS .| (,)
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^...

test/Data/Conduit/TextSpec.hs:142:17: warning: [GHC-62161] [-Wincomplete-uni-patterns]
    Pattern match(es) are non-exhaustive
    In a pattern binding:
        Patterns of type ‘Either
                            SomeException
                            ([Either SomeException T.Text], [S.ByteString])’ not matched:
            Left _
    |
142 |             let Right res = runIdentity $ runCatchT $ runConduit $
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^...
[11 of 12] Compiling Data.Conduit.ZlibSpec
[12 of 12] Compiling Main
[13 of 13] Linking /tmp/workdir-conduit-extra/conduit-extra-1.3.6/dist-newstyle/build/x86_64-linux/ghc-9.6.6/conduit-extra-1.3.6/t/test/build/test/test
